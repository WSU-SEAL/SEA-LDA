Id,PostTypeId,AcceptedAnswerId,ParentId,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,CreationDate
32412043,2,,32337701,5,,"<p>For a Relay compliant GraphQL server, object with a global ID is called a <code>Node</code>, any <code>node</code> could be refetch by query</p>&#xA;&#xA;<pre><code>{&#xA;  node: (id: ""some global id"") {&#xA;    id,&#xA;    ... on SomeType {&#xA;      someField&#xA;    }&#xA;  }&#xA;} &#xA;</code></pre>&#xA;&#xA;<p><code>Node</code> interface is used for that on GraphGL schema, which helps you to define the Type with global id.</p>&#xA;&#xA;<p>Check details on <a href=""http://facebook.github.io/relay/docs/graphql-object-identification.html#content"">Global Object Identification</a> and it's <a href=""http://facebook.github.io/relay/graphql/objectidentification.htm"">Specification</a></p>&#xA;",1127411,,,,2015-09-05 10:33:23,"",,0,0,0,2015-09-05 10:33:23
32497759,1,32508427,,5,3617,"<p>First off my graphql data model:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>type Human {&#xA;  id: !String,&#xA;  name: !String,&#xA;  children: [Human]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The only route (relay route config) I'm atm using:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class extends Relay.Route {&#xA;  static queries = {&#xA;    human: () =&gt; Relay.QL`query RootQuery { viewer }`&#xA;  };&#xA;  static routeName = 'AppHomeRoute';&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The list component:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class HumanList extends Component {&#xA;  render() {&#xA;    let {children} = this.props.human;&#xA;&#xA;    let subListsHTML = human ? children.map(child =&gt; (&#xA;      &lt;HumanListItem key={child.id} human={child}/&gt;&#xA;    )) : '';&#xA;&#xA;    return &lt;ul&gt;{subListsHTML}&lt;/ul&gt;;&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(HumanList, {&#xA;  fragments: {&#xA;    human: () =&gt;  Relay.QL`&#xA;      fragment on Human {&#xA;        children {&#xA;          id,&#xA;          ${HumanListItem.getFragment('human')}&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The list item component:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class HumanListItem extends Component {&#xA;  state = {expanded: false};&#xA;&#xA;  render() {&#xA;    let {human} = this.props;&#xA;&#xA;    let sublistHTML = '';&#xA;    if (this.state.expanded) {&#xA;      sublistHTML = &lt;ul&gt;&lt;HumanList human={human}/&gt;&lt;/ul&gt;;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;li&gt;&#xA;        &lt;div onClick={this.onClickHead.bind(this)}&gt;{human.name}&lt;/div&gt;&#xA;        {sublistHTML}&#xA;      &lt;/li&gt;&#xA;    );&#xA;  }&#xA;&#xA;  onClickHead() {&#xA;    this.props.relay.setVariables({expanded: true});&#xA;    this.setState({expanded: true});&#xA;  }&#xA;&#xA;}&#xA;&#xA;HumanListItem.defaultProps = {viewer: {}};&#xA;&#xA;export default Relay.createContainer(HumanListItem, {&#xA;&#xA;  initialVariables: {&#xA;    expanded: false&#xA;  },&#xA;&#xA;  fragments: {&#xA;    human: (variables) =&gt;  Relay.QL`&#xA;      fragment on Human {&#xA;        name,&#xA;        ${HumanList.getFragment('human').if(variables.expanded)}&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Which runs fine for the root list. But as soon as I click on a ListItem and it is expanded, I get the following error:</p>&#xA;&#xA;<p><code>Warning: RelayContainer: Expected prop 'human' supplied 'HumanList' to be data fetched by Relay. This is likely an error unless you are purposely passing in mock data that conforms to the shape of this component's fragment.</code></p>&#xA;&#xA;<p>I can't make much sense of it, since the data I'm passing is not mocked but directly fetched by Relay as can be seen in the HumanList comp.</p>&#xA;",1501916,,,,2015-09-10 18:11:29,"Recursive data & components, later fetches throwing an error",<reactjs><graphql><relayjs>,1,0,0,2015-09-10 09:15:58
32498191,2,,32442814,0,,"<p>I suppose you have a <code>depth</code> attribute of the <code>Comment</code> data structure, which should be pretty useful, for example, to limit the max nested depth when the users are posting comments.</p>&#xA;&#xA;<p>So that your problem could be solved like this: in the <code>resolver</code> of the <code>comments</code> attribute, check the <code>depth</code>, return nothing if the <code>depth</code> is going illegal, otherwise fetch the comments and return.</p>&#xA;",783794,,,,2015-09-10 09:35:05,"",,0,0,0,2015-09-10 09:35:05
32508427,2,,32497759,10,,"<p>The error indicates that the <code>&lt;HumanList&gt;</code> is being rendered before its data is ready. </p>&#xA;&#xA;&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class HumanListItem extends Component {&#xA;  onClickHead() {&#xA;    this.props.relay.setVariables({expanded: true});&#xA;    this.setState({expanded: true});  // &lt;-- this causes the component to re-render before data is ready&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Rather than using state, you can instead look at the current value of the variables:</p>&#xA;&#xA;&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class HumanListItem extends Component {&#xA;  // no need for `state.expanded`&#xA;&#xA;  render() {&#xA;    let {human} = this.props;&#xA;&#xA;    let sublistHTML = '';&#xA;    if (this.props.relay.variables.expanded) {&#xA;      // `variables` are the *currently fetched* data&#xA;      // if `variables.expanded` is true, expanded data is fetched&#xA;      sublistHTML = &lt;ul&gt;&lt;HumanList human={human}/&gt;&lt;/ul&gt;;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;li&gt;&#xA;        &lt;div onClick={this.onClickHead.bind(this)}&gt;{human.name}&lt;/div&gt;&#xA;        {sublistHTML}&#xA;      &lt;/li&gt;&#xA;    );&#xA;  }&#xA;&#xA;  onClickHead() {&#xA;    this.props.relay.setVariables({expanded: true});&#xA;    // no need for `setState()`&#xA;  }&#xA;&#xA;}&#xA;&#xA;HumanListItem.defaultProps = {viewer: {}};&#xA;&#xA;export default Relay.createContainer(HumanListItem, {&#xA;&#xA;  initialVariables: {&#xA;    expanded: false&#xA;  },&#xA;&#xA;  fragments: {&#xA;    human: (variables) =&gt;  Relay.QL`&#xA;      fragment on Human {&#xA;        name,&#xA;        ${HumanList.getFragment('human').if(variables.expanded)}&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;});&#xA;</code></pre>&#xA;",4690687,,4690687,2015-09-10 18:11:29,2015-09-10 18:11:29,"",,0,1,0,2015-09-10 17:41:36
32508505,2,,32491117,12,,"<p>You probably want a <code>@relay(plural: true)</code> directive on your <code>cards</code> query fragment. There is an example of a plural field in action <a href=""https://github.com/facebook/relay/blob/2d822400dbcf14f9636ab3149477f4ff0a0ee466/examples/star-wars/js/components/StarWarsApp.js#L26"" rel=""noreferrer"">in the Star Wars example</a> in the Relay repo.</p>&#xA;&#xA;<p>If you care about pagination, though, you probably want a connection instead of a plural field. Connections are described <a href=""http://facebook.github.io/relay/docs/graphql-connections.html#content"" rel=""noreferrer"">in the Relay docs</a> and implemented in <a href=""https://github.com/graphql/graphql-relay-js#connections"" rel=""noreferrer"">graphql-relay-js</a>.</p>&#xA;",2103996,,2653,2015-10-14 04:14:41,2015-10-14 04:14:41,"",,0,3,0,2015-09-10 17:45:55
32588021,1,32591989,,6,1117,<p>I've looked through all of Relay's documentation and there doesn't seem to be a straightforward explanation on how to build a Relay connection with an ORM. All the examples seem to use the <code>connectionFromArray</code> method which is fine if you're storing your data in memory but when you're storing the data in a database how would you go about providing the information necessary for a connection's pagination to work?</p>&#xA;,3105183,,3105183,2015-09-15 14:21:22,2015-09-15 17:17:45,How do you define a relay connection for pagination against an ORM?,<javascript><node.js><graphql><relayjs><graphql-js>,1,0,0,2015-09-15 13:57:12
32591989,2,,32588021,6,,"<p>The cursor is <a href=""http://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"" rel=""noreferrer"">opaque</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>The result of this field is considered opaque by Relay, but will be passed back to the server as described in the ""Arguments"" section below.</p>&#xA;</blockquote>&#xA;&#xA;<p>So, depending on your data model, it may be appropriate to pass something as simple as an ID string as a cursor, which you could then use on the server to load the connection using a clause like <code>WHERE id &gt; ?</code>. You could pack arbitrary info in here necessary for pagination here and Base-64 encode it, for example.</p>&#xA;&#xA;<p>It you look at <a href=""https://github.com/graphql/graphql-relay-js/blob/2a5fdb48145e143e67a318ee2ebb10fb4fbe9c5e/src/connection/arrayconnection.js#L27-L73"" rel=""noreferrer"">the code which returns a connection from an array</a>, you'll get a rough idea of the semantics you'll need do implement on top of your ORM-backed storage, but instead of indexing into the array like it does, you'll be synthesizing an opaque cursor that contains enough info to do subsequent pagination with your ORM.</p>&#xA;",2103996,,,,2015-09-15 17:17:45,"",,0,1,0,2015-09-15 17:17:45
32613879,1,32615799,,3,589,"<p>The <code>RANGE_ADD</code> mutation requires an <code>edgeName</code> so that it can insert the new edge into the client side connection. As part of its query, it also includes the <code>cursor</code>.</p>&#xA;&#xA;<p>The issue is that the server has no way of knowing which args the client might be applying to a connection when it's generating the edge response.</p>&#xA;&#xA;<p>Does this mean that the <code>cursor</code> should be stable?</p>&#xA;",2540138,,,,2015-09-16 18:14:49,Should the opaque cursors in connections be stable across different field args?,<graphql><relayjs>,1,0,0,2015-09-16 16:21:20
32615683,1,32619017,,4,1933,"<p>Using Relay and GraphQL, let's say that I have a schema that returns a viewer, and an embedded list of associated documents. The root query (composed with fragments) would look like something like this:</p>&#xA;&#xA;<pre><code>query Root {&#xA;  viewer {&#xA;    id,&#xA;    name,&#xA;    groups {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          name,&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This will allow me to display the user, and a list of all of its associated groups. </p>&#xA;&#xA;<p>Now let's say that I want the user to be able to click on that list item, and have it expand to show the comments associated with that particular list item. How should I restructure my query for the relay route such that I can receive those comments? If I add a comments edge to my groups edge, then won't it fetch the comments for all of the groups?</p>&#xA;&#xA;<pre><code>query Root {&#xA;  viewer {&#xA;    id,&#xA;    name,&#xA;    groups {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          name,&#xA;          comments {&#xA;            edges {&#xA;              node {&#xA;                id,&#xA;                content&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Or should I alter the route query to find a specific group?</p>&#xA;&#xA;<pre><code>query Root {&#xA;  group(id: ""someid""){&#xA;    id,&#xA;    name,&#xA;    comments {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          content&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  viewer {&#xA;    id,&#xA;    name,&#xA;    groups {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          name,&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My concern is, in particular, using this within the context of <code>relay</code>. I.e., how can I efficiently construct a route query that will only fetch the comments for the expanded list item (or items), while still taking advantage of the cached data that already exists, and will be updated when doing mutations? The above example might work for a specific expanded group, but I'm not sure how I could expand multiple groups simultaneously without fetching those fields for <em>all</em> of the group items. </p>&#xA;",1198166,,,,2015-09-16 21:25:57,fetching additional information for a particular list item in relay/graphql,<graphql><relayjs><graphql-js>,1,0,0,2015-09-16 18:07:55
32615799,2,,32613879,10,,"<p>In general, cursors are not required to be the same when connections are used with different arguments. For example, if I did:</p>&#xA;&#xA;<pre><code>{&#xA;  namedFriends: friends(orderby:NAME first:5) {&#xA;    edges { cursor, node { id } }&#xA;  }&#xA;  favoriteFriends: friends(orderby:FAVORITE first:5) {&#xA;    edges { cursor, node { id } }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Different backends might be use to server those two connections, since we might have different backends for the two orderings; because of that, the cursors might be different for the same friend, because they might need to encode different information for the different backends.</p>&#xA;&#xA;<p>This makes it tricky when performing a mutation, though:</p>&#xA;&#xA;<pre><code>mutation M {&#xA;  addFriend($input) {&#xA;    newFriendsEdge {&#xA;      { cursor, node { id } } // Which cursor is this?&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In cases like this, where the mutation is going to return an edge from a connection, it's useful for the <em>field</em> to accept the same non-pagination arguments that the connection does. So in the above case, we would do:</p>&#xA;&#xA;<pre><code>mutation M {&#xA;  addFriend($input) {&#xA;    newNamedFriendsEdge: newFriendsEdge(orderby:NAME) {&#xA;      { cursor, node { id } } // Cursor for namedFriends&#xA;    }&#xA;    newFavoriteFriendsEdge: newFriendsEdge(orderby:FAVORITE) {&#xA;      { cursor, node { id } } // Cursor for favoriteFriends&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And ideally, the implementation for <code>newFriendsEdge(orderby:FAVORITE)</code> and <code>favoriteFriends: friends(orderby:FAVORITE first:5)</code> share common code to generate cursors.</p>&#xA;&#xA;<p>Note that while the cursors are not required to be the same, it's fine if they are, as an implementation detail of the server. Often, the cursor is just the ID of the node, which is a common way for this to happen. In practice, in these situations, if a argument on the connections <em>doesn't</em> affect the cursor, we would omit it from the mutation's edge field; so if <code>orderby</code> didn't affect the cursor, then:</p>&#xA;&#xA;<pre><code>mutation M {&#xA;  addFriend($input) {&#xA;    newFriendsEdge {&#xA;      { cursor, node { id } } // orderby didn't exist on newFriendsEdge, so this cursor must apply to both.&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the common pattern in our mutations. Let me know if you run into any issues; we thought through the ""arguments change cursors"" case when developing the pattern of returning edges on mutations to make sure there was a possible solution to it (which is when we came up with the arguments on edge fields idea), but it hasn't come up in practice all that much, so if you run into trickiness definitely let me know, and we can and should revisit these assumptions / requirements!</p>&#xA;",5343575,,,,2015-09-16 18:14:49,"",,0,0,0,2015-09-16 18:14:49
32619017,2,,32615683,5,,"&#xA;&#xA;<p>Relay 0.3.2 will support the <code>@skip</code> and <code>@include</code> directives.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>Group = Relay.createContainer(Group, {&#xA;  initialVariables: {&#xA;    numCommentsToShow: 10,&#xA;    showComments: false,&#xA;  },&#xA;  fragments: {&#xA;    group: () =&gt; Relay.QL`&#xA;      fragment on Group {&#xA;        comments(first: $numCommentsToShow) @include(if: $showComments) {&#xA;          edges {&#xA;            node {&#xA;              content,&#xA;              id,&#xA;            },&#xA;          },&#xA;        },&#xA;        id,&#xA;        name,&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>In your render method, only render comments if <code>this.props.group.comments</code> is defined. Invoke <code>this.props.relay.setVariables({showComments: true})</code> in the Group component to cause the comments field to be included (and fetched, if necessary).</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class Group extends React.Component {&#xA;  _handleShowCommentsClick() {&#xA;    this.props.relay.setVariables({showComments: true});&#xA;  }&#xA;  renderComments() {&#xA;    return this.props.group.comments&#xA;      ? &lt;Comments comments={this.props.group.comments} /&gt;&#xA;      : &lt;button onClick={this._handleShowCommentsClick}&gt;Show comments&lt;/button&gt;;&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        ...&#xA;        {this.renderComments()}&#xA;      &lt;/div&gt;&#xA;    );  &#xA;  }&#xA;}&#xA;</code></pre>&#xA;",802047,,,,2015-09-16 21:25:57,"",,0,6,0,2015-09-16 21:25:57
32734901,1,32739012,,1,1455,"<p>I have the following GraphQL schema:</p>&#xA;&#xA;<pre><code>interface Node {&#xA;  id: ID!&#xA;}&#xA;&#xA;type User : Node {&#xA;  id: ID!&#xA;  name: String!&#xA;  tasks: [Task]&#xA;}&#xA;&#xA;type Task : Node {&#xA;  id: ID!&#xA;  day: Int!&#xA;  description: String!&#xA;}&#xA;&#xA;type Viewer {&#xA;  users: [User]&#xA;}&#xA;&#xA;type Query {&#xA;  viewer: Viewer&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Basically, every user can have a list of tasks. The problem occurs when I need to fetch a list of all tasks to get a response like this:</p>&#xA;&#xA;<pre><code>tasks: [{&#xA;  day: 1,&#xA;  user: {&#xA;    name: ""John""&#xA;  }&#xA;}, {&#xA;  day: 2,&#xA;  user: {&#xA;    name: ""Jane""&#xA;  }&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>How should I edit my schema to allow fetching like that?</p>&#xA;",1518183,,1011722,2019-06-02 22:29:03,2019-06-02 22:29:03,Bidirectional fetching in GraphQL,<reactjs><relay><graphql><graphql-js>,1,0,0,2015-09-23 08:47:30
32743156,1,,,0,435,"<p>I still have some troubles understanding the concept of fat queries in Relay, especially about the part of the intersection logic to determine which data to re-fetch.</p>&#xA;&#xA;<p>Up to now, I have build a simple hierarchical data structure with a <code>UserType</code> as root query (named <code>viewer</code>) which has a number of <code>projects</code> (of type <code>ProjectConnectionType</code>) associated with it. Each of this projects has another <code>projects</code> field (also of type <code>ProjectConnectionType</code>) to model an arbitrarily nested sub-project hierarchy.</p>&#xA;&#xA;<p>I also have two higher order React components <code>ProjectList</code> and <code>ProjectListItem</code> to render this structure by conditionally expanding fragments (by using a Relay variable <code>expanded</code> within my list item component).</p>&#xA;&#xA;<p>So far, this works fine and I am quite happy with it. The tricky part is now the <code>AddProject</code> mutation. I have created a mutation which takes a name and the <code>parentProjectId</code> as input (might be null for root projects) and creates a new node on the server side at the right location. After that, it should return the new <code>projectEdges</code> (which are appended using <code>RANGE_ADD</code> afterwards), as well as the <code>parentProject</code> or <code>viewer</code> so that I also can update the <code>subprojectCount</code> there.</p>&#xA;&#xA;<p>In case of the viewer (unique global root query point) everything works fine as well. Relay correctly calculates the intersection and asks for the new data from the server. But when I try to add a sub-project, I keep getting a completely empty response without any output fields (besides the mutation id). My guess is that Relay seems to get the intersection wrong by not knowing how to map the <code>parentProject</code> field accordingly. I have already tried to add a <code>FIELDS_CHANGE</code> config for it as well as querying <code>parentProject: node(id: ""$parentProjectId"")</code> within my fat query (which wasn't working either).</p>&#xA;&#xA;<p>What I am missing? I have read the documentation a couple of times now, but I still do not understand the concept of mutations and I feel already quite dumb.</p>&#xA;",82219,,,,2015-09-23 15:06:01,Understanding fat queries and tree structures,<reactjs><graphql><relayjs>,0,3,0,2015-09-23 15:06:01
32760418,1,,,21,3609,"<p>I am experimenting with React + Relay + Graphql these days. Unfortunately, I cannot find any easy and convenient way to test React component wrapped by Relay Container.</p>&#xA;&#xA;<p>Basically, I would like to achieve these goals along TDD,</p>&#xA;&#xA;<ol>&#xA;<li>Render a container and test its content,</li>&#xA;<li>Change variables and test its changes on content.</li>&#xA;</ol>&#xA;&#xA;<p>Compared with React + Flux, React + Relay is more like black box, or, declarative.</p>&#xA;&#xA;<p>I can see people mock Relay.createContainer to bypass Relay and merely test React Component. It leaves the Relay part uncovered and there is no way to <em>drive</em> this part by testing.&#xA;<a href=""https://github.com/facebook/relay/issues/161"">https://github.com/facebook/relay/issues/161</a></p>&#xA;&#xA;<p>Also, I read through test cases of Relay and its really tedious to render a mock container.&#xA;<a href=""https://github.com/facebook/relay/blob/master/src/tools/__mocks__/RelayTestUtils.js"">https://github.com/facebook/relay/blob/master/src/tools/<strong>mocks</strong>/RelayTestUtils.js</a></p>&#xA;&#xA;<p>I will be really grateful if you can share you solution.</p>&#xA;&#xA;<p>Thanks!</p>&#xA;",2741411,,,,2016-12-07 18:19:19,Testing strategy on Relay + React,<reactjs><tdd><graphql><relayjs>,2,1,0,2015-09-24 11:41:16
32776189,1,,,1,268,"<p>I'm having trouble figuring out how to accomplish what seems to be a pretty standard pattern when doing a <code>RANGE_ADD</code> mutation.</p>&#xA;&#xA;<p>Say on page load I pull in and render a connection <code>chatmessages</code> with <code>first: 10</code> pagination. I now do a <code>AddMessageMutation</code> which does a prepend to the that same connection. Since the connection is paginated by <code>first: 10</code> the last item of the connection is now gone to give room for my new edge and is thus removed from rendering. I can of course add +1 to <code>first</code> on the <code>onSuccess</code> of the mutation, but this often leaves a weird flickering effect of removing and reinserting the edge at the end.</p>&#xA;&#xA;<p>This problem seem to get even more difficult if I want to do an optimistic update to the connection since there is no <code>onOptimistic</code> callback.</p>&#xA;&#xA;<p>Since this seems like a pretty common pattern I figured I'd ask if I'm approaching this the wrong way.</p>&#xA;&#xA;<p>Referenced in issue:&#xA;<a href=""https://github.com/facebook/relay/issues/384"" rel=""nofollow"">https://github.com/facebook/relay/issues/384</a></p>&#xA;",1024243,,,,2015-09-29 03:24:19,Paginated connection plus added edge from mutation,<graphql><relayjs><graphql-js>,1,1,0,2015-09-25 06:35:51
32908821,2,,32760418,12,,"<p>I've been trying to test Relay containers like I would components in a Flux application. Specifically, I want to make sure that they render the correct content for a given state and props and that they call methods to change data in appropriate places; in Flux this is a call to an action creator, in Relay this is a call to <code>Relay.Store.update</code> or <code>this.props.relay.setVariables</code>.  </p>&#xA;&#xA;<p>My first attempt was to build a <code>RelayTestUtil</code> object with a <code>renderContainerIntoDocument</code> method. I based it heavily on <a href=""https://github.com/facebook/relay/blob/master/src/tools/__mocks__/RelayTestUtils.js"">https://github.com/facebook/relay/blob/master/src/tools/<strong>mocks</strong>/RelayTestUtils.js</a>, <a href=""https://github.com/facebook/relay/blob/master/src/legacy/store/__mocks__/GraphQLStoreQueryResolver.js"">https://github.com/facebook/relay/blob/master/src/legacy/store/<strong>mocks</strong>/GraphQLStoreQueryResolver.js</a>, and the Relay Container tests. This used very minimal mocking and was great for testing container rendering but was completely useless for testing data changes. Trying to spy on calls to <code>Relay.Store.update</code> and <code>this.props.relay.setVariables</code>, or to mock data changes, became more trouble than it was worth. </p>&#xA;&#xA;<p>I settled on adding <code>__mocks__\react-relay.js</code> to completely mock Relay and using simpler version of <code>RelayTestUtils.renderContainerIntoDocument</code> to inject Relay properties into a container. I'm not entirely satisfied with this solution, but it seems to work for now.</p>&#xA;&#xA;<p><code>__mocks__\react-relay.js</code>:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>var Relay = require.requireActual('react-relay');&#xA;var React = require('react');&#xA;&#xA;module.exports = {&#xA;  QL: Relay.QL,&#xA;  Mutation: Relay.Mutation,&#xA;  Route: Relay.Route,&#xA;  Store: {&#xA;    update: jest.genMockFn()&#xA;  },&#xA;  createContainer: (component, containerSpec) =&gt; {&#xA;    const fragments = containerSpec.fragments || {};&#xA;&#xA;    // mock the static container methods&#xA;    Object.assign(component, { getFragment: (fragmentName) =&gt; fragments[fragmentName] });&#xA;&#xA;    return component;&#xA;  }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p><code>RelayTestUtils.js</code>:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const React = require('react');&#xA;const ReactDOM = require('react-dom');&#xA;&#xA;&#xA;const RelayTestUtils = {&#xA;  renderContainerIntoDocument(containerElement, relayOptions) {&#xA;    relayOptions = relayOptions || {};&#xA;&#xA;    const relaySpec = {&#xA;      forceFetch: jest.genMockFn(),&#xA;      getPendingTransactions: jest.genMockFn().mockImplementation(() =&gt; relayOptions.pendingTransactions),&#xA;      hasOptimisticUpdate: jest.genMockFn().mockImplementation(() =&gt; relayOptions.hasOptimisticUpdate),&#xA;      route: relayOptions.route || { name: 'MockRoute', path: '/mock' },&#xA;      setVariables: jest.genMockFn(),&#xA;      variables: relayOptions.variables || {}&#xA;    };&#xA;&#xA;    return ReactDOM.render(&#xA;      React.cloneElement(containerElement, { relay: relaySpec }),&#xA;      document.createElement('div')&#xA;    );&#xA;  }&#xA;};&#xA;&#xA;export default RelayTestUtils;&#xA;</code></pre>&#xA;&#xA;<p>Tests look something like this, where <code>fragmentData</code> matches the shape of the GraphQL response:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>it('changes items', () =&gt; {&#xA;  const myContainer = RelayTestUtils.renderContainerIntoDocument(&#xA;    &lt;MyContainer { ...fragmentData }/&gt;, &#xA;    { variables: { itemId: 'asdf' } }&#xA;  );&#xA;  myContainer.changeItem();&#xA;  expect(myContainer.props.relay.setVariables).toBeCalled();&#xA;});&#xA;</code></pre>&#xA;",2394472,,,,2015-10-02 13:55:38,"",,0,2,0,2015-10-02 13:55:38
33088119,1,33088120,,55,4980,"<p>In Relay GraphQL, connections and lists are both array-like, but they have different features. When should I use each?</p>&#xA;",2103996,,,,2015-10-25 16:30:37,When should I use a Relay GraphQL connection and when a plain list?,<graphql><relayjs>,1,0,0,2015-10-12 18:45:58
33088120,2,,33088119,65,,"<h1><a href=""http://facebook.github.io/relay/docs/graphql-connections.html"">Connections</a></h1>&#xA;&#xA;<ul>&#xA;<li>More powerful and flexible than simple lists.</li>&#xA;<li>Support pagination (forward and back), with cursors.</li>&#xA;<li>Fine-grained <a href=""http://facebook.github.io/relay/docs/graphql-mutations.html"">mutation</a> support (eg. <code>RANGE_ADD</code>, <code>RANGE_DELETE</code>, <code>NODE_DELETE</code>, as described in <a href=""http://facebook.github.io/relay/docs/guides-mutations.html"">the guide</a>).</li>&#xA;<li>Requires a <code>first</code> or <code>last</code> argument in order to limit the size of the result set.</li>&#xA;<li>Has an <code>edges</code> field that provides a place to locate per-edge, edge-specific data.</li>&#xA;<li>A heavier-weight concept, requiring more work to define in the schema.</li>&#xA;</ul>&#xA;&#xA;<h1>Lists</h1>&#xA;&#xA;<ul>&#xA;<li>Simple and lightweight.</li>&#xA;<li>No support for pagination (the entire list is always returned).</li>&#xA;<li>No special mutations features for prepending, appending etc (<a href=""https://github.com/facebook/relay/issues/444"">although it is a requested feature</a>).</li>&#xA;</ul>&#xA;&#xA;<h1>Which to use?</h1>&#xA;&#xA;<ul>&#xA;<li>Whenever you need pagination, you should use a connection.</li>&#xA;<li>If you need fine-grained control over mutations, you may choose to use a connection, even if you don't need pagination.</li>&#xA;<li>If you want all the items in a connection, you can use <code>first</code> with some large number.</li>&#xA;<li>If you want to expose a short list with minimal effort, use a simple list.</li>&#xA;</ul>&#xA;",2103996,,2103996,2015-10-25 16:30:37,2015-10-25 16:30:37,"",,0,4,0,2015-10-12 18:45:58
33235109,1,33242114,,4,1813,"<p>I'm trying Relay in my React application, and it uses GraphQL by default. It looks like this (<code>Score</code> is some React.js component):</p>&#xA;&#xA;<pre><code>Score = Relay.createContainer(Score, {&#xA;    fragments: {&#xA;        score: () =&gt; Relay.QL`&#xA;            fragment on Score {&#xA;                initials,&#xA;                score,&#xA;            }&#xA;        `,&#xA;    },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The question is: can I use custom API functions to return data into fragments? Like this:</p>&#xA;&#xA;<pre><code>Score = Relay.createContainer(Score, {&#xA;    fragments: {&#xA;        score: myCustomFunction(), // It will return a dataset.&#xA;    },&#xA;});&#xA;</code></pre>&#xA;",1887427,,678093,2015-10-20 11:13:57,2015-10-20 16:39:03,Is there way to use Relay without GraphQL?,<reactjs><graphql><relayjs>,1,0,0,2015-10-20 11:11:23
33323894,1,33332068,,15,5980,"<p>In a Relay/GraphQL schema configuration, one-to-many relationships (with pagination) are specified as in the <a href=""https://github.com/facebook/relay/blob/master/examples/star-wars/data/schema.js#L74-L82"">tutorial example</a></p>&#xA;&#xA;<pre><code>type ShipConnection {&#xA;  edges: [ShipEdge]&#xA;  pageInfo: PageInfo!&#xA;}&#xA;type ShipEdge {&#xA;  cursor: String!&#xA;  node: Ship&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, the one-to-one connection made by <code>ShipEdge</code> seems redundant. Why can't we move the cursor to <code>ShipConnection</code> and store an array of <code>Ship</code> IDs as edges?</p>&#xA;&#xA;<pre><code>type ShipConnection {&#xA;  edges: [Ship]&#xA;  pageInfo: PageInfo!&#xA;  cursor: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What were the design decisions to require one extra object for every <code>edge</code> in a one-to-many relationship?</p>&#xA;",2178566,,,,2021-04-01 13:43:10,Why are edges required in a Relay/GraphQL Connection?,<graphql><relayjs>,3,0,0,2015-10-24 22:10:28
33332068,2,,33323894,9,,"<p>The <code>edges</code> field provides you with a place to put per-edge data. For example, you might want to put a <code>creator</code> or <code>priority</code> field on there, describing who added the edge and how important the relationship is, respectively. </p>&#xA;&#xA;<p>If you don't require this kind of flexibility (or the other features that you get with connections, such as pagination), you could use a simple <code>GraphQLList</code> type. See <a href=""https://stackoverflow.com/questions/33088119/when-should-i-use-a-relay-graphql-connection-and-when-a-plain-list"">this answer</a> for more on the difference between between connections and lists.</p>&#xA;",2103996,,-1,2017-05-23 11:47:26,2016-01-25 23:00:29,"",,0,0,0,2015-10-25 16:29:25
33336147,2,,33157168,2,,"<p>Yes, your sample responses look right to me. Here's a more detailed example of ""case 3"".</p>&#xA;&#xA;<h1>Sample query with an error in one of the fields</h1>&#xA;&#xA;<pre><code>query MyQuery {&#xA;  viewer {&#xA;    articles(first: 1) {&#xA;      edges {&#xA;        node {&#xA;          title&#xA;          tags # we'll introduce an error in the schema here&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h1>Sample response</h1>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""articles"": {&#xA;        ""edges"": [&#xA;          {&#xA;            ""node"": {&#xA;              ""title"": ""Sample article title"",&#xA;              ""tags"": null&#xA;            }&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  },&#xA;  ""errors"": [&#xA;    {&#xA;      ""message"": ""Cannot read property 'bar' of undefined"",&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 7,&#xA;          ""column"": 11&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;",2103996,,,,2015-10-25 23:10:34,"",,0,0,0,2015-10-25 23:10:34
33354818,1,33367168,,3,1019,"<p>I am trying to figure out how to create and delete nodes with Relay where I don't have a parent node. It seems that <code>NODE_DELETE</code>/<code>RANGE_DELETE</code> and <code>RANGE_ADD</code> all require a parent node. Is there a way to perform create and delete mutations from the root query object in Relay.js?</p>&#xA;&#xA;<p><strong><em>Note:</em></strong> I did find example where creates can be performed with a FIELDS_CHANGE query, but they lack any documentation or reason.</p>&#xA;",834102,,,,2019-04-09 18:18:15,Root Query Create and Delete in Relay.js,<reactjs><graphql><relayjs>,2,1,0,2015-10-26 20:18:30
33411416,2,,33399901,57,,"<p>The <code>Node</code> root field, in combination with globally unique IDs, comes into play when Relay needs to <em>refetch</em> an object. Refetching occurs when you call <code>this.props.relay.forceFetch()</code> or when you add fields to the query for an object whose global ID is known because it has already been partially fetched.</p>&#xA;<p>In cases like these, Relay will short circuit the regular query and execute a query for the object(s) directly using its global ID and the <code>node</code> root call.</p>&#xA;<p><strong>Example</strong>:</p>&#xA;<p>Assume that <code>$showComments</code> was <code>false</code> when this query was first resolved.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>query {&#xA;  viewer {&#xA;    stories(first: 10) {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          comments(first: 10) @include(if: $showComments) { &#xA;            author, &#xA;            commentText &#xA;          }&#xA;          text,&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This will have caused a fetch for <code>id</code> and <code>text</code> for some number of stories, whose IDs are now known.</p>&#xA;<p>Imagine that at some future time, the variable <code>$showComments</code> became <code>true</code>. Relay will refetch only the data it needs using the <code>node</code> root field.</p>&#xA;<pre><code>query {&#xA;  node(id: &quot;ABC123&quot;) { &#xA;    fragment on Story { comments(first: 10) { author, commentText } }&#xA;  }&#xA;  node(id: &quot;DEF456&quot;) { &#xA;    fragment on Story { comments(first: 10) { author, commentText } }&#xA;  }&#xA;  node(id: &quot;GHI789&quot;) { &#xA;    fragment on Story { comments(first: 10) { author, commentText } }&#xA;  }&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;<p>This depends on a few pieces:</p>&#xA;<ol>&#xA;<li>Each object must have a globally unique ID, or be identified by a type/ID pair (the <code>globalIdField</code> helper does this and produces a base64 encoded string).</li>&#xA;<li>The server must know how to resolve an object from a globally unique ID, and vice versa. This is what the <code>nodeDefinitions</code> are for.</li>&#xA;<li>Any object that hopes to be refetchable using this system must implement the <code>nodeInterface</code>.</li>&#xA;</ol>&#xA;<p>See also: <a href=""https://relay.dev/docs/guides/graphql-server-specification/#object-identification"" rel=""nofollow noreferrer"">https://relay.dev/docs/guides/graphql-server-specification/#object-identification</a></p>&#xA;",802047,,802047,2021-03-16 18:55:51,2021-03-16 18:55:51,"",,0,7,0,2015-10-29 10:15:13
33415517,1,,,0,1591,"<p>Assume I have a field called <code>country</code> defined at the top level of my GraphQL schema. I can query it in the following way:</p>&#xA;&#xA;<pre><code>query {&#xA;  country(alpha2: ""gb"") {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In my relay container I can specify the attributes that I would like returned with a fragment on <code>Country</code>:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(CountryComponent, {&#xA;  fragments: {&#xA;    country: () =&gt; Relay.QL`&#xA;      fragment on Country {&#xA;        name&#xA;      }&#xA;    `&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I change the value of the <code>alpha2</code> argument from within my react component? I could nest the <code>country</code> field under some arbitrary field and declare my relay fragment on the parent but would rather avoid unnecessarily modifying my graph if possible.</p>&#xA;",122446,,,,2015-10-29 17:20:53,Passing arguments to top level fields from within a Relay container,<reactjs><graphql><relayjs>,1,1,0,2015-10-29 13:26:01
33472181,2,,33460053,0,,"<p><code>activities</code> is an example of a <em>plural non-identifying field</em>. It is plural in the sense that it returns a list of things, and non-identifying in the sense that the individual elements of that list are not identified by global IDs.</p>&#xA;&#xA;<p>Relay does not support plural non-identifying fields at the root, but support is coming. Follow along at <a href=""https://github.com/facebook/relay/issues/112"" rel=""nofollow"">https://github.com/facebook/relay/issues/112</a></p>&#xA;",802047,,,,2015-11-02 06:53:11,"",,0,0,0,2015-11-02 06:53:11
33617817,2,,33617319,6,,"<p>Relay requires that you follow certain conventions with your GraphQL schema; these conventions are documented in the <a href=""http://facebook.github.io/relay/docs/graphql-relay-specification.html#content"" rel=""noreferrer"">GraphQL Relay Specification</a>. Note that these conventions are useful whether or not you're using Relay as the client.</p>&#xA;&#xA;<p><code>graphql-relay-js</code> is a set of helpers to make it easier to implement the above specification. This module is <em>not</em> required in order to use Relay - you're free to implement the above spec manually.</p>&#xA;",4690687,,,,2015-11-09 20:37:48,"",,0,0,0,2015-11-09 20:37:48
33631322,1,33686001,,1,302,"<p>The <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#range-add"" rel=""nofollow"">docs describe</a> <code>rangeBehaviors</code> as:</p>&#xA;&#xA;<blockquote>&#xA;  <p>A map of GraphQL calls to the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls. Behaviors can be one of 'append', 'prepend', or 'remove'.</p>&#xA;</blockquote>&#xA;&#xA;<p>The example in the docs is:</p>&#xA;&#xA;<pre><code>rangeBehaviors: {&#xA;  // When the ships connection is not under the influence&#xA;  // of any call, append the ship to the end of the connection&#xA;  '': 'append',&#xA;  // Prepend the ship, wherever the connection is sorted by age&#xA;  'orderby(newest)': 'prepend',&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and in another example in the <a href=""https://github.com/facebook/relay/blob/v0.4.0/examples/todo/js/mutations/AddTodoMutation.js#L45-L50"" rel=""nofollow"">todos example repo</a> you have: </p>&#xA;&#xA;<pre><code>rangeBehaviors: {&#xA;  '': 'append',&#xA;  'status(any)': 'append',&#xA;  'status(active)': 'append',&#xA;  'status(completed)': null,&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What is a ""GraphQL call"" in this case? What does it mean to be ""under the influence of"" such a call?</p>&#xA;",741970,,,,2015-11-13 04:35:03,"What are the ""GraphQL calls"" in the `rangeBehaviors` attribute of the `RANGE_ADD` mutator config?",<graphql><relayjs>,1,0,0,2015-11-10 13:37:55
33638409,1,,,1,456,"<p>How to write <code>outputFields</code>, <code>getFatQuery</code>, <code>getConfigs</code> for create new item and update items list<br>&#xA;Please take a look <a href=""https://gist.github.com/ButuzGOL/9e7e7323db7d9b6ce28d"" rel=""nofollow"">gist</a> or <a href=""https://facebook.github.io/relay/prototyping/playground.html#source=class%20CreateCommentMutation%20extends%20Relay.Mutation%20%7B%0A%20%20getMutation()%20%7B%0A%20%20%20%20return%20Relay.QL%60%0A%20%20%20%20%20%20mutation%7B%20createComment%20%7D%0A%20%20%20%20%60%3B%0A%20%20%7D%0A%20%20getFatQuery()%20%7B%0A%20%20%20%20return%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20CreateCommentPayload%20%7B%20%0A%20%20%20%20%20%20%20%20story%20%7B%20comments%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%3B%0A%20%20%7D%0A%20%20getConfigs()%20%7B%0A%20%20%20%20return%20%5B%5D%3B%0A%20%20%7D%0A%20%20getVariables()%20%7B%0A%20%20%20%20return%20%7B%20text%3A%20this.props.text%20%7D%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Comment%20extends%20React.Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20var%20%7Bid%2C%20text%7D%20%3D%20this.props.comment%3B%0A%20%20%20%20return%20%3Cli%20key%3D%7Bid%7D%3E%7Btext%7D%3C%2Fli%3E%3B%0A%20%20%7D%0A%7D%0AComment%20%3D%20Relay.createContainer(Comment%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20comment%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Comment%20%7B%0A%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20text%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20Story%20extends%20React.Component%20%7B%0A%20%20_handleSubmit%20%3D%20(e)%20%3D%3E%20%7B%0A%20%20%20%20e.preventDefault()%3B%0A%20%20%20%20Relay.Store.update(%0A%20%20%20%20%20%20new%20CreateCommentMutation(%7B%0A%20%20%20%20%20%20%20%20text%3A%20this.refs.newCommentInput.value%2C%0A%20%20%20%20%20%20%7D)%0A%20%20%20%20)%3B%0A%20%20%20%20this.refs.newCommentInput.value%20%3D%20&#39;&#39;%3B%0A%20%20%7D%0A%20%20render()%20%7B%0A%20%20%20%20var%20%7Bcomments%7D%20%3D%20this.props.story%3B%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3Cform%20onSubmit%3D%7Bthis._handleSubmit%7D%3E%0A%20%20%20%20%20%20%20%20%3Ch1%3EBreaking%20News%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%3Cp%3EThe%20peanut%20is%20neither%20a%20pea%20nor%20a%20nut.%3C%2Fp%3E%0A%20%20%20%20%20%20%20%20%3Cstrong%3EDiscuss%3A%3C%2Fstrong%3E%0A%20%20%20%20%20%20%20%20%3Cul%3E%0A%20%20%20%20%20%20%20%20%20%20%7Bcomments.map(%0A%20%20%20%20%20%20%20%20%20%20%20%20comment%20%3D%3E%20%3CComment%20comment%3D%7Bcomment%7D%20%2F%3E%0A%20%20%20%20%20%20%20%20%20%20)%7D%0A%20%20%20%20%20%20%20%20%3C%2Ful%3E%0A%20%20%20%20%20%20%20%20%3Cinput%0A%20%20%20%20%20%20%20%20%20%20placeholder%3D%22Weigh%20in%26hellip%3B%22%0A%20%20%20%20%20%20%20%20%20%20ref%3D%22newCommentInput%22%0A%20%20%20%20%20%20%20%20%20%20type%3D%22text%22%0A%20%20%20%20%20%20%20%20%2F%3E%0A%20%20%20%20%20%20%3C%2Fform%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0AStory%20%3D%20Relay.createContainer(Story%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20story%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Story%20%7B%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BComment.getFragment(&#39;comment&#39;)%7D%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20StoryHomeRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20&#39;Home&#39;%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20story%3A%20(Component)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20StoryQuery%20%7B%0A%20%20%20%20%20%20%20%20story%20%7B%20%24%7BComponent.getFragment(&#39;story&#39;)%7D%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BStory%7D%0A%20%20%20%20route%3D%7Bnew%20StoryHomeRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B&amp;schema=import%20%7B%0A%20%20GraphQLID%2C%0A%20%20GraphQLList%2C%0A%20%20GraphQLNonNull%2C%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%7D%20from%20&#39;graphql&#39;%3B%0Aimport%20%7B%0A%20%20mutationWithClientMutationId%2C%0A%7D%20from%20&#39;graphql-relay&#39;%3B%0A%0Aconst%20STORY%20%3D%20%7B%0A%20%20comments%3A%20%5B%5D%0A%7D%3B%0A%0Avar%20CommentType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Comment&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20id%3A%20%7Btype%3A%20GraphQLID%7D%2C%0A%20%20%20%20text%3A%20%7Btype%3A%20GraphQLString%7D%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A%0Avar%20StoryType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Story&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20comments%3A%20%7B%20type%3A%20new%20GraphQLList(CommentType)%20%7D%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A%0Avar%20CreateCommentMutation%20%3D%20mutationWithClientMutationId(%7B%0A%20%20name%3A%20&#39;CreateComment&#39;%2C%0A%20%20inputFields%3A%20%7B%0A%20%20%20%20text%3A%20%7B%20type%3A%20new%20GraphQLNonNull(GraphQLString)%20%7D%2C%0A%20%20%7D%2C%0A%20%20outputFields%3A%20%7B%0A%20%20%20%20story%3A%20%7B%0A%20%20%20%20%20%20type%3A%20StoryType%2C%0A%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20STORY%2C%0A%20%20%20%20%7D%2C%0A%20%20%7D%2C%0A%20%20mutateAndGetPayload%3A%20(%7Btext%7D)%20%3D%3E%20%7B%0A%20%20%20%20var%20newComment%20%3D%20%7B%0A%20%20%20%20%20%20id%3A%20STORY.comments.length%2C%0A%20%20%20%20%20%20text%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20STORY.comments.push(newComment)%3B%0A%20%20%20%20return%20newComment%3B%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aexport%20default%20new%20GraphQLSchema(%7B%0A%20%20query%3A%20new%20GraphQLObjectType(%7B%0A%20%20%20%20name%3A%20&#39;Query&#39;%2C%0A%20%20%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20%20%20story%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20StoryType%2C%0A%20%20%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20STORY%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D)%2C%0A%20%20%7D)%2C%0A%20%20mutation%3A%20new%20GraphQLObjectType(%7B%0A%20%20%20%20name%3A%20&#39;Mutation&#39;%2C%0A%20%20%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20%20%20createComment%3A%20CreateCommentMutation%2C%0A%20%20%20%20%7D)%2C%0A%20%20%7D)%2C%0A%7D)%3B"" rel=""nofollow"">live</a> </p>&#xA;&#xA;<p>Questions are</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>  getFatQuery() {&#xA;    return Relay.QL`&#xA;      ???&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [???];&#xA;  }&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>  outputFields: {&#xA;    ???&#xA;  },&#xA;</code></pre>&#xA;&#xA;&#xA;&#xA;&#xA;",1309841,,1309841,2015-11-11 05:24:27,2016-03-09 21:41:48,"Relay how to write outputFields, getFatQuery, getConfigs for create new Item",<graphql><relayjs>,1,0,0,2015-11-10 19:54:52
33678984,1,,,-2,96,"<p>I'm trying to update the <code>viewer</code> field of the root node when user logs in with a <code>UpdateUserSessionMutation</code>. However since viewer starts as null and doesn't have an id initially, I'm not able to update the viewer field with the MutaitonPayload using <code>FIELDS_CHANGE</code>.</p>&#xA;",96725,,,,2015-11-18 21:31:09,How to update root node such as viewer?,<reactjs><graphql><relayjs>,1,1,0,2015-11-12 18:47:09
33686001,2,,33631322,2,,"<p>When you query for a connection field in Relay, you can potentially specify arguments beyond just the standard pagination arguments of <code>first</code>, <code>last</code>, <code>before</code>, and <code>after</code>.</p>&#xA;&#xA;<p>In the TodoMVC example above, we qualify the query by the current filter on status. The meaning of the TodoMVC code you've shown is that the mutation should append the new todo for queries that filter for statuses of <code>""active""</code> or <code>""any""</code> (or the default status), but not for queries that filter to only the status of <code>""completed""</code> (which makes sense in context, since the mutation adds a new, active todo).</p>&#xA;",5319173,,,,2015-11-13 04:35:03,"",,0,3,0,2015-11-13 04:35:03
33773263,1,33790684,,2,1270,"<p>Relay provides the <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#node-delete"" rel=""nofollow""><code>NODE_DELETE</code> mutation config</a> to ""remove the node from a connection and delete the associated record from the store"". </p>&#xA;&#xA;<p>But what happens when for instance node A is included as a connection from nodes B1, B2, B3... (an unknown number of them), and our application has Relay containers showing those B nodes and their respective connections to A? If we delete A just from the B1 connection via <code>NODE_DELETE</code>, will all Relay containers get updated, or just the one showing B1?</p>&#xA;",2773399,,,,2015-11-18 21:24:35,How to delete a node fetched by Relay from all connections that include it?,<reactjs><relayjs><graphql>,1,0,0,2015-11-18 06:33:15
33790684,2,,33773263,3,,"<p>Since every node has a globally unique ID, Relay knows that the nodes with IDs specified in <code>deletedIDFieldName</code> were deleted, and can exclude them from all connections in which they existed.</p>&#xA;",384349,,,,2015-11-18 21:24:35,"",,0,2,0,2015-11-18 21:24:35
33959991,1,,,2,456,"<p>The schemas of GraphQL and Relay differ a bit, like Relay has connections for example. Is it still possible to do queries to these nodes with cURL, for instance, on a Relay schema with connections? Or what is the best way to check if the schema is working accordingly?</p>&#xA;",5393551,,5052733,2019-07-30 12:35:37,2019-07-30 12:35:37,Difference between schemas in GraphQL and Relay,<javascript><relay><graphql>,1,2,0,2015-11-27 14:56:09
34098791,1,,,2,965,"<p>With Relay, you create a React component as usual:</p>&#xA;&#xA;<pre><code>class TodoApp extends React.Component {&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then component is wrapped in a Relay container:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(TodoApp, {&#xA;  ...&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The Relay container will fetch data using GraphQL and then update the state. This is a higher order component and this state is then passed down as props to its children. </p>&#xA;&#xA;<p>This isn't (or doesn't appear to be) compatible with a flux implementation like Redux. Redux has a single global state object and it too has higher order components that pass props down to presentational components. So I don't see how both the Redux store and Relay containers can coexist currently.</p>&#xA;&#xA;<p>So then how should we update state that doesn't come from the database? How is this state supposed to be managed with Relay?</p>&#xA;",4285364,,458193,2015-12-07 13:44:24,2016-01-04 11:21:53,Updating React state with Relay,<javascript><reactjs><redux><relay><graphql>,3,0,0,2015-12-04 22:49:24
34117054,2,,34098791,0,,"<p>These things are still in discussion and the current state of Redux and Relay may not fit well together if you use a Relay container.</p>&#xA;&#xA;<p>You can join the discussion <a href=""https://github.com/rackt/redux/issues/464"" rel=""nofollow"">here</a></p>&#xA;",2626103,,,,2015-12-06 11:44:23,"",,0,0,0,2015-12-06 11:44:23
34135053,2,,34098791,5,,"<p>While I can’t offer you an advice on using them together, <strong>technically you can definitely have several higher order components applied one after another:</strong></p>&#xA;&#xA;<pre><code>class TodoApp extends React.Component {&#xA;  // ...&#xA;}&#xA;&#xA;TodoApp = connect(&#xA;  // ...&#xA;)(TodoApp);&#xA;&#xA;TodoApp = Relay.createContainer(TodoApp, {&#xA;  // ...&#xA;});&#xA;&#xA;export default TodoApp;&#xA;</code></pre>&#xA;&#xA;<p>I’m not sure this makes a lot of sense, but it’s easily doable.</p>&#xA;",458193,,458193,2015-12-08 11:33:18,2015-12-08 11:33:18,"",,0,1,0,2015-12-07 13:44:08
34192507,1,34192654,,9,9307,<p>I use <code>first</code> <code>after</code> and <code>last</code> <code>before</code> to do pagination.&#xA;<code>hasNextPage</code> and <code>hasPreviousPage</code> are very useful.</p>&#xA;&#xA;<p>But what I need is also the <code>total count</code> so that I can calculate and show things like <code>page 5 of 343 pages</code> on the client.</p>&#xA;&#xA;<p>Unfortunately that is not part of <code>pageInfo</code> even though I have the information on the server site.</p>&#xA;&#xA;<p>Can you please include a <code>total</code> field in the <code>pageInfo</code> and extend <code>connectionFromArray</code> to take in the total <code>arrayLength</code> like <code>connectionFromArraySlice</code> already does?</p>&#xA;&#xA;<p>Thanks</p>&#xA;,2514535,,3354657,2016-11-14 09:34:53,2018-08-08 18:14:08,How to pass total count to the client in pageInfo,<javascript><reactjs><relayjs><graphql-js>,3,0,0,2015-12-10 02:06:45
34192587,1,,,0,234,"<p>I have an array/table with lets say 10000 items.</p>&#xA;&#xA;<p>Now I try to show the items from index 4000 to 4010 in my react relay client.</p>&#xA;&#xA;<p>But at the moment the <code>connectionArgs</code> only allow navigation with <code>cursors</code>, but I DON'T want to page until I arrive at item 4000.</p>&#xA;&#xA;<p>How to I navigate to a given offset with a GraphQL query ?</p>&#xA;&#xA;<p>Thank you</p>&#xA;",2514535,,,,2016-03-27 02:11:06,How to navigate without cursors in a connection,<reactjs><relayjs><graphql-js>,1,0,0,2015-12-10 02:14:11
34192654,2,,34192507,17,,"<p><code>pageInfo</code> is designed to represent information about the specific page, whereas the total number of items is really a property of the connection itself. We recommend adding a <code>count</code> field to the connection. You might query it with:</p>&#xA;&#xA;<pre><code>fragment on TodoList {&#xA;  tasks(first: 10) {&#xA;    count # &lt;-- total number of tasks&#xA;    edges { ... }&#xA;    pageInfo { ... }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Relay supports arbitrary fields on a connection, so you're free to name this <code>count</code>, <code>totalCount</code>, etc.</p>&#xA;",4690687,,,,2015-12-10 02:20:51,"",,0,0,0,2015-12-10 02:20:51
34193320,2,,33323894,14,,"<p>(Updated with more explanations)</p>&#xA;<p>There are 3 ways to represent an array of data in GraphQL:</p>&#xA;<ol>&#xA;<li>List: Use when you have a finite list of associated objects that you're fine fetching all at once. In GraphQL SDL, this is represented as <code>[Ship]</code>.</li>&#xA;<li>Nodes: Use when you need to paginate over a list, usually because there can be thousands of items. Note that this is not part of the Relay specification and as such is not supported by the Relay client (instead, you'd wrap the item in an edge as described in #3), but some other clients such as Apollo are more flexible and support this construct (but you need to provide more boilerplate). In GraphQL, this would be represented as <code>type ShipConnection { nodes: [Ship], pageInfo: PageInfo! }</code>.</li>&#xA;<li>Edges: Use when, in addition to pagination, you also need to provide extra information for each edge in the connection (read below for more details). In GraphQL, you'd write it as <code>type ShipConnection { edges: [ShipEdge], pageInfo: PageInfo! }</code>.</li>&#xA;</ol>&#xA;<p>Note that your GraphQL server might support all three options for a specific association, and the client then selects which field they want. Here's how they'd all look together:</p>&#xA;<pre><code>type Query {&#xA;  ships: [Ship]       // #1&#xA;  shipsConnection: [ShipConnection]&#xA;}&#xA;&#xA;type ShipConnection {&#xA;  nodes: [Ship]       // #2&#xA;  edges: [ShipEdge]   // #3&#xA;  pageInfo: PageInfo!&#xA;}&#xA;&#xA;type PageInfo {&#xA;  endCursor           // page-based pagination&#xA;  hasNextPage&#xA;}&#xA;&#xA;type ShipEdge {&#xA;  cursor: String!     // edge-based pagination&#xA;  node: Ship&#xA;  // ... edge attributes&#xA;}&#xA;&#xA;type Ship {&#xA;  // ... ship attributes&#xA;}&#xA;</code></pre>&#xA;<p>Lists (#1) should only ever be used when you know that the number of items won't grow (for example, if you have a <code>Post</code>, you may want to return <code>tags</code> as a List, but you shouldn't do that with <code>comments</code>). To decide between #2 and #3, there are two reasons for using edges over just plain nodes:</p>&#xA;<ul>&#xA;<li><p>It's a place for edge-specific attributes. For example, if you have a <code>User</code> that belongs to many <code>Group</code>s, in a relational database you'd have a UserGroup table with <code>user_id</code> and <code>group_id</code>. This table can have additional attributes like <code>role</code>, <code>joined_at</code> etc. The <code>GroupUserEdge</code> would then be the place where you could access these attributes.</p>&#xA;</li>&#xA;<li><p>Have a place for the cursor. Relay, in addition to page-based pagination (using <code>pageInfo</code>) supports edge-based pagination. Why does Relay need a cursor for each edge? Because Relay intelligently merges data requirements from your entire app, it may already have a connection with the same parameters you're requesting but not enough records in it. To fetch the missing data, it can ask for data in the connection after some edge's cursor.</p>&#xA;<p>I understand it may be confusing, considering databases have cursors, too, and there is only one cursor per query. A Relay connection is not a query really, it's rather a set of parameters that identify a query. A cursor of connection's edge is a set of parameters that identify a position within a connection. This is a higher abstraction level than a pure query cursor (remember that edges need to be able to identify a position even over a connection that might not be a DB query, or be hidden by a 3rd party system). Because of this required flexibility, one cursor for a connection would not be enough.</p>&#xA;</li>&#xA;</ul>&#xA;",384349,,384349,2021-03-21 08:53:15,2021-03-21 08:53:15,"",,0,11,0,2015-12-10 03:44:21
34205309,2,,34199982,63,,"<p>I guess the only way to do this is by utilizing reusable fragments:</p>&#xA;&#xA;<pre><code>fragment UserFragment on Users {&#xA;    id&#xA;    username&#xA;    count&#xA;} &#xA;&#xA;FetchUsers {&#xA;    users(id: ""2"") {&#xA;        ...UserFragment&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",3726647,,,,2015-12-10 15:08:18,"",,0,6,0,2015-12-10 15:08:18
34214487,2,,34192507,9,,"<p>Thank you @Joe Savona</p>&#xA;&#xA;<p>He is absolutely right. Since it took me a moment to figure out how to actually add the property to the connection on the server site I thought I share that here as well:</p>&#xA;&#xA;<pre><code>var {connectionType: postsConnection} = connectionDefinitions({&#xA;  name: 'post',&#xA;  nodeType: qlPost,&#xA;  connectionFields: () =&gt; ({&#xA;    totalCount: {&#xA;      type: GraphQLInt,&#xA;      resolve: (connection) =&gt; connection.totalCount,&#xA;      description: `A count of the total number of objects in this connection, ignoring pagination.&#xA;This allows a client to fetch the first five objects by passing ""5"" as the&#xA;argument to ""first"", then fetch the total count so it could display ""5 of 83"",&#xA;for example.`&#xA;    }&#xA;  })&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Hope that helps others.</p>&#xA;&#xA;<p>Cheers</p>&#xA;",2514535,,2030321,2016-07-25 09:14:30,2016-07-25 09:14:30,"",,0,2,0,2015-12-11 00:54:34
34246441,2,,33280824,0,,"<p>I'm using <code>graphql@0.4.14</code>, and found it here: </p>&#xA;&#xA;<pre><code>info //third argument&#xA;.fieldASTs[0]&#xA;.selectionSet&#xA;.selections&#xA;//.reduce...&#xA;</code></pre>&#xA;&#xA;<p>I guess they are still changing everything, so I've added try/catch to <code>getProjection()</code></p>&#xA;",4391952,,,,2015-12-13 00:01:12,"",,0,0,0,2015-12-13 00:01:12
34406667,1,34407181,,6,1505,"<p>So based on this comment here, I've been able to hack together a simple ""paginating"" component/container: <a href=""https://github.com/facebook/graphql/issues/4#issuecomment-118162627"" rel=""noreferrer"">https://github.com/facebook/graphql/issues/4#issuecomment-118162627</a></p>&#xA;&#xA;<p>I say ""hack"" because that's just what I did.  </p>&#xA;&#xA;<p>I got it to work by taking a look at the edge cursors on the <code>/graphql</code> response in my browser.  Problem is.. how do I make this work for the <em>first</em> ""page"" of items, when I have no ""prior query"" to work from?</p>&#xA;&#xA;<p>I tried leaving <code>after</code> as <code>undefined</code> in my query, but I only got the following error:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Uncaught Invariant Violation: callsFromGraphQL(): Expected a declared value for variable, $curs.</p>&#xA;</blockquote>&#xA;&#xA;<p>It seems, if you define <code>first</code> and <code>after</code> in your container's fragment, then they're required parameters.  But I have no value for <code>after</code>, so how in the world does one go about initializing this?</p>&#xA;&#xA;<p>This example throws the error above:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Widgets2, {&#xA;  initialVariables: {&#xA;    pageSize: 2&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        widgets(&#xA;          first: $pageSize,&#xA;          after: $curs&#xA;        ) {&#xA;          edges {&#xA;            cursor,&#xA;            node {&#xA;              id,&#xA;              name,&#xA;            },&#xA;          },&#xA;        },&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;//And in the React component:&#xA;nextPage () {&#xA;    let lastIndex = this.props.viewer.widgets.edges.length - 1&#xA;    this.props.relay.setVariables({&#xA;        curs: this.props.viewer.widgets.edges[lastIndex].cursor&#xA;    })&#xA; }&#xA;</code></pre>&#xA;",282250,,282250,2015-12-22 17:45:42,2015-12-22 17:45:42,"Relay Pagination: How to initialize ""after"" value?",<pagination><reactjs><relayjs><graphql><graphql-js>,1,0,0,2015-12-22 00:28:27
34407181,2,,34406667,6,,"<p>Good question. In Relay, a default value must be provided for all variables. If the value isn't known you can use <code>null</code>: in this case that would mean specifying <code>curs: null</code> in <code>initialVariables</code>. We require an explicit <code>null</code> to help ensure that developers haven't forgotten to specify a value.</p>&#xA;",4690687,,,,2015-12-22 01:36:11,"",,0,1,0,2015-12-22 01:36:11
34411292,1,34455310,,4,508,"<p>I am building a dashboard that contains many different widgets. User can add and remove any widget and place them in any order they prefer to. Each widget has its own data requirement. What is the correct Relay way to construct the container hierarchy?</p>&#xA;&#xA;<p>To provide some context this is the architecture so far:</p>&#xA;&#xA;&#xA;&#xA;<p><code>Widget</code> is a component that takes in a config object and render the corresponding component accordingly.</p>&#xA;&#xA;<pre class=""lang-jsx prettyprint-override""><code>class Widget extends React.Component {&#xA;  render() {&#xA;    const {widget} = this.props;&#xA;    // widgetMap is a map that maps string to React component&#xA;    const ActualWidget = widgetMap.get(widget.component);&#xA;&#xA;    return (&#xA;      &lt;ActualWidget data={widget.data} /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(Widget, {&#xA;  fragments: {&#xA;    data: () =&gt; Relay.QL`&#xA;      fragment on ??? {&#xA;        # What should be here since we don't know what will be rendered?&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><code>Dashboard</code> component holds a number of widgets added by user.</p>&#xA;&#xA;<pre class=""lang-jsx prettyprint-override""><code>class Dashboard extends React.Component {&#xA;  renderWidgets = () =&gt; {&#xA;    return this.props.widgets.map(widget =&gt; {&#xA;      return &lt;Widget widget={widget}/&gt;;&#xA;    });&#xA;  };&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;span&gt;Hello, {this.props.user.name}&lt;/span&gt;&#xA;        {this.renderWidgets()}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(Dashboard, {&#xA;  fragments: {&#xA;    // `user` fragment is used by Dashboard&#xA;    user: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        name&#xA;      }&#xA;    `,&#xA;    // Each widget have different fragment,&#xA;    // So what should be here?&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>Update</strong></p>&#xA;&#xA;<p>I have tried to make each <code>ActualWidget</code> to be a field of viewer. So the schema is sort of like this:</p>&#xA;&#xA;<pre class=""lang-jsx prettyprint-override""><code>type Viewer {&#xA;  widget1: Widget1&#xA;  widget2: Widget2&#xA;}&#xA;&#xA;type Widget1 {&#xA;  name,&#xA;  fieldOnlyForWidget1&#xA;}&#xA;&#xA;type Widget2 {&#xA;  name,&#xA;  fieldOnlyForWidget2&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then for my <code>Widget</code> container, I try to insert the fragment dynamically.</p>&#xA;&#xA;<pre class=""lang-jsx prettyprint-override""><code>export default Relay.createContainer(Widget, {&#xA;  initialVariables: {&#xA;    component: 'Widget1' // Trying to set the string here&#xA;  }&#xA;&#xA;  fragments: {&#xA;    data: (variables) =&gt; Relay.QL`&#xA;      fragment on Viewer { # We now know it is Viewer type&#xA;        # This didn't work because `variables.component` is not string! :(&#xA;        ${widgetMap.get(variables.component).getFragment('viewer')}&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>That does not work. I believe Relay parsed the QL statically so it is unable to compose dynamic fragments. However that's just my guess.</p>&#xA;&#xA;<p>I am in the process of testing the feasibility of using <code>RootContainer</code> for each widget and will update this soon.</p>&#xA;",605840,,605840,2015-12-24 02:47:04,2015-12-24 16:09:57,RelayJS: Children components querying arbitrary data,<reactjs><relayjs><graphql>,1,4,0,2015-12-22 08:18:40
34492614,1,34691871,,5,1782,"<p>Lets say I have a GraphQL type <code>Echo</code> that echo whatever I query with some decorations. On the other hand, I have a React component that echo <code>message</code> passed to it with some decorations determined by <code>Echo</code> type. How can I set <code>initialVariables</code> for the <code>Echo</code> component?</p>&#xA;&#xA;<p>I read that setting props sets <code>initialVariables</code>, however that does not work. I have tried <code>componentDidMount</code>, but that does not work too.</p>&#xA;&#xA;<p>This <a href=""https://facebook.github.io/relay/prototyping/playground.html#source=class%20Echo%20extends%20React.Component%20%7B%0A%20%20componentDidMount()%20%7B%0A%20%20%20%20let%20%7Brelay%2C%20message%7D%20%3D%20this.props%3B%20%0A%20%20%20%20%0A%20%20%20%20relay.setVariables(%7B%0A%20%20%20%20%20%20message%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20render()%20%7B%0A%20%20%20%20let%20name%20%3D%20&#39;&#39;%3B%0A%20%20%20%20if%20(this.props.echo)%20%7B%0A%20%20%20%20%20%20name%20%3D%20this.props.echo.name%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3Cli%3EMessage%3A%20%7Bname%7D%3C%2Fli%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0AEcho%20%3D%20Relay.createContainer(Echo%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20message%3A%20null%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20echo%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Echo%20%7B%0A%20%20%20%20%20%20%20%20name(message%3A%20%24message)%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20EchoApp%20extends%20React.Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20return%20%3Cul%3E%0A%20%20%20%20%20%20%3CEcho%20echo%3D%7Bthis.props.viewer.echo%7D%20message%3D%22Test%22%2F%3E%0A%20%20%20%20%3C%2Ful%3E%3B%0A%20%20%7D%0A%7D%0AEchoApp%20%3D%20Relay.createContainer(EchoApp%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20viewer%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Viewer%20%7B%0A%20%20%20%20%20%20%20%20echo%20%7B%20%24%7BEcho.getFragment(&#39;echo&#39;)%7D%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20EchoRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20&#39;Home&#39;%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20viewer%3A%20(Component)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20%7B%0A%20%20%20%20%20%20%20%20viewer%20%7B%20%24%7BComponent.getFragment(&#39;viewer&#39;)%7D%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BEchoApp%7D%0A%20%20%20%20route%3D%7Bnew%20EchoRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B&amp;schema=import%20%7B%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%7D%20from%20&#39;graphql&#39;%3B%0A%0Alet%20EchoType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Echo&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20name%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20message%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20type%3A%20GraphQLString%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20(echo%2C%20%7Bmessage%7D)%20%3D%3E%20%60Hello%2C%20%24%7Bmessage%7D!%60%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D)%3B%0A%20%20%0Alet%20ViewerType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Viewer&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20echo%3A%20%7B%0A%20%20%20%20%20%20type%3A%20EchoType%2C%0A%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20(%7B%7D)%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D)%3B%0A%20%20%0Aexport%20default%20new%20GraphQLSchema(%7B%0A%20%20query%3A%20new%20GraphQLObjectType(%7B%0A%20%20%20%20name%3A%20&#39;Query&#39;%2C%0A%20%20%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20%20%20viewer%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20ViewerType%2C%0A%20%20%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20(%7B%7D)%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D)%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A"" rel=""noreferrer"">Relay Playground</a> shows that message is not being displayed correctly.</p>&#xA;&#xA;<p>For context,</p>&#xA;&#xA;<pre class=""lang-jsx prettyprint-override""><code>// This component consumes `Echo` type&#xA;class Echo extends React.Component {&#xA;  componentDidMount() {&#xA;    let {relay, message} = this.props; &#xA;&#xA;    relay.setVariables({&#xA;      message&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    let name = '';&#xA;    if (this.props.echo) {&#xA;      name = this.props.echo.name;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;li&gt;Message: {name}&lt;/li&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;Echo = Relay.createContainer(Echo, {&#xA;  // By default `message` is null&#xA;  initialVariables: {&#xA;    message: null&#xA;  },&#xA;&#xA;  fragments: {&#xA;    echo: () =&gt; Relay.QL`&#xA;      fragment on Echo {&#xA;        name(message: $message)&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>This is the type that resolve with an echo</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>let EchoType = new GraphQLObjectType({&#xA;  name: 'Echo',&#xA;  fields: () =&gt; ({&#xA;    name: {&#xA;      type: GraphQLString,&#xA;      args: {&#xA;        message: {&#xA;          type: GraphQLString&#xA;        }&#xA;      },&#xA;      resolve: (echo, {message}) =&gt; `Hello, ${message}!`&#xA;    }&#xA;  })&#xA;});&#xA;</code></pre>&#xA;",605840,,605840,2015-12-28 12:05:16,2016-01-09 09:35:18,RelayJS: How to set initialVariables via props,<reactjs><relayjs><graphql><graphql-js>,1,0,0,2015-12-28 11:24:09
34522077,1,34540346,,2,928,"<p>I'm diving into GraphQL and Relay. So far, everything has been relatively smooth and easy, for me, to comprehend. I've got a GraphQL schema going with <code>Accounts</code> and <code>Teams</code>. There is no relationships between the two, yet. I've got some Relay-specific GraphQL adjustments for connections, for both the accounts and teams. Here's an example query for those two connections ...</p>&#xA;&#xA;<pre><code>{&#xA;  viewer {&#xA;    teams {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;    accounts {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          username&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've got a GraphQL mutation ready to go that creates a new account. Here's the GraphQL representation of that ...</p>&#xA;&#xA;<pre><code>type Mutation {&#xA;  newAccount(input: NewAccountInput!): NewAccountPayload&#xA;}&#xA;&#xA;input NewAccountInput {&#xA;  username: String!&#xA;  password: String!&#xA;  clientMutationId: String!&#xA;}&#xA;&#xA;type NewAccountPayload {&#xA;  account: Account&#xA;  clientMutationId: String!&#xA;}&#xA;&#xA;type Account implements Node {&#xA;  id: ID!&#xA;  username: String!&#xA;  date_created: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm now trying to create my client-side Relay mutation that uses this GraphQL mutation. I'm thoroughly confused as to how to do this correctly, though. I've followed examples and nothing I come up with even seems to run correctly. I tend to get errors relating to fragment composition.</p>&#xA;&#xA;<p>If I were writing a Relay mutation that uses this GraphQL mutation, what would the appropriate mutator configuration be? Should I be using <code>RANGE_ADD</code>?</p>&#xA;",294120,,,,2015-12-31 05:08:38,What type of Relay mutator configuration is appropriate for inserting a new record?,<javascript><relayjs><graphql>,2,0,0,2015-12-30 02:20:19
34539522,2,,34522077,6,,"<p>For your client side mutation, you can use something like this:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default class AddAccountMutation extends Relay.Mutation {&#xA;   static fragments = {&#xA;      viewer: () =&gt; Relay.QL`&#xA;         fragment on Viewer {&#xA;            id,&#xA;         }&#xA;       `,&#xA;   };&#xA;&#xA;   getMutation() {&#xA;      return Relay.QL`mutation{addAccount}`;&#xA;   }&#xA;&#xA;   getVariables() {&#xA;      return {&#xA;         newAccount: this.props.newAccount,&#xA;      };&#xA;   }&#xA;&#xA;   getFatQuery() {&#xA;      return Relay.QL`&#xA;         fragment on AddAccountPayload {&#xA;            accountEdge,&#xA;            viewer {&#xA;               accounts,&#xA;            },&#xA;         }&#xA;       `;&#xA;    }&#xA;&#xA;   getConfigs() {&#xA;      return [{&#xA;         type: 'RANGE_ADD',&#xA;         parentName: 'viewer',&#xA;         parentID: this.props.viewer.id,&#xA;         connectionName: 'accounts',&#xA;         edgeName: 'accountEdge',&#xA;         rangeBehaviors: {&#xA;            '': 'append',&#xA;         },&#xA;      }];&#xA;   }&#xA;&#xA;   getOptimisticResponse() {&#xA;      return {&#xA;         accountEdge: {&#xA;            node: {&#xA;               userName: this.props.newAccount.userName,&#xA;            },&#xA;         },&#xA;         viewer: {&#xA;            id: this.props.viewer.id,&#xA;         },&#xA;      };&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then, in your GraphQL schema, you'll need to return the newly created edge, as well as the cursor:</p>&#xA;&#xA;<pre><code>var GraphQLAddAccountMutation = mutationWithClientMutationId({&#xA;   name: 'AddAccount',&#xA;   inputFields: {&#xA;      newAccount: { type: new GraphQLNonNull(NewAccountInput) } &#xA;   },&#xA;   outputFields: {&#xA;      accountEdge: {&#xA;         type: GraphQLAccountEdge,&#xA;         resolve: async ({localAccountId}) =&gt; {&#xA;            var account = await getAccountById(localAccountId);&#xA;            var accounts = await getAccounts();&#xA;            return {&#xA;              cursor: cursorForObjectInConnection(accounts, account)&#xA;              node: account,&#xA;            };&#xA;         }&#xA;      },&#xA;      viewer: {&#xA;        type: GraphQLViewer,&#xA;        resolve: () =&gt; getViewer()&#xA;      },&#xA;   },&#xA;   mutateAndGetPayload: async ({ newAccount }) =&gt; {&#xA;      var localAccountId = await createAccount(newAccount);&#xA;      return {localAccountId};&#xA;   }&#xA;});&#xA;&#xA;var {&#xA;   connectionType: AccountsConnection,&#xA;   edgeType: GraphQLAccountEdge,&#xA;} = connectionDefinitions({&#xA;   name: 'Account',&#xA;   nodeType: Account,&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>You'll need to substitute the getAccounts(), getAccountById() and createAccount method calls to whatever your server/back-end uses. </p>&#xA;&#xA;<p>There may be a better way to calculate the cursor without having to do multiple server trips, but keep in mind the Relay helper cursorForObjectInConnection does not do any kind of deep comparison of objects, so in case you need to find the account by an id in the list, you may need to do a custom comparison:</p>&#xA;&#xA;<pre><code>function getCursor(dataList, item) {&#xA;   for (const i of dataList) {&#xA;      if (i._id.toString() === item._id.toString()) {&#xA;         let cursor = cursorForObjectInConnection(dataList, i);&#xA;         return cursor;&#xA;      } &#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Finally, add the GraphQL mutation as 'addAccount' to your schema mutation fields, which is referenced by the client side mutation.</p>&#xA;",2396046,,,,2015-12-31 00:49:34,"",,0,2,0,2015-12-31 00:49:34
34540346,2,,34522077,4,,"<p>Right now, I'm following a roughly 5 step process to define mutations:</p>&#xA;&#xA;<ol>&#xA;<li>Define the input variables based on what portion of the graph you are targeting - in your case, it's a new account, so you just need the new data</li>&#xA;<li>Name the mutation based on #1 - for you, that's <code>AddAccountMutation</code></li>&#xA;<li>Define the fat query based on what is affected by the mutation - for you, it's just the <code>accounts</code> connection on <code>viewer</code>, but in the future I'm sure your schema will become more complex</li>&#xA;<li>Define the mutation config based on how you can intersect the fat query with your local graph</li>&#xA;<li>Define the mutation fragments you need to satisfy the requirements of #1, #3 and #4</li>&#xA;</ol>&#xA;&#xA;<p>Generally speaking, step #4 is the one people find the most confusing. That's because it's confusing. It's hard to summarize in a Stack Overflow answer why I feel this is good advice but... I recommend you use <code>FIELDS_CHANGE</code> for all your mutations*. It's relatively easy to explain and reason about - just tell Relay how to look up the nodes corresponding to the top level fields in your mutation payload. Relay will then use the mutation config to build a ""tracked query"" representing everything you've requested so far, and intersect that with the ""fat query"" representing everything that could change. In your case, you want the intersected query to be something like <code>viewer { accounts(first: 10) { edges { nodes { ... } } }</code>, so that means you're going to want to make sure you've requested the existing accounts somewhere already. But you almost certainly have, and if you haven't... maybe you don't actually need to make any changes locally for this mutation!</p>&#xA;&#xA;<p>Make sense?</p>&#xA;&#xA;<p>EDIT: For clarity, here's what I mean for the fat query &amp; configs.</p>&#xA;&#xA;<pre><code>getConfigs() {&#xA;  return [&#xA;  {&#xA;    type: ""FIELDS_CHANGE"",&#xA;    fieldIDs: {&#xA;      viewer: this.props.viewer.id&#xA;    }&#xA;  }]&#xA;}&#xA;&#xA;getFatQuery() {&#xA;  return Relay.QL`&#xA;    fragment on AddAccountMutation {&#xA;      viewer {&#xA;        accounts&#xA;      }&#xA;    }&#xA;  `&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>*addendum: I currently believe there are only one or two reasons not to use <code>FIELDS_CHANGE</code>. The first is that you can't reliably say what fields are changing, so you want to just manipulate the graph directly. The second is because you decide you need the query performance optimizations afforded by the more specific variants of <code>FIELDS_CHANGE</code> like <code>NODE_DELETE</code>, <code>RANGE_ADD</code>, etc.</p>&#xA;",1750095,,1750095,2015-12-31 05:08:38,2015-12-31 05:08:38,"",,0,0,0,2015-12-31 02:51:35
34601653,1,,,4,550,"<p>I'm trying to understand <code>RANGE_ADD</code>. I've provided the mutation config, for <code>RANGE_ADD</code>, with all the required information. I use the <code>viewer</code> naming convention, with my connections nested within <code>viewer</code>. Below is what my complete Relay Mutation looks like ...</p>&#xA;&#xA;<pre><code>import Relay from ""react-relay"";&#xA;&#xA;export default class CreateTeamMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        id&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`&#xA;      mutation { createTeam }&#xA;    `;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      name: this.props.name&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateTeamPayload {&#xA;        edge,&#xA;        viewer {&#xA;          teams&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    console.log(this.props.viewer);&#xA;    return [{&#xA;      type: ""RANGE_ADD"",&#xA;      edgeName: ""edge"",&#xA;      parentID: this.props.viewer.id,&#xA;      parentName: ""viewer"",&#xA;      connectionName: ""teams"",&#xA;      rangeBehaviors: {&#xA;        """": ""append""&#xA;      }&#xA;    }];&#xA;  }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>I provide a fragment for the <code>viewer</code> id, which at run-time, within <code>getConfigs</code>, I can see is present.</p>&#xA;&#xA;<p>In the GraphQL Mutation response payload, <code>CreateTeamPayload</code>, the <code>viewer</code> field is provided so that Relay can make use of the connection within the mutation config for <code>RANGE_ADD</code>. Also, within <code>CreateTeamPayload</code>, the new edge is provided as <code>edge</code>.</p>&#xA;&#xA;<p>These three bits of info (viewer id for the parent, the connection information and the edge) seem to be all that <code>RANGE_ADD</code> demands. I also make sure to request this data from the server, via the fat query so that Relay has access to it for the mutation config.</p>&#xA;&#xA;<p>Relay does not seem to be including what I've specified in the fat query, and what is required for the mutation config, in what it dispatches to the server, though. All that Relay is requesting is the <code>clientMutationId</code>. Here is the request made by Relay ...</p>&#xA;&#xA;<pre><code>{&#xA;  ""query"": ""mutation CreateTeamMutation($input_0:CreateTeamInput!){createTeam(input:$input_0){clientMutationId}}"",&#xA;  ""variables"": {&#xA;    ""input_0"": {&#xA;      ""name"": ""foo bar"",&#xA;      ""clientMutationId"": ""0""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And, in chain reaction fashion, this causes Relay, who is expecting the <code>viewer</code> and <code>edge</code> for the mutation config, to throw an error ...</p>&#xA;&#xA;<pre><code>Warning: writeRelayUpdatePayload(): Expected response payload to include the newly created edge `edge` and its `node` field. Did you forget to update the `RANGE_ADD` mutation config?&#xA;</code></pre>&#xA;&#xA;<p>Those required fields could totally be there if Relay had included them. Does <code>RANGE_ADD</code> have to be accompanied by <code>REQUIRED_CHILDREN</code> for this to work? The mutation goes through to the server, and the record is created on the server, it's just the client-side mutation config fails to incorporate the changed data into the store.</p>&#xA;",294120,,,,2016-01-08 01:22:23,Mutation not fetching data specified by the fat query in conjunction with RANGE_ADD?,<relayjs><graphql>,1,0,0,2016-01-04 23:19:14
34668050,2,,34601653,2,,"<p>This is probably a case of an ambiguous warning: <a href=""https://github.com/facebook/relay/issues/542"" rel=""nofollow"">https://github.com/facebook/relay/issues/542</a></p>&#xA;&#xA;<p>Relay intersects the range behaviours with the previously fetched connections.</p>&#xA;&#xA;<p>Your range behaviors here only define what to do when the teams connection is not under the influence of any call. How are you calling your teams connection in the app ?</p>&#xA;&#xA;<p>For example if your app fetches <code>teams(order_by: 'recent')</code>, you should define a range behavior like this one <code>'orderby(recent)': 'append'</code></p>&#xA;",1577648,,,,2016-01-08 01:22:23,"",,0,1,0,2016-01-08 01:22:23
34691871,2,,34492614,8,,"<p>I'll admit I don't know a whole lot about Relay, but the <code>message</code> property passed to <code>Echo</code> seems to be shadowing it (or otherwise affecting it). I made the following changes:</p>&#xA;&#xA;&#xA;&#xA;<ol>&#xA;<li><p>Change the prop name passed to <code>Echo</code>:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>&lt;Echo echo={this.props.viewer.echo} defaultMessage=""Default""/&gt;&#xA;</code></pre></li>&#xA;<li><p>Change the property name in <code>componentDidMount</code>:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>componentDidMount() {&#xA;  let {relay, defaultMessage} = this.props; &#xA;&#xA;  relay.setVariables({&#xA;    message: defaultMessage&#xA;  });&#xA;}&#xA;</code></pre></li>&#xA;</ol>&#xA;&#xA;<p>Here is the full source (and <a href=""https://facebook.github.io/relay/prototyping/playground.html#source=class%20Echo%20extends%20React.Component%20%7B%0A%20%20componentDidMount()%20%7B%0A%20%20%20%20let%20%7Brelay%2C%20defaultMessage%7D%20%3D%20this.props%3B%20%0A%20%20%20%20%0A%20%20%20%20relay.setVariables(%7B%0A%20%20%20%20%20%20message%3A%20defaultMessage%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20render()%20%7B%0A%20%20%20%20let%20name%20%3D%20&#39;&#39;%3B%0A%20%20%20%20if%20(this.props.echo)%20%7B%0A%20%20%20%20%20%20name%20%3D%20this.props.echo.name%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3Cli%3EMessage%3A%20%7Bname%7D%3C%2Fli%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0AEcho%20%3D%20Relay.createContainer(Echo%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20message%3A%20%22%22%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20echo%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Echo%20%7B%0A%20%20%20%20%20%20%20%20name(message%3A%20%24message)%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20EchoApp%20extends%20React.Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20return%20%3Cul%3E%0A%20%20%20%20%20%20%3CEcho%20echo%3D%7Bthis.props.viewer.echo%7D%20defaultMessage%3D%22Default%22%2F%3E%0A%20%20%20%20%3C%2Ful%3E%3B%0A%20%20%7D%0A%7D%0AEchoApp%20%3D%20Relay.createContainer(EchoApp%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20viewer%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Viewer%20%7B%0A%20%20%20%20%20%20%20%20echo%20%7B%20%24%7BEcho.getFragment(&#39;echo&#39;)%7D%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0Aclass%20EchoRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20&#39;Home&#39;%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20viewer%3A%20(Component)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20%7B%0A%20%20%20%20%20%20%20%20viewer%20%7B%20%24%7BComponent.getFragment(&#39;viewer&#39;)%7D%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BEchoApp%7D%0A%20%20%20%20route%3D%7Bnew%20EchoRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B&amp;schema=import%20%7B%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%7D%20from%20&#39;graphql&#39;%3B%0A%0Alet%20EchoType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Echo&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20name%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20message%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20type%3A%20GraphQLString%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20(echo%2C%20%7Bmessage%7D)%20%3D%3E%20console.log(message)%20%7C%7C%20%60Hello%2C%20%24%7Bmessage%7D!%60%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D)%3B%0A%20%20%0Alet%20ViewerType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20&#39;Viewer&#39;%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20echo%3A%20%7B%0A%20%20%20%20%20%20type%3A%20EchoType%2C%0A%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20(%7B%7D)%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D)%3B%0A%20%20%0Aexport%20default%20new%20GraphQLSchema(%7B%0A%20%20query%3A%20new%20GraphQLObjectType(%7B%0A%20%20%20%20name%3A%20&#39;Query&#39;%2C%0A%20%20%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20%20%20viewer%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20ViewerType%2C%0A%20%20%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20(%7B%7D)%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D)%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A"">a link to a working example</a>):</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class Echo extends React.Component {&#xA;  componentDidMount() {&#xA;    let {relay, defaultMessage} = this.props; &#xA;&#xA;    relay.setVariables({&#xA;      message: defaultMessage&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    let name = '';&#xA;    if (this.props.echo) {&#xA;      name = this.props.echo.name;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;li&gt;Message: {name}&lt;/li&gt;&#xA;    );&#xA;  }&#xA;}&#xA;Echo = Relay.createContainer(Echo, {&#xA;  initialVariables: {&#xA;    message: """"&#xA;  },&#xA;  fragments: {&#xA;    echo: () =&gt; Relay.QL`&#xA;      fragment on Echo {&#xA;        name(message: $message)&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;&#xA;class EchoApp extends React.Component {&#xA;  render() {&#xA;    return &lt;ul&gt;&#xA;      &lt;Echo echo={this.props.viewer.echo} defaultMessage=""Default""/&gt;&#xA;    &lt;/ul&gt;;&#xA;  }&#xA;}&#xA;EchoApp = Relay.createContainer(EchoApp, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        echo { ${Echo.getFragment('echo')} },&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;&#xA;class EchoRoute extends Relay.Route {&#xA;  static routeName = 'Home';&#xA;  static queries = {&#xA;    viewer: (Component) =&gt; Relay.QL`&#xA;      query {&#xA;        viewer { ${Component.getFragment('viewer')} },&#xA;      }&#xA;    `,&#xA;  };&#xA;}&#xA;&#xA;ReactDOM.render(&#xA;  &lt;Relay.RootContainer&#xA;    Component={EchoApp}&#xA;    route={new EchoRoute()}&#xA;  /&gt;,&#xA;  mountNode&#xA;);&#xA;</code></pre>&#xA;",62082,,,,2016-01-09 09:35:18,"",,0,4,0,2016-01-09 09:35:18
34693042,2,,34321688,19,,"<p>There's no automatic aggregate function in GraphQL itself.</p>&#xA;&#xA;<p>You can add a field called <code>summary</code>, and in the <code>resolve</code> function calculate the totals.</p>&#xA;",384349,,,,2016-01-09 11:44:43,"",,0,0,0,2016-01-09 11:44:43
34828418,1,34951905,,60,14292,"<p>The <a href=""https://facebook.github.io/relay/docs/graphql-object-identification.html#content"" rel=""noreferrer"">relay docs</a> contain this fragment:</p>&#xA;&#xA;<pre><code>query RebelsRefetchQuery {&#xA;  node(id: ""RmFjdGlvbjox"") {&#xA;    id&#xA;    ... on Faction {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What does this <code>... on Faction</code> on syntax mean?</p>&#xA;",2400966,,,,2019-12-16 14:32:26,What do 3 dots/periods/ellipsis in a relay/graphql query mean?,<relayjs><graphql>,2,0,0,2016-01-16 15:02:23
34838089,2,,34828418,9,,"<p>Ah. It's explained <a href=""https://graphql.github.io/graphql-spec/June2018/#sec-Language.Fragments"" rel=""nofollow noreferrer"">here</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Fragments are consumed by using the spread operator (...). All fields&#xA;  selected by the fragment will be added to the query field selection at&#xA;  the same level as the fragment invocation. This happens through&#xA;  multiple levels of fragment spreads.</p>&#xA;</blockquote>&#xA;",2400966,,7104980,2019-11-15 18:21:32,2019-11-15 18:21:32,"",,0,0,0,2016-01-17 12:03:13
34882707,1,38065226,,1,188,"<p>I have a recursive data structure to be fetched and displayed. I have a graph ql type as follow:</p>&#xA;&#xA;<pre><code>human {&#xA;  name,&#xA;  children: [human]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I wanted to incrementally fetch data and hence used to react classes HumanList and HumanItem, where I've used relay to fetch children only when a item is clicked. In my actual code relay gives children a null on very click i.e. on rendering very first set of children. I tried test code on relay playground and found similar issue. <a href=""https://gist.github.com/shahankit/409c8640b01f1d910fb0"" rel=""nofollow"">Here</a> is the link to gist. Playground.js contains the code part and Playground.gql.js contains schema part. Clicking on each number open children under it. After 3 or 4 level it starts showing <code>Found children as null</code>. For me it happens on <code>1.1.2.2</code>. If it doesn't happens so for you then try adding more levels in SCHEMA code and the bug would pop in.</p>&#xA;&#xA;<p>I've already checked relay issues <a href=""https://github.com/facebook/relay/issues/246"" rel=""nofollow"">#246</a> and <a href=""https://github.com/facebook/relay/issues/536"" rel=""nofollow"">#536</a> but none of them helped.</p>&#xA;&#xA;<p>Any help is very much welcome.</p>&#xA;",2082521,,2082521,2016-01-19 17:23:45,2016-06-28 00:26:47,Relay: fetch for recursive data returns null,<javascript><recursion><reactjs><relayjs><graphql>,1,3,0,2016-01-19 17:02:17
34984343,1,35002177,,1,823,"<p>When expressing data filters, via GraphQL, should we be creating explicitly-named fields for that filter or should we be adding a parameter to a more generic list-type field that would apply the filter?</p>&#xA;&#xA;<p>For example, if I've got a field called <code>teams</code> but I want to provide the ability to filter the data, provided by <code>teams</code>, down to only the teams who are active (versus inactive), should I expose that filter via GraphQL as a param on the <code>teams</code> field, or should I create a new field called <code>activeTeams</code>?</p>&#xA;&#xA;<p>I'm thinking the clearly, explicitly named fields might scale better and be less confusing in the long run because there won't be questions about how params works when paired with each other, etc.</p>&#xA;&#xA;<p>I wanted to get feedback on how maybe Facebook approaches this, or how others are doing so.</p>&#xA;",294120,,,,2016-01-25 20:54:33,"Should specific filters be expressed as an explicitly named field, or a generic field with a filter param?",<graphql>,1,0,0,2016-01-25 02:46:50
35019325,2,,35007667,7,,"&#xA;&#xA;<p>This pattern is pretty much the representative scenario for connections. Here's a hypothetical <code>&lt;PostsIndex&gt;</code> component that shows a list of posts with a ""load more"" button. If you don't want to explicitly change the UI when in the <code>isLoading</code> state you could delete the constructor and the <code>setVariables</code> callback. Adding viewport based infinite scrolling would not be hard either; you'd just need to wire a scroll listener up to you <code>setVariables</code> call.</p>&#xA;&#xA;<pre><code>class PostsIndex extends React.Component {&#xA;  constructor(props) {&#xA;    super(props);&#xA;    this.state = {isLoading: false};&#xA;  }&#xA;&#xA;  _handleLoadMore = () =&gt; {&#xA;    this.props.relay.setVariables({&#xA;      count: this.props.relay.variables.count + 10,&#xA;    }, ({ready, done, error, aborted}) =&gt; {&#xA;      this.setState({isLoading: !ready &amp;&amp; !(done || error || aborted)});&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {&#xA;          this.props.viewer.posts.edges.map(({node}) =&gt; (&#xA;            &lt;Post key={node.id} post={node} /&gt;&#xA;          ))&#xA;        }&#xA;        {&#xA;          this.props.viewer.posts.pageInfo.hasNextPage ?&#xA;            &lt;LoadMoreButton&#xA;              isLoading={this.state.isLoading}&#xA;              onLoadMore={this._handleLoadMore}&#xA;            /&gt; :&#xA;            null&#xA;        }&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(PostsIndex, {&#xA;  initialVariables: {&#xA;    count: 10,&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        posts(first: $count) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              ${Post.getFragment('post')}&#xA;            }&#xA;          }&#xA;          pageInfo {&#xA;            hasNextPage&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",2103996,,,,2016-01-26 16:52:10,"",,0,1,0,2016-01-26 16:52:10
35043967,1,35930023,,4,2744,"<p>I am new to graphql and I need a help to send graphql query with fragments for my android app. &#xA;Below is the query format accepted by network.</p>&#xA;&#xA;<pre><code>query{&#xA;  user(ident:""JohnDoe""){&#xA;    myStory{&#xA;      description,&#xA;    placements(first:3){&#xA;      edges{&#xA;        node{&#xA;          mediaItemType&#xA;          mediaItem {&#xA;            ...VideoFragment&#xA;            ...PhotoFragment&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    }&#xA;  }&#xA;}&#xA;fragment VideoFragment on Video {&#xA;    videoHTML&#xA;}&#xA;fragment PhotoFragment on Photo {&#xA;    url(size:10)&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any help appreciated!!</p>&#xA;",4169023,,,,2018-08-01 06:29:45,How to send graphql query with fragments in Android,<java><android><graphql>,2,4,0,2016-01-27 17:21:00
35067685,1,35471007,,6,3141,"<p>My use case is that I have a Node application that consumes data from a CMS, and in that CMS I give the users the ability to select a React Component as a ""Layout"". I'd like for Relay to be able to get a GraphQL Fragment from that dynamically select component. When the Layout's parent component mounts, it goes through its query and gets the layout component it needs and sets a Relay variable - it then needs to get a fragment from that component. Is there a way to do that? </p>&#xA;&#xA;<p>Here is the parent level query:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default Relay.createContainer(WordpressPage, {&#xA;&#xA;initialVariables:{&#xA;    Component: null,&#xA;    page: null,&#xA;    showPosts: false,&#xA;    limit: 5&#xA;},&#xA;&#xA;prepareVariables(prevVars){&#xA;    return{&#xA;        ...prevVars,&#xA;        showPosts: true&#xA;    }&#xA;},&#xA;&#xA;fragments: {&#xA;  viewer: ({Component, showPosts, limit}) =&gt; Relay.QL`&#xA;    fragment on User {&#xA;      ${PostList.getFragment(""viewer"", {limit:limit}).if(showPosts)},&#xA;        page(post_name:$page){&#xA;          id,&#xA;          post_title,&#xA;          post_type,&#xA;          post_content,&#xA;          thumbnail,&#xA;          layout{&#xA;           meta_value&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>As you can see, it queries and gets a layout field. When it mounts, it sets the Relay Component variable to be a React Component. Instead of ""PostList.getFragment"", I'd really like to be able to do a Component.getFragment.</p>&#xA;",2168061,,1434116,2016-01-30 07:54:20,2016-03-03 05:34:19,getFragment from a dynamic component in Relay,<reactjs><relayjs><graphql>,1,0,0,2016-01-28 17:09:18
35074446,2,,35070523,1,,"<p>I want to point out that I see that you're saying that your mutation requires no parameters - how does it know what the new user's details are? You'll probably need some parameters on that mutation, eventually. They would be available to your <code>mutateAndGetPayload</code> on that first function parameter. (I'm not saying every mutation needs parameters, but this one probably does)</p>&#xA;&#xA;<p>If you're using Relay, there is some pretty good information on the <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#content"" rel=""nofollow"">official document</a> as to how to use your mutations from Relay. Particularly down at the bottom where it shows the various mutator configs. If you're using connections, you may want to use <code>RANGE_ADD</code> to add this new account to the Relay store manually, otherwise if you'd like to perform a more broad refetch you can use <code>FIELDS_CHANGE</code>. You said you need the new user id after the mutation finishes. If you're using Relay, you may need to look into <code>REQUIRED_CHILDREN</code> to specify that regardless of the computed query that Relay will build, you always want that id to be queried.</p>&#xA;&#xA;<p>The output of your mutation is a <code>userType</code>, so you'd be able to access it with a fragment on the payload type, which would probably be <code>RegisterUserPayload</code>, that might look something like ...</p>&#xA;&#xA;<pre><code>fragment on RegisterUserPayload {&#xA;  user {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, that's assuming you're using Relay. If you'd like to try this out manually via GraphiQL, then you can use the examples of how to do mutations through there on the <a href=""https://facebook.github.io/relay/docs/graphql-mutations.html"" rel=""nofollow"">GraphQL Mutation docs</a>. There's a direct example of how you'd query your mutation.</p>&#xA;&#xA;<p>Last, since you asked how to do this at a low level of issuing the HTTP request yourself, for that you can look at <code>express-graphql</code> documentation, <a href=""https://github.com/graphql/express-graphql#http-usage"" rel=""nofollow"">which explains</a> how to query it.</p>&#xA;",294120,,,,2016-01-28 23:55:19,"",,0,1,0,2016-01-28 23:55:19
35194917,1,,,0,1368,"<p>when I am trying to update a record in Relay using Relay Mutations I getting an error like this.</p>&#xA;&#xA;<blockquote>&#xA;  <p>doesn't have a field ""clientMutationId""</p>&#xA;</blockquote>&#xA;&#xA;<p>But I did't declare any clientMutationId in my GraphQL schema. Here  is my code in Relay </p>&#xA;&#xA;<pre><code>function updateZipdata1(){&#xA;  console.log(""update zip"");&#xA;   return new Promise((resolve, reject) =&gt; {&#xA;    var Connection = require('tedious').Connection;&#xA;    var Request = require('tedious').Request;&#xA;    var config = {&#xA;        userName: 'xxx',&#xA;        password: 'xxxx',&#xA;        server: 'xxxx', &#xA;        options: {&#xA;            database: 'xxxx'&#xA;&#xA;        }&#xA;     }&#xA;    var results = [];&#xA;    var connection = new Connection(config);&#xA;    connection.on('connect', (err)=&gt; {&#xA;         if (err) {&#xA;            console.log(err)&#xA;            reject(err);&#xA;        }&#xA;        var ZipCode=""123456"";&#xA;        var RecNo=""789456"";&#xA;&#xA;        var sql = ""update dbo.xrxZip set ZipCode='""+ZipCode+""' where RecNo='""+RecNo+""'"";&#xA;        var request = new Request(sql,&#xA;            (err, rowCount)=&gt; {&#xA;                if (err) {&#xA;                    console.log('SQLError');&#xA;                    connection.close();&#xA;                    reject(err);&#xA;                }&#xA;                else {&#xA;                  console.log(""sql:""+rowCount)&#xA;                    connection.close();&#xA;                    resolve(results);   &#xA;              }&#xA;            });&#xA;            request.on('row', (columns)=&gt; {&#xA;            var row = {};&#xA;            columns.forEach((column)=&gt; {&#xA;                if (column.isNull) {&#xA;                    row[column.metadata.colName] = null;&#xA;                } else {&#xA;                    row[column.metadata.colName] = column.value;&#xA;                }&#xA;            });&#xA;            console.log(""hai:""+results)&#xA;            results.push(row);&#xA;&#xA;        });&#xA;          connection.execSql(request);&#xA;      })&#xA;   })&#xA;};  &#xA;</code></pre>&#xA;&#xA;<p><strong>my GraphQL schema:</strong></p>&#xA;&#xA;<pre><code>var zipType = new GraphQLObjectType({&#xA;  name: 'Zipcode',&#xA;  fields: () =&gt; ({&#xA;&#xA;    ZipCode: {type: GraphQLString},&#xA;    City: {type: GraphQLString},&#xA;    ShortCode:{type: GraphQLString},&#xA;    State:{type: GraphQLString},&#xA;    Phone:{type: GraphQLString},&#xA;    TaxCode:{type: GraphQLString},&#xA;    Tax:{type: GraphQLString},&#xA;    RecNo:{type: GraphQLString}&#xA;&#xA;  }),&#xA;});&#xA;&#xA;var zipCodeType = new GraphQLObjectType({&#xA;  name: 'Zip',&#xA;  fields: () =&gt; ({&#xA;    zipcodes: {type: new GraphQLList(zipType)},&#xA;  }),&#xA;});&#xA;&#xA;export var Schema = new GraphQLSchema({&#xA;  mutation: new GraphQLObjectType({&#xA;    name: ""Mutation"",&#xA;     fields: () =&gt; ({&#xA;      UpdateZipcode:{&#xA;        type: zipCodeType,&#xA;        args: {&#xA;          ZipCode: {type: GraphQLString}&#xA;        },&#xA;        resolve: (root,{ZipCode}) =&gt;updateZipdata,&#xA;&#xA;      }&#xA;    })&#xA;  })&#xA;})&#xA; const updateZipdata = {&#xA; zipcodes: updateZipdata1(), // Calling the function&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>When I run it in terminal for hard coded ZipCode and RecNo it is working without any error. But when I try to execute in Relay I am getting an error like as mentioned above.</p>&#xA;&#xA;<p><strong>Hear is my Relay code:</strong>  </p>&#xA;&#xA;<p>This is subclass in Relay for mutations.</p>&#xA;&#xA;<pre><code>export default class updateZipMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    alert(""getMutation"");&#xA;    return Relay.QL`mutation{UpdateZipcode}` ;&#xA;  }&#xA;  getVariables() {&#xA;    alert(""getVariables"");&#xA;    return { RecNo: this.props.data.RecNo,ZipCode:this.props.data.ZipCode,City:this.props.data.City,Phone:this.props.data.Phone,ShortCode:this.props.data.ShortCode,Tax:this.props.data.Tax,TaxCode:this.props.data.TaxCode,State:this.props.data.State};&#xA;  }&#xA;  getFatQuery() {&#xA;    alert(""getFatQuery"")&#xA;    return Relay.QL`&#xA;      fragment on Zipcode {&#xA;          RecNo,&#xA;          ZipCode,&#xA;          City,&#xA;          Phone,&#xA;          ShortCode,&#xA;          Tax,&#xA;          TaxCode,&#xA;          State&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    alert(""getConfigs"");&#xA;    return [{&#xA;      type: 'zipCodeType',&#xA;      fieldIDs:{&#xA;        RecNo: this.props.data.RecNo&#xA;      },&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is my main class in Relay calling the subclass for mutations:</p>&#xA;&#xA;<pre><code>export default class zips extends React.Component {&#xA; Relay.Store.update(&#xA;      new updateZipMutation({        //I am getting the data from form&#xA;        data: { RecNo, ZipCode,City,Phone,ShortCode,Tax,TaxCode,State},&#xA;      })&#xA;    );&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>any one please give me suggestions how to resolve it, and how to work on mutations. Any help much appreciated. </p>&#xA;",5283410,,5283410,2016-02-04 08:31:57,2016-05-28 14:27:44,"doesn't have a field ""clientMutationId"" in Relay mutations",<sql><graphql><relay>,2,0,0,2016-02-04 07:25:38
35197523,1,,,2,785,"<p>This is a follow-up question to <a href=""https://stackoverflow.com/a/34776023/2030321"">this answer</a> posted earlier on SO about a react-relay mutation warning.</p>&#xA;&#xA;<blockquote>&#xA;  <p>""In you case what you have to do is to add the FeatureLabelNameMutation getFragment to your AddCampaignFeatureLabelMutation query.""</p>&#xA;</blockquote>&#xA;&#xA;<p>As with the OP in that question, I too want to make a nested relay mutation and I've tried doing what @Christine is suggesting, but I'm uncertain on where exactly to put the <code>getFragment</code> part.</p>&#xA;&#xA;<p>In my application, I want to create a ""task"" with multiple nested ""sub-tasks"" when the user creates a task.</p>&#xA;&#xA;<p>What I have tried works, but I don't get the returned PayLoad for the <code>AddSubTaskMutation</code> mutation. Here's what I've tried so far:</p>&#xA;&#xA;<h3>AddTaskMutation.js</h3>&#xA;&#xA;<pre><code>export default class AddTaskMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    classroom: () =&gt; Relay.QL`&#xA;      fragment on Classroom { &#xA;        id,&#xA;        tasks(last: 1000) {&#xA;          edges {&#xA;            node {&#xA;                id,&#xA;                ${AddSubTaskMutation.getFragment('task')}, //&lt;-- what I tried adding &#xA;            },&#xA;          }&#xA;        },&#xA;      }`,&#xA;    }`,&#xA;  };&#xA;  ...&#xA;</code></pre>&#xA;&#xA;<h3>AddSubTaskMutation.js</h3>&#xA;&#xA;<pre><code>export default class AddSubTaskMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    task: () =&gt; Relay.QL`&#xA;      fragment on Task { &#xA;        id,&#xA;      }`,&#xA;   };&#xA;   ...&#xA;</code></pre>&#xA;&#xA;<h3>TaskCreate.js</h3>&#xA;&#xA;<pre><code>Relay.Store.update(&#xA;  new AddTaskMutation({&#xA;    title,&#xA;    instruction,&#xA;    start_date,&#xA;    end_date,&#xA;    published: isPublished,&#xA;    classroom: this.props.classroom&#xA;  }),&#xA;  {&#xA;    onSuccess: (response) =&gt; {&#xA;      let {taskEdge} = response.addTask;&#xA;      for (let subTask of this.state.subTaskContent) {&#xA;        Relay.Store.update(&#xA;          new AddSubTaskMutation({&#xA;            task: taskEdge.node,&#xA;            type: subTask['type'],&#xA;            position: subTask['position'],&#xA;            ...&#xA;          }),&#xA;        );&#xA;      }&#xA;    }&#xA;  }&#xA;)&#xA;...&#xA;export default Relay.createContainer(TaskCreate, {&#xA;  prepareVariables() {&#xA;    return {&#xA;      limit: Number.MAX_SAFE_INTEGER || 9007199254740991,&#xA;    };&#xA;  },&#xA;  fragments: {&#xA;    classroom: () =&gt; Relay.QL`&#xA;      fragment on Classroom {&#xA;        id,&#xA;        tasks(last: $limit) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              ...&#xA;            }   &#xA;          }&#xA;        },&#xA;        ...&#xA;        ${AddTaskMutation.getFragment('classroom')},&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Apart from not getting the payload, I'm also getting the following warnings: </p>&#xA;&#xA;<pre><code>Warning: RelayMutation: Expected prop `task` supplied to `AddSubTaskMutation` to be data fetched by Relay. This is likely an error unless you are purposely passing in mock data that conforms to the shape of this mutation's fragment.&#xA;Warning: writeRelayUpdatePayload(): Expected response payload to include the newly created edge `subTaskEdge` and its `node` field. Did you forget to update the `RANGE_ADD` mutation config?&#xA;</code></pre>&#xA;&#xA;<p>So my question is: where do i add the <code>getFragment</code> in <code>AddTaskMutation.js</code> to make this work?</p>&#xA;",2030321,,-1,2017-05-23 10:27:34,2016-02-07 02:37:30,Not getting payload after React-relay nested mutation,<reactjs><relayjs><graphql>,1,1,0,2016-02-04 09:45:25
35249073,2,,35197523,1,,"<p>From what I can tell, the issue is that you don't really understand what the mutation ""fragment"" is for vs. the rest of the mutation properties (fat query &amp; configs). The warning you are seeing is related to Relay noticing that the task prop you are giving it isn't from the <code>AddSubtaskMutation</code> fragment, it's from the <code>AddTaskMutation</code> mutation query. But that's really just a red herring; your issue is that you don't need those fragments at all, you just need to configure the mutation appropriately to create your new nodes &amp; edges. Here's a couple suggestions.</p>&#xA;&#xA;<p>Step #1</p>&#xA;&#xA;<ul>&#xA;<li>Get rid of the fragments in both <code>AddTaskMutation</code> and <code>AddSubtaskMutation</code>, they seem unnecessary</li>&#xA;<li>Modify <code>AddTaskMutation</code>'s constructor to take a bunch of fields for the task and a <code>classroomID</code> to specify the affected classroom</li>&#xA;<li>Similarly, modify <code>AddSubTaskMutation</code> to take a bunch of fields for the subtask and a <code>taskID</code> to specify the parent task</li>&#xA;<li>Make sure your <code>AddTaskMutation</code> payload includes the modified classroom and the new task edge</li>&#xA;<li>Define a <code>RANGE_ADD</code> mutation using the <code>classroomID</code> to target the classroom for the new task</li>&#xA;<li>Define a <code>FIELDS_CHANGE</code> mutation on <code>AddSubtaskMutation</code> that mutates the parent using the given <code>taskID</code> (I'm not sure how you're storing subtasks, probably a connection). You can change this to a <code>RANGE_ADD</code> if you really want.</li>&#xA;</ul>&#xA;&#xA;<p>Step #2: Simplify</p>&#xA;&#xA;<ul>&#xA;<li>It seems unnecessary to do this in 1+N mutations (N subtasks), when you seem to have all the information at the start. I'd modify the input of <code>AddTaskMutation</code> to accept a new task and an array of subtasks, and do it all at once...</li>&#xA;</ul>&#xA;",1750095,,,,2016-02-07 02:37:30,"",,0,1,0,2016-02-07 02:37:30
35278297,1,,,2,341,"<p>I'm trying to create new object using client-side mutation described below:  </p>&#xA;&#xA;<pre><code>import Relay from 'react-relay'&#xA;&#xA;export default class CreateThemeMutation extends Relay.Mutation {&#xA;&#xA;  static fragments = {&#xA;    admin: () =&gt; Relay.QL`fragment on Admin { id }`,&#xA;  };&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { createTheme }`&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateThemePayload {&#xA;        admin { themes }&#xA;        themeEdge&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      name: this.props.name,&#xA;    }&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'admin',&#xA;      parentID: this.props.admin.id,&#xA;      connectionName: 'themes',&#xA;      edgeName: 'themeEdge',&#xA;      rangeBehaviors: {&#xA;        '': 'append',&#xA;      },&#xA;    }]&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Root query field <code>admin</code> is quite similar to <code>viewer</code> so this shouldn't be a problem. The problem is I haven't found <code>themeEdge</code> (which I believe should present) within the request payload (<code>admin { themes }</code> is there though):</p>&#xA;&#xA;<pre><code>query: ""mutation CreateThemeMutation($input_0:CreateThemeInput!){createTheme(input:$input_0){clientMutationId,...F3}} fragment F0 on Admin{id} fragment F1 on Admin{id,...F0} fragment F2 on Admin{_themes2gcwoM:themes(first:20,query:""""){count,pageInfo{hasNextPage,hasPreviousPage,startCursor,endCursor},edges{node{id,name,createdAt},cursor}},id,...F1} fragment F3 on CreateThemePayload{admin{id,...F0,id,...F2}}""&#xA;variables: {input_0: {name: ""test"", clientMutationId: ""0""}}&#xA;</code></pre>&#xA;&#xA;<p>As a result <code>outputFields.themeEdge.resolve</code> inside the server-side mutation never get called and I see this message:</p>&#xA;&#xA;<pre><code>Warning: writeRelayUpdatePayload(): Expected response payload to include the newly created edge `themeEdge` and its `node` field. Did you forget to update the `RANGE_ADD` mutation config?&#xA;</code></pre>&#xA;&#xA;<p>I've seen <a href=""https://github.com/facebook/relay/issues/719"" rel=""nofollow"">similar issue on github</a>. However <code>REQUIRED_CHILDREN</code> isn't my case because the application has requested <code>themes</code> connection already. Am I missing something obvious? Should I paste more info? Thanks.</p>&#xA;&#xA;<p>react-relay version: <code>0.6.1</code></p>&#xA;",480410,,,,2016-02-10 10:03:02,Client-side mutation with RANGE_ADD type doesn't include edge inside request payload,<relayjs><graphql>,1,0,0,2016-02-08 20:03:23
35312038,2,,35278297,1,,"<p>I ran into the same issue and eventually solved it by making sure that my equivalent of <code>themeEdge</code> actually existed as an edge in my schema. If you grep your schema for <code>themeEdge</code>, does an object exist?</p>&#xA;&#xA;<p>For reference, here's my edge definition tailored for you:</p>&#xA;&#xA;<pre><code>{&#xA;      ""name"":""themeEdge"",&#xA;      ""description"":null,&#xA;      ""args"":[],&#xA;      ""type"":{&#xA;        ""kind"":""NON_NULL"",&#xA;        ""name"":null,&#xA;        ""ofType"":{&#xA;          ""kind"":""OBJECT"",&#xA;          ""name"":""ThemeEdge"",&#xA;          ""ofType"":null&#xA;        }&#xA;      },&#xA;      ""isDeprecated"":false,&#xA;      ""deprecationReason"":null&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>and</p>&#xA;&#xA;<pre><code>{&#xA;    ""kind"":""OBJECT"",&#xA;    ""name"":""ThemeEdge"",&#xA;    ""description"":""An edge in a connection."",&#xA;    ""fields"":[{&#xA;      ""name"":""node"",&#xA;      ""description"":""The item at the end of the edge."",&#xA;      ""args"":[],&#xA;      ""type"":{&#xA;        ""kind"":""NON_NULL"",&#xA;        ""name"":null,&#xA;        ""ofType"":{&#xA;          ""kind"":""OBJECT"",&#xA;          ""name"":""Theme"",&#xA;          ""ofType"":null&#xA;        }&#xA;      },&#xA;      ""isDeprecated"":false,&#xA;      ""deprecationReason"":null&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Also note that your <code>rangeBehaviors</code> must <em>exactly</em> match the query you use to retrieve your parent object. You can specify multiple queries as follows, which also shows the syntax for when your query contains multiple variables:</p>&#xA;&#xA;<pre><code>{&#xA;    type: 'RANGE_ADD',&#xA;    parentName: 'admin',&#xA;    parentID: this.props.admin.id,&#xA;    connectionName: 'themes',&#xA;    edgeName: 'themeEdge',&#xA;    rangeBehaviors: {&#xA;      '': 'append',&#xA;      'first(1).id($adminId)': 'append',&#xA;    },&#xA;  }&#xA;</code></pre>&#xA;",2400966,,,,2016-02-10 10:03:02,"",,0,3,0,2016-02-10 10:03:02
35471007,2,,35067685,8,,"<p>What you must do here is to interpolate <em>all possible fragment references</em> into the query. Starting with Relay v0.7.1 you will be able to interpolate into your query an <em>array</em> of fragment references:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const COMPONENTS = [&#xA;  [PostList, 'showPosts'],&#xA;  [OtherKindOfList, 'showOthers'],&#xA;  /* ... */&#xA;];&#xA;&#xA;static initialVariables = {&#xA;  showPosts: false,&#xA;  showOthers: false,&#xA;  /* ... */&#xA;};&#xA;&#xA;fragments: {&#xA;  viewer: variables =&gt; Relay.QL`&#xA;    fragment on User {&#xA;      ${COMPONENTS.map(([Component, variableName]) =&gt; {&#xA;        const condition = variables[variableName];&#xA;        return Component&#xA;          .getFragment('viewer', {limit: variables.limit})&#xA;          .if(condition);&#xA;      })},&#xA;      # ...&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>Warning</strong>: Presently there is a limitation in Relay that requires that the interpolated expression return either:</p>&#xA;&#xA;<ul>&#xA;<li><p>a fragment reference</p>&#xA;&#xA;<p><code>${Foo.getFragment('viewer')}</code></p></li>&#xA;<li><p>an array of fragment references</p>&#xA;&#xA;<p><code>${COMPONENTS.map(c =&gt; c.getFragment('viewer'))}</code></p></li>&#xA;<li><p>a route-conditional function that returns exactly <em>one</em> fragment reference</p>&#xA;&#xA;<p><code>${(route) =&gt; COMPONENTS[route].getFragment('viewer')}</code></p></li>&#xA;</ul>&#xA;&#xA;<p>The original poster's use case was for a route-conditional function that returns an <em>array</em> of fragment references, which is not yet supported. See the comments for more information. See also <a href=""https://github.com/facebook/relay/issues/896"" rel=""noreferrer"">facebook/relay/issues/896</a></p>&#xA;",802047,,802047,2016-03-03 05:34:19,2016-03-03 05:34:19,"",,0,17,0,2016-02-18 01:16:51
35471836,1,35472008,,3,1112,<p>I use <code>react-router-relay</code> and within one of my routes I have a dropdown.</p>&#xA;&#xA;<p>Now I select a different value from that dropdown - that will call <code>this.props.relay.setVariables</code> which will fetch some data based on this variables. This data will be displayed in a chart component within the current route.</p>&#xA;&#xA;<p>How can I provide a callback or something to know that the current component is fetching data now / finished fetching data now ?</p>&#xA;&#xA;<p>I need this to be able to show a loading indicator on top of the chart component.</p>&#xA;&#xA;<p>I think I can't use <code>react-router-relay</code> for this since it would only enable me to show a loading indicator instead of my current route - but I want to show the loading indicator within the current route.</p>&#xA;&#xA;<p>Please help.</p>&#xA;,2514535,,,,2016-02-18 03:00:02,Loading indicator after this.props.relay.setVariables triggered fetch?,<reactjs><relayjs><graphql-js>,1,0,0,2016-02-18 02:44:38
35479704,1,,,0,292,"<p>I am just started working on GraphQL Relay in that I want to perform the mutation but it gives an error like this in my console</p>&#xA;&#xA;<blockquote>&#xA;  <p>Uncaught TypeError: Comment.getFragment is not a function</p>&#xA;</blockquote>&#xA;&#xA;<p>Here is my <strong>Relay code</strong>:</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;import React from 'react';&#xA;&#xA;export default class CreateCommentMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    story: () =&gt; Relay.QL`&#xA;      fragment on Story { id }&#xA;    `,&#xA;  };&#xA;  getMutation() {&#xA;    return Relay.QL`&#xA;      mutation{ createComment }&#xA;    `;&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateCommentPayload { &#xA;        story { comments },&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: { story: this.props.story.id },&#xA;    }];&#xA;  }&#xA;  getVariables() {&#xA;    return { text: this.props.text };&#xA;  }&#xA;}&#xA;&#xA;&#xA;export default class Comment extends React.Component {&#xA;  render() {&#xA;    console.log(""hai:""+this.props.comment)&#xA;    var {id, text} = this.props.comment;&#xA;    return &lt;li key={id}&gt;{text}&lt;/li&gt;;&#xA;  }&#xA;}&#xA;export default Relay.createContainer(Comment, {&#xA;  fragments: {&#xA;    comment: () =&gt; Relay.QL`&#xA;      fragment on Comment {&#xA;        id,&#xA;        text,&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;&#xA;export default class Story extends React.Component {&#xA;  _handleSubmit = (e) =&gt; {&#xA;    e.preventDefault();&#xA;    Relay.Store.update(&#xA;      new CreateCommentMutation({&#xA;        story: this.props.story,&#xA;        text: this.refs.newCommentInput.value,&#xA;      })&#xA;    );&#xA;    this.refs.newCommentInput.value = '';&#xA;  }&#xA;  render() {&#xA;    var {comments} = this.props.story;&#xA;    return (&#xA;      &lt;form onSubmit={this._handleSubmit}&gt;&#xA;        &lt;h1&gt;Breaking News&lt;/h1&gt;&#xA;        &lt;p&gt;The peanut is neither a pea nor a nut.&lt;/p&gt;&#xA;        &lt;strong&gt;Discuss:&lt;/strong&gt;&#xA;        &lt;ul&gt;&#xA;          {comments.map(&#xA;            comment =&gt; &lt;Comment comment={comment} /&gt;&#xA;          )}&#xA;        &lt;/ul&gt;&#xA;        &lt;input&#xA;          placeholder=""Weigh in&amp;hellip;""&#xA;          ref=""newCommentInput""&#xA;          type=""text""&#xA;        /&gt;&#xA;      &lt;/form&gt;&#xA;    );&#xA;  }&#xA;}&#xA;export default Relay.createContainer(Story, {&#xA;  fragments: {&#xA;    story: () =&gt; Relay.QL`&#xA;      fragment on Story {&#xA;        comments {&#xA;          ${Comment.getFragment('comment')}, //here getting the error&#xA;        },&#xA;        ${CreateCommentMutation.getFragment('story')},&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;export default class StoryHomeRoute extends Relay.Route {&#xA;  static routeName = 'StoryHomeRoute';&#xA;  static queries = {&#xA;    story: (Component) =&gt; Relay.QL`&#xA;      query StoryQuery {&#xA;        story { ${Component.getFragment('story')} },&#xA;      }&#xA;    `,&#xA;  };&#xA;}&#xA;&#xA;&#xA;export class Root extends React.Component {&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;Relay.RootContainer&#xA;        Component={ Story }&#xA;        route={ new StoryHomeRoute() } /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;ReactDOM.render(&#xA;  &lt;Root /&gt;,&#xA;  document.getElementById('container')&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>my <strong>GraphQL schema</strong>:</p>&#xA;&#xA;<pre><code>import {&#xA;  GraphQLID,&#xA;  GraphQLList,&#xA;  GraphQLNonNull,&#xA;  GraphQLObjectType,&#xA;  GraphQLSchema,&#xA;  GraphQLString,&#xA;} from 'graphql';&#xA;import {&#xA;  mutationWithClientMutationId,&#xA;} from 'graphql-relay';&#xA;&#xA;const STORY = {&#xA;  comments: [],&#xA;  id: '42',&#xA;};&#xA;&#xA;var CommentType = new GraphQLObjectType({&#xA;  name: 'Comment',&#xA;  fields: () =&gt; ({&#xA;    id: {type: GraphQLID},&#xA;    text: {type: GraphQLString},&#xA;  }),&#xA;});&#xA;&#xA;var StoryType = new GraphQLObjectType({&#xA;  name: 'Story',&#xA;  fields: () =&gt; ({&#xA;    comments: { type: new GraphQLList(CommentType) },&#xA;    id: { type: GraphQLString },&#xA;  }),&#xA;});&#xA;&#xA;var CreateCommentMutation = mutationWithClientMutationId({&#xA;  name: 'CreateComment',&#xA;  inputFields: {&#xA;    text: { type: new GraphQLNonNull(GraphQLString) },&#xA;  },&#xA;  outputFields: {&#xA;    story: {&#xA;      type: StoryType,&#xA;      resolve: () =&gt; STORY,&#xA;    },&#xA;  },&#xA;  mutateAndGetPayload: ({text}) =&gt; {&#xA;    var newComment = {&#xA;      id: STORY.comments.length,&#xA;      text,&#xA;    };&#xA;    STORY.comments.push(newComment);&#xA;    return newComment;&#xA;  },&#xA;});&#xA;&#xA;export var Schema = new GraphQLSchema({&#xA;  query: new GraphQLObjectType({&#xA;    name: 'Query',&#xA;    fields: () =&gt; ({&#xA;      story: {&#xA;        type: StoryType,&#xA;        resolve: () =&gt; STORY,&#xA;      },&#xA;    }),&#xA;  }),&#xA;  mutation: new GraphQLObjectType({&#xA;    name: 'Mutation',&#xA;    fields: () =&gt; ({&#xA;      createComment: CreateCommentMutation,&#xA;    }),&#xA;  }),&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Please any one give me suggestions how to resolve it, and how to work on mutations. Any help much appreciated.</p>&#xA;",5283410,,,,2016-03-01 20:51:58,How to do the sample GraphQL Relay mutation,<graphql><relay>,1,0,0,2016-02-18 11:06:33
35534931,1,35566124,,2,594,"<p>Let's use the TODO example. In <a href=""https://github.com/facebook/relay/blob/master/examples/todo/js/components/TodoList.js"" rel=""nofollow"" title=""TodoList"">TodoList</a> it(Line 81) has a fragment composed as</p>&#xA;&#xA;<pre><code>todos(status: $status, first: $limit) {&#xA;  edges {&#xA;    node {&#xA;      id,&#xA;      ${Todo.getFragment('todo')},&#xA;    },&#xA;  },&#xA;  ....&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And now if I add a loop</p>&#xA;&#xA;<pre><code>this.props.viewer.todos.edges.map(edge =&gt;&#xA;console.log(edge.node.text)&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>to function <strong>renderTodos()</strong> at Line 30, it will output <strong>undefined</strong></p>&#xA;&#xA;<p>The interesting thing is, if we add <strong>text</strong> to to the fragment like below</p>&#xA;&#xA;<pre><code>todos(status: $status, first: $limit) {&#xA;  edges {&#xA;    node {&#xA;      id,&#xA;      text,&#xA;      ${Todo.getFragment('todo')},&#xA;    },&#xA;  },&#xA;  ....&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It actually ""declared"" <strong>text</strong> twice(declare in Todo component as well) and the loop works perfectly.</p>&#xA;&#xA;<p>My question is, why it is not possible to get the ""properties"" back from a composition even though they are returned by Graphql Server?</p>&#xA;",2213606,,,,2016-02-22 23:41:25,How does fragment composition work in Relay?,<relayjs><graphql><graphql-js>,1,0,0,2016-02-21 10:24:56
35585482,2,,33060182,10,,"<p>First you need to write the Relay update in your frontend component.&#xA;Like this: </p>&#xA;&#xA;<pre><code>onDrop: function(files) {&#xA;  files.forEach((file)=&gt; {&#xA;    Relay.Store.commitUpdate(&#xA;      new AddImageMutation({&#xA;        file,&#xA;        images: this.props.User,&#xA;      }),&#xA;      {onSuccess, onFailure}&#xA;    );&#xA;  });&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>And then follow by implementing the mutation on the frontend:</p>&#xA;&#xA;<pre><code>class AddImageMutation extends Relay.Mutation {&#xA;   static fragments = {&#xA;     images: () =&gt; Relay.QL`&#xA;       fragment on User {&#xA;         id,&#xA;       }`,&#xA;     };&#xA;&#xA;   getMutation() {&#xA;     return Relay.QL`mutation{ introduceImage }`;&#xA;   }&#xA;&#xA;   getFiles() {&#xA;     return {&#xA;       file: this.props.file,&#xA;     };&#xA;   }&#xA;&#xA;   getVariables() {&#xA;     return {&#xA;       imageName: this.props.file.name,&#xA;     };&#xA;   }&#xA;&#xA;   getFatQuery() {&#xA;     return Relay.QL`&#xA;       fragment on IntroduceImagePayload {&#xA;         User {&#xA;           images(first: 30) {&#xA;             edges {&#xA;               node {&#xA;                 id,&#xA;               }&#xA;             }&#xA;           }&#xA;         },&#xA;         newImageEdge,&#xA;       }&#xA;     `;&#xA;   }&#xA;&#xA;   getConfigs() {&#xA;     return [{&#xA;       type: 'RANGE_ADD',&#xA;       parentName: 'User',&#xA;       parentID: this.props.images.id,&#xA;       connectionName: 'images',&#xA;       edgeName: 'newImageEdge',&#xA;       rangeBehaviors: {&#xA;         '': 'prepend',&#xA;       },&#xA;     }];&#xA;   }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>And last, implement the handler on the server/schema.</p>&#xA;&#xA;<pre><code>const imageMutation = Relay.mutationWithClientMutationId({&#xA;  name: 'IntroduceImage',&#xA;  inputFields: {&#xA;    imageName: {&#xA;      type: new GraphQL.GraphQLNonNull(GraphQL.GraphQLString),&#xA;    },&#xA;  },&#xA;  outputFields: {&#xA;    newImageEdge: {&#xA;      type: ImageEdge,&#xA;      resolve: (payload, args, options) =&gt; {&#xA;        const file = options.rootValue.request.file;&#xA;        //write the image to you disk&#xA;        return uploadFile(file.buffer, filePath, filename)&#xA;        .then(() =&gt; {&#xA;          /* Find the offset for new edge*/&#xA;          return Promise.all(&#xA;            [(new myImages()).getAll(),&#xA;              (new myImages()).getById(payload.insertId)])&#xA;          .spread((allImages, newImage) =&gt; {&#xA;            const newImageStr = JSON.stringify(newImage);&#xA;            /* If edge is in list return index */&#xA;            const offset = allImages.reduce((pre, ele, idx) =&gt; {&#xA;              if (JSON.stringify(ele) === newImageStr) {&#xA;                return idx;&#xA;              }&#xA;              return pre;&#xA;            }, -1);&#xA;&#xA;            return {&#xA;              cursor: offset !== -1 ? Relay.offsetToCursor(offset) : null,&#xA;              node: newImage,&#xA;            };&#xA;          });&#xA;        });&#xA;      },&#xA;    },&#xA;    User: {&#xA;      type: UserType,&#xA;      resolve: () =&gt; (new myImages()).getAll(),&#xA;    },&#xA;  },&#xA;  mutateAndGetPayload: (input) =&gt; {&#xA;    //break the names to array.&#xA;    let imageName = input.imageName.substring(0, input.imageName.lastIndexOf('.'));&#xA;    const mimeType = input.imageName.substring(input.imageName.lastIndexOf('.'));&#xA;    //wirte the image to database&#xA;    return (new myImages())&#xA;    .add(imageName)&#xA;    .then(id =&gt; {&#xA;    //prepare to wirte disk&#xA;      return {&#xA;        insertId: id,&#xA;        imgNmae: imageName,&#xA;      };&#xA;    });&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>All the code above you can find them in my repo <a href=""https://github.com/bfwg/relay-gallery"" rel=""nofollow noreferrer"">https://github.com/bfwg/relay-gallery</a>&#xA;There is also a live demo <a href=""https://fanjin.io"" rel=""nofollow noreferrer"">https://fanjin.io</a></p>&#xA;",5718107,,5718107,2018-09-24 20:16:27,2018-09-24 20:16:27,"",,0,1,0,2016-02-23 18:36:27
35618759,1,,,2,1824,"&#xA;&#xA;<p>I'm building an instant messenger feature into a project of mine. The project uses React and Relay. The instant messenger feature is similar to Facebook chat, where you can see a list of people to talk to and clicking on a person will open a chat window for that one-on-one discussion.</p>&#xA;&#xA;<p>In my implementation, the user list, of who you can chat with, is separated from the list of opened chat windows. So, the user list is not actually important to this question.</p>&#xA;&#xA;<p>Regarding the rendering of the open chat windows, my approach to this has been to create a parent React Component / Relay Container. This parent component will keep track of which chat windows the user has opened, and will build the array of chat window React Components and finally render them. This list of open chat windows is all local state within the parent React Component.</p>&#xA;&#xA;<p>The individual chat window React Component / Relay Container has a fragment that queries from a parameterized field, where the parameter is the id of the user that the chat window's discussion is with. So, if this chat window is for a discussion with Bob, it'll be Bob's id.</p>&#xA;&#xA;<p>With that all in mind, here's an example parent component implementation ...</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class FloatingDiscussionPane extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;ul&gt;&#xA;        {this.renderDiscussions()}&#xA;      &lt;/ul&gt;&#xA;    );&#xA;  }&#xA;&#xA;  renderDiscussions() {&#xA;    const {teamIds} = this.props;&#xA;    return teamIds.map(teamId =&gt; {&#xA;      return (&#xA;        &lt;FloatingDiscussionPaneDiscussion&#xA;          teamId={teamId} /&gt;&#xA;      );&#xA;    });&#xA;  }&#xA;};&#xA;&#xA;export default Relay.createContainer(FloatingDiscussionPane, {&#xA;  fragments: {&#xA;    session: () =&gt; Relay.QL`&#xA;      fragment on Session {&#xA;        ${/* how to get fragments from the array of discussion windows */}&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And here would be an example implementation of the chat window ...</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class FloatingDiscussionPaneDiscussion extends React.Component {&#xA;  render() {&#xA;    ...&#xA;  }&#xA;};&#xA;&#xA;export default Relay.createContainer(FloatingDiscussionPaneDiscussion, {&#xA;  fragments: {&#xA;    session: () =&gt; Relay.QL`&#xA;      fragment on Session {&#xA;        messages: myDiscussionMessages(team: $teamId) {&#xA;          ...&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>As you can see, the <code>FloatingDiscussionPaneDiscussion</code> container has a fragment that needs to be included in the parent container, <code>FloatingDiscussionPane</code>. The parent component, <code>FloatingDiscussionPane</code>, will have an array of <code>FloatingDiscussionPaneDiscussion</code> though, all needing to have their own fragments included in the parent fragment.</p>&#xA;&#xA;<p>How can I achieve this?</p>&#xA;",294120,,710693,2017-08-11 01:09:00,2017-08-11 01:09:00,How to compose fragments from an array of relay containers?,<reactjs><graphql><relayjs>,1,0,0,2016-02-25 05:02:21
35669870,1,,,2,457,"&#xA;&#xA;<p>This React/Relay/GraphQL app has a simple container <code>App</code> and one nested index page <code>EntriesPage</code>. The <code>App</code> requests the <code>viewer</code>'s <code>id</code>, while the <code>EntriesPage</code> requests additional <code>viewer</code> fields like <code>name</code> and a list of <code>entries</code>.</p>&#xA;&#xA;<p>The <code>EntriesPage</code> query fragment being sent to GraphQL correctly contains the additional <code>name</code> field but is missing the <code>entries</code> connection.</p>&#xA;&#xA;<p>Any idea why <code>entries</code>, specified in the fragment, is being ignored, while <code>name</code> is happily included?&#xA;<a href=""https://dl.dropboxusercontent.com/u/891448/queries.png"" rel=""nofollow"">https://dl.dropboxusercontent.com/u/891448/queries.png</a></p>&#xA;&#xA;<p>Running a similar query in <code>GraphiQL</code> returns proper results.</p>&#xA;&#xA;<p>Routes:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default (&#xA;  &lt;Route&#xA;    path=""/""&#xA;    component={App}&#xA;    queries={ViewerQueries}&#xA;  &gt;&#xA;    &lt;IndexRoute&#xA;      component={EntriesPage}&#xA;      queries={ViewerQueries}&#xA;    /&gt;&#xA;  &lt;/Route&gt;&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>App.js</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class App extends React.Component {&#xA;  render() {&#xA;    const { children } = this.props;&#xA;    return (&#xA;      &lt;div className=""container-fluid""&gt;&#xA;        {children}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(App, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        id&#xA;      }&#xA;    `&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>EntriesPage:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class EntriesPage extends React.Component {&#xA;  render() {&#xA;    const { viewer } = this.props;&#xA;    const entries = viewer.entries.edges.map(e =&gt; e.node);&#xA;    return (&#xA;      &lt;div className=""row""&gt;&#xA;        &lt;div className=""col-sm-3""&gt;&#xA;          &lt;EntryList entries={entries} /&gt;&#xA;        &lt;/div&gt;&#xA;        &lt;div className=""col-sm-9""&gt;&#xA;        &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(EntriesPage, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        id,&#xA;        name,&#xA;        entries(first:10) {&#xA;          edges {node {id}}&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;",4164348,,710693,2017-08-11 01:08:42,2017-08-11 01:08:42,GraphQL query fragment missing connection,<reactjs><react-router><graphql><relayjs>,0,2,0,2016-02-27 12:36:51
35698582,1,,,7,1513,"<p>I'm currently working on a page that displays the status of a certain set of ""tasks"" for a specific user. To fetch the data, I have the following Relay container:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default Relay.createContainer(TaskReview, {&#xA;  initialVariables: {&#xA;    limit: Number.MAX_SAFE_INTEGER,&#xA;    studentId: null,&#xA;  },&#xA;  fragments: {&#xA;    task: () =&gt; Relay.QL`&#xA;      fragment on Task {&#xA;        id,&#xA;        title,&#xA;        instruction,&#xA;        end_date,&#xA;        taskDataList(first: $limit, type: ""subTasks"", member: $studentId) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              answer,&#xA;              completion_date,&#xA;            }&#xA;          }&#xA;        },&#xA;        ...&#xA;</code></pre>&#xA;&#xA;<p>To define which user I want to get data from, I use:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>componentWillMount = () =&gt; {&#xA;  let {relay} = this.props;&#xA;  relay.setVariables({&#xA;    studentId: this.props.member.id&#xA;  });&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, the problem here is that the query is first executed with <code>null</code> as defined in <code>initialVariables</code>. My backend implementation has it so that if the <code>studentId</code> is NULL, then it returns the data for all members.</p>&#xA;&#xA;<p>The result is that the above query executes twice, the first time with all members, and the second time with the given <code>memberId</code>.</p>&#xA;&#xA;<p>This messes up with other things within my <code>componentWillUpdate</code>. Is there anyway I can pass this variable and only get the data for that member on the first query?</p>&#xA;&#xA;<p>Thanks.</p>&#xA;",2030321,,151461,2017-02-07 21:01:57,2017-02-07 21:01:57,Relay - set variable before query,<reactjs><relayjs><graphql>,1,0,0,2016-02-29 11:38:59
35713364,1,35760444,,1,368,"<p>I try to have a <code>addColumn</code> and a <code>removeColumn</code> mutation on a <code>Chart</code> component.</p>&#xA;&#xA;<p>But when I call</p>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(new RemoveChartColumnMutation({&#xA;  chart: this.props.viewer.chart,&#xA;  column: this.props.viewer.chart.columns[0]&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>I get this error</p>&#xA;&#xA;<pre><code>""Fragment \""F2\"" cannot be spread here as objects of type ""AddChartColumnPayload\"" can never be of type \""RemoveChartColumnPayload\"".""&#xA;</code></pre>&#xA;&#xA;<p>What am I doing wrong here?</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Home, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        chart {&#xA;          columns&#xA;          ${AddChartColumnMutation.getFragment('chart')}&#xA;          ${RemoveChartColumnMutation.getFragment('chart')}&#xA;        }&#xA;      }`&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>With these mutations</p>&#xA;&#xA;<pre><code>class AddChartColumnMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {addChartColumn}`;&#xA;  }&#xA;  getVariables() {&#xA;    return {&#xA;      id: this.props.chart.id,&#xA;      key: this.props.key,&#xA;      aggregation: this.props.aggregation&#xA;    };&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on AddChartColumnPayload {&#xA;        chart {&#xA;          columns&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {&#xA;        chart: this.props.chart.id&#xA;      }&#xA;    }];&#xA;  }&#xA;  static fragments = {&#xA;    chart: () =&gt; Relay.QL`&#xA;      fragment on Chart {&#xA;        id&#xA;        type&#xA;      }&#xA;    `&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and</p>&#xA;&#xA;<pre><code>class RemoveChartColumnMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {addChartColumn}`;&#xA;  }&#xA;  getVariables() {&#xA;    return {&#xA;      chartId: this.props.chart.id,&#xA;      columnId: this.props.column.id&#xA;    };&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on RemoveChartColumnPayload {&#xA;        chart {&#xA;          columns&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {&#xA;        chart: this.props.chart.id&#xA;      }&#xA;    }];&#xA;  }&#xA;  static fragments = {&#xA;    chart: () =&gt; Relay.QL`&#xA;      fragment on Chart {&#xA;        id&#xA;        type&#xA;      }&#xA;    `&#xA;  };&#xA;}&#xA;</code></pre>&#xA;",2514535,,,,2016-03-02 23:40:21,Multiple Mutations on a single object,<relayjs><graphql-js>,1,0,0,2016-03-01 02:01:10
35733241,2,,35479704,0,,"<p>I'm assuming you've got each component in it's own file and you've just joined them all together for your sample above? I haven't been able to try this, but it looks like you've got multiple default exports for the Comment module. You can only have one default export per module. Try removing the ""export default"" from ""export default class Comment extends React.Component {"". The Relay.createContainer() should be your default export, it's a wrapper around the Comment class.</p>&#xA;&#xA;<p>For example, I'd have a comment.js containing the following:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';&#xD;&#xA;import Relay from 'react-relay';&#xD;&#xA;&#xD;&#xA;class Comment extends React.Component {&#xD;&#xA;  render() {&#xD;&#xA;    console.log(""hai:""+this.props.comment)&#xD;&#xA;    var {id, text} = this.props.comment;&#xD;&#xA;    return &lt;li key={id}&gt;{text}&lt;/li&gt;;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;export default Relay.createContainer(Comment, {&#xD;&#xA;  fragments: {&#xD;&#xA;    comment: () =&gt; Relay.QL`&#xD;&#xA;      fragment on Comment {&#xD;&#xA;        id,&#xD;&#xA;        text,&#xD;&#xA;      }&#xD;&#xA;    `,&#xD;&#xA;  },&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",1536555,,,,2016-03-01 20:51:58,"",,0,0,0,2016-03-01 20:51:58
35766363,1,35894176,,1,733,"<p>I'm writing a relay.js app, and I'm using <a href=""https://github.com/relay-tools/react-router-relay"" rel=""nofollow"">react-relay-router</a> for routing. Routing works, but I believe it is exposing a misunderstanding on my part of how to organize query fragments across different views.</p>&#xA;&#xA;<p>routes defined in <strong>app.js</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const rootComponent =&#xA;  (&lt;RelayRouter history={hashHistory}&gt;&#xA;    &lt;Route path=""/""&#xA;      component={App}&#xA;      queries={ViewerQueries}&#xA;      onReadyStateChange={this.handleStateChange}&#xA;    &gt;&#xA;      &lt;IndexRoute&#xA;        component={Dashboard}&#xA;        queries={ViewerQueries}&#xA;      /&gt;&#xA;      &lt;Route&#xA;        path=""/org_setup""&#xA;        component={OrgSetup}&#xA;        queries={ViewerQueries}&#xA;      /&gt;&#xA;      &lt;Route&#xA;        path=""/admin/data_models""&#xA;        component={DataModelList}&#xA;        queries={ViewerQueries}&#xA;      /&gt;&#xA;    &lt;/Route&gt;&#xA;  &lt;/RelayRouter&gt;);&#xA;ReactDOM.render(rootComponent, mountNode);&#xA;</code></pre>&#xA;&#xA;<p>query fragment declaration in <strong>DataModelList.js</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default Relay.createContainer(DataModelList, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        dataModels(first: 10) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              name,&#xA;              isAuthority,&#xA;              categories(first: 10) {&#xA;                edges {&#xA;                  node {&#xA;                    id,&#xA;                    name,&#xA;                    tags(first: 10) {&#xA;                      edges {&#xA;                        node {&#xA;                          id,&#xA;                          code,&#xA;                          label,&#xA;                        }&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                }&#xA;              },&#xA;              adapter {&#xA;                categories(first: 10) {&#xA;                  edges {&#xA;                    node {&#xA;                      id,&#xA;                      name,&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>query fragment in <strong>OrgSetup.js</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default Relay.createContainer(OrgSetup, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        dataModels(first: 10) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              name,&#xA;              isAuthority,&#xA;              categories(first: 10) {&#xA;                edges {&#xA;                  node {&#xA;                    id,&#xA;                    name,&#xA;                    tags(first: 10) {&#xA;                      edges {&#xA;                        node {&#xA;                          id,&#xA;                          code,&#xA;                          label,&#xA;                        }&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                }&#xA;              },&#xA;            }&#xA;          }&#xA;        },&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>When navigating between <code>DataModelList</code> and <code>OrgSetup</code> (in either direction) I see the following error in the console:</p>&#xA;&#xA;<pre><code>Server request for query `ViewerQueries` failed for the following reasons:&#xA;&#xA;1. Cannot query field ""node"" on ""Query"".&#xA;   rQueries($id_0:ID!){node(id:$id_0){id,__typename,...F0}} fra&#xA;&#xA;Warning: RelayReadyState: Invalid state change from &#xA;{""aborted"":false,""done"":false,""error"":{""source"":{""data"":null,""errors"":&#xA;[{""message"":""Cannot query field \""node\"" on \""Query\""."",""locations"":&#xA;[{""line"":1,""column"":32}]}]}},""ready"":false,""stale"":false}` to `{""error"":&#xA;{""source"":{""data"":null,""errors"":[{""message"":""Cannot query field \""node\"" on &#xA;\""Query\""."",""locations"":[{""line"":1,""column"":32}]}]}}}`.warning @ &#xA;app.js:31567update @ app.js:39409onRejected @ app.js:39035tryCallOne @ &#xA;app.js:30045(anonymous function) @ app.js:30131flush @ app.js:30279&#xA;</code></pre>&#xA;&#xA;<p>I'm able to prevent this error from occurring by making the query fragments in the two views identical - specifically by adding the <code>adapter</code> fragment. </p>&#xA;&#xA;<p>However, this feels wrong. They don't need to be identical (in fact they are somewhat intentionally bloated at the moment since this is a learning app for me), and other views will of course not share these data needs.</p>&#xA;&#xA;<ol>&#xA;<li>What is the best practice for keeping query declarations concise?&#xA;Ideally I would have top level views only declare top level data&#xA;requirements. Concretely, in my example view files I would request&#xA;only the <code>viewer</code> and their <code>dataModels</code>, and then allow child&#xA;components to express their needs, requesting any nested data (eg&#xA;<code>categories</code>, <code>tags</code>, or <code>adapters</code> and their respective <code>categories</code>).</li>&#xA;<li>What does the <code>invalid state change</code> error really mean? I can see&#xA;that it's satisfied by the queries matching exactly, but I can't&#xA;imagine unrelated views are required to share query declarations. I&#xA;suspect this is a byproduct of my doing something wrong elsewhere.</li>&#xA;</ol>&#xA;&#xA;<p>Thanks!</p>&#xA;",618360,,710693,2017-08-11 01:09:55,2017-08-11 01:09:55,Navigating relay.js app with RelayRouter throwing Invalid State Change error,<reactjs><react-router><graphql><relayjs>,1,2,0,2016-03-03 08:01:05
35894176,2,,35766363,5,,"<p>When the query changes (eg. due to a route transition, or a call to <code>setVariables()</code>) Relay will diff the query you're coming from and the query you're headed to, computing the minimal query to get you from A to B. In your case, Relay starts from the series of known records stored on the client (the already-fetched ones) and tries to fetch only the new fields on those exact records in an effort to build a complete picture of the world. These refetches rely on something called the <a href=""https://facebook.github.io/relay/graphql/objectidentification.htm#sec-Node-root-field"" rel=""noreferrer"">node interface</a>.</p>&#xA;&#xA;<p>Relay-compliant GraphQL servers must expose a root field called <code>node</code> that can fetch any record given a global ID. This field must take an <code>id</code> argument of type <code>GraphQLID!</code>.</p>&#xA;&#xA;<p>For an example of how to build such a root field, see <a href=""https://github.com/graphql/graphql-relay-js#object-identification"" rel=""noreferrer"">this <code>graphql-js</code> example</a>.</p>&#xA;",802047,,,,2016-03-09 14:21:25,"",,0,1,0,2016-03-09 14:21:25
35895451,2,,35698582,2,,"<p>Prime your app with these initial conditions by passing your variable down through the route.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class TaskReviewRoute extends Relay.Route {&#xA;  static paramDefinitions = {&#xA;    studentId: {required: true},&#xA;  };&#xA;  static queries = {&#xA;    task: () =&gt; Relay.QL`query { ... }`,&#xA;  };&#xA;  static routeName = 'TaskReviewRoute';&#xA;}&#xA;&#xA;&lt;Relay.RootContainer&#xA;  Container={TaskReview}&#xA;  route={new TaskReviewRoute({studentId: '123'})}&#xA;/&gt;&#xA;</code></pre>&#xA;",802047,,,,2016-03-09 15:14:09,"",,0,5,0,2016-03-09 15:14:09
35903187,2,,33638409,2,,"&#xA;&#xA;<p>The <code>outputFields</code> in your schema make up the GraphQL type <code>CreateActivityPayload</code> that will be generated from your schema.js file. A mutation is like a regular query, but with side effects. In <code>outputFields</code> you get to decide what's queryable. Since your store is the only thing in your app that can change as a result of this mutation, we can start with that.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>outputFields: {&#xA;  store: {&#xA;    type: storeType,&#xA;    resolve: () =&gt; store,&#xA;  },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The fat query operates on these output fields. Here you tell Relay what could possibly change as a result of this mutation. Adding an activity could change the following fields:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>getFatQuery() {&#xA;  return Relay.QL`&#xA;    fragment on CreateActivityPayload @relay(pattern: true) {&#xA;      store {&#xA;        activities&#xA;      }&#xA;    }&#xA;  `;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Finally, the config tells Relay what to do with the query when it gets it, or even if it needs to be made at all. Here, you're looking to update a field after creating a new activity. Use the <code>FIELDS_CHANGE</code> config to tell Relay to update your store.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>getConfigs() {&#xA;  return [{&#xA;    type: 'FIELDS_CHANGE',&#xA;    fieldsIDs: {&#xA;      store: this.props.storeId,&#xA;    },&#xA;  }];&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>See more: <a href=""https://facebook.github.io/relay/docs/guides-mutations.html"" rel=""nofollow"">https://facebook.github.io/relay/docs/guides-mutations.html</a></p>&#xA;",802047,,,,2016-03-09 21:41:48,"",,0,3,0,2016-03-09 21:41:48
35919036,1,35943543,,2,180,"<p>I'm working on a chat feature on my website which I am developing with Reactjs and Relayjs.</p>&#xA;&#xA;<p>I can successfully query and display the relevant data (chat messages) in my view. However, the view remains static even if the chat partner sends a new message.</p>&#xA;&#xA;<p>I'm looking for ways to implement this, either by checking for database changes or executing the same query on intervals and then fetching the changes, if any.</p>&#xA;&#xA;<p>The relay documentation doesn't seem to describe how to do this. I was first thinking of creating a dummy mutation that doesn't do anything, so that the data is re-fetched which would update the view. However, not only does this seem like a bad implementation, but it would probably not work as the mutation would only return the changes, and not the entire resultset.</p>&#xA;&#xA;<p>I'd rather not use 3rd party libraries, if possible.</p>&#xA;&#xA;<p>Here's my relay container:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(StartConversationModal, {&#xA;  prepareVariables() {&#xA;    return {&#xA;      limit: 1000,&#xA;    };&#xA;  },&#xA;  fragments: {&#xA;    conversation: () =&gt; Relay.QL`&#xA;      fragment on Conversation {&#xA;        id,&#xA;        title,&#xA;        type,&#xA;        conversationDataList(last: $limit) {&#xA;          edges {&#xA;            node {&#xA;              last_read_message_id,&#xA;              member {&#xA;                id,&#xA;                user {&#xA;                  firstname,&#xA;                  lastname&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;        messageList(last: $limit) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              message,&#xA;              sent_on,&#xA;              member {&#xA;                id,&#xA;                role,&#xA;                user {&#xA;                  firstname,&#xA;                  lastname&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;        task {&#xA;          title,&#xA;        },&#xA;        ${AddMessageMutation.getFragment('conversation')},&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",2030321,,710693,2017-08-11 00:32:14,2017-08-11 00:32:14,Re-execute relayjs query,<reactjs><graphql><relayjs>,1,0,0,2016-03-10 14:20:27
35943543,2,,35919036,2,,"<p>To refetch all the fragments for a container, you can use the imperative <code>forceFetch</code> API given by RelayContainer, see <a href=""https://facebook.github.io/relay/docs/api-reference-relay-container.html#forcefetch"" rel=""nofollow"">docs</a></p>&#xA;&#xA;<p>Basically inside <code>StartConversationModal</code> you could set up a poller that calls <code>forceFetch</code> off <code>this.props.relay</code>. Note that this will refetch the entire connection which might not be what you want, you'd have to experiment with it. </p>&#xA;",1750095,,,,2016-03-11 15:06:10,"",,0,3,0,2016-03-11 15:06:10
35946313,1,35987582,,3,1918,"<p>Example fragment:</p>&#xA;&#xA;<pre><code>fragments: {&#xA;  viewer: () =&gt; Relay.QL`&#xA;    fragment on Viewer {&#xA;      people(first: $limit orderBy: $orderBy) {&#xA;        count&#xA;        edges {&#xA;          node {&#xA;            id,&#xA;            ${PersonListItem.getFragment('person')},&#xA;          },&#xA;        },&#xA;      }&#xA;    }&#xA;  `,&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>The <code>orderBy</code> argument accepts the following enum values: <code>firstNameASC</code>/<code>firstNameDESC</code>/<code>lastNameASC</code>/<code>lastNameDESC</code>.</p>&#xA;&#xA;<p>When doing <code>this.setVariables({orderBy: 'firstName'})</code> the <code>orderBy</code> variable is passed as a string to the GraphQL server.</p>&#xA;&#xA;<p>How do I pass any of these variables into Relay's setVariables without them being sent as strings?</p>&#xA;",590396,,590396,2016-03-11 17:44:55,2016-04-28 14:31:51,How to set a Relay variable as an enum value?,<javascript><reactjs><graphql><relay><graphql-js>,1,0,0,2016-03-11 17:25:23
35987582,2,,35946313,5,,"<p>You can now use an enum variable as a string. </p>&#xA;&#xA;<h2>Example</h2>&#xA;&#xA;<h3>Query (<code>EventsConnectionOrder</code> is an enum)</h3>&#xA;&#xA;<pre><code>query($orderBy: [EventsConnectionOrder]){&#xA;  viewer {&#xA;    events(first:1 orderBy: $orderBy) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h3>Variables</h3>&#xA;&#xA;<pre><code>{&#xA;  ""orderBy"": ""dateASC""&#xA;}&#xA;</code></pre>&#xA;",590396,,590396,2016-04-28 14:31:51,2016-04-28 14:31:51,"",,0,0,0,2016-03-14 12:28:50
36011426,2,,35971738,1,,<p>In your HomeRoute:</p>&#xA;&#xA;<pre><code>class HomeRoute extends Relay.Route {&#xA;    static routeName = 'Home';&#xA;    static queries = {&#xA;        store:(Component) =&gt; Relay.QL`&#xA;        query MainQuery {&#xA;            store { ${Component.getFragment('store')}}&#xA;        }`&#xA;    }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Have you tried just:</p>&#xA;&#xA;<pre><code>    static queries = {&#xA;        store:() =&gt; Relay.QL`&#xA;        query MainQuery {&#xA;            store&#xA;        }`&#xA;    }&#xA;</code></pre>&#xA;,5418906,,,,2016-03-15 12:30:20,"",,0,6,0,2016-03-15 12:30:20
36050731,2,,36047291,3,,"<p>Relay maintains a list of companies that are using it in production in the GitHub repo:</p>&#xA;&#xA;<p><a href=""https://github.com/facebook/relay/blob/master/USERS.md"" rel=""nofollow"">https://github.com/facebook/relay/blob/master/USERS.md</a></p>&#xA;",2442219,,,,2016-03-17 02:43:07,"",,0,2,0,2016-03-17 02:43:07
36137231,1,,,0,462,<p>Does any Angular 2 GraphQL API or comparable exist? So thinking of anything like relay but just for Angular2?</p>&#xA;,827148,,,,2016-07-04 21:33:35,Does any Angular2 GraphQL API Library or comparable datalayer exist?,<angular><graphql>,2,0,0,2016-03-21 16:57:18
36224649,1,36273826,,3,687,"<p>I'm new to Relay and am having an issue with nested data on a fragment.</p>&#xA;&#xA;<p>The following query returns the correct data when I test in it graphiql so I am confident my schema is correct.</p>&#xA;&#xA;<pre><code> {&#xA;  viewer {&#xA;    customers {&#xA;      name&#xA;      billing_address {&#xA;        city&#xA;      }&#xA;    } &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, when I use the above query with Relay the <code>customer.name</code> will be correct but <code>customer.billing_address.city</code> is the same for every customer. It's confusing to me why some of the data would be correct while the nested data would just be copied.</p>&#xA;&#xA;<p>I would appreciate any help with the issue and if anymore information is needed I would be glad to add it. Below is the only Relay code currently in my project and where I believe the issue may be. </p>&#xA;&#xA;<pre><code>class App extends Component {&#xA;  render() {&#xA;    console.log(this.props.viewer.customers);&#xA;    return (&#xA;      &lt;div&gt;&#xA;      {this.props.viewer.customers.map((customer) =&gt; (&#xA;        &lt;div&gt;&#xA;          &lt;div&gt;{customer.name}&lt;/div&gt;&#xA;          &lt;div&gt;{customer.billing_address.city}&lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;      ))}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;class AppHomeRoute extends Relay.Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      query {&#xA;        viewer&#xA;      }&#xA;    `,&#xA;  };&#xA;  static routeName = 'AppHomeRoute';&#xA;}&#xA;&#xA;const AppContainer =  Relay.createContainer(App, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        customers{&#xA;          name&#xA;          billing_address{&#xA;            city&#xA;          }&#xA;        }&#xA;      }`&#xA;  },&#xA;});&#xA;&#xA;ReactDOM.render(&#xA;  &lt;Relay.RootContainer&#xA;    Component={AppContainer}&#xA;    route={new AppHomeRoute()}&#xA;  /&gt;,&#xA;  document.getElementById('root')&#xA;);&#xA;</code></pre>&#xA;",4686189,,5418906,2016-03-28 04:05:45,2016-03-29 01:19:54,Nested fragment data always the same in Relay,<javascript><reactjs><graphql><relay>,1,5,0,2016-03-25 17:17:07
36280693,1,36286475,,3,508,"<p>I am trying to implement pagination using relay in application. Displaying data in react-bootstrap table and pagination to navigate pages. First time when I hit page it loads first page data (executes root Query). On click event of on pagination (1, 2, 3 ..) I request server for next page data. as expected root query executes and fetches data But data on UI is not getting updated.. and in browser console I can see following error</p>&#xA;&#xA;<p><em>Warning: Relay was unable to reconcile edges on a connection. This most likely occurred while trying to handle a server response that includes connection edges with nodes that lack an <code>id</code> field.</em> </p>&#xA;&#xA;<p>After pagination click I can see changes in url with required parameters say pageNum=2 and on page refresh it shows new data.. but data should come without page refresh.</p>&#xA;",5598165,,,,2016-03-29 13:55:50,Relay was unable to reconcile edges on a connection,<reactjs><graphql><relay>,1,0,0,2016-03-29 09:44:14
36287608,1,36316545,,2,1057,"<p>I am trying to build an application using GraphQL and React Relay.</p>&#xA;&#xA;<p>As part of this I have created a root query with the following specification:</p>&#xA;&#xA;<pre><code>query {&#xA;  AllServices {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So I have created a mutation - which works well - called CreateGithubService.</p>&#xA;&#xA;<p>Here is a snippet from the Relay mutation:</p>&#xA;&#xA;<pre><code>getFatQuery() {&#xA;      return Relay.QL`&#xA;        fragment on CreateGithubServicePayload {&#xA;          createdService&#xA;        }&#xA;      `&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;      return [{&#xA;          type: ""REQUIRED_CHILDREN"",&#xA;          children: [&#xA;              Relay.QL`&#xA;                  fragment on CreateGithubServicePayload {&#xA;                      createdService {&#xA;                          id&#xA;                      }&#xA;                  }&#xA;              `&#xA;          ]&#xA;      }]&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>The problem I have is that this is not causing the views which rely on the information to update.</p>&#xA;&#xA;<p>My AllServices query is not refetched and I am unable to specify it in the Fat Query.</p>&#xA;&#xA;<p>How can I setup my mutation to add the element to the all services query?</p>&#xA;&#xA;<p>Thanks!</p>&#xA;",5884998,,710693,2017-08-11 00:31:23,2017-08-11 00:31:23,React Relay update a root query as part of a mutation fat query,<reactjs><graphql><relayjs><graphql-js>,1,0,0,2016-03-29 14:44:06
36304369,1,36394664,,0,1139,"<p>I have a mongoose schema like the one below:</p>&#xA;&#xA;<pre><code>import mongoose from 'mongoose'&#xA;&#xA;const ProjectSchema = new mongoose.Schema({&#xA;  name: {&#xA;    type: String&#xA;  },&#xA;  owner: {&#xA;    type: String&#xA;  },&#xA;  member: {&#xA;    type: String&#xA;  },&#xA;  updatedDate: {&#xA;    type: Date&#xA;  },&#xA;  description: {&#xA;    type: String&#xA;  },&#xA;  folder: {&#xA;    type: mongoose.Schema.Types.ObjectId,&#xA;    ref: 'Folder'&#xA;  },&#xA;  dataSources: [{&#xA;    name: {&#xA;      type: String&#xA;    },&#xA;    updatedDate: {&#xA;      type: Date&#xA;    },&#xA;  }],&#xA;  propjectHistory: [{&#xA;    no: {&#xA;      type: Number&#xA;    },&#xA;    member: {  // is this reference or just a string?&#xA;      type: String&#xA;    },&#xA;    action: {&#xA;      type: String&#xA;    },&#xA;    updatedDate: {&#xA;      type: Date&#xA;    },&#xA;  }]&#xA;})&#xA;&#xA;const Project = mongoose.model('Project', ProjectSchema)&#xA;</code></pre>&#xA;&#xA;<p>And I integrated with graphql using graffiti and graffiti-mongoose.&#xA;However, the Graphiql documentation shows that I only have the ones below:</p>&#xA;&#xA;<pre><code>addProject(input: addProjectInput!):&#xA;&#xA;name: String&#xA;owner: String&#xA;member: String&#xA;updatedDate: Date&#xA;description: String&#xA;folder: ID&#xA;clientMutationId: String!&#xA;</code></pre>&#xA;&#xA;<p>I could successfully add project with a mutation query only using those parameters, but it seems that I cannot even send mutation query with projectHistory and dataSource, which are embedded inside project schema.</p>&#xA;&#xA;<p>However, I can access projectHistory and dataSource when I send find queries.</p>&#xA;&#xA;<p>I can't find any documentation about the problem.</p>&#xA;&#xA;<p>sample mutation query without nested ones works.</p>&#xA;&#xA;<pre><code>mutation {&#xA;  addProject(input:{&#xA;    clientMutationId: ""1""&#xA;    name: ""testproject"",&#xA;    owner: ""keonwoo"",&#xA;    member: ""keonwoo"",&#xA;    updatedDate: ""2015-07-24T13:23:15.580Z"",&#xA;    description: ""this is test project"",&#xA;    folder: ""56fb93403eab9e1c14358fb7""&#xA;  }){&#xA;    clientMutationId&#xA;    changedProjectEdge{&#xA;      node{&#xA;        _id&#xA;        name&#xA;        updatedDate&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>the above mutation returns the following:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""addProject"": {&#xA;      ""clientMutationId"": ""1"",&#xA;      ""changedProjectEdge"": {&#xA;        ""node"": {&#xA;          ""_id"": ""56fb93ab3eab9e1c14358fb8"",&#xA;          ""name"": ""testproject"",&#xA;          ""updatedDate"": ""2015-07-24T13:23:15.580Z""&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am not using client like relay.</p>&#xA;",4489778,,4489778,2016-03-31 01:18:43,2016-04-04 04:37:41,How to mutate nested object using graphql,<graphql>,1,6,0,2016-03-30 09:11:42
36316545,2,,36287608,5,,"<p><code>REQUIRED_CHILDREN</code> will not update the local graph; it's strictly for fetching extra data that is only used in the success callback of the mutation update. In fact, it's not even documented outside of the source code, so I'm not sure how you decided to use it like this...</p>&#xA;&#xA;<p>Although you haven't said so, I assume you want this new node (<code>createdService</code>) to be added to the <code>AllServices</code> connection? If so, you need to tell Relay that your mutation affects that connection:</p>&#xA;&#xA;<ol>&#xA;<li><p>At the moment, Relay basically assumes all mutations affect nodes, not arbitrary queries. To my knowledge, you won't be able to configure a mutation to update a non-node root query. Therefore, you should add a node at the root that acts as the parent of your <code>AllServices</code> connection (the convention for this is typically <code>viewer</code>). In other words, make it work like this: <code>query { viewer { AllServices { ... } } }</code></p></li>&#xA;<li><p>Your mutation payload should always return everything that has been changed, not just the new data. That means you need a way to refetch the <code>AllServices</code> connection from the payload. Once you add the <code>viewer</code> node to your schema, you can return that node in the mutation payload and change your fat query to specify that the connection has changed, e.g.: <code>fragment on CreateGithubServicePayload { viewer { AllServices } }</code></p></li>&#xA;<li>Given those two schema changes, you can then configure your mutation using <code>FIELDS_CHANGE</code> and specify the fieldIDs like <code>{ viewer: this.props.viewer.id }</code></li>&#xA;</ol>&#xA;",1750095,,,,2016-03-30 18:13:06,"",,0,0,0,2016-03-30 18:13:06
36437712,1,,,0,1713,"<p>How does graphql generates hasNextPage if only ""first"" parameter passed?&#xA;I am using </p>&#xA;&#xA;<p><code>&#xA;  return relay.connectionFromPromisedArray(&#xA;    global.app.get('model__user').getUsers(args),&#xA;    args&#xA;  );&#xA;</code></p>&#xA;&#xA;<p>and query:</p>&#xA;&#xA;<p><code>&#xA;query RootQueryType { viewer { user(id: 1){ id,email,friends(first: 5) {edges {cursor, node { id, email } }, pageInfo { hasNextPage } } } } }&#xA;</code></p>&#xA;&#xA;<p>So how can i pass to graphql / relay friends count so hasNextPage will be generated correct?</p>&#xA;",946231,,,,2016-06-28 20:17:54,GraphQL Relay hasNextPage,<graphql><relay><graphql-js>,2,0,0,2016-04-05 21:50:49
36446258,2,,36437712,1,,"<p>Relay pagination is not page based, but rather <code>cursor</code> based. So you paginate by saying ""I want X items after item Y"". Item Y is not pointed to as a page number or an offset, but rather as a pointer to that exact object, a so-called cursor. This model of pagination is nice for, for example, infinite scrolling. ""Pages"" are also stable after adding or removing items, as they don't depend on number of items.</p>&#xA;&#xA;<p><code>hasNextPage</code> in Relay GraphQL spec just indicates whether there are more items after the last element that has been retrieved. So in your case, it means there are more than 5 elements in total and you'll get more elements if you do</p>&#xA;&#xA;<pre><code>friends(first: 5, after: ""CURSOR_TO_THE_LAST_ELEMENT"")&#xA;</code></pre>&#xA;&#xA;<p>You can retrieve cursor from the <code>edges</code> list, it's one of the elements alongside <code>node</code> there.</p>&#xA;",68544,,,,2016-04-06 09:00:58,"",,0,0,0,2016-04-06 09:00:58
36590682,1,36619888,,1,758,"<p>I am having a hard time figuring out how to do mutations on plain array via relay.</p>&#xA;&#xA;<p>I am trying to add a new tag to a post.&#xA;It does not get updated on client-side after being successfully added on the server-side.</p>&#xA;&#xA;<p>I have to manually reload to see the new tag.&#xA;I have tried both <code>REQUIRED_CHILDREN</code> and <code>this.props.relay.forceFetch()</code>, but to no avail.</p>&#xA;&#xA;<p>Also, tried <code>FIELDS_CHANGE</code> for post.</p>&#xA;&#xA;<p>GraphQL Schema:</p>&#xA;&#xA;<pre><code>Post {&#xA;  id: ID!&#xA;  text: String!&#xA;  tags: [Tag!]!&#xA;}&#xA;&#xA;Tag {&#xA;  id: ID!&#xA;  name: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>AddTagToPostMutation:</p>&#xA;&#xA;<pre><code>  static fragments = {&#xA;    post: () =&gt; Relay.QL`&#xA;      fragment on Post {&#xA;        id&#xA;        tags&#xA;      }&#xA;    `,&#xA;  }&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { addTagToPost }`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      name: this.props.tag.name,&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on AddTagToPostMutationPayload {&#xA;        tag {&#xA;          id&#xA;          name&#xA;        }&#xA;        post {&#xA;          id&#xA;          tags&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'REQUIRED_CHILDREN',&#xA;      children: [Relay.QL`&#xA;        fragment on AddTagToPostMutationPayload {&#xA;          tag {&#xA;            id&#xA;            name&#xA;          }&#xA;          post {&#xA;            id&#xA;            tags&#xA;          }&#xA;        }&#xA;      `],&#xA;    }];&#xA;  }&#xA;&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      tag: {&#xA;        name: this.props.tag.name,&#xA;      },&#xA;      post: {&#xA;        id: this.props.post.id,&#xA;      },&#xA;    };&#xA;  }&#xA;</code></pre>&#xA;",692528,,692528,2016-04-13 21:30:39,2016-04-14 10:11:52,Relay mutation on plain array is not working,<reactjs><graphql><relayjs><graphql-js>,2,0,0,2016-04-13 06:51:14
36596116,2,,36590682,1,,"<p>I think you should just use FIELDS_CHANGE in such situations.</p>&#xA;&#xA;<pre><code>  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {post: this.props.post.id},&#xA;    }];&#xA;  }&#xA;&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      post: {&#xA;        id: this.props.post.id,&#xA;        tags: [...this.props.post.tags, this.props.tag],&#xA;      },&#xA;    };&#xA;  }&#xA;</code></pre>&#xA;",68544,,,,2016-04-13 10:50:15,"",,0,2,0,2016-04-13 10:50:15
36619350,2,,35194917,3,,"<p>Relay mutations must have <code>clientMutationId</code> field that is accepted in their <code>input</code> and is returned as is in the resulting payload. Relay uses them to track which mutation server have response to. In addition for Relay, mutations must accept one argument - <code>input</code>. It can be a InputObject type, but it must be formed like that. Here is detailed guide on Relay GraphQL Mutation inteface <a href=""https://facebook.github.io/relay/docs/graphql-mutations.html#content"" rel=""nofollow"">https://facebook.github.io/relay/docs/graphql-mutations.html#content</a></p>&#xA;&#xA;<p>In your case you could do something like this:</p>&#xA;&#xA;<pre><code>export var Schema = new GraphQLSchema({&#xA;  mutation: new GraphQLObjectType({&#xA;    name: ""Mutation"",&#xA;     fields: () =&gt; ({&#xA;      UpdateZipcode:{&#xA;        type: zipCodeType,&#xA;        args: {&#xA;          input: {type: new GraphQLInputObjectType({&#xA;            name: ""UpdateZipCodeInput"",&#xA;            fields: {&#xA;              clientMutationId: { type: String },&#xA;              ZipCode: { type: String },&#xA;          })}&#xA;        },&#xA;        resolve: (root,{input: { clientMutationId, ZipCode}) =&gt; ({&#xA;          ...updateZipCode(ZipCode),&#xA;          clientMutationId,&#xA;        }),&#xA;      }&#xA;    })&#xA;  })&#xA;})&#xA;</code></pre>&#xA;",68544,,,,2016-04-14 09:44:12,"",,0,1,0,2016-04-14 09:44:12
36658671,1,36659107,,5,1073,"<p>I'm trying to pass an attribute into another component. Passing the array as <code>&lt;VideoList videos={this.props.channel.video_list}&gt;&lt;/VideoList&gt;</code> results in <code>this.props.videos</code> being an empty object:</p>&#xA;&#xA;<pre><code>{&#xA;  ""videos"": {&#xA;    ""__dataID__"": ""client:5610611954"",&#xA;    ""__fragments__"": {&#xA;      ""2::client"": ""client:5610611954""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(GraphQL returns the correct data as confirmed by the React Chrome extension, it's just not being passed into the <code>VideoList</code>.)</p>&#xA;&#xA;<p><strong>components/video_list.js</strong></p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import Relay from 'react-relay'&#xA;import VideoItem from '../containers/video_item'    &#xA;&#xA;export default class VideoList extends React.Component {&#xA;  render() {&#xA;    return(&#xA;      &lt;div&gt;&#xA;      {&#xA;        this.props.videos.edges.map(video =&gt;&#xA;          &lt;VideoItem key={video.id} video={video.node}/&gt;&#xA;        )&#xA;      }&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>components/channel_list.js</strong></p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import Relay from 'react-relay'&#xA;import VideoList from './video_list'&#xA;&#xA;export default class ChannelView extends React.Component {&#xA;  render() {&#xA;    return(&#xA;      &lt;div&gt;&#xA;        &lt;Column small={24}&gt;&#xA;          &lt;h2&gt;{this.props.channel.title}&lt;/h2&gt;&#xA;        &lt;/Column&gt;&#xA;&#xA;        &lt;VideoList videos={this.props.channel.video_list}&gt;&lt;/VideoList&gt;&#xA;      &lt;/div&gt;&#xA;&#xA;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>containers/channel_list.js</strong></p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import Relay from 'react-relay'&#xA;import ChannelView from '../components/channel_view'&#xA;import VideoList from './video_list'&#xA;&#xA;export default Relay.createContainer(ChannelView, {&#xA;  fragments: {&#xA;    channel: () =&gt; Relay.QL`&#xA;      fragment on Channel {&#xA;        title&#xA;        video_list {&#xA;          ${VideoList.getFragment('videos')}&#xA;        }&#xA;      }`&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>containers/video_list.js</strong></p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import Relay from 'react-relay'&#xA;import VideoList from '../components/video_list'&#xA;import VideoItem from './video_item'&#xA;&#xA;export default Relay.createContainer(VideoList, {&#xA;  initialVariables: {&#xA;    count: 28&#xA;  },&#xA;  fragments: {&#xA;    videos: () =&gt; Relay.QL`&#xA;      fragment on Videos {&#xA;        videos(first: $count) {&#xA;          pageInfo {&#xA;            hasPreviousPage&#xA;            hasNextPage&#xA;          }&#xA;          edges {&#xA;            node {&#xA;              ${VideoItem.getFragment('video')}&#xA;            }&#xA;          }&#xA;        }&#xA;      }`&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>What am I doing wrong? Am I misunderstanding how Relay works? I want to be able to set the <code>count</code> relay variable in the <code>VideoList</code> for pagination purposes. The <code>VideoList</code> object is going to be nested within multiple other components (e.g. channel, most popular, user's favorites, etc.)</p>&#xA;&#xA;<p>Thank you!</p>&#xA;",101116,,710693,2017-08-11 00:24:59,2017-08-11 00:24:59,Nested React/Relay component not receiving props,<javascript><reactjs><graphql><relayjs>,1,0,0,2016-04-16 00:07:46
36659107,2,,36658671,4,,"<p>You are trying to use the <code>VideoList</code> component directly, without the relay container wrapping it, and that's wrong.&#xA;You need to use the <code>VideoList</code> wrapped version - the one you are exporting in <code>./containers/video_list.js</code>. </p>&#xA;&#xA;<p>Like this:</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import Relay from 'react-relay'&#xA;import VideoList from '../containers/video_list'&#xA;&#xA;export default class ChannelView extends React.Component {&#xA;  render() {&#xA;    return(&#xA;      &lt;div&gt;&#xA;        &lt;Column small={24}&gt;&#xA;          &lt;h2&gt;{this.props.channel.title}&lt;/h2&gt;&#xA;        &lt;/Column&gt;&#xA;&#xA;        &lt;VideoList videos={this.props.channel.video_list}&gt;&lt;/VideoList&gt;&#xA;      &lt;/div&gt;&#xA;&#xA;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2679942,,,,2016-04-16 01:12:59,"",,0,2,0,2016-04-16 01:12:59
36664385,1,,,3,1143,"<p>I'm writing a deletion mutation. The mutation should delete a <code>Key</code> node and update the <code>viewer</code>'s <code>keys</code> collection (I'm using Relay-style collections: <code>viewer { keys(first: 3) { edges { node { ... }}}}</code>.</p>&#xA;&#xA;<p>Following the advice <a href=""http://blog.pathgather.com/blog/a-beginners-guide-to-relay-mutations"" rel=""nofollow"">here</a>, I'm using the <code>FIELDS_CHANGE</code> config for simplicity, and it's actually working:</p>&#xA;&#xA;<pre><code>export class DeleteKeyMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer { id }&#xA;    `,&#xA;  };&#xA;  getMutation() { return Relay.QL`mutation {deleteKey}`; }&#xA;  getVariables() {&#xA;    return {&#xA;      id: this.props.id,&#xA;    };&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on DeleteKeyPayload {&#xA;        viewer { keys }&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [&#xA;      {&#xA;        type: 'FIELDS_CHANGE',&#xA;        fieldIDs: {&#xA;          viewer: this.props.viewer.id,&#xA;        },&#xA;      },&#xA;    ];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, how should I write an optimistic mutation for this? I've tried different approaches but none worked.</p>&#xA;",2773399,,710693,2017-08-11 00:28:01,2017-08-11 00:28:01,Optimistic update for a deletion mutation,<graphql><relayjs>,1,0,0,2016-04-16 12:48:41
36666622,1,,,6,3802,"<p>When defining a query in a schema, how do I refer to a value of an GraphQLEnumType declared previously, to use it as the default value of an argument?</p>&#xA;&#xA;<p>Let's say I've defined following <code>ObservationPeriod</code> GraphQLEnumType:</p>&#xA;&#xA;<pre><code>observationPeriodEnum = new GraphQLEnumType {&#xA;  name: ""ObservationPeriod""&#xA;  description: ""One of the performance metrics observation periods""&#xA;  values:&#xA;    Daily:&#xA;      value: '1D'&#xA;      description: ""Daily""&#xA;    […]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and use it as the type of query argument <code>period</code>:</p>&#xA;&#xA;<pre><code>queryRootType = new GraphQLObjectType {&#xA;  name: ""QueryRoot""&#xA;  description: ""Query entry points to the DWH.""&#xA;  fields:&#xA;    performance:&#xA;      type: performanceType&#xA;      description: ""Given a portfolio EID, an observation period (defaults to YTD)&#xA;                    and as-of date, as well as the source performance engine,&#xA;                    return the matching performance metrics.""&#xA;      args:&#xA;        period:&#xA;          type: observationPeriodEnum &#xA;          defaultValue: observationPeriodEnum.Daily ← how to achieve this?&#xA;      […]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Currently I'm using the actual <code>'1D'</code> string value as the default value; this works:</p>&#xA;&#xA;<pre><code>        period:&#xA;          type: observationPeriodEnum &#xA;          defaultValue: '1D'&#xA;</code></pre>&#xA;&#xA;<p>But is there a way I could use the <code>Daily</code> symbolic name instead? I couldn't find a way to use the names within the schema itself. Is there something I overlooked?</p>&#xA;&#xA;<p>I'm asking, because I was expecting an enum type to behave as a set of constants also, and to be able to use them like this in the schema definition:</p>&#xA;&#xA;<pre><code>        period:&#xA;          type: observationPeriodEnum &#xA;          defaultValue: observationPeriodEnum.Daily&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p>Naïve workaround:</p>&#xA;&#xA;<pre><code>##&#xA;# Given a GraphQLEnumType instance, this macro function injects the names &#xA;# of its enum values as keys the instance itself and returns the modified&#xA;# GraphQLEnumType instance.&#xA;#&#xA;modifiedWithNameKeys = (enumType) -&gt;&#xA;  for ev in enumType.getValues()&#xA;    unless enumType[ ev.name]?&#xA;      enumType[ ev.name] = ev.value&#xA;    else&#xA;      console.warn ""SCHEMA&gt; Enum name #{ev.name} conflicts with key of same&#xA;        name on GraphQLEnumType object; it won't be injected for value lookup""&#xA;  enumType&#xA;&#xA;observationPeriodEnum = modifiedWithNameKeys new GraphQLEnumType {&#xA;  name: ""description: ""Daily""""&#xA;  values:&#xA;    […]&#xA;</code></pre>&#xA;&#xA;<p>which allows to use it as desired in schema definition:</p>&#xA;&#xA;<pre><code>        period:&#xA;          type: observationPeriodEnum &#xA;          defaultValue: observationPeriodEnum.Daily&#xA;</code></pre>&#xA;&#xA;<p>Of course, this modifier fullfils its promise, only as long as the enum names do not interfere with GraphQLEnumType existing method and variable names (which are currently: <code>name</code>, <code>description</code>, <code>_values</code>, <code>_enumConfig</code>, <code>_valueLookup</code>, <code>_nameLookup</code>, <code>getValues</code>, <code>serialize</code>, <code>parseValue</code>, <code>_getValueLookup</code>, <code>_getNameLookup</code> and <code>toString</code> — see definition of <code>GraphQLEnumType</code> class around line 687 in <a href=""https://github.com/graphql/graphql-js/blob/master/src/type/definition.js#L687"" rel=""noreferrer"">https://github.com/graphql/graphql-js/blob/master/src/type/definition.js#L687</a>)</p>&#xA;",695603,,695603,2016-04-17 17:13:19,2018-12-12 15:54:25,How to use the names in a GraphQLEnumType as the defaultValue of a GraphQL query argument?,<graphql><graphql-js>,3,0,0,2016-04-16 16:19:51
36693004,2,,36676092,2,,"<p>You can't have fragments that depend on actual value of the parent, because fragments are composed before the query request is actually made to server. There are two different ways to handle this, one is to have fragment vary based on variables and other is to use interface and typed fragments inside your component.</p>&#xA;&#xA;<p>Here is a good answer showing example of using variables: <a href=""https://stackoverflow.com/questions/32577496/conditional-fragments-or-embedded-root-containers-when-using-relay-with-react-na"">Conditional fragments or embedded root-containers when using Relay with React-Native</a></p>&#xA;&#xA;<p>For the interface solution, if you have ContentNode an interfaces with implementations like 'ContentNode1' and 'ContentNode2', then you can do something like that:</p>&#xA;&#xA;<pre><code>{&#xA;  content {&#xA;    ${ContentType.getFragment('content')}&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And in your ContentType component</p>&#xA;&#xA;<pre><code>fragment on ContentNode {&#xA;   contentType&#xA;   someOtherCommonField&#xA;   ... on ContentNode1 {&#xA;     someContent1Field&#xA;   }&#xA;&#xA;   ... on ContentNode2 {&#xA;     someContent2Field&#xA;   }&#xA;}&#xA;</code></pre>&#xA;",68544,,-1,2017-05-23 12:09:00,2016-04-18 11:43:20,"",,0,5,0,2016-04-18 11:43:20
36693244,2,,36664385,2,,"<p>Optimistic update in Relay is just a simulation of what the server will return if operation succeeds. In your case you are removing one key, meaning the result would be an object without that key.</p>&#xA;&#xA;<pre><code>getOptimisticUpdate() {&#xA;  return {&#xA;    viewer: {&#xA;      id: this.props.viewer.id,&#xA;      keys: {&#xA;        edges: this.props.viewer.keys.edges.filter((keyEdge) =&gt; key.node.id !== this.props.id)&#xA;      }&#xA;    }&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You will also need to include the keys to your fragments so they are available in the mutation.</p>&#xA;&#xA;<pre><code>static fragments = {&#xA;  viewer: () =&gt; Relay.QL`&#xA;    fragment on Viewer { id, keys { edges(first: 3) { node { id } }}&#xA;  `,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>The problem with this approach is that it relies on your mutation to know what's your current keys pagination. If you are operating on the whole Connection at once, it is fine, but if you are using Relay pagination you should consider using other mutation operations.</p>&#xA;&#xA;<p>There is <code>NODE_DELETE</code>, which can delete all occurrences of your key from Relay store or you can use <code>RANGE_DELETE</code> to only delete it from your current connection.</p>&#xA;",68544,,68544,2016-05-24 10:07:33,2016-05-24 10:07:33,"",,0,6,0,2016-04-18 11:53:49
36786615,2,,36782263,2,,"<p>Once the data is in the datastore that relay uses on the backend, you can use forceFetch to refetch all fragments in your container.</p>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/docs/api-reference-relay-container.html#forcefetch"" rel=""nofollow"">https://facebook.github.io/relay/docs/api-reference-relay-container.html#forcefetch</a></p>&#xA;",5461242,,,,2016-04-22 06:37:08,"",,0,0,0,2016-04-22 06:37:08
36861285,1,36866021,,3,360,"<p>I have the following mutation:</p>&#xA;&#xA;<pre><code>export default class AddTaskMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    classroom: () =&gt; Relay.QL`&#xA;      fragment on Classroom {&#xA;        id,&#xA;      }`,&#xA;  };&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { addTask }`;&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on AddTaskPayload {&#xA;        classroom {&#xA;          taskList,&#xA;        },&#xA;        taskEdge,&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {    &#xA;    let rangeBehaviors = {};&#xA;    let member_id = 'hasNewMessages(true) member_id(' + Global.fromGlobalId(this.props.createdByMember)['id'] + ')';&#xA;    rangeBehaviors[''] = 'append';&#xA;    rangeBehaviors['hasToDo(true)'] = 'append';&#xA;    rangeBehaviors['hasToDo(false)'] = 'append';&#xA;    rangeBehaviors['isStart(true)'] = 'ignore';&#xA;    rangeBehaviors['isStart(false)'] = 'append';&#xA;    rangeBehaviors[`${member_id}`] = 'append';&#xA;    rangeBehaviors['hasNewMessages(true) member_id(null)'] = 'ignore';&#xA;    return [&#xA;      {&#xA;        type: 'RANGE_ADD',&#xA;        parentName: 'classroom',&#xA;        parentID: this.props.classroomId,&#xA;        connectionName: 'taskList',&#xA;        edgeName: 'taskEdge',&#xA;        rangeBehaviors,&#xA;      }&#xA;    ];&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      title: this.props.title,&#xA;      instruction: this.props.instruction,&#xA;      start_date: this.props.start_date,&#xA;      end_date: this.props.end_date,&#xA;      is_archived: this.props.is_archived,&#xA;      is_published: this.props.is_published,&#xA;      is_preview: this.props.is_preview,&#xA;      productId: this.props.productId,&#xA;      classroomId: this.props.classroomId,&#xA;      createdByMember: this.props.createdByMember,&#xA;      subTasks: this.props.subTasks,&#xA;      students: this.props.students,&#xA;    };&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When running my application I get the following 2 warnings:</p>&#xA;&#xA;<blockquote>&#xA;  <p>warning.js:44 Warning: RelayMutation: The connection <code>taskList{hasNewMessages:true,member_id:null}</code> on the mutation field <code>classroom</code> that corresponds to the ID <code>Classroom:35</code> did not match any of the <code>rangeBehaviors</code> specified in your RANGE_ADD config. This means that the entire connection will be refetched. Configure a range behavior for this mutation in order to fetch only the new edge and to enable optimistic mutations or use <code>refetch</code> to squelch this warning.</p>&#xA;</blockquote>&#xA;&#xA;<p>and</p>&#xA;&#xA;<blockquote>&#xA;  <p>warning.js:44 Warning: Using <code>null</code> as a rangeBehavior value is deprecated. Use <code>ignore</code> to avoid refetching a range.</p>&#xA;</blockquote>&#xA;&#xA;<p>Since the other <code>rangeBehaviors</code> work, I assume there must be a syntactical error when declaring 2 variables in one behavior - in this case <code>hasNewMessages</code> and <code>memeber_id</code>.</p>&#xA;&#xA;<p>I've looked for an answer for this, but I just cannot find any. The docs don't seem to cover this edge case either.</p>&#xA;&#xA;<p>EDIT: I also tried <code>rangeBehaviors['hasNewMessages(true),member_id(null)'] = 'ignore';</code> (comma as a separator) but with no success.</p>&#xA;",2030321,,,,2016-04-26 13:13:49,No match on any of the rangeBehaviors specified in RANGE_ADD config,<reactjs><graphql><relayjs>,1,0,0,2016-04-26 09:49:12
36866021,2,,36861285,2,,"<p>After inspecting the source code of Relay (file <code>RelayMutationQuery.js</code>) I could see what array key it was searching for in the array of all <code>rangeBehaviors</code>. I could then update my code to the correct formatting.</p>&#xA;&#xA;<p>Since I haven't found anything on the web about this edge case, I'll post my solution here - perhaps someone will find it helpful in the future.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>When having 2 (or more) variables for a <code>rangeBehavior</code>, you need to separate them with a period (<code>.</code>). Also, when passing <code>null</code> you don't pass it explicitly - just omit it from its' variable.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<h3>Right:</h3>&#xA;&#xA;<pre><code>rangeBehaviors['hasNewMessages(true).member_id()'] = 'ignore';&#xA;</code></pre>&#xA;&#xA;<h3>Wrong:</h3>&#xA;&#xA;<pre><code>rangeBehaviors['hasNewMessages(true),member_id(null)'] = 'ignore';&#xA;</code></pre>&#xA;",2030321,,,,2016-04-26 13:13:49,"",,0,0,0,2016-04-26 13:13:49
36948277,1,,,0,98,"<p>Not sure what I'm doing wrong here. My relay query seems to be composed correctly (i.e. i can verify query is successfully returning results expected) but I'm getting the error of <code>Error: repeat() argument must be greater than or equal to 0 and not be infinity</code> when the app renders in the browser.</p>&#xA;&#xA;<p>The app has been fine until I added the fragment for paginated results (<code>edge</code> + <code>node</code>):</p>&#xA;&#xA;<pre><code>const ConversationContainer = Relay.createContainer(Conversation, {&#xA;  fragments: {&#xA;    conversation: () =&gt; Relay.QL`fragment on Conversation {&#xA;      id&#xA;      fingerprint&#xA;      unreadCount&#xA;      messages(first: 3) {&#xA;        pageInfo {&#xA;          hasNextPage&#xA;        }&#xA;        edges {&#xA;          node {&#xA;            body&#xA;          },&#xA;          cursor&#xA;        },&#xA;      }&#xA;    }`&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>and the presentation component:</p>&#xA;&#xA;<pre><code>class Conversation extends Component {&#xA;  render() {&#xA;    const { id, fingerprint, unreadCount, messages } = this.props.conversation;&#xA;    return &lt;div&gt;&#xA;      &lt;div&gt;conversation &lt;code&gt;{id}&lt;/code&gt;&lt;/div&gt;&#xA;      &lt;div&gt;fingerprint: &lt;code&gt;{fingerprint}&lt;/code&gt;, unreadCount: {unreadCount}&lt;/div&gt;&#xA;      &lt;pre&gt;{JSON.stringify(messages, null, 2)}&lt;/pre&gt;&#xA;    &lt;/div&gt;;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So what's the cause of the error?</p>&#xA;&#xA;<p>Edit: the error is in the UI as rendered by my root component's <code>renderFailure</code> property (also as warning in the console)</p>&#xA;&#xA;<pre><code>const root = &lt;Relay.RootContainer&#xA;  Component={AppContainer}&#xA;  route={new AppRoute()}&#xA;  renderLoading={() =&gt; &lt;div&gt;Loading...&lt;/div&gt;}&#xA;  renderFailure={(error, retry) =&gt; &lt;div&gt;Error: {error.message}&lt;/div&gt;}&#xA;/&gt;;&#xA;</code></pre>&#xA;",18590,,18590,2016-04-29 22:21:21,2016-04-30 13:38:07,Relay.js Error: repeat() argument must be greater than or equal to 0 and not be infinity,<reactjs><graphql><relayjs>,1,1,0,2016-04-29 22:15:08
36994711,1,37000309,,1,200,"<p>GraphQL and Relay has a robust pagination algorithm which enables easy pagination for the end user, allowing pagination even in unbounded and order-independent results.</p>&#xA;&#xA;<p>However, I have a use case that I'm not really sure how to go about doing in GraphQL and relay, and it's quite easy that I'm sure I just missed something.</p>&#xA;&#xA;<p>How do I, for example, get the 5th item (and only the 5th item), if my list is ordered (by, say, an orderBy argument)?</p>&#xA;",1314444,,802047,2016-05-26 21:30:22,2016-05-26 21:30:22,Why is there no 'position' argument in Relay+GraphQL connections?,<pagination><graphql><relayjs>,2,0,0,2016-05-03 02:40:44
37000309,2,,36994711,1,,"<p>This not very well documented, but here's how to do it.</p>&#xA;&#xA;<pre><code>query {&#xA;  allPeople(first: 5, last: 1) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>First you select <code>first: 5</code> to get the first 5 people in the list. Then, do <code>last:1</code> which gets the last person from that <em>subset</em>. In other words - get the fifth person.</p>&#xA;&#xA;<p>If you do <code>(first: 5, last: 2)</code> you would get the 4th and the 5th person in the list.</p>&#xA;&#xA;<p><a href=""http://graphql-swapi.parseapp.com/?query=query%20%7B%0A%20%20allPeople(first%3A%205%2C%20last%3A%201)%20%7B%0A%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=undefined"" rel=""nofollow""><strong>Demo</strong></a> &#xA;<em>(if it returns an error - manually re-type the word <code>query</code> in the query and it will work). Then, try again without <code>first</code> and <code>last</code> to see the whole list and you'll see that Leia is 5th.</em></p>&#xA;",2030321,,2030321,2016-05-03 09:29:15,2016-05-03 09:29:15,"",,0,3,0,2016-05-03 09:23:31
37012595,1,37037189,,10,2681,"<p>I try to Implement some stuff with React, Relay and GraphQL, but I faced a Problem I dont understand and where i cant find a solution.</p>&#xA;&#xA;<p>First I created a RootQuery and had one Component and it worked well. Now I created a Sub Component with an own fragment an i get this Error: </p>&#xA;&#xA;<blockquote>&#xA;  <p>relay.js:1799 Warning: RelayContainer: Expected prop <code>room</code> to be supplied to <code>RoomList</code>, but got <code>undefined</code>. Pass an explicit <code>null</code> if this is intentional.</p>&#xA;</blockquote>&#xA;&#xA;<p>In the Networkrequest I see all the requested Data.</p>&#xA;&#xA;<p>Here is some code:</p>&#xA;&#xA;<p>Root Query</p>&#xA;&#xA;<pre><code>const RoomQuery = {&#xA;    room: (Component) =&gt; Relay.QL`&#xA;      query {&#xA;        room {&#xA;            ${Component.getFragment('room')},&#xA;        }&#xA;      }&#xA;    `&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Route</p>&#xA;&#xA;<pre><code>&lt;Route name=""rooms"" path=""/rooms"" component={Rooms} onEnter={requireAuth} queries={RoomQuery}/&gt;&#xA;</code></pre>&#xA;&#xA;<p>Relay Container</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Rooms, {&#xA;fragments: {&#xA;    room: () =&gt; Relay.QL`&#xA;    fragment on Room {&#xA;        title,&#xA;        description,&#xA;        publicKeys,&#xA;        takenKeys,&#xA;        image_filename,&#xA;        subRoomsCount,&#xA;        owner {&#xA;            fullName&#xA;        },&#xA;        ${RoomList.getFragment('room')},&#xA;    }&#xA;`,&#xA;}&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Relay Sub Container</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(RoomList, {&#xA;fragments: {&#xA;    room: () =&gt; Relay.QL`&#xA;    fragment on Room {&#xA;        subRooms{&#xA;            title,&#xA;            description,&#xA;            publicKeys,&#xA;            takenKeys,&#xA;            image_filename,&#xA;            availableKeys,&#xA;            owner {&#xA;                fullName&#xA;            },&#xA;            subRoomsCount&#xA;        }&#xA;    }&#xA;`,&#xA;}&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>In my React Component I use this Sub React Component like this:</p>&#xA;&#xA;<pre><code>&lt;RoomList&gt;&lt;/RoomList&gt;&#xA;</code></pre>&#xA;&#xA;<p>I dont know if I understand something wrong but I thougt that Relay will load the Data and fill it in this.props, but there is only a relay Object.</p>&#xA;&#xA;<p>Thanks for your help :)</p>&#xA;&#xA;<p>Greetings </p>&#xA;&#xA;<p>Ronny Gerndt</p>&#xA;",3928846,,710693,2017-08-11 00:16:19,2017-08-11 00:16:19,"RelayContainer: Expected prop `%s` to be supplied to `%s`, but ' + 'got `undefined`. Pass an explicit `null` if this is intentional",<reactjs><graphql><relayjs>,1,0,0,2016-05-03 19:17:02
37037189,2,,37012595,8,,"<p>Ok, I found a solution for the problem. I just needed to change</p>&#xA;&#xA;<pre><code>&lt;RoomList&gt;&lt;/RoomList&gt;   &#xA;</code></pre>&#xA;&#xA;<p>to</p>&#xA;&#xA;<pre><code>&lt;RoomList room={this.props.room}&gt;&lt;/RoomList&gt;&#xA;</code></pre>&#xA;&#xA;<p>and Relay gives me my right Filled subroom List.</p>&#xA;&#xA;<p>I hope someone else will find this useful ;)</p>&#xA;",3928846,,,,2016-05-04 20:13:55,"",,0,0,0,2016-05-04 20:13:55
37065908,1,37076585,,1,81,"<p>Adding a nested item is easy: the config is just a <code>RANGE_ADD</code></p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    item {&#xA;      edges {&#xA;        node {&#xA;          subitem {&#xA;            edges {&#xA;              node {&#xA;                id,&#xA;                title&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Adding a <code>subitem</code> will just require a <code>RANGE_ADD</code> with the parentId equal to the id of <code>item</code>.</p>&#xA;&#xA;<p>However, how do I add an <code>item</code> which doesn't have a parent? I tried using a <code>RANGE_ADD</code> config without a parentId but it didn't work.</p>&#xA;&#xA;<p>I feel like this is such a simple thing, but I can't seem to find it in the docs.</p>&#xA;",1314444,,,,2016-05-06 15:51:20,How do I add a Root Node,<graphql><relayjs><graphql-js>,1,0,0,2016-05-06 06:39:15
37147453,1,,,1,220,"<p>I'm pretty new to Relay so perhaps it's a very stupid error.</p>&#xA;&#xA;<p>I'm trying to make a simple mutation that add a <code>defect</code> to a <code>photo</code>.</p>&#xA;&#xA;<p>Here is my Relay.Mutation object :</p>&#xA;&#xA;<p><strong>AddDefectMutation.js</strong></p>&#xA;&#xA;<pre><code>export default class AddDefectMutation extends Relay.Mutation {&#xA;&#xA;    getMutation() {&#xA;        return Relay.QL`mutation { addDefect }`;&#xA;    }&#xA;&#xA;    getVariables() {&#xA;        return{&#xA;            photoId: this.props.photoId,&#xA;            title: this.props.title&#xA;        }&#xA;    }&#xA;&#xA;    getFatQuery() {&#xA;        return Relay.QL`&#xA;            fragment on AddDefectMutationPayload {&#xA;                updatedPhoto {&#xA;                    issues&#xA;                }&#xA;            }&#xA;        `&#xA;    }&#xA;&#xA;    getConfigs() {&#xA;        return [{&#xA;            type : 'FIELDS_CHANGE',&#xA;            fieldIDs : {&#xA;                updatedPhoto : this.props.photoId&#xA;            }&#xA;        }]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And here is the part of the GraphQl schema </p>&#xA;&#xA;<pre><code>const AddDefectMutation = mutationWithClientMutationId({&#xA;    name: 'AddDefectMutation',&#xA;    description: 'Add a new defect and return all the defects.',&#xA;    inputFields: {&#xA;        photoId: {&#xA;            description: 'Photo of this defect',&#xA;            type: new GraphQLNonNull(GraphQLString)&#xA;        },&#xA;        title: {&#xA;            description: 'A short description of the defect',&#xA;            type: GraphQLString&#xA;        }&#xA;    },&#xA;    outputFields: {&#xA;        updatedPhoto: {&#xA;            type: PhotoGraphQLType,&#xA;            resolve: ({localIdIssue}) =&gt; driver.getIssuePhoto(localIdIssue)&#xA;        }&#xA;    },&#xA;    mutateAndGetPayload: ({photoId, title}) =&gt;&#xA;        driver.addIssue(photoId, title).then(localIdIssue =&gt; ({localIdIssue}))&#xA;})&#xA;&#xA;const MutationGraphQLType = new GraphQLObjectType({&#xA;    name: 'Mutation',&#xA;    fields: () =&gt; ({&#xA;        addDefect: AddDefectMutation&#xA;    })&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>My problem is that when I make this call :</p>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(new AddDefectMutation(&#xA;        {photoId: this.props.pictureId, title: this.props.title}), {&#xA;        onSuccess: ()=&gt; console.log(""Mutation Success !""),&#xA;        onFailure: transaction =&gt; console.error(transaction.getError() || new Error('Mutation failed.'))&#xA;    })&#xA;</code></pre>&#xA;&#xA;<p>Relay generate the good mutation query without problem but it doesn't place the variables given in the constructor.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>EDIT : Here the fragment of mutation generated by relay</p>&#xA;&#xA;<pre><code>mutation AddDefect($input_0:AddDefectMutationInput!) {&#xA;    addDefect(input:$input_0) {&#xA;        ...F4,&#xA;        clientMutationId&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the problem is that <code>$input_0</code> is an empty object</p>&#xA;",3548191,,3548191,2016-05-10 21:06:28,2016-05-10 21:06:28,No Variables in Relay generated mutation query,<reactjs><graphql><relayjs><relay>,1,0,0,2016-05-10 19:35:36
37167278,1,,,2,275,"<p>I have a Relay Mutation that delete a node in a connection :</p>&#xA;&#xA;<pre><code>export default class DeleteDefectMutation extends Relay.Mutation {&#xA;&#xA;    getMutation() {&#xA;        return Relay.QL`mutation { deleteDefect }`;&#xA;    }&#xA;&#xA;    getVariables() {&#xA;        return {&#xA;            photoId: this.props.photoId,&#xA;            defectId : this.props.defectId&#xA;        }&#xA;    }&#xA;&#xA;    getFatQuery() {&#xA;        return Relay.QL`&#xA;            fragment on DeleteDefectMutationPayload {&#xA;                updatedPhoto { issues }&#xA;                deletedDefectId&#xA;            }&#xA;        `&#xA;    }&#xA;&#xA;    getConfigs() {&#xA;        return [{&#xA;            type : ""NODE_DELETE"",&#xA;            parentName: 'updatedPhoto',&#xA;            parentID: this.props.photoId,&#xA;            connectionName: 'issues',&#xA;            deletedIDFieldName: 'deletedDefectId'&#xA;        }]&#xA;    }&#xA;&#xA;    getOptimisticResponse() {&#xA;        return {&#xA;            deletedDefectId : this.props.defectId,&#xA;            updatedPhoto : {&#xA;                id : this.props.photoId&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And when I use it with :</p>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(new DeleteDefectMutation({photoId, defectId},{&#xA;    onSuccess : () =&gt; console.log('Mutation Success !'),&#xA;    onFailure : transaction =&gt; console.error(transaction.error ? transaction.error : new Error(""Mutation Failed""))&#xA;}))&#xA;</code></pre>&#xA;&#xA;<p>I get an error that I don't understand :</p>&#xA;&#xA;<pre><code>Uncaught Invariant Violation: writeRelayUpdatePayload(): Expected a record ID in the response payload supplied to update the store&#xA;</code></pre>&#xA;",3548191,,,,2016-05-11 15:36:29,Relay mutation error : Expected a record ID in the response payload,<reactjs><graphql><relayjs><relay>,0,3,0,2016-05-11 15:36:29
37193982,1,,,6,506,"<p>I'm trying to implement a mutation for login. The mutation validates the provided id_token and logs the user in via sessions. The mutation itself works (verified with GraphiQL), but I'm having issues integrating it with Relay.</p>&#xA;&#xA;<p>When a user logs in, the entire Relay store is possibly altered since ""viewer"" is the root query. But I don't want to list out my entire query tree in the fat query. It would be nice to be able to clear the entire store somehow, but I don't see a way of doing that with <code>react-router-relay</code>.</p>&#xA;&#xA;<p>Relay mutation:</p>&#xA;&#xA;<pre><code>export default class LoginMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {login}`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      id_token: this.props.id_token&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    // TODO: list everything?&#xA;    return Relay.QL`&#xA;      fragment on LoginPayload {&#xA;        viewer&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return []; // TODO: not sure what to return...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Usage:</p>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(new LoginMutation({id_token}), {&#xA;        onSuccess: (resp) =&gt; {&#xA;          history.push('/');&#xA;        }&#xA;      });&#xA;</code></pre>&#xA;&#xA;<p>GraphQL schema:</p>&#xA;&#xA;<pre><code>input LoginInput {&#xA;  id_token: String!&#xA;  clientMutationId: String!&#xA;}&#xA;&#xA;type LoginPayload {&#xA;  viewer: Viewer&#xA;  clientMutationId: String!&#xA;}&#xA;&#xA;type Mutation {&#xA;  login(input: LoginInput!): LoginPayload&#xA;}&#xA;&#xA;interface Node {&#xA;  id: ID!&#xA;}&#xA;&#xA;type Query {&#xA;  viewer: Viewer&#xA;  node(id: ID!): Node&#xA;}&#xA;&#xA;type Viewer implements Node {&#xA;  id: ID!&#xA;  user: User&#xA;  ships: [Ship]&#xA;  ship(id: ID!): Ship&#xA;}&#xA;&#xA;schema {&#xA;  query: Query&#xA;  mutation: Mutation&#xA;}&#xA;</code></pre>&#xA;",1522508,,2030321,2016-05-20 10:05:45,2017-01-27 15:44:38,Relay/router login mutation?,<react-router><graphql><relayjs><react-router-relay>,1,1,0,2016-05-12 17:42:07
37227933,1,37231660,,0,160,"<p>Using a <code>NODE_DELETE</code> requires the parent, and to actually return the parent of the connection:</p>&#xA;&#xA;<p><a href=""https://stackoverflow.com/questions/35165693/relay-error-when-deleting-relaymutationquery-invalid-field-name-on-fat-query"">Relay Error when deleting: RelayMutationQuery: Invalid field name on fat query</a></p>&#xA;&#xA;<p>Unfortunately, using this refetches <strong>ALL</strong> my nested items, which is simply unacceptable for my use case.</p>&#xA;&#xA;<pre><code>  fragment on deleteItemNested @relay(pattern: true) {&#xA;    id&#xA;    ok&#xA;    item {&#xA;      nested {&#xA;        edges {&#xA;          node { id }&#xA;        }&#xA;      }&#xA;    }&#xA;    clientMutationId&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Is there a way to delete an item from a connection/list without refetching all data? Trying not to fetch for the edges in nested results in nested being just an empty object.</p>&#xA;",1314444,,-1,2017-05-23 12:31:39,2016-05-14 21:34:21,Using NODE_DELETE without refetching data,<graphql><relayjs><relay><graphql-js>,1,0,0,2016-05-14 14:36:47
37231660,2,,37227933,1,,"<p>All the nested items are refetched because <code>@relay(pattern: true)</code> was used in the query. This makes the query to match against the tracked query, which already includes the nested fields. See an excellent answer by <a href=""https://stackoverflow.com/users/802047/steveluscher"">steveluscher</a> to the question <a href=""https://stackoverflow.com/questions/34103296/purpose-of-relaypatterntrue"">Purpose of @relay(pattern:true)</a>.</p>&#xA;&#xA;<p>The code example of <code>NODE_DELETE</code> in <a href=""https://facebook.github.io/relay/docs/guides-mutations.html"" rel=""nofollow noreferrer"">mutation documentation</a> is worth taking a look.</p>&#xA;",2821632,,-1,2017-05-23 12:31:39,2016-05-14 20:44:44,"",,0,0,0,2016-05-14 20:44:44
37246035,1,37247461,,2,259,"<p>What is the best way to 'reorder' a connection in RelayJS?</p>&#xA;&#xA;<p>In my user interface, I allow my user to 'swap' two items, but creating a mutation around that is a bit tricky.</p>&#xA;&#xA;<p>What I'm doing right now is the naive way, namely using <code>FIELDS_CHANGE</code> to change my node itself.</p>&#xA;&#xA;<p>It works, but the problem is I can't seem to write an optimistic update for it. I am able to just pass a list of ids to my graphql server, but that doesn't work for the optimistic update because it expects the actual data.</p>&#xA;&#xA;<p>So I guess I have to mock out my 'connection' interface, but unfortunately, it still doesn't work. I 'copied' my reordered nodes to getOptimisticResponse but it seems to be ignored. The data matches the actual server response. (ids simplified)</p>&#xA;&#xA;<p>original:</p>&#xA;&#xA;<pre><code>{&#xA;  item: {&#xA;    edges: {&#xA;      {cursor: 1, node: {id:2}}&#xA;      {cursor: 2, node: {id:1}}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(doesn't do anything):&#xA;optimistic reponse:</p>&#xA;&#xA;<pre><code>{&#xA;  item: {&#xA;    edges: {&#xA;      node: {id:1}&#xA;      node: {id:2}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>server reponse:</p>&#xA;&#xA;<pre><code>{&#xA;  item: {&#xA;    edges: {&#xA;      {cursor: 1, node: {id:1}}&#xA;      {cursor: 2, node: {id:2}}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What gives? It's equivalent (except for the cursor), and even if I add the cursor in, it still doesn't work.</p>&#xA;&#xA;<p>What am I doing wrong? Also is there an easier way to do mock my ids to a connection?</p>&#xA;&#xA;<p>Also, as an aside, is there a way to get this data piecemeal? Right now, reordering two item re-requests the whole list because of my mutation config. I suppose I can do it with <code>RANGE_ADD</code>, and <code>RANGE_DELETE</code> to 'simulate a swap` but is there any easier way to do it?</p>&#xA;",1314444,,710693,2017-08-11 00:39:56,2017-08-11 00:39:56,Creating an optimistic response for a reordered connection,<graphql><relayjs><graphql-js>,1,0,0,2016-05-16 02:50:52
37247461,2,,37246035,1,,"<p>Since you trigger a mutation in response to the user reordering the items, I assume, you store the position or order of the items on the server side. For what you're doing, one way of creating optimistic response can be using that <code>position</code> or <code>order</code> information. On the server side, an item needs to provide an additional field <code>position</code>. On the client side, the items displayed are sorted by <code>position</code>.</p>&#xA;&#xA;<p>When the user swaps two items, in the optimistic response of your client-side mutation, you just need to swap the <code>position</code> fields of those two items. The same applies on the server-side mutation.</p>&#xA;&#xA;<p>The optimistic response code can be like:</p>&#xA;&#xA;<pre><code>getOptimisticResponse() {&#xA;  return {&#xA;    item1: {&#xA;      id: this.props.item1.id,&#xA;      position: this.props.item2.position,&#xA;    },&#xA;    item2: {&#xA;      id: this.props.item2.id,&#xA;      position: this.props.item1.position,&#xA;    },&#xA;  };&#xA;}&#xA;</code></pre>&#xA;",2821632,,,,2016-05-16 05:50:32,"",,0,0,0,2016-05-16 05:50:32
37342541,1,37361171,,6,908,"<p>I have a page that uses GraphQL Relay connection which fetches <code>drafts</code>.</p>&#xA;&#xA;<pre class=""lang-json prettyprint-override""><code>query {&#xA;    connections {&#xA;        drafts(first: 10) {&#xA;            edges {&#xA;                node {&#xA;                    ... on Draft {&#xA;                        id&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In this page, I also create draft through <code>CreateDraftMutation</code>.</p>&#xA;&#xA;<pre class=""lang-json prettyprint-override""><code>mutation {&#xA;    createDraft(input: {&#xA;        clientMutationId: ""1""&#xA;        content: ""content""&#xA;    }) {&#xA;        draft {&#xA;            id&#xA;            content&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>After this mutation, I want Relay to add the created draft into its store. The best candidate for mutation config is RANGE_ADD, which is documented as following:</p>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/docs/guides-mutations.html"" rel=""noreferrer"">https://facebook.github.io/relay/docs/guides-mutations.html</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>RANGE_ADD &#xA;  Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</p>&#xA;  &#xA;  <p>Arguments </p>&#xA;  &#xA;  <p>parentName: string&#xA;  The field name in the response that represents the parent of the connection</p>&#xA;  &#xA;  <p>parentID: string&#xA;  The DataID of the parent node that contains the connection</p>&#xA;  &#xA;  <p>connectionName: string&#xA;  The field name in the response that represents the connection</p>&#xA;  &#xA;  <p>edgeName: string&#xA;  The field name in the response that represents the newly created edge</p>&#xA;  &#xA;  <p>rangeBehaviors: {[call: string]: GraphQLMutatorConstants.RANGE_OPERATIONS}</p>&#xA;  &#xA;  <p>A map between printed, dot-separated GraphQL calls in alphabetical order, and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls. Behaviors can be one of 'append', 'ignore', 'prepend', 'refetch', or 'remove'.</p>&#xA;</blockquote>&#xA;&#xA;<p>The example from the documentation goes as the following:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class IntroduceShipMutation extends Relay.Mutation {&#xA;  // This mutation declares a dependency on the faction&#xA;  // into which this ship is to be introduced.&#xA;  static fragments = {&#xA;    faction: () =&gt; Relay.QL`fragment on Faction { id }`,&#xA;  };&#xA;  // Introducing a ship will add it to a faction's fleet, so we&#xA;  // specify the faction's ships connection as part of the fat query.&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on IntroduceShipPayload {&#xA;        faction { ships },&#xA;        newShipEdge,&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'faction',&#xA;      parentID: this.props.faction.id,&#xA;      connectionName: 'ships',&#xA;      edgeName: 'newShipEdge',&#xA;      rangeBehaviors: {&#xA;        // When the ships connection is not under the influence&#xA;        // of any call, append the ship to the end of the connection&#xA;        '': 'append',&#xA;        // Prepend the ship, wherever the connection is sorted by age&#xA;        'orderby(newest)': 'prepend',&#xA;      },&#xA;    }];&#xA;  }&#xA;  /* ... */&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If the parent is as obvious as faction, this is a piece of cake, but I've been having hard time identifying parentName and parentID if it came directly from query connections.</p>&#xA;&#xA;<p>How do I do this?</p>&#xA;&#xA;<p>Edit:</p>&#xA;&#xA;<p>This is how query was exported.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default new GraphQLObjectType({&#xA;  name: 'Query',&#xA;  fields: () =&gt; ({&#xA;    node: nodeField,&#xA;    viewer: {&#xA;      type: viewerType,&#xA;      resolve: () =&gt; ({}),&#xA;    },&#xA;    connections: {&#xA;      type: new GraphQLObjectType({&#xA;        name: 'Connections',&#xA;</code></pre>&#xA;&#xA;<p>which in return is used in the relay container</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(MakeRequestPage, {&#xA;    fragments: {&#xA;        connections: () =&gt; Relay.QL`&#xA;          fragment on Connections {&#xA;</code></pre>&#xA;",1796315,,710693,2017-08-11 00:22:55,2017-08-11 00:22:55,GraphQL Relay Mutation Config RANGE_ADD's parentName for connections,<graphql><relayjs><graphql-js>,1,2,0,2016-05-20 09:07:14
37361171,2,,37342541,1,,"<blockquote>&#xA;  <p>I've been having hard time identifying parentName and parentID <em>if it&#xA;  came directly from query connections.</em></p>&#xA;</blockquote>&#xA;&#xA;<p><code>faction</code> and <code>ships</code> in the example from Relay documentation are exactly the same as <code>connections</code> and <code>drafts</code> in your case. Each <code>GraphQLObject</code> has an ID,so does your <code>connections</code> object. Therefore, for your mutation,  <code>parentName</code> is <code>connctions</code> and <code>parentID</code> is the ID of <code>connections</code>.</p>&#xA;&#xA;<pre><code>query {&#xA;    connections {&#xA;        id&#xA;        drafts(first: 10) {&#xA;            edges {&#xA;                node {&#xA;                    ... on Draft {&#xA;                        id&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>By the way, I guess<code>connections</code> and <code>drafts</code> are terms from your application domain. Otherwise, <code>connections</code> confuses with GraphQL connection type.</p>&#xA;",2821632,,,,2016-05-21 09:32:23,"",,0,3,0,2016-05-21 09:32:23
37372630,1,37378838,,0,158,"<p>I am learning React + Graphql + Relay ... and i am fighting for a few hours with this situation:&#xA;- my component looks like this</p>&#xA;&#xA;<pre><code>class Main extends React.Component {&#xA;  setLimit = (e) =&gt; {&#xA;    let newLimit = Number(e.target.value);&#xA;    this.props.relay.setVariables({ limit: newLimit });&#xA;  };&#xA;  render() {&#xA;    let content = this.props.store.linkConnection.edges.map(edge =&gt; {&#xA;      return &lt;Link key={edge.node.id} link={edge.node} /&gt; ;&#xA;    });&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;h3&gt;Links&lt;/h3&gt;&#xA;        &lt;select onChange={this.setLimit}&gt;&#xA;          &lt;option value=""2"" selected&gt;2&lt;/option&gt;&#xA;          &lt;option value=""4""&gt;4&lt;/option&gt;&#xA;          &lt;option value=""6""&gt;6&lt;/option&gt;&#xA;        &lt;/select&gt;&#xA;        &lt;ul&gt;&#xA;          {content}&#xA;        &lt;/ul&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  };&#xA;}&#xA;&#xA;Main = Relay.createContainer(Main, {&#xA;  initialVariables: {&#xA;    limit: 2&#xA;  },&#xA;  fragments: {&#xA;    store: () =&gt; Relay.QL`&#xA;      fragment on Store {&#xA;        linkConnection(first: $limit) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              ${Link.getFragment('link')}&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>as u can see, there is a select in there that is correctly triggering the setLimit handler ... inside setLimit i have this.props.relay.setVariables ... although i do not get any error the query is not being re-rendered</p>&#xA;&#xA;<p>i am surely doing a noob mistake ... just do not know what that is :) ... cause i am noob :))</p>&#xA;&#xA;<p>thanks</p>&#xA;",2030809,,,,2016-05-22 19:40:30,relay setVariables not trigger the query,<reactjs><graphql><relay>,1,1,0,2016-05-22 09:33:31
37500175,2,,35194917,1,,"<p>Just use Relay helper function from <code>graphql-relay</code> package</p>&#xA;&#xA;<pre><code>mutationWithClientMutationId&#xA;</code></pre>&#xA;&#xA;<p>It will provide a Relay compatible mutation</p>&#xA;&#xA;<p><a href=""https://github.com/graphql/graphql-relay-js#mutations"" rel=""nofollow"">https://github.com/graphql/graphql-relay-js#mutations</a></p>&#xA;",3042366,,,,2016-05-28 14:27:44,"",,0,0,0,2016-05-28 14:27:44
37551108,1,,,-1,87,"<p>Has anyone seen this error before? I am working on my first NodeJS / React / GraphQL project. This is driving me a bit crazy. I have searched Google but no one else seems to have ever had this problem before. </p>&#xA;&#xA;<pre><code>  error: Server error: local network layer GraphQL failure errors=[], _settled=true, _resolve=function (value) {&#xA;  [1]     if (done) return;&#xA;  [1]     done = true;&#xA;  [1]     resolve(promise, value);&#xA;  [1]   }, _reject=function (reason) {&#xA;  [1]     if (done) return;&#xA;  [1]     done = true;&#xA;  [1]     reject(promise, reason);&#xA;  [1]   }, _45=2, _81=2, , _54=null, text=query Routes {&#xA;  [1]   Viewer {&#xA;  [1]     id,&#xA;  [1]     ...F3&#xA;  [1]   }&#xA;  [1] }&#xA;  [1] fragment F0 on Viewer {&#xA;  [1]   User_IsAnonymous,&#xA;  [1]   User_DisplayName,&#xA;  [1]   User_ProfilePhoto,&#xA;  [1]   id&#xA;  [1] }&#xA;  [1] fragment F1 on Viewer {&#xA;  [1]   User_IsAnonymous,&#xA;  [1]   id&#xA;  [1] }&#xA;  [1] fragment F2 on Viewer {&#xA;  [1]   id,&#xA;  [1]   ...F1&#xA;  [1] }&#xA;  [1] fragment F3 on Viewer {&#xA;  [1]   User_IsAnonymous,&#xA;  [1]   User_AuthToken,&#xA;  [1]   id,&#xA;  [1]   ...F0,&#xA;  [1]   ...F2,&#xA;  [1]   ...F1&#xA;  [1] }, , children=[fieldName=id, kind=Field, isGenerated=true, isRequisite=true, type=ID, , children=[fieldName=User_IsAnonymous, kind=Field, , type=Boolean, fieldName=User_AuthToken, kind=Field, , type=String, fieldName=id, kind=Field, isGenerated=true, isRequisite=true, type=ID, , children=[fieldName=User_IsAnonymous, kind=Field, , type=Boolean, fieldName=User_DisplayName, kind=Field, , type=String, fieldName=User_ProfilePhoto, kind=Field, , type=String, fieldName=id, kind=Field, isGenerated=true, isRequisite=true, type=ID], id=1::client, kind=Fragment, , name=AppBar_Auth_ViewerRelayQL, type=Viewer, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""], name=$$_aggregated-$$_route[1]_@@default_Viewer-$$_route[2]_@@default_Viewer, , __calls__=null, __children__=[$ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""children""][0], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__variables__""], __calls__=[], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""children""][1], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__variables__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__children__""][0][""__calls__""], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""children""][2], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__variables__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__children__""][0][""__calls__""], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""children""][3], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__variables__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__children__""][0][""__calls__""], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __compositeHash__=_1::client1hz3YB, isDeferred=false, isContainerFragment=true, __cacheKey__=$$_aggregated-$$_route[1]_@@default_Viewer-$$_route[2]_@@default_Viewer:{}:{isContainerFragment:true,isDeferred:false}, _fragmentGetter=function () {&#xA;  [1]       return buildContainerFragment(containerName, fragmentName, fragmentBuilder, initialVariables);&#xA;  [1]     }, _isContainerFragment=true, _isDeferred=false, _variableMapping=undefined, _prepareVariables=undefined, , children=[fieldName=id, kind=Field, isGenerated=true, isRequisite=true, type=ID, , children=[fieldName=User_IsAnonymous, kind=Field, , type=Boolean, fieldName=id, kind=Field, isGenerated=true, isRequisite=true, type=ID], id=4::client, kind=Fragment, , name=NavMenu_ViewerRelayQL, type=Viewer, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][4][""_fragment""][""children""][1][""_fragment""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], , __calls__=null, __children__=[$ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][4][""_fragment""][""children""][1][""_fragment""][""children""][0], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][4][""_fragment""][""children""][1][""_fragment""][""__cachedFragment__""][""__variables__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__children__""][0][""__calls__""], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined, $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][4][""_fragment""][""children""][1][""_fragment""][""children""][1], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__route__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][4][""_fragment""][""children""][1][""_fragment""][""__cachedFragment__""][""__variables__""], $ref=$[""request""][""_query""][""__concreteNode__""][""children""][1][""_fragment""][""children""][3][""_fragment""][""__cachedFragment__""][""__children__""][0][""__calls__""], __children__=[], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __debugName__=undefined, __isRefQueryDependency__=false, __rangeBehaviorKey__=undefined, __shallowHash__=undefined], __fieldMap__=null, __hasDeferredDescendant__=false, __hasValidatedConnectionCalls__=null, __serializationKey__=null, __storageKey__=null, __compositeHash__=_4::client3dbVxF, isDeferred=false, isContainerFragment=true, __cacheKey__=$$_aggregated-$$_route[1]_@@default_Viewer-$$_route[2]_@@default_Viewer:{}:{isContainerFragment:true,isDeferred:false}, _fragmentGetter=function () {&#xA;  [1]       return buildContainerFragment(containerName, fragmentName, fragmentBuilder, initialVariables);&#xA;  [1]     }, _isContainerFragment=true, _isDeferred=false, _variableMapping=undefined, _&#xA;  [1] /Users/lorm/projects/React-Relay-Boilerplate/node_modules/promise/lib/done.js:10&#xA;  [1]       throw err;&#xA;  [1]       ^&#xA;  [1] &#xA;  [1] Error: Can't set headers after they are sent.&#xA;  [1]     at ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:346:11)&#xA;  [1]     at ServerResponse.header (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/express/lib/response.js:718:10)&#xA;  [1]     at ServerResponse.send (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/express/lib/response.js:163:12)&#xA;  [1]     at serveFailure (renderOnServer.js:28:21)&#xA;  [1]     at NetworkLayer.onError [as _onError] (renderOnServer.js:58:41)&#xA;  [1]     at NetworkLayer._executeRequest$ (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/relay-local-schema/lib/NetworkLayer.js:71:18)&#xA;  [1]     at tryCatch (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/relay-local-schema/node_modules/babel-runtime/regenerator/runtime.js:72:40)&#xA;  [1]     at GeneratorFunctionPrototype.invoke [as _invoke] (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/relay-local-schema/node_modules/babel-runtime/regenerator/runtime.js:334:22)&#xA;  [1]     at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/relay-local-schema/node_modules/babel-runtime/regenerator/runtime.js:105:21)&#xA;  [1]     at tryCatch (/Users/lorm/projects/React-Relay-Boilerplate/node_modules/relay-local-schema/node_modules/babel-runtime/regenerator/runtime.js:72:40)&#xA;</code></pre>&#xA;",5920891,,,,2016-05-31 20:11:02,Server error: local network layer GraphQL failure errors,<node.js><graphql>,1,3,0,2016-05-31 16:31:15
37607450,2,,37594134,1,,"<p>TL;DR;</p>&#xA;&#xA;<p>Your root query does not have a <code>node</code> field. That's why fetching more items fail. Add the <code>node</code> field like this:</p>&#xA;&#xA;<pre><code>const RootQuery = new GraphQLObjectType({&#xA;  ...&#xA;  fields: () =&gt; ({&#xA;    viewer: {&#xA;      ...&#xA;    },&#xA;    node: nodeField,&#xA;  })&#xA;});&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<blockquote>&#xA;  <p>when I check the Request Payload I notice that it is querying ""node"" instead of ""viewer"" like it did previously.</p>&#xA;</blockquote>&#xA;&#xA;<p>The first time Relay fetches an object, it uses the regular query.</p>&#xA;&#xA;<pre><code>viewer {&#xA;    id,&#xA;    ...F0&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now Relay knows the global ID of <code>viewer</code>. Later when more data of <code>viewer</code> need to be fetched, Relay uses <code>node</code> root field to query that object directly.</p>&#xA;&#xA;<pre><code>node(id:$id_0) {&#xA;    ...F0&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>See an <a href=""https://stackoverflow.com/a/33411416/2821632"">excellent answer</a> by steveluscher to how node definitions work in Relay.</p>&#xA;",2821632,,-1,2017-05-23 12:02:38,2016-06-03 06:33:53,"",,0,0,0,2016-06-03 06:33:53
37635328,1,37636116,,29,11117,"<p>What is the purpose of root query field <code>viewer</code> in GraphQL?</p>&#xA;&#xA;<p>Based on <a href=""https://medium.com/the-graphqlhub/graphql-and-authentication-b73aed34bbeb#.cpmrcqcyt"">this article</a>, <code>viewer</code> could be used to accept a token parameter so we can see who is currently logged in.</p>&#xA;&#xA;<p>How should I implement it?</p>&#xA;",2628278,,710693,2017-08-11 00:12:27,2021-10-12 12:37:38,What is the meaning of viewer field in GraphQL?,<graphql><relayjs>,2,3,0,2016-06-04 21:46:50
37817883,2,,37805245,1,,"<p>If you want to get the <code>outputFields</code> directly, instead of using them to update the client store, you can define <code>onSuccess</code> function and access them through <code>response</code> object.</p>&#xA;&#xA;<pre><code>const onSuccess = response =&gt; {&#xA;    if (response.createToken.error) {&#xA;        console.log('Could not create token. Got error: ' + error);&#xA;    } else {&#xA;        // store response.createToken.token for future use.&#xA;    }&#xA;};&#xA;this.props.relay.commitUpdate(&#xA;    new CreateTokenMutation({username, password}),&#xA;    {onSuccess}&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>On your client-side mutation implementation i.e. <code>CreateTokenMutation</code>, you have to specify that the <code>outputFields</code> are not meant to update the client store. So, you'll use <code>REQUIRED_CHILDREN</code> mutator configuration.</p>&#xA;&#xA;<pre><code>class CreateTokenMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {createToken}`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;        username: this.props.username,&#xA;        password: this.props.password,&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateTokenPayload @relay(pattern: true) {&#xA;        token,&#xA;        error,&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: REQUIRED_CHILDREN,&#xA;      children: [&#xA;        Relay.QL`&#xA;          fragment on CreateTokenPayload {&#xA;            token,&#xA;            error,&#xA;          }&#xA;        `,&#xA;      ],&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>To know more about it, check <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#required-children"" rel=""nofollow"">Relay documentation on mutation</a>.</p>&#xA;",2821632,,,,2016-06-14 16:49:43,"",,0,0,0,2016-06-14 16:49:43
37924948,2,,37914632,0,,"<p>You can try creating a Sortable type with the custom sorting fields that you want as the input fields, and have your Poll type be a list that implements the Sortable interface.</p>&#xA;",6452097,,,,2016-06-20 14:22:10,"",,0,0,0,2016-06-20 14:22:10
37969096,1,37981905,,15,25099,"<p>im trying to perform a query like this:</p>&#xA;&#xA;<pre><code>{&#xA; people{&#xA;   pet{&#xA;     name&#xA;   }&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>result:</p>&#xA;&#xA;<pre><code>{&#xA; ""people"": {&#xA;   ""pet"": null&#xA; }&#xA;},&#xA;{&#xA; ""people"": {&#xA;   ""pet"": {&#xA;     name: ""steve""&#xA;  }&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What i want is to get only people that contains a pet, is there any way to achieve this not coding on my resolver ?</p>&#xA;",3400454,,,,2021-10-05 11:57:53,Graphql query only not null objects,<express><meteor><graphql><graphql-js>,2,2,0,2016-06-22 13:11:15
38003487,2,,37985413,0,,"<p>I would try to debug you _loadMore function a bit more to see if you're setting those variables properly.</p>&#xA;&#xA;<pre><code>_loadMore(){&#xA;  console.log(this.props.viewer.people);&#xA;  this.props.relay.setVariables({&#xA;    first: this.props.relay.variables.first,&#xA;    after: this.props.viewer.people.pageInfo.endCursor&#xA;  });&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The only difference between in-lining the whole query versus using fragments is that you're passing in those query variables dynamically. So it seems like your <code>initialVariables</code> sets <code>after</code> to null, which may be causing the query to break on the GraphQL server side.</p>&#xA;",6452097,,,,2016-06-23 23:32:30,"",,0,0,0,2016-06-23 23:32:30
38022973,2,,38021899,7,,"<p>That's a great question. The operation name is pretty much up to you on what you want to call it. However, you do need it when you pass in query / mutation parameters like so:</p>&#xA;&#xA;<pre><code>// GraphQL Query&#xA;&#xA;query Welcome ($data: String!) {&#xA;  echo (email: $data) {&#xA;    name&#xA;  }&#xA;}&#xA;&#xA;// GraphQL Variables&#xA;&#xA;{&#xA;  ""data"": ""hi@example.com""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>As for the return fields, you must write out the subfields of a given typed selection since GraphQL's philosophy is that everything is strongly-typed and the client dictates <em>exactly</em> what data it needs down to the subfield.</p>&#xA;&#xA;<p>Hope this helps!</p>&#xA;",6452097,,,,2016-06-24 22:29:09,"",,0,0,0,2016-06-24 22:29:09
38039434,2,,38036128,0,,"<p>It seems you have to query everything through either <code>node</code> or <code>viewer</code>, because those are the only fields on the root query type. So maybe try this:</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    game&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6268377,,,,2016-06-26 14:21:47,"",,0,0,0,2016-06-26 14:21:47
38046010,1,,,2,364,"<p>I want to request to GraphQL Server from Relay only Queries without Fragments. &#xA;For example with simple relay app at the link: <a href=""https://facebook.github.io/relay/prototyping/playground.html#/"" rel=""nofollow"">https://facebook.github.io/relay/prototyping/playground.html#/</a>, this always post to GraphQL server a query inculde Fragments like that:</p>&#xA;&#xA;<pre><code>query GreetingsQuery {&#xA;    greetingsSchema {&#xA;        ...F0&#xA;    }&#xA;} &#xA;fragment F0 on GreetingsQL {&#xA;    hello&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I just want to post a single query without any fragment inside, something like that:</p>&#xA;&#xA;<pre><code>query UserQuery {&#xA;    users() {&#xA;        id&#xA;        name&#xA;    },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any solutions for that?</p>&#xA;",1294843,,3156647,2016-06-27 05:59:10,2016-06-27 07:05:07,Request to GraphQL with only Queries without Fragments,<reactjs><graphql><relay>,1,0,0,2016-06-27 04:36:19
38047766,2,,38046010,0,,<p>You can inline the entire query in your Relay user queries. No need for fragments. Also make sure you don't have an empty parentheses if you don't have query params.</p>&#xA;,6452097,,,,2016-06-27 07:05:07,"",,0,2,0,2016-06-27 07:05:07
38063417,1,38254380,,1,831,"<p>If a container has multiple fragments, how can I <code>forceFetch</code> only one of them ?</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>Relay.createContainer(MyContainerComponent, {&#xA;    fragments: {&#xA;        fragment1: () =&gt; Relay.QL`my first fragment`,&#xA;        fragment2: () =&gt; Relay.QL`my second fragment`&#xA;    } &#xA;});&#xA;</code></pre>&#xA;&#xA;<p>According to the docs, calling <code>this.props.relay.forceFetch()</code> will update every fragments associated to the container.</p>&#xA;&#xA;<p>While force fetching 'as is' does the job, the whole point of Relay is to avoid over/under fetching.</p>&#xA;&#xA;<p>Any advice ?</p>&#xA;",3830786,,3830786,2016-06-27 21:25:37,2016-07-07 20:07:26,forceFetch a specific fragment from a Relay container,<reactjs><graphql><relayjs><relay>,1,0,0,2016-06-27 21:18:01
38065226,2,,34882707,1,,"<p>This was a bug. Given a plural field, when the time came to make a query for new data, we would diff what we have in the store with what the application wants. The bug was that we would assume that <em>all</em> records of a plural field have the same shape in the store, and only use the first store record in any plural field against which to diff. This was of course not true in your case, where some records in a plural field might be expanded and some might be collapsed.</p>&#xA;&#xA;<p>This has been fixed as part of <a href=""https://github.com/facebook/relay/issues/1243"" rel=""nofollow"">https://github.com/facebook/relay/issues/1243</a> and will be released in the version after Relay 0.9.1.</p>&#xA;",802047,,,,2016-06-28 00:26:47,"",,0,0,0,2016-06-28 00:26:47
38085549,2,,36437712,1,,"<p>You can find detailed information on the relay pagination algorithm here: <a href=""https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm"" rel=""nofollow"">https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm</a>.</p>&#xA;&#xA;<p>To answer your specific question about hasNextPage, this is the algorithm:</p>&#xA;&#xA;<pre><code>function hasNextPage(allEdges, before, after, first, last) {&#xA;&#xA;    // If first was not set, return false.&#xA;    if (first === null) { return false; }&#xA;&#xA;    // Apply the before &amp; after cursor arguments to the set of edges.&#xA;    // i.e. edges is the set of edges between the before and after cursors&#xA;    const edges = ApplyCursorsToEdges(allEdges, before, after)&#xA;&#xA;    // If more edges exist between the before &amp; after cursors than&#xA;    // you are asking for then there is a next page.&#xA;    if (edges.length &gt; first) { return true; }&#xA;    return false&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>A quick note on cursor vs page based pagination. It is generally a bad idea to paginate using fixed page sizes. A classic example of this is using the OFFSET keyword in SQL to grab the next page. There are many issues with this approach. For example, what would happen if a new object was inserted while you were in the middle of paginating the set? If the new object was inserted before the page you are currently grabbing and you use a fixed offset you are going to grab an object that you have already grabbed which leads to duplicate data in your presentation layer. Using cursors for pagination fixes this problem by allowing you to keep track of the objects themselves instead of counts of the objects.</p>&#xA;&#xA;<p>Once last thing with relay pagination specifically. I recommend only using (first &amp; after) OR (last &amp; before) at any given time. Using both in the same query can lead to logical, yet unexpected results.</p>&#xA;&#xA;<p>Best of luck!</p>&#xA;",6506620,,,,2016-06-28 20:17:54,"",,0,0,0,2016-06-28 20:17:54
38254380,2,,38063417,0,,"<p>Refetches are managed by the container, so one solution would be:</p>&#xA;&#xA;<pre><code>Relay.createContainer(MyContainerComponent, {&#xA;    fragments: {&#xA;        fragment1: () =&gt; Relay.QL`fragment on SomeThing { ${SomeThingContainer.getFragment(""something"")}`,&#xA;        fragment2: () =&gt; Relay.QL`fragment on OtherThing { ${OtherThingContainer.getFragment(""otherthing"")}`&#xA;    } &#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Then just use the two sub containers to refetch their individual fragments. </p>&#xA;&#xA;<p>If you actually need data from both fragments in <code>MyContainerComponent</code> so you can't separate those into sub-containers, refetching the full container fragment makes sense for me...</p>&#xA;&#xA;<p>However, if you <em>really</em> need data from both fragments and you <em>really</em> only want to refetch one of them, you can always use the imperative Store API to execute an ad-hoc query for whatever you want. See <a href=""https://stackoverflow.com/questions/34053662/how-to-dispatch-an-ad-hoc-query-with-relay"">this question</a> for details on that.</p>&#xA;&#xA;<p>ASIDE:</p>&#xA;&#xA;<blockquote>&#xA;  <p>the whole point of Relay is to avoid over/under fetching</p>&#xA;</blockquote>&#xA;&#xA;<p>I disagree... That's a welcome benefit of course, but the real ""point"" is to be a declarative framework for getting data to your components. There is no simple, declarative API for refetching individual container fragments, true. Maybe there should be! But I think it's probably more likely that you are prematurely optimizing here :)</p>&#xA;",1750095,,-1,2017-05-23 11:51:27,2016-07-07 20:07:26,"",,0,1,0,2016-07-07 20:07:26
38254997,1,38256398,,0,1626,"<p>Trying to use mutation in Relay, so I create a new ""Relay.Mutation"" subclass ""RemoveMutation"" export it and trying to use it in React component. But it always give me this massage: </p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/ycHCr.png&quot;EOF?"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ycHCr.png&quot;EOF?"" alt=""enter image description here""></a>&#xA;<code>Uncaught Error: Relay transform error ``Syntax Error RelayMutation (4:14) Expected Name, found EOF</code></p>&#xA;&#xA;<p>I'm using phpstorm and it mark it too:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/rJbq8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rJbq8.png"" alt=""enter image description here""></a> </p>&#xA;&#xA;<p>Does any one have normal full example how to use Relay mutation? with creating subclass and mutation type?</p>&#xA;",5278472,,5641669,2016-07-07 22:46:25,2016-07-07 22:46:25,"""Expected Name, found EOF"" mutation in Relay",<javascript><eof><graphql><relayjs><graphql-js>,1,0,0,2016-07-07 20:48:14
38275354,1,,,1,192,"<p>I'm receiving the following error after a save comment mutation</p>&#xA;&#xA;<p>GraphQLRange cannot find a segment that has the cursor: MTQ2NzkxNTE5NA==</p>&#xA;&#xA;<p>this only happens after I ask for more comments before adding a new one</p>&#xA;&#xA;<p>this is my createContainer code:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(CommentsDetails, {&#xA;  initialVariables: {&#xA;    count: 10,&#xA;  },&#xA;&#xA;  fragments: {&#xA;    post: () =&gt; Relay.QL`&#xA;      fragment on Post {&#xA;        id,&#xA;        comments(first: $count) {&#xA;          edges {&#xA;            cursor,&#xA;            node {&#xA;              createdAt,&#xA;              ${Comment.getFragment('comment')},&#xA;            }&#xA;          },&#xA;          pageInfo {&#xA;            hasNextPage,&#xA;            hasPreviousPage,&#xA;            startCursor,&#xA;            endCursor,&#xA;          },&#xA;        }&#xA;      },&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>this is my save comment mutation</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default class SaveCommentMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL `mutation {&#xA;      saveComment&#xA;    }`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    const { post, body } = this.props;&#xA;    console.log('variables: ', post, body, this.props);&#xA;    return {&#xA;      post_id: post.id,&#xA;      body,&#xA;    }&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on saveCommentPayload {&#xA;        commentEdge,&#xA;        post {&#xA;          id,&#xA;          comments,&#xA;        },&#xA;        error,&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [&#xA;      {&#xA;        type: 'FIELDS_CHANGE',&#xA;        fieldIDs: {&#xA;          post: this.props.post.id,&#xA;        },&#xA;      },&#xA;      {&#xA;        type: 'RANGE_ADD',&#xA;        parentName: 'post',&#xA;        parentID: this.props.post.id,&#xA;        connectionName: 'comments',&#xA;        edgeName: 'commentEdge',&#xA;        rangeBehaviors: {&#xA;          '': 'append',&#xA;          'orderby(createdAt)': 'append',&#xA;      },&#xA;    }];&#xA;  }&#xA;&#xA;  getOptimisticResponse() {&#xA;    const { post, body } = this.props;&#xA;&#xA;    return {&#xA;      post: {&#xA;        id: post.id,&#xA;      },&#xA;      commentEdge: {&#xA;        node: {&#xA;          body: body,&#xA;          createdAt: new Date().toUTCString(),&#xA;          user: {&#xA;            name: 'anonymous',&#xA;          }&#xA;        }&#xA;      }&#xA;    };&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this is the generated graphql query, it works if I try on graphql</p>&#xA;&#xA;<pre><code>mutation SaveCommentMutation($input_0:saveCommentInput!) {&#xA;  saveComment(input:$input_0) {&#xA;    clientMutationId,&#xA;    ...F5,&#xA;    ...F6&#xA;  }&#xA;}&#xA;fragment F0 on Post {&#xA;  id&#xA;}&#xA;fragment F1 on Comment {&#xA;  id,&#xA;  body,&#xA;  createdAt,&#xA;  user {&#xA;    username,&#xA;    name,&#xA;    id&#xA;  }&#xA;}&#xA;fragment F2 on Post {&#xA;  id,&#xA;  _comments2g8zcs:comments(first:10) {&#xA;    edges {&#xA;      cursor,&#xA;      node {&#xA;        createdAt,&#xA;        id,&#xA;        ...F1&#xA;      }&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage,&#xA;      startCursor,&#xA;      endCursor&#xA;    }&#xA;  }&#xA;}&#xA;fragment F3 on Post {&#xA;  id,&#xA;  _comments3Cdb4n:comments(after:""MTQ2NzkyMDExNQ=="",first:10) {&#xA;    edges {&#xA;      cursor,&#xA;      node {&#xA;        createdAt,&#xA;        id,&#xA;        ...F1&#xA;      }&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage,&#xA;      startCursor,&#xA;      endCursor&#xA;    }&#xA;  }&#xA;}&#xA;fragment F4 on Post {&#xA;  id,&#xA;  _comments1Z6zk7:comments(after:""MTQ2NzkxNTE5NA=="",first:10) {&#xA;    edges {&#xA;      cursor,&#xA;      node {&#xA;        createdAt,&#xA;        id,&#xA;        ...F1&#xA;      }&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage,&#xA;      startCursor,&#xA;      endCursor&#xA;    }&#xA;  }&#xA;}&#xA;fragment F5 on saveCommentPayload {&#xA;  post {&#xA;    id,&#xA;    ...F0,&#xA;    id,&#xA;    id,&#xA;    ...F2,&#xA;    ...F3,&#xA;    ...F4&#xA;  }&#xA;}&#xA;fragment F6 on saveCommentPayload {&#xA;  commentEdge {&#xA;    cursor,&#xA;    __typename,&#xA;    node {&#xA;      createdAt,&#xA;      id,&#xA;      body,&#xA;      user {&#xA;        username,&#xA;        name,&#xA;        id&#xA;      }&#xA;    }&#xA;  },&#xA;  post {&#xA;    id,&#xA;    ...F0,&#xA;    id,&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think this happens because it cannot find the right list of comments that it should append the new created comment</p>&#xA;",2628278,,,,2016-07-08 21:02:53,GraphQLRange cannot find a segment that has the cursor,<graphql><relayjs><relay><graphql-js>,0,0,0,2016-07-08 21:02:53
38276015,1,38310349,,0,112,"<p>what is the correct point to authenticate a user ?</p>&#xA;&#xA;<p>going by the relay starter kit as an example.</p>&#xA;&#xA;<p>this would seem like be the point to query  (i have added the args id )</p>&#xA;&#xA;<pre><code>var queryType = new GraphQLObjectType({&#xA;  name: 'Query',&#xA;  fields: () =&gt; ({&#xA;    node: nodeField,&#xA;    // Add your own root fields here&#xA;    viewer: {&#xA;      args: {&#xA;        id: {&#xA;          type: GraphQLString&#xA;        },&#xA;      },&#xA;      type: userType,&#xA;      resolve: (_, args) =&gt; getViewer(args.id),&#xA;    },&#xA;  }),&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>then in the database do something like</p>&#xA;&#xA;<pre><code>getViewer: (id) =&gt; id === viewer.id ? viewer : null,&#xA;</code></pre>&#xA;&#xA;<p>now its this point where it's falling apart, where would be the place to  request the id be made from ? i would assume the route </p>&#xA;&#xA;<pre><code>export default class extends Relay.Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      query {&#xA;        viewer(id:""1"")&#xA;      }&#xA;    `,&#xA;  };&#xA;  static routeName = 'AppHomeRoute';&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this isn't working.</p>&#xA;",3224271,,,,2016-07-11 15:07:41,How to authenticate in relay,<graphql><relayjs><relay><graphql-js>,1,0,0,2016-07-08 22:05:19
38284556,1,38334690,,0,1035,"<p>In relay/graphql, how to express a query where the response can be empty. I have a dilemma now that, I can't respond with an empty/null response because <code>id</code> field is required by relay (and possibly other non nullable fields in graphql schema), and I can't send error as it stops my component being rendered.</p>&#xA;&#xA;<p>For example, say I am modelling a relationship hierarchy and has a query like</p>&#xA;&#xA;<p><code>getSpouse(partnerID: string): Person</code></p>&#xA;&#xA;<p>and this may be empty for some. So, I do either respond with a null Person object (which I think is not quite possible with relay as Person might have non nullable fields including a globalID), or send an error. It is ok to send error, but I am not sure how to catch this error and continue with rendering relay container. I know hot to get errors in case of mutation but query is processed by relay container and couldn't see an interface to get error and continue loading the component.</p>&#xA;&#xA;<p>Is there a way to catch the query error at the Relay container or pass it down to my component ?</p>&#xA;",303477,,303477,2016-07-10 16:20:47,2016-11-07 02:21:19,relay/ graphql: nullable response or a way to catch query error,<javascript><graphql><relayjs><relay><graphql-js>,1,1,0,2016-07-09 17:42:15
38311712,1,,,3,477,"<p>I am trying to code pagination without infinite scroll. I want to be able to click on a page number and update the before and after cursors accordingly. When the cursor of the last record on that page. I am not sure if this is the best way to go about this. First time with relay. I am not sure how i can i change my container dynamically based on conditionals. Sometimes i wont have a after or a before. I was passing empty strings but relay complains about that where graphql query tool does not. </p>&#xA;&#xA;<pre><code>1] Warning: GraphQLRange cannot find a segment that has the cursor:&#xA;[1] GraphQLRange cannot find a segment that has the cursor:&#xA;&#xA;export default Relay.createContainer(Search,{&#xA;  initialVariables: {&#xA;    pageSize: 20,&#xA;    lastRecord:""""&#xA;&#xA;  },&#xA;  fragments: {&#xA;    Viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;          User_Email,&#xA;     Books (first: $pageSize, after: $lastRecord) {&#xA;              totalCount&#xA;              pageInfo {&#xA;                hasNextPage&#xA;                hasPreviousPage&#xA;                startCursor,&#xA;                endCursor&#xA;              }&#xA;              edges{&#xA;              cursor,&#xA;              node{&#xA;                  Title,&#xA;&#xA;                  id,&#xA;                  Pub_Date,&#xA;&#xA;                }&#xA;              }&#xA;            }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Is this a good approach? Has anyone else trying to do this. Every article you read on pagination for relay is infinite scroll. </p>&#xA;",1108957,,710693,2017-08-11 00:28:13,2017-08-11 00:28:13,Relay pagination(Not infinite scroll),<javascript><pagination><graphql><relayjs>,1,0,0,2016-07-11 16:20:40
38314612,1,38815072,,1,572,"<p>Similar when we're using <code>${Component.getFragment('fragment')}</code>, is there a way I can simply concat a variable with a valid query inside a relay fragment? similiar to this:</p>&#xA;&#xA;<pre><code>const query = `&#xA;    allFriends {&#xA;        id&#xA;    }&#xA;`&#xA;&#xA;Relay.createContainer(Component, {&#xA;    fragments: {&#xA;      viewer: () =&gt; Relay.QL`&#xA;        fragment on Query {&#xA;          allUsers {&#xA;            id&#xA;          }&#xA;&#xA;          ${query}&#xA;&#xA;        }&#xA;      `&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Thanks!</p>&#xA;",1347129,,,,2016-08-07 14:22:38,How to concat a variable in relay fragment,<graphql><relay>,1,0,0,2016-07-11 19:22:16
38334690,2,,38284556,3,,"<p>@josephsavona of the relay core team commented one way to do this. at&#xA;<a href=""https://github.com/facebook/relay/issues/487#issuecomment-232102389"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/issues/487#issuecomment-232102389</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>One workaround is to use a custom network layer that resolves the&#xA;  RelayQueryRequest if there is any data (regardless of errors), and&#xA;  only rejects the request if there is no data and errors.</p>&#xA;</blockquote>&#xA;&#xA;<p>Edit: to elaborate based on the comment.</p>&#xA;&#xA;<pre><code>import { DefaultNetworkLayer } from 'react-relay';&#xA;export default class RelayNetworkLayer extends DefaultNetworkLayer {&#xA;  // override whichever methods (like sendMutation, sendQueries)&#xA;}&#xA;</code></pre>&#xA;",303477,,303477,2016-11-07 02:21:19,2016-11-07 02:21:19,"",,0,1,0,2016-07-12 16:42:17
38369825,1,38398472,,1,1002,"<p>I almost finished package for NodeJS <a href=""https://github.com/nodkz/graphql-compose-connection"" rel=""nofollow"">https://github.com/nodkz/graphql-compose-connection</a> which allows to construct connection types for graphql types builded with graphql-compose.</p>&#xA;&#xA;<p>This package completly follows to Relay Cursor Connections Specification (<a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow"">https://facebook.github.io/relay/graphql/connections.htm</a>) with great additions: <code>filter</code> arg (for filtering records) and <code>sort</code> arg (for sorting records by unique indexes). </p>&#xA;&#xA;<p>So I have following questions about cursor uniqueness:  </p>&#xA;&#xA;<p><strong>1) Should cursor be unique among different types?</strong> </p>&#xA;&#xA;<p><strong>2) Should cursor be unique among one connection with different args?</strong></p>&#xA;&#xA;<p>Eg. in UserConnection I have filter arg. And I want display all users in first list and online users in the second (2 lists simultaneously on the page). One user with same cursor may be exists in both list.</p>&#xA;&#xA;<p><strong>3) If Relay gets similar cursors in one connection, will it throw error?</strong></p>&#xA;&#xA;<p><strong>4) Should be cursor base64 encoded, or it may contains stringified json object?</strong></p>&#xA;",3340384,,,,2016-07-15 14:20:33,What restrictions has cursor in GraphQL Connections for Relay?,<connection><graphql><relay>,1,0,0,2016-07-14 08:59:13
38392504,1,,,1,1009,"<p>I've read the docs and I cannot seem to figure out how to structure my GraphQL for a particular query. For my data I have:</p>&#xA;&#xA;<pre><code>child&#xA;  |_ school&#xA;       |_ class&#xA;</code></pre>&#xA;&#xA;<p>A child has schools and schools have classes, but a child is only assigned to specific classes in a school.</p>&#xA;&#xA;<p>I want to query a specific child to get only the classes they are in. </p>&#xA;&#xA;<pre><code>query={&#xA;  child(id:$id){&#xA;    schools{&#xA;      name&#xA;      classes{&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I can technically filter the classes while resolving the schools field in the child type by looking deep down the fields but I wanted to clarify that this is still conforming to GraphQL. Should I be placing the classes as a field in the child type instead?</p>&#xA;",2688498,,,,2016-07-15 09:33:31,GraphQL filtering based on parent context,<graphql>,1,0,0,2016-07-15 09:25:01
38398472,2,,38369825,1,,"<p><strong>1) Should cursor be unique among different types?</strong></p>&#xA;&#xA;<p>If your question here is ""should cursors be globally unique"", the answer is no. They are not like IDs, which must be globally unique in Relay in order to facilitate refetching (for diffing). A cursor could be as simple as something like ""100"" or ""101"", although in practice often contain something more descriptive and/or structured than that.</p>&#xA;&#xA;<p><strong>2) Should cursor be unique among one connection with different args?</strong></p>&#xA;&#xA;<blockquote>&#xA;  <p>Eg. in UserConnection I have filter arg. And I want display all users&#xA;  in first list and online users in the second (2 lists simultaneously&#xA;  on the page). One user with same cursor may be exists in both list.</p>&#xA;</blockquote>&#xA;&#xA;<p>This is an implementation-specific thing. The point of the cursor is to enable pagination, and its contents are arbitrary. Simply, it should contain enough information, in conjunction with the other arguments on the connections, to enable your GraphQL schema on the server to be able to determine what it should return for the next (<code>after</code>) or previous (<code>before</code>) page.</p>&#xA;&#xA;<p><strong>3) If Relay gets similar cursors in one connection, will it throw error?</strong></p>&#xA;&#xA;<p>I am not sure if it will, but you could try it and find out. Even if it doesn't throw an error, it probably wouldn't make sense. The purpose of a cursor is to allow you to specify a relative starting point for a pagination, so if the cursor ""x"" appears at two different places in a connection, what does ""first 10 after x"" mean?</p>&#xA;&#xA;<p><strong>4) Should be cursor base64 encoded, or it may contains stringified json object?</strong></p>&#xA;&#xA;<p>The Base64 is something we do by convention, not because it is mandated, in order to make it clearer that cursors should be considered opaque tokens whose internal structure should not be relied upon. They're implementation-specific. So, I believe you could use a JSON string if you wanted, but there is some benefit to Base64 encoding it.</p>&#xA;",2103996,,,,2016-07-15 14:20:33,"",,0,3,0,2016-07-15 14:20:33
38398947,2,,37510286,4,,"<p>Looking at the <a href=""http://docs.sequelizejs.com/en/latest/docs/querying/#basics"" rel=""nofollow"">Sequelize docs</a>, you can try doing something like this in the students resolve function: </p>&#xA;&#xA;<pre><code>resolve(root, args) {&#xA;    // Assuming you've imported your model&#xA;    return Db.models.student.findAll({&#xA;        where: {&#xA;            days: {&#xA;                // greater than&#xA;                $gt: args.days&#xA;            }&#xA;        }&#xA;    });&#xA;}&#xA;</code></pre>&#xA;",4957288,,,,2016-07-15 14:42:05,"",,0,0,0,2016-07-15 14:42:05
38415536,1,38417795,,1,114,"<p>I'm using <a href=""https://github.com/relay-tools/react-router-relay"" rel=""nofollow"">react-router-relay</a> in a project. The design seems off to me given that every component basically ends up with a fragment having the same name as the root query. Shouldn't each component be able to have uniquely named fragments of any arbitrary type under the root query? Is this possible using this package or is my thinking flawed here?</p>&#xA;&#xA;<p><strong>Edit:</strong> Perhaps my question was a bit vague. My problem is that there are essentially two rules for the queries attribute defined by react-router-relay that enforce what seems to me to be a weird design pattern. Those two rules are:</p>&#xA;&#xA;<ol>&#xA;<li>Each query can only go ""one level"" deep.</li>&#xA;<li>Each query must map to a fragment with an identical name on the component that uses it.</li>&#xA;</ol>&#xA;&#xA;<p>This leaves you with a scenario whereby you either:</p>&#xA;&#xA;<ol>&#xA;<li>Use the same ""viewer"" query for every component and define a complimentary ""viewer"" fragment on each component. These fragments would all define different data requirements, despite having the same name, which seems very confusing.</li>&#xA;<li>You create unique fragment names for different components and then repeat the same exact root query with different names depending on the type of data you want to fetch, which seems downright silly.</li>&#xA;</ol>&#xA;",4957411,,2030321,2017-07-10 07:42:05,2017-07-10 07:42:05,Is react-router-relay inconsistent with the Relay pattern?,<javascript><reactjs><graphql><relayjs><react-router-relay>,1,0,0,2016-07-16 20:53:56
38417795,2,,38415536,1,,"<p>Good question. When you're dealing with Relay, you're thinking is correct in that every component should have its own fragment so that the query itself maps exactly to the data needed for that particular component. The naming of the fragments can be however you like them named, but the type cannot be arbitrary. It must be a declared type underneath the Root Query object (or whatever field you are appending the fragment to). Otherwise the fragment will throw an error saying that you cannot query that type on Query or field.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>var componentOneFragment = Relay.QL`&#xA;    fragment on User {&#xA;        name&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>One thing to note here is that you don't need to have a name for fragments like <code>fragment userFragment on User { ... }</code>. This will give you more flexibility when referencing component fragments dynamically from Relay queries in your router by declaring <code>${Component.getFragment(componentOneFragment)}</code>. Hope this helps!</p>&#xA;&#xA;<p><strong>EDIT:</strong></p>&#xA;&#xA;<blockquote>&#xA;  <p>Use the same ""viewer"" query for every component and define a&#xA;  complimentary ""viewer"" fragment on each component. These fragments&#xA;  would all define different data requirements, despite having the same&#xA;  name, which seems very confusing.</p>&#xA;</blockquote>&#xA;&#xA;<p>Although the fact that the identical names of the fragments may seem confusing, this is the best way to think about things. Each component does indeed have different data requirements, so naturally their Relay containers will have different fragments, but still under the same fragment name.</p>&#xA;&#xA;<p>This fragment may be included in one of your Relay containers that need <strong>User</strong> data:</p>&#xA;&#xA;<pre><code>const WidgetList = Relay.createContainer(/* ... */, {&#xA;  initialVariables: {&#xA;    color: null,&#xA;    size: null,&#xA;    limit: null&#xA;  },&#xA;&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        widgets(color: $color, size: $size, first: $limit) {&#xA;          edges {&#xA;            node {&#xA;              name,&#xA;            },&#xA;          },&#xA;        },&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>While this fragment (with still the same name) may be included in another Relay container that needs Widget data:</p>&#xA;&#xA;<pre><code>const ActionsList = Relay.createContainer(/* ... */, {&#xA;  initialVariables: {&#xA;    input: null&#xA;  },&#xA;&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Widget {&#xA;        actions(input: $input) {&#xA;          edges {&#xA;            node {&#xA;              name,&#xA;            },&#xA;          },&#xA;        },&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>These can both be used dynamically (i.e. <code>$Component.getFragment('viewer')</code>) in the same GraphQL query as long as <strong>User</strong> and <strong>Widget</strong> are both types under the Root Query object.</p>&#xA;",6452097,,6452097,2016-07-17 06:49:51,2016-07-17 06:49:51,"",,0,3,0,2016-07-17 04:01:48
38495083,1,38964786,,-1,286,"<p>Help, plz! Perhaps someone already faced with my problem....</p>&#xA;&#xA;<p>When re-fetch data with the updated variables -- using <em>relay.setVariables()</em> -- I get the error <strong>""Relay was unable to reconcile edges on a connection. This most likely occurred while trying to handle a server response that includes connection edges with nodes that lack an<code>id</code> field.""</strong> and Relay storage is not updated although the data come correct.</p>&#xA;&#xA;<p>See code below... (Ruby &amp;&amp; ES6)</p>&#xA;&#xA;<p><strong>gemfile</strong></p>&#xA;&#xA;  <pre class=""lang-rb prettyprint-override""><code>gem 'graphql', '0.16.0'&#xA;gem 'graphql-relay', '0.11.2'&#xA;</code></pre>&#xA;&#xA;<p>....server-side code</p>&#xA;&#xA;<p><strong>node_identification.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>NodeIdentification = GraphQL::Relay::GlobalNodeIdentification.define do&#xA;object_from_id -&gt; (id, ctx) do&#xA;    type, id = NodeIdentification.from_global_id(id)&#xA;    case type&#xA;        when 'FrontApp'&#xA;            Relay::FrontApp::STATIC&#xA;        else&#xA;            Object.const_get(type).find_by(id: id)&#xA;    end&#xA;end&#xA;&#xA;type_from_object -&gt; (obj) do&#xA;    begin&#xA;        MODEL_TO_TYPE[obj.class.name.to_sym].constantize&#xA;    rescue&#xA;        (obj.class.name + 'Type').constantize&#xA;    end&#xA;end&#xA;end&#xA;&#xA;MODEL_TO_TYPE = {&#xA;   :'Relay::FrontApp' =&gt; 'FrontAppType'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>front_app_query_type.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>FrontAppQueryType = GraphQL::ObjectType.define do&#xA;name 'FrontAppRootQuery'&#xA;field :node, field: NodeIdentification.field&#xA;&#xA;field :main, FrontAppType do&#xA;    resolve -&gt; (obj, args, ctx) {&#xA;        Relay::FrontApp::STATIC&#xA;    }&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p><strong>front_app_type.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>FrontAppType = GraphQL::ObjectType.define do&#xA;name 'FrontApp'&#xA;# field :node, field: NodeIdentification.field&#xA;interfaces [NodeIdentification.interface]&#xA;global_id_field :id&#xA;&#xA;field :tips, TipsType do&#xA;    argument :filters, types.String&#xA;    resolve -&gt; (obj, args, ctx) {&#xA;        filters = args[:filters]&#xA;        begin&#xA;            filters = JSON.parse(filters).deep_symbolize_keys!&#xA;        rescue&#xA;            filters = nil&#xA;        end&#xA;        ctx[:filters] = filters&#xA;        Relay::Tips::STATIC&#xA;    }&#xA;end&#xA;connection :footer, FooterMenuItemType.connection_type do&#xA;    argument :id, types.ID!&#xA;    resolve -&gt;(obj, args, ctx){&#xA;        ::Footer.order(:id)&#xA;    }&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p><strong>tips_connection_type.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>TipsConnectionType = TipShowType.define_connection do&#xA;field :totalCount, types.Int do&#xA;    resolve -&gt; (obj, args, ctx) {&#xA;        obj.object.size&#xA;    }&#xA;end&#xA;end&#xA;&#xA;&#xA;TipsType = GraphQL::ObjectType.define do&#xA;name 'Tips'&#xA;description 'Tips list for home page'&#xA;interfaces [NodeIdentification.interface]&#xA;global_id_field :id&#xA;&#xA;connection :mostRecent, TipsConnectionType do&#xA;    argument :limit, types.Int&#xA;    resolve -&gt;(obj, args, ctx){&#xA;        tips = ::Tip.active_users.started(Time.zone.now.in_time_zone(ctx[:current_user] ? ctx[:current_user].time_zone : ::User.get_locally_time_zone).to_date).ready.active.moderated.published.includes(:comments, :tip_type).order('created_at desc').limit(args[:limit])&#xA;        TipHelpers::Filter.filter(tips: tips, filters: ctx[:filters], reorder: 'created_at desc')&#xA;    }&#xA;end&#xA;connection :mostPopular, TipsConnectionType do&#xA;    argument :limit, types.Int&#xA;    resolve -&gt;(obj, args, ctx){&#xA;        tips = ::Tip.active_users.started(Time.zone.now.in_time_zone(ctx[:current_user] ? ctx[:current_user].time_zone : ::User.get_locally_time_zone).to_date).ready.active.moderated.published.includes(:comments, :tip_type).order('(SELECT COUNT(*) FROM comments WHERE tid = tips.id) desc').limit(args[:limit])&#xA;        TipHelpers::Filter.filter(tips: tips, filters: ctx[:filters], reorder: '(SELECT COUNT(*) FROM comments WHERE tid = tips.id) desc')&#xA;    }&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p><strong>/app/models/relay/front_app.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>module Relay&#xA;class FrontApp &lt; Struct.new :id&#xA;    # HACK::// For relay root queries&#xA;    STATIC = new(id: 'main').freeze&#xA;&#xA;    def initialize *args&#xA;        opts = args.last.is_a?(Hash) ? args.pop : Hash.new&#xA;        super *args&#xA;        opts.each_pair do |k, v|&#xA;            self.send ""#{k}="", v&#xA;        end&#xA;    end&#xA;&#xA;    def self.find(_)&#xA;        STATIC&#xA;    end&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>** /app/models/relay/tips.rb**</p>&#xA;&#xA;  <pre class=""lang-rb prettyprint-override""><code>module Relay&#xA;class Tips &lt; Struct.new :id&#xA;    # HACK:// For relay root queries&#xA;    STATIC = new(id: 'tips').freeze&#xA;&#xA;    def initialize *args&#xA;        opts = args.last.is_a?(Hash) ? args.pop : Hash.new&#xA;        super *args&#xA;        opts.each_pair do |k, v|&#xA;            self.send ""#{k}="", v&#xA;        end&#xA;    end&#xA;&#xA;    def self.find(_)&#xA;        STATIC&#xA;    end&#xA;&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>....and client-side code</p>&#xA;&#xA;  <pre class=""lang-js prettyprint-override""><code>class MainApp extends React.Component {&#xA;&#xA;constructor(props) {&#xA;    super(props);&#xA;&#xA;    this.state = {&#xA;        filters: filtersTemplate&#xA;    };&#xA;&#xA;    this.setFilter = this.setFilter.bind(this);&#xA;}&#xA;&#xA;setFilter(filter, value, e) {&#xA;    if (e) {&#xA;        e.nativeEvent.stopImmediatePropagation();&#xA;        e.preventDefault();&#xA;    }&#xA;&#xA;    let { filters } = this.state;&#xA;    if (['currency', 'sum'].inArray(filter)) {&#xA;        filters.funds[filter] = value;&#xA;    } else {&#xA;        filters[filter] = value;&#xA;    }&#xA;    this.setState({&#xA;        filters: filters&#xA;    });&#xA;    this.props.relay.setVariables({filters: filters});&#xA;}&#xA;&#xA;render() {&#xA;    let { tips } = this.props.main;&#xA;    let renderTipsSection = (section) =&gt; {&#xA;        let tipsCount = tips[section] ? tips[section].edges.length : 0;&#xA;        let blankCount = 10 - tipsCount;&#xA;        return (&#xA;            &lt;ul className=""tips__list""&gt;&#xA;                {&#xA;                    tips[section] &amp;&amp; tips[section].edges.map(({node}) =&gt; (&#xA;                        &lt;li key={node.id} className=""tips__list_item""&gt;&#xA;                            &lt;TipCard node={node}/&gt;&#xA;                        &lt;/li&gt;&#xA;                    ))&#xA;                }&#xA;                {&#xA;                    [...new Array(blankCount).keys()].map((item, idx) =&gt; (&#xA;                        &lt;li key={idx} className=""tips__list_item""&gt;&#xA;                            &lt;TipCard dummy={true}/&gt;&#xA;                        &lt;/li&gt;&#xA;                    ))&#xA;                }&#xA;            &lt;/ul&gt;&#xA;        );&#xA;    };&#xA;    return (&#xA;        &lt;div&gt;&#xA;            &lt;div className=""wrapper""&gt;&#xA;                &lt;div className=""TipsWrapper""&gt;&#xA;                    &lt;div className=""wrapper""&gt;&#xA;&#xA;                        { renderTipsSection('mostRecent') }&#xA;&#xA;                        { renderTipsSection('mostPopular') }&#xA;&#xA;                    &lt;/div&gt;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;    );&#xA;}}&#xA;&#xA;export default Relay.createContainer(MainApp, {&#xA;initialVariables: {&#xA;    filters: {&#xA;        category: null,&#xA;        funds: {&#xA;            currency: null,&#xA;            sum: null&#xA;        },&#xA;        date: null,&#xA;        location: null,&#xA;        browse: null&#xA;    }&#xA;},&#xA;prepareVariables: (prevVars) =&gt; {&#xA;    return {&#xA;        ...prevVars,&#xA;        filters: JSON.stringify(prevVars.filters)&#xA;    }&#xA;},&#xA;fragments: {&#xA;    main: () =&gt; Relay.QL`&#xA;        fragment on FrontApp {&#xA;            tips(filters: $filters) {&#xA;              mostRecent(first: 10, limit: 10){&#xA;                edges {&#xA;                  node {&#xA;                    id&#xA;                    tid&#xA;                    title_name&#xA;                    category&#xA;                  }&#xA;                }&#xA;              }  &#xA;              mostPopular(first: 10, limit: 10){&#xA;                edges {&#xA;                  node {&#xA;                    id&#xA;                    tid&#xA;                    title_name&#xA;                    category&#xA;                  }&#xA;                }&#xA;              }  &#xA;            }&#xA;        }&#xA;    `&#xA;}});&#xA;</code></pre>&#xA;&#xA;<p>When setFilter() triggered the relay.setVariables will be called...&#xA;and result...</p>&#xA;&#xA;<pre><code>[RELAY-NETWORK] Run query q3 Object {relayReqId: ""q3"", relayReqObj: RelayQueryRequest, relayReqType: ""query"", method: ""POST"", headers: Object…}&#xA;[RELAY-NETWORK] query q3: 3429ms&#xA;Warning: Relay was unable to reconcile edges on a connection. This most likely occurred while trying to handle a server response that includes connection edges with nodes that lack an `id` field&#xA;</code></pre>&#xA;",5451913,,2564301,2016-08-24 17:48:48,2016-08-24 17:48:48,Relay re-fetching failed... error Relay was unable to reconcile edges on a connection,<ruby><reactjs><graphql><relayjs>,1,5,0,2016-07-21 04:47:52
38638823,1,38654447,,0,621,"<p>I'm very confused regarding the the relations in GraphQL-Relay. When its about one-to-many it seems very straightforward. I created some <a href=""https://github.com/graphql/graphql-relay-js"" rel=""nofollow"">connectionDefinitions</a> and it worked perfectly. But I have the following case where I would like to create / update the model below.</p>&#xA;&#xA;<pre><code>new Schema({&#xA;    item: {type: String, ref: ‘Item’, required: true},&#xA;    user: {type: String, ref: ‘User’, required: true},&#xA;    liked: {type: Boolean, required: true, default: false}&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Should I create a connection with User and Item in my GraphQL Schema?</p>&#xA;&#xA;<p>If I look at the <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#range-add"" rel=""nofollow"">config</a> for 'RANGE_ADD' it shows parentName and parentId but in my case I have more than one parent. Should I have two objects configuration (one for each parent) in my getConfigs array?</p>&#xA;&#xA;<p>Can I create and update this object without a connection?</p>&#xA;&#xA;<p>Thanks</p>&#xA;",2785486,,,,2016-07-29 08:49:15,GraphQL Relay relationships and mutation,<facebook><reactjs><relayjs><graphql-js>,1,6,0,2016-07-28 14:05:31
38680332,2,,38679952,1,,"<p>The fundamental difference between declarative data loading and the http/ajax data loading is rooted in the difference between declarative and imperative programming. With declarative approach, you just mention <em>what</em> you need and that's all. On the othe hand, with imperative approach, you also need to tell the steps, i.e. <em>how</em> to get what you need.</p>&#xA;&#xA;<p>Let's take a look at the following <a href=""https://github.com/relayjs/relay-examples/blob/3a134b03fa9b741754f0b2e6ad15b5da79151846/star-wars/js/components/StarWarsApp.js#L90-L109"" rel=""nofollow"">example of Relay's declarative data loading</a>. It tells that for each faction, it wants these data: id, factionId, name, ships and also the data <code>AddShipMutation</code> wants for a faction. How the data are fetched is abstract.</p>&#xA;&#xA;<pre><code>fragments: {&#xA;  factions: () =&gt; Relay.QL`&#xA;    fragment on Faction @relay(plural: true) {&#xA;      id,&#xA;      factionId,&#xA;      name,&#xA;      ships(first: 10) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            ${StarWarsShip.getFragment('ship')}&#xA;          }&#xA;        }&#xA;      }&#xA;      ${AddShipMutation.getFragment('faction')},&#xA;    }&#xA;  `,&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>For data loading with HTTP or AJAX, we have to specify how to get the data.</p>&#xA;&#xA;<ol>&#xA;<li>make a request</li>&#xA;<li>receive response</li>&#xA;<li>extract data from response</li>&#xA;<li>store the data</li>&#xA;</ol>&#xA;&#xA;<p>Hope this helps!</p>&#xA;",2821632,,,,2016-07-31 02:53:39,"",,0,4,0,2016-07-31 02:53:39
38683594,1,38686657,,0,634,"<p>I'm trying to figure out how to make a query with Sequelize.js that outputs something like </p>&#xA;&#xA;<p><code>SELECT ... WHERE C1 = X AND (C2 LIKE '%Y%' OR C3 LIKE '%Y%')... to MySQL</code></p>&#xA;&#xA;<p>code</p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    findItems(_, args) {&#xA;      return Item.findAll({&#xA;        limit: 10,&#xA;        active: 1,&#xA;        offset: args.offset,&#xA;        order: [['created_at', 'DESC']],&#xA;        $or: [&#xA;          {&#xA;            column_a: {&#xA;              $like: args.y,&#xA;            },&#xA;          },&#xA;          {&#xA;            column_b: {&#xA;              $like: args.y,&#xA;            },&#xA;          }]&#xA;      });&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It's querying <code>SELECT * FROM item ORDER BY created_at DESC LIMIT...</code> (no where)</p>&#xA;&#xA;<p>Schema from GraphQL</p>&#xA;&#xA;<pre><code>const typeDefinitions = `&#xA;        type Item {&#xA;                column_a: String,&#xA;                column_b: String,&#xA;                active: Int,&#xA;        }&#xA;        type Query {&#xA;                findItems(column_a: String, column_b: String, active: Int, offset: Int): [Item]&#xA;        }&#xA;        type Mutation {&#xA;                //..&#xA;        }&#xA;        schema {&#xA;                query: Query&#xA;                mutation: Mutation&#xA;}`;&#xA;export default [typeDefinitions];&#xA;</code></pre>&#xA;&#xA;<p>The docs from Sequelize.js don't explain how to do this query, I don't know if the problem is coming from the GraphQL query either.</p>&#xA;&#xA;<p>Here's the query</p>&#xA;&#xA;<pre><code>{&#xA;  findItems(column_a: ""hello"", column_b:""hello"", active: 1, offset: 0) {&#xA;    column_a&#xA;    column_b&#xA;    active&#xA;    created_at&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>SELECT * FROM item ORDER BY created_at DESC LIMIT...</code> (no where)</p>&#xA;",2284676,,2284676,2016-07-31 11:45:13,2016-07-31 21:08:25,Query from GraphQL to Sequelize.js SELECT ... WHERE COL1 = X AND (COL2 LIKE Y OR COL3 LIKE Y),<javascript><mysql><meteor><sequelize.js><graphql>,2,0,0,2016-07-31 11:40:05
38684232,2,,38683594,0,,"<p>You can always pass in an optional where object to filter the query. See <a href=""http://docs.sequelizejs.com/en/latest/docs/querying/"" rel=""nofollow"">Querying</a></p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    findItems(_, args) {&#xA;      return Item.findAll({&#xA;        where: {&#xA;          column_a: args.x&#xA;        },&#xA;        limit: 10,&#xA;        active: 1,&#xA;        offset: args.offset,&#xA;        order: [['created_at', 'DESC']],&#xA;        $or: [&#xA;          {&#xA;            column_a: {&#xA;              $like: args.y,&#xA;            },&#xA;          },&#xA;          {&#xA;            column_b: {&#xA;              $like: args.y,&#xA;            },&#xA;          }]&#xA;      });&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5189811,,,,2016-07-31 13:00:01,"",,0,0,0,2016-07-31 13:00:01
38684933,1,,,0,1115,"<p>I have a Relay mutation which creates a post and prepends it to a post list.  The optimistic update will prepend the post's title and url to the list before the mutation gets sent out to my GraphQL server.  My problem is that when the mutation fails or is unable to complete, that optimistic update is removed from the list automatically after.  Is there a way to catch and handle a failed mutation so I could show some sort of message to the user indicating that the post cannot be saved?</p>&#xA;&#xA;<p>My Relay mutation:</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;class CreatePostMutation extends Relay.Mutation {&#xA;    getMutation () {&#xA;        return Relay.QL`&#xA;            mutation {&#xA;                createPost&#xA;            }&#xA;        `&#xA;    }&#xA;&#xA;    getVariables() {&#xA;        return {&#xA;            title: this.props.title,&#xA;            url: this.props.url&#xA;        }&#xA;    }&#xA;&#xA;    getFatQuery() {&#xA;        return Relay.QL`&#xA;            fragment on CreatePostPayload {&#xA;                postEdge,&#xA;                store {&#xA;                    id&#xA;                }&#xA;            }&#xA;        `;&#xA;    }&#xA;&#xA;    getConfigs() {&#xA;        return [{&#xA;            type: 'RANGE_ADD',&#xA;            parentName: 'store',&#xA;            parentID: this.props.store.id,&#xA;            connectionName: 'allPosts',&#xA;            edgeName: 'postEdge',&#xA;            rangeBehaviors: {&#xA;                '': 'prepend'&#xA;            }&#xA;        }]&#xA;    }&#xA;&#xA;    getOptimisticResponse() {&#xA;        return {&#xA;            postEdge: {&#xA;                node: {&#xA;                    title: this.props.title,&#xA;                    url: this.props.url&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;export default CreatePostMutation;&#xA;</code></pre>&#xA;&#xA;<p>My PostForm React component:</p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import Relay from 'react-relay';&#xA;&#xA;import CreatePostMutation from '../../mutations/create_post';&#xA;&#xA;class PostForm extends React.Component {&#xA;    handleSubmit = (e) =&gt; {&#xA;        e.preventDefault();&#xA;&#xA;        let {relay, store} = this.props;&#xA;        let {title, url}   = this.refs;&#xA;&#xA;        relay.commitUpdate(&#xA;            new CreatePostMutation({&#xA;                title: title.value,&#xA;                url: url.value,&#xA;                store&#xA;            })&#xA;        );&#xA;&#xA;        // clear values&#xA;        title.value = '';&#xA;        url.value   = '';&#xA;    }&#xA;&#xA;    render () {&#xA;        return (&#xA;            &lt;div&gt;&#xA;                &lt;form onSubmit={this.handleSubmit}&gt;&#xA;                    &lt;input name=""title"" placeholder=""Title"" ref=""title"" /&gt;&#xA;                    &lt;input name=""url"" placeholder=""URL"" ref=""url"" /&gt;&#xA;                    &lt;input type=""submit"" /&gt;&#xA;                &lt;/form&gt;&#xA;            &lt;/div&gt;&#xA;        )&#xA;    }&#xA;}&#xA;&#xA;export default PostForm;&#xA;</code></pre>&#xA;",712558,,2821632,2016-07-31 17:42:10,2016-07-31 18:09:27,How to catch and handle failed mutation in Relay?,<reactjs><graphql><relayjs><relay>,1,0,0,2016-07-31 14:20:48
38686657,2,,38683594,0,,"<p>Had to put the $or inside the where and add a dollar sign.</p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    findItems(_, args) {&#xA;      return Item.findAll({&#xA;        where: {&#xA;        active: 1,&#xA;        $or: [&#xA;          {&#xA;            column_a: {&#xA;              $like: args.y,&#xA;            },&#xA;          },&#xA;          {&#xA;            column_b: {&#xA;              $like: args.y,&#xA;            },&#xA;          }],&#xA;        },&#xA;        limit: 10,&#xA;        active: 1,&#xA;        offset: args.offset,&#xA;        order: [['created_at', 'DESC']],&#xA;      });&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2284676,,2284676,2016-07-31 21:08:25,2016-07-31 21:08:25,"",,0,0,0,2016-07-31 17:31:12
38688907,1,38690305,,6,4178,"<p>I can successfully do graphql/relay queries and mutations with CURL and GraphiQL tool:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/gY8a2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gY8a2.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>However, in my react/relay app I can query and get the data into the app, but &#xA;every time I try to mutate something in my app, I get this error in the console:</p>&#xA;&#xA;<pre><code>    bundle.js:51511 Uncaught Error: GraphQL validation error ``Cannot query field ""store"" on type ""CreateLinkPayload"".`` in file &#xA;`/Users/johndoe/react-relay-project/src/mutations/CreateLinkMutation.js`. Try updating your GraphQL schema if an argument/field/type was recently added.&#xA;(anonymous function) @ bundle.js:51511&#xA;getFatQuery @ bundle.js:51512&#xA;getFatQuery @ bundle.js:35664&#xA;getQuery @ bundle.js:35791&#xA;_handleCommit @ bundle.js:35539&#xA;commit @ bundle.js:35453&#xA;commit @ bundle.js:35894&#xA;(anonymous function) @ bundle.js:28526&#xA;</code></pre>&#xA;&#xA;<p>and every time I do <code>npm start</code> I get this error:</p>&#xA;&#xA;<pre><code>-- GraphQL Validation Error -- CreateLinkMutation --&#xA;&#xA;File:  /Users/johndoe/react-relay-project/src/mutations/CreateLinkMutation.js&#xA;Error: Cannot query field ""store"" on type ""CreateLinkPayload"".&#xA;Source:&#xA;&gt; &#xA;&gt;         store { linkConnection }&#xA;&gt;         ^^^&#xA;</code></pre>&#xA;&#xA;<p><code>CreateLinkMutation.js</code></p>&#xA;&#xA;<pre><code>import Relay from 'react-relay'&#xA;&#xA;class CreateLinkMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`&#xA;      mutation { createLink }&#xA;    `&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      title: this.props.title,&#xA;      url: this.props.url&#xA;    }&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateLinkPayload {&#xA;        linkEdge,&#xA;        store { linkConnection }&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'store',&#xA;      parentID: this.props.store.id,&#xA;      connectionName: 'linkConnection',&#xA;      edgeName: 'linkEdge',&#xA;      rangeBehaviors: {&#xA;        '': 'append'&#xA;      }&#xA;    }]&#xA;&#xA;  }&#xA;}&#xA;&#xA;export default CreateLinkMutation&#xA;</code></pre>&#xA;&#xA;<p>parts of <code>Link.js</code></p>&#xA;&#xA;<pre><code>Link = Relay.createContainer(Link, {&#xA;  fragments: {&#xA;    link: () =&gt; Relay.QL`&#xA;      fragment on Link {&#xA;        url,&#xA;        title&#xA;      }&#xA;    `&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>parts of <code>App.js</code></p>&#xA;&#xA;<pre><code> handleSubmit(e) {&#xA;    e.preventDefault()&#xA;    Relay.Store.update(&#xA;      new CreateLinkMutation({&#xA;        title: this.refs.newTitle.value,&#xA;        url: this.refs.newUrl.value,&#xA;        store: this.props.store&#xA;      })&#xA;    )&#xA;    this.refs.newTitle.value = ''&#xA;    this.refs.newUrl.value = ''&#xA;  }&#xA;&#xA;&#xA;&#xA;App = Relay.createContainer(App, {&#xA;  initialVariables: {&#xA;    limit: 10&#xA;  },&#xA;  fragments: {&#xA;    store: () =&gt; Relay.QL`&#xA;      fragment on Store {&#xA;        id,&#xA;        linkConnection(first: $limit) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              ${Link.getFragment('link')}&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>parts of <code>main.js</code></p>&#xA;&#xA;<pre><code>class LinkStoreRoute extends Relay.Route {&#xA;  static routeName = 'LinkStoreRoute'&#xA;  static queries = {&#xA;    store: () =&gt; Relay.QL`query { store }`&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My <code>schema.js</code>:</p>&#xA;&#xA;<pre><code>const store = {}&#xA;&#xA;const Store = new GraphQLObjectType({&#xA;  name: 'Store',&#xA;  fields: () =&gt; ({&#xA;    id: globalIdField('Store'),&#xA;    linkConnection: {&#xA;      type: linkConnection.connectionType,&#xA;      args: connectionArgs,&#xA;      resolve: (_, args) =&gt; {&#xA;        return docClient.scan(&#xA;          Object.assign(&#xA;            {},&#xA;            {TableName: linksTable},&#xA;            paginationToParams(args)&#xA;          )&#xA;        ).promise().then(dataToConnection)&#xA;      }&#xA;    }&#xA;  })&#xA;})&#xA;&#xA;const Link = new GraphQLObjectType({&#xA;  name: 'Link',&#xA;  fields: () =&gt; ({&#xA;    id: {&#xA;      type: new GraphQLNonNull(GraphQLID),&#xA;      resolve: (obj) =&gt; obj.id&#xA;    },&#xA;    title: { type: GraphQLString },&#xA;    url: { type: GraphQLString }&#xA;  })&#xA;})&#xA;&#xA;const linkConnection = connectionDefinitions({&#xA;  name: 'Link',&#xA;  nodeType: Link&#xA;})&#xA;&#xA;let createLinkMutation = mutationWithClientMutationId({&#xA;&#xA;  name: 'CreateLink',&#xA;&#xA;  inputFields: {&#xA;    title: { type: new GraphQLNonNull(GraphQLString) },&#xA;    url: { type: new GraphQLNonNull(GraphQLString) }&#xA;  },&#xA;&#xA;  outputFields: {&#xA;    linkEdge: {&#xA;      type: linkConnection.edgeType,&#xA;      resolve: (obj) =&gt; ({node: obj, cursor: obj.id})&#xA;    }&#xA;  },&#xA;&#xA;  store: {&#xA;    type: Store,&#xA;    resolve: () =&gt; store&#xA;  },&#xA;&#xA;  mutateAndGetPayload: (inputFields) =&gt; {&#xA;&#xA;    let link = {&#xA;      id: uuid.v4(),&#xA;      title: inputFields.title,&#xA;      url: inputFields.url&#xA;    }&#xA;&#xA;    return new Promise((resolve, reject) =&gt; {&#xA;      docClient.put(&#xA;        Object.assign(&#xA;          {},&#xA;          {TableName: linksTable},&#xA;          {Item: link}&#xA;        ),&#xA;        (err, data) =&gt; {&#xA;          if (err) return reject(err)&#xA;          return resolve(link)&#xA;        }&#xA;      )&#xA;    })&#xA;  }&#xA;})&#xA;&#xA;const schema = new GraphQLSchema({&#xA;  query: new GraphQLObjectType({&#xA;    name: 'Query',&#xA;    fields: () =&gt; ({&#xA;      store: {&#xA;        type: Store,&#xA;        resolve: () =&gt; store&#xA;      }&#xA;    })&#xA;  }),&#xA;&#xA;  mutation: new GraphQLObjectType({&#xA;    name: 'Mutation',&#xA;    fields: () =&gt; ({&#xA;      createLink: createLinkMutation&#xA;    })&#xA;  })&#xA;})&#xA;&#xA;module.exports = schema&#xA;</code></pre>&#xA;&#xA;<p>Note that I excluded 40 lines of <code>require</code> statements at the top.</p>&#xA;&#xA;<p>How is this even possible? And how can I fix it?&#xA;Could it be a bug of relay/react?</p>&#xA;",2097095,,710693,2017-08-11 00:24:37,2017-08-11 00:24:37,"GraphQL/Relay Schema Cannot query field ""store"" on type ""CreateLinkPayload""",<javascript><reactjs><graphql><relayjs>,2,0,0,2016-07-31 22:31:22
38689898,2,,38688907,1,,"<p>Turns out store</p>&#xA;&#xA;<pre><code>  store: {&#xA;    type: Store,&#xA;    resolve: () =&gt; store&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>has to go inside outputFields like so:</p>&#xA;&#xA;<pre><code>  outputFields: {&#xA;    linkEdge: {&#xA;      type: linkConnection.edgeType,&#xA;      resolve: (obj) =&gt; ({node: obj, cursor: obj.id})&#xA;    }&#xA;    store: {&#xA;      type: Store,&#xA;      resolve: () =&gt; store&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",2097095,,,,2016-08-01 01:34:17,"",,0,0,0,2016-08-01 01:34:17
38690305,2,,38688907,7,,"<p>In your client-side implementation of <code>CreateLinkMutation</code> (CreateLinkMutation.js file), <code>getFatQuery()</code> function specifies that it expects two outputs after the mutation is complete - <code>linkEdge</code> and <code>store</code>. Therefore, in your server-side implementation of the mutation, you must include these two things as output. However, only <code>linkEdge</code> is included to the mutation's outputs in your current implementation (<code>createLinkMutation</code> in schema.js file). To solve the problem, include <code>store</code> to the outputs.</p>&#xA;&#xA;<pre><code>outputFields: {&#xA;  linkEdge: {&#xA;    type: linkConnection.edgeType,&#xA;    resolve: (obj) =&gt; ({node: obj, cursor: obj.id})&#xA;  },&#xA;  store: {&#xA;    type: Store,&#xA;    resolve: () =&gt; store&#xA;  },&#xA;},&#xA;</code></pre>&#xA;",2821632,,,,2016-08-01 02:40:56,"",,0,0,0,2016-08-01 02:40:56
38706347,1,,,1,368,"<p>I am trying to code a relay mutation that will allow server side validation. Such as a record with that name already exists. </p>&#xA;&#xA;<p>Below is my GraphQL mutation. </p>&#xA;&#xA;<pre><code>/* @flow weak */&#xA;import {mutationWithClientMutationId,offsetToCursor} from ""graphql-relay"";&#xA;import {GraphQLString, GraphQLList, GraphQLNonNull} from ""graphql"";&#xA;import NominationConnection from '../NominationsConnection';&#xA;import ViewerType from '../../../types/ViewerType';&#xA;import Helper from '../../../helper/helper';&#xA;import Nomination from '../../../model/Nomination';&#xA;&#xA;&#xA;const mongo = require('mongodb');&#xA;&#xA;/**&#xA; * mutationWithClientMutationId()&#xA; *&#xA; * This helper function helps us create Relay-compliant GraphQL mutations it takes an object with the following params&#xA; * { name: """", inputField: { }, outputFields: {},  mutateAndGetPayload: function({}) }&#xA; *&#xA; */&#xA;export default mutationWithClientMutationId({&#xA;&#xA;  // Name of the Mutation&#xA;  name: ""Nomination_Add"",&#xA;&#xA;  // Describes the fields that should be used when invoking the mutation&#xA;  inputFields: {&#xA;    name: {&#xA;      type: new GraphQLNonNull(GraphQLString)&#xA;    },&#xA;    description: {&#xA;      type: new GraphQLNonNull(GraphQLString)&#xA;    },&#xA;    books: {&#xA;      type: new GraphQLList(GraphQLString)&#xA;    }&#xA;&#xA;  },&#xA;&#xA;  // response that will be sent back when the mutation is complete&#xA;  outputFields: {&#xA;    NominationsEdge: {&#xA;      type: NominationConnection.edgeType,&#xA;      resolve: ( {local_id}, { ...args }, context, { rootValue: objectManager } ) =&gt;&#xA;      {&#xA;        //RT: local_id is the object that was inserted into DB.;&#xA;        let nomination = local_id[0];&#xA;        console.log(""nomination: "", nomination);&#xA;        if(nomination.Errors.length &gt; 0){&#xA;&#xA;          return objectManager.getListBy('Nomination', nomination, {}, {})&#xA;              .then((arr) =&gt; {&#xA;&#xA;                return ( {&#xA;                  cursor: null,&#xA;                  node: nomination,&#xA;                } )&#xA;              })&#xA;        }else {&#xA;&#xA;          let an_Object;&#xA;          return objectManager.getOneByParam('Nomination', nomination, {_id: nomination.id})&#xA;              .then((retrieved_Object) =&gt; {&#xA;&#xA;&#xA;                an_Object = retrieved_Object;&#xA;&#xA;              })&#xA;&#xA;              .then(() =&gt; objectManager.getListBy('Nomination', an_Object, {}, {}, objectManager.getViewerUserId()))&#xA;              .then((arr) =&gt; {&#xA;&#xA;&#xA;                return ( {&#xA;                  cursor: Helper.cursorForObjectInConnection(arr, an_Object, ""id""),&#xA;                  node: an_Object,&#xA;                } )&#xA;              })&#xA;              ;&#xA;        }&#xA;      }&#xA;    },&#xA;&#xA;    Viewer: {&#xA;      type: ViewerType,&#xA;      resolve: (parent, args, context, {rootValue: objectManager}) =&gt; objectManager.getOneById('User', objectManager.getViewerUserId())&#xA;    }&#xA;  },&#xA;&#xA;  mutateAndGetPayload: ({name, description, books}, context, {rootValue: objectManager}) =&gt; {&#xA;    if(!books){&#xA;      books = [];&#xA;    }&#xA;&#xA;    return objectManager.add('Nomination', {&#xA;      name,&#xA;      description,&#xA;      books&#xA;    }, {name: name}).then((local_id) =&gt; ( {local_id} ));&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Below is my relay mutation. </p>&#xA;&#xA;<pre><code>/* @flow weak */&#xA;&#xA;import Relay from 'react-relay';&#xA;&#xA;export default class Nomination_addMutation extends Relay.Mutation {&#xA;  // static fragments = {&#xA;  //   Viewer: () =&gt; Relay.QL`&#xA;  //     fragment on Viewer {&#xA;  //       id,&#xA;  //     }&#xA;  //   `,&#xA;  // };&#xA;  getMutation() {&#xA;&#xA;    return Relay.QL`mutation{Nomination_Add}`;&#xA;  }&#xA;  getFatQuery() {&#xA;&#xA;&#xA;    return Relay.QL`&#xA;      fragment on Nomination_AddPayload {&#xA;      NominationsEdge,&#xA;        Viewer {&#xA;         Nominations(first:500){&#xA;         edges{&#xA;          node{&#xA;             id,&#xA;            Name,&#xA;            Description&#xA;            }&#xA;          }&#xA;         }&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'Viewer',&#xA;      parentID: this.props.Viewer.id,&#xA;      connectionName: 'Nominations',&#xA;      edgeName: 'NominationsEdge',&#xA;      rangeBehaviors: {&#xA;        // When the ships connection is not under the influence&#xA;        // of any call, append the ship to the end of the connection&#xA;        '': 'append',&#xA;        // Prepend the ship, wherever the connection is sorted by age&#xA;       // 'orderby(newest)': 'prepend',&#xA;      },&#xA;    }];&#xA;  }&#xA;  getVariables() {&#xA;&#xA;    return {&#xA;&#xA;      name: this.props.name,&#xA;      description: this.props.description,&#xA;      books: this.props.books,&#xA;    };&#xA;  }&#xA;  getOptimisticResponse() {&#xA;&#xA;&#xA;    return {&#xA;      Nomination: {&#xA;&#xA;        name: this.props.name,&#xA;        description: this.props.description,&#xA;        books: this.props.books,&#xA;&#xA;    },&#xA;      Viewer: {&#xA;      id: this.props.Viewer.id,&#xA;    },&#xA;    };&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is how i call on it. </p>&#xA;&#xA;<pre><code> Relay.Store.commitUpdate(&#xA;        new Nomination_Add( {name: fields.name , description: fields.desc ,Viewer:this.props.Viewer}),&#xA;          {&#xA;            onSuccess: response =&gt; {&#xA;             console.log(response);&#xA;              console.log(response.Nomination_Add);&#xA;            },&#xA;          }&#xA;      );&#xA;</code></pre>&#xA;&#xA;<p>My response object only has the Viewer.id and clientmuationID nothing else. When i call on this mutation via graphql it looks like this. </p>&#xA;&#xA;<pre><code>mutation{&#xA;  Nomination_Add(input:{name:""test"", description:""test"", clientMutationId:""2""}){&#xA;  NominationsEdge{&#xA;    node{&#xA;      Name,&#xA;      Description,&#xA;    Errors {&#xA;      Message&#xA;    }&#xA;      Books{&#xA;        Title&#xA;      }&#xA;    }&#xA;  }&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>with a response of this. </p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""Nomination_Add"": {&#xA;      ""NominationsEdge"": {&#xA;        ""node"": {&#xA;          ""Name"": ""test"",&#xA;          ""Description"": ""test"",&#xA;          ""Errors"": [&#xA;            {&#xA;              ""Message"": ""Nomination Already Exists""&#xA;            }&#xA;          ],&#xA;          ""Books"": []&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can i get my server validation error messages back to the client via relay to write logic against?</p>&#xA;&#xA;<p>also tried this as my fat query </p>&#xA;&#xA;<pre><code> return Relay.QL`&#xA;      fragment on Nomination_AddPayload {&#xA;      NominationsEdge {&#xA;        node{&#xA;            Errors {&#xA;              Message&#xA;            }&#xA;          }&#xA;        },&#xA;        Viewer {&#xA;         Nominations(first:500){&#xA;         edges{&#xA;          node{&#xA;             id,&#xA;            Name,&#xA;            Description&#xA;            }&#xA;          }&#xA;         }&#xA;        }&#xA;      }&#xA;    `;&#xA;</code></pre>&#xA;&#xA;<p>response looks like this: </p>&#xA;&#xA;<pre><code>{,…}&#xA;data&#xA;:&#xA;{Nomination_Add: {clientMutationId: ""0"", Viewer: {id: ""00000000-0000-0000-0000-000000000000""}}}&#xA;Nomination_Add&#xA;:&#xA;{clientMutationId: ""0"", Viewer: {id: ""00000000-0000-0000-0000-000000000000""}}&#xA;Viewer&#xA;:&#xA;{id: ""00000000-0000-0000-0000-000000000000""}&#xA;id&#xA;:&#xA;""00000000-0000-0000-0000-000000000000""&#xA;clientMutationId&#xA;:&#xA;""0""&#xA;</code></pre>&#xA;",1108957,,1108957,2016-08-02 00:10:10,2016-08-02 03:22:05,Relay Mutation with serverside validation,<graphql><relayjs>,2,3,0,2016-08-01 19:07:40
38707233,2,,38706347,0,,"<p>You're not receiving server-side validation error messages because you haven't told Relay that you want them. Take a look at your GraphiQL mutation and your relay mutation's fat query. You have included <code>Errors</code> in the former, but not in the latter.</p>&#xA;&#xA;<p>Include <code>Errors</code> in your relay mutation's (<code>Nomination_addMutation</code>) fat query like below:</p>&#xA;&#xA;<pre><code>fragment on Nomination_AddPayload {&#xA;  NominationsEdge {&#xA;      node {&#xA;        Errors {&#xA;          Message&#xA;        }&#xA;      }&#xA;  },&#xA;  Viewer {&#xA;    Nominations(first:500){&#xA;      edges{&#xA;        node{&#xA;          id,&#xA;          Name,&#xA;          Description&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2821632,,2821632,2016-08-02 03:22:05,2016-08-02 03:22:05,"",,0,4,0,2016-08-01 20:06:14
38745809,1,,,2,423,"<p>Using Relay + GraphQL (graphql-relay-js) connections and trying to determine the best way to optimize queries to the data source etc.</p>&#xA;&#xA;<p>Everything is working, though inefficient when connection results are sliced.  In the below query example, the resolver on item will obtain 200+ records for sale 727506341339, when in reality we only need 1 to be returned.</p>&#xA;&#xA;<p>I should note that in order to fulfill this request we actually make two db queries: &#xA;1. Obtain all items ids associated with a sale&#xA;2. Obtain item data for each item id.</p>&#xA;&#xA;<p>In testing and reviewing of the graphql-relay-js src, it looks like the slice happens on the final connection resolver.</p>&#xA;&#xA;<p>Is there a method provided, short of nesting connections or mutating the sliced results of connectionFromArray, that would allow us to slice the results provided to the connection (item ids) and then in the connection resolver fetch the item details against the already sliced id result set?  This would optimize the second query so we would only need to query for 1 items details, not all items...</p>&#xA;&#xA;<p>Obviously we can implement something custom or nest connections, though it seems this is something that would be avail, thus I feel like I am missing something here...  </p>&#xA;&#xA;<p>Example Query:</p>&#xA;&#xA;<pre><code>query ItemBySaleQuery {&#xA;    viewer {&#xA;      item (sale: 727506341339) {&#xA;        items (first:1){&#xA;          edges {&#xA;            node {&#xA;              dateDisplay,&#xA;              title&#xA;            }&#xA;          }             &#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",3990170,,710693,2017-08-11 00:37:01,2017-12-18 21:03:13,GraphQL + Relay Connection Optimization,<graphql><relayjs><graphql-js>,1,1,0,2016-08-03 14:00:41
38771200,1,,,1,4753,"<p>I have a postgres table that represents a hierarchy with a parent child table:</p>&#xA;&#xA;<p>Table (Categories):</p>&#xA;&#xA;<pre><code>id name parentId&#xA;1  CatA null&#xA;2  CatB null&#xA;3  CatC 1&#xA;4  CatD 1&#xA;5  CatE 3&#xA;</code></pre>&#xA;&#xA;<p>desired result:</p>&#xA;&#xA;<pre><code>categories: &#xA;[&#xA;   {&#xA;      name: ""CatA"",&#xA;      children: [&#xA;      {&#xA;         name: ""CatC"",&#xA;         children: [&#xA;         {&#xA;             name: ""CatE"",&#xA;             children: []&#xA;         }]&#xA;      },&#xA;      {&#xA;         name: ""CatD"",&#xA;         children: [] &#xA;      } &#xA;   ],&#xA;&#xA; },&#xA; {&#xA;       name: ""CatB"",&#xA;       children: []&#xA; }&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>The problem is that I don't know how many levels there are, so I can't query something like:</p>&#xA;&#xA;<pre><code>category {&#xA;  name&#xA;  parent {&#xA;    name&#xA;    parent {&#xA;       name&#xA;       ...&#xA;</code></pre>&#xA;",5661749,,,,2016-12-20 19:25:56,graphql query SQL parent child relationship,<graphql><graphql-js>,2,0,0,2016-08-04 15:12:45
38813032,2,,38769841,1,,"<p><code>Relay.Store</code> is a globally accessible singleton instance of <code>Relay.Environment</code> and <code>Relay.Store.commitUpdate()</code> updates data in that global environment. But since you're using your own instance of <code>Relay.Environment</code>, to update it you need to use <code>this.props.relay.commitUpdate()</code>, as you noted. This updates the environment the container was rendered with.</p>&#xA;&#xA;<p><strong>If need to make mutations from child components of containers</strong>, that are not wrapped in a <code>Relay.Container</code>, there are two ways to do that. You could simply pass the <code>relay</code> prop to them, so in the render function of your container you would have:</p>&#xA;&#xA;<pre><code>&lt;Child relay={this.props.relay} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>However, since those plain components are not in a Relay container, they don't currently need to know anything about Relay. If you want to keep them that way, you could write the method that does the update in your container component like this:</p>&#xA;&#xA;<pre><code>onCreateProfile = () =&gt; {&#xA;  this.props.relay.commitUpdate(new CreateProfile());&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>and only pass a callback to your child component in <code>render</code>:</p>&#xA;&#xA;<pre><code>&lt;Child onCreateProfile={this.onCreateProfile} /&gt;&#xA;</code></pre>&#xA;&#xA;<p><strong>If you need to make a mutation from a component that does not have a <code>Relay.Container</code> above it in the component hierarchy</strong> at all, you could create the <code>Relay.Environment</code> in a shared root component higher up and pass it down using props (or pass a callback using the strategy shown above).</p>&#xA;",1530110,,,,2016-08-07 10:04:58,"",,0,0,0,2016-08-07 10:04:58
38813787,1,38814901,,0,201,"<p>I have mutation (<a href=""https://github.com/calebmer/postgraphql/blob/feat/relay-example/examples/forum-relay/src/mutations.js#L54-L86"" rel=""nofollow noreferrer"">code</a>) in which I want to delete a node. It has a dependency on the post rowId — which is the primary key of the row in the database — and the viewer id. When the pertaining component (<a href=""https://github.com/calebmer/postgraphql/blob/feat/relay-example/examples/forum-relay/src/components/Post.js#L22-L31"" rel=""nofollow noreferrer"">code</a>) gets rendered. The following queries are sent</p>&#xA;&#xA;<pre><code>query Queries {&#xA;  viewer {&#xA;    id,&#xA;    ...F1&#xA;  }&#xA;}&#xA;fragment F0 on Viewer {&#xA;  id&#xA;}&#xA;fragment F1 on Viewer {&#xA;  id,&#xA;  ...F0&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and</p>&#xA;&#xA;<pre><code>query Queries($id_0:ID!) {&#xA;  post(id:$id_0) {&#xA;    id,&#xA;    ...F2&#xA;  }&#xA;}&#xA;fragment F0 on Post {&#xA;  id,&#xA;  rowId&#xA;}&#xA;fragment F1 on Post {&#xA;  rowId,&#xA;  id&#xA;}&#xA;fragment F2 on Post {&#xA;  headline,&#xA;  body,&#xA;  id,&#xA;  ...F0,&#xA;  ...F1&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The response I get includes the <code>viewer.id</code> and <code>post.rowId</code>. As you can see here,</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""post"": {&#xA;      ""id"": ""cG9zdDo0"",&#xA;      ""headline"": ""You hit me with a cricket bat."",&#xA;      ""body"": ""Hello."",&#xA;      ""rowId"": 4&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and here,</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""id"": ""viewer""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However when I want to pass them to the <code>DeletePostMutation</code> like so <code>this.props.post.id</code> they are <code>undefined</code>. When I inspect <code>this.props.post</code>, I get the following</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/8mB2D.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8mB2D.png"" alt=""console""></a></p>&#xA;",1140494,,,,2016-08-07 14:04:53,Why is fragment data fetched but not accessible by Relay mutation,<graphql><relayjs>,1,0,0,2016-08-07 11:45:34
38814901,2,,38813787,5,,"<p>The error suggests that the props passed down to DeletePostMutation is not data fetched by Relay, and looking at the <a href=""https://github.com/calebmer/postgraphql/blob/feat/relay-example/examples/forum-relay/src/components/Post.js#L22-L31"">code</a> it seems you are constructing a new object for the <strong>post</strong> and the <strong>viewer</strong> as opposed to sending the <strong>post and viewer</strong> fetched by relay.</p>&#xA;&#xA;<p>I see you are doing this:</p>&#xA;&#xA;<pre><code>  handleDelete(event) {&#xA;    this.props.relay.commitUpdate(&#xA;      new DeletePostMutation({&#xA;        post: { rowId: this.props.post.rowId },&#xA;        viewer: { id: this.props.viewer.id },&#xA;      })&#xA;    )&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Try this instead:</p>&#xA;&#xA;<pre><code>  handleDelete(event) {&#xA;    this.props.relay.commitUpdate(&#xA;      new DeletePostMutation({&#xA;        post: this.props.post,&#xA;        viewer: this.props.viewer,&#xA;      })&#xA;    )&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Since you are already composing the GraphQL fragments of <strong>DeletePostMutation</strong> inside the <strong>Post Relay Container</strong> then inside DeletePostMutation each prop should have the fields defined in the fragments accessible.</p>&#xA;",522995,,,,2016-08-07 14:04:53,"",,0,1,0,2016-08-07 14:04:53
38815072,2,,38314612,1,,"<p>The RelayQL plugin allows you do this by defining the fragment as a variable. <a href=""https://facebook.github.io/relay/docs/api-reference-relay-ql.html#inline-fragments"" rel=""nofollow"">See example here</a> on the RelayQL documentation page or see example below:</p>&#xA;&#xA;<p>Here I create a fragment on the <strong>Email</strong> type and I can inject that fragment into any field of type <strong>Email</strong> such as the Interview#email or the User#email:</p>&#xA;&#xA;<pre><code>const emailFragment = Relay.QL`&#xA;  fragment on Email {&#xA;    from&#xA;    to&#xA;    body&#xA;    subject&#xA;  }&#xA;`;&#xA;&#xA;export default Relay.createContainer(Component, {&#xA;  initialVariables: {&#xA;    emailId: $emailId&#xA;  },&#xA;  fragments: {&#xA;    interview: () =&gt; Relay.QL`&#xA;      fragment on Interview {&#xA;        recordId&#xA;        email {&#xA;          ${emailFragment}&#xA;        }&#xA;      }&#xA;    `,&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        recordId&#xA;        email(id: $emailId) {&#xA;          ${emailFragment}&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;",522995,,,,2016-08-07 14:22:38,"",,0,1,0,2016-08-07 14:22:38
38881790,2,,38311712,1,,"<p>To avoid this error, set the lastRecord variable as null instead of an empty string.</p>&#xA;&#xA;<pre><code>    initialVariables: {&#xA;      pageSize: 20,&#xA;      lastRecord:null&#xA;    }&#xA;</code></pre>&#xA;",4801797,,,,2016-08-10 19:16:20,"",,0,0,0,2016-08-10 19:16:20
38964786,2,,38495083,-2,,"<p>After many hours of torment solution of the problem above described was found... see below</p>&#xA;&#xA;<p><strong>SOLUTION</strong></p>&#xA;&#xA;<p><strong>client-side mutation</strong></p>&#xA;&#xA;  <pre><code>export default class ApplyFiltersMutation extends Relay.Mutation {&#xA;static fragments = {&#xA;    tips: () =&gt; Relay.QL`&#xA;        fragment on Tips { &#xA;            id &#xA;        }&#xA;    `,&#xA;};&#xA;&#xA;getMutation() {&#xA;    return Relay.QL`mutation {&#xA;        applyFilters&#xA;    }`;&#xA;}&#xA;&#xA;getVariables() {&#xA;    return {&#xA;        filters: this.props.filters&#xA;    };&#xA;}&#xA;&#xA;getFatQuery() {&#xA;    return Relay.QL`&#xA;        fragment on ApplyFiltersPayload {&#xA;            tips&#xA;        }&#xA;    `;&#xA;}&#xA;&#xA;getConfigs() {&#xA;    return [&#xA;        {&#xA;            type: 'FIELDS_CHANGE',&#xA;            fieldIDs: {tips: this.props.tips.id},&#xA;        }&#xA;    ];&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>server-side</strong></p>&#xA;&#xA;<p><strong>home_mutations.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>module HomeMutations&#xA;  ApplyFilters = GraphQL::Relay::Mutation.define do&#xA;    name 'ApplyFilters'&#xA;    input_field :filters, !types.String&#xA;&#xA;    return_field :tips, BipsType&#xA;&#xA;    resolve -&gt; (args, ctx) {&#xA;        filters = args[:filters]&#xA;        begin&#xA;            filters = JSON.parse(filters).deep_symbolize_keys!&#xA;        rescue&#xA;            filters = nil&#xA;        end&#xA;        ctx[:filters] = filters&#xA;&#xA;        {&#xA;            tips: Relay::Tips::STATIC&#xA;        }&#xA;    }&#xA;  end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p><strong>tips_type.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>include TipHelpers::Filter&#xA;&#xA;TipsType = GraphQL::ObjectType.define do&#xA;name 'Tips'&#xA;description 'Tips list for home page'&#xA;interfaces [NodeIdentification.interface]&#xA;global_id_field :id&#xA;&#xA;connection :almostRaised, TipsConnectionType do&#xA;    resolve -&gt;(obj, args, ctx){&#xA;        TipHelpers::Filter.filter(section: 'almost_raised', filters: ctx[:filters], current_user: ctx[:current_user])&#xA;    }&#xA;end&#xA;&#xA;...&#xA;&#xA;end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p><strong>lib/tip_helpers.rb</strong></p>&#xA;&#xA;  <pre class=""lang-ruby prettyprint-override""><code>class TipHelpers&#xA;module Filter&#xA;&#xA;    def filter(section:, filters:, current_user:)&#xA;&#xA;        ...&#xA;&#xA;        # p tips.reorder(reorder).to_sql&#xA;        tips.reorder(reorder)&#xA;    end&#xA;end&#xA;end&#xA;</code></pre>&#xA;",5451913,,,,2016-08-16 00:10:23,"",,0,1,0,2016-08-16 00:10:23
39013808,1,39020135,,2,524,"<p>I'm kinda lost with this issue so any help would be appreciated! So here is the query that I would like to send:</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer{&#xA;    search_places(lat: ""40.7127"", lng: ""-74.0059"", searchType:""all"", searchTerm:""shopping""){&#xA;      edges{&#xA;        node{&#xA;          id,&#xA;          name, &#xA;          lat,&#xA;          lng&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>so far so good, this query is working when I try it on GraphiQL. This query returns a PlaceConnection object. Now I tried to implement the same on React Native with Relay:</p>&#xA;&#xA;<pre><code>class SearchPlacesRoute extends Route {&#xA;  static paramDefinitions = {&#xA;    lat        : { required: true },&#xA;    lng        : { required: true },&#xA;    searchType : { required: true },&#xA;    searchTerm : { required: true }&#xA;  }&#xA;  static queries = {&#xA;    search_places: () =&gt; Relay.QL`&#xA;      query {&#xA;        viewer{&#xA;          search_places(lat: $lat, lng: $lng, searchType: $searchType, searchTerm: $searchTerm) &#xA;        }&#xA;      }&#xA;      `&#xA;  }&#xA;  static routeName = 'SearchPlacesRoute'&#xA;}&#xA;&#xA;class SearchPlacesComponent extends Component {&#xA;  render () {&#xA;    const places = this.props.search_places;&#xA;    console.log(places);&#xA;    for (var index = 0; index &lt; places.length; index++) {&#xA;        var element = places[index];&#xA;        console.log(element);&#xA;      }&#xA;    return (&#xA;      &lt;View&gt;&#xA;        &lt;Text&gt;email: {places[0].name}&lt;/Text&gt;&#xA;      &lt;/View&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;SearchPlacesComponent = Relay.createContainer(SearchPlacesComponent, {&#xA;  fragments: {&#xA;    search_places: () =&gt; Relay.QL`&#xA;      fragment on PlaceConnection {&#xA;          edges &#xA;          {&#xA;            node &#xA;            {&#xA;              id,&#xA;              name,&#xA;              lat,&#xA;              lng&#xA;            }&#xA;          }&#xA;        }&#xA;      `&#xA;  }&#xA;}) &#xA;&#xA;&lt;RootContainer&#xA;  Component={SearchPlacesComponent}&#xA;  route={new SearchPlacesRoute({lat:""40.7127"", lng: ""-74.0059"", searchType:""all"",searchTerm: ""shopping""})}&#xA;  renderFetched={(data) =&gt; &lt;SearchPlaces {...this.props} {...data} /&gt;}/&gt;&#xA;</code></pre>&#xA;&#xA;<p>but when I try to grab the data with this I get the following error: </p>&#xA;&#xA;<pre><code>1. Objects must have selections (field 'search_places' returns PlaceConnection but has no selections)&#xA;       _search_places40zPNn:search_places(lat:""40.7127"",lng:""-7&#xA;       ^^^&#xA;2. Fragment F0 on PlaceConnection can't be spread inside Viewer&#xA;       ...F0&#xA;       ^^^&#xA;</code></pre>&#xA;&#xA;<p>So I examined what's actually sent to the server:&#xA;<a href=""https://i.stack.imgur.com/aLpef.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aLpef.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>and it seems to me that the fragment is sent as a separate query instead of a selection. Any idea why is this happening or how can I avoid this behaviour?</p>&#xA;&#xA;<p><strong>EDIT:</strong></p>&#xA;&#xA;<p>here is my final code - hope it'll be helpful for some:&#xA;<a href=""https://gist.github.com/adamivancza/586c42ff8b30cdf70a30153944d6ace9"" rel=""nofollow noreferrer"">https://gist.github.com/adamivancza/586c42ff8b30cdf70a30153944d6ace9</a></p>&#xA;",851490,,851490,2016-08-19 16:33:09,2016-08-19 16:33:09,React Native graphql query with relay not working,<reactjs><react-native><graphql><relayjs>,1,0,0,2016-08-18 08:52:26
39020135,2,,39013808,2,,"<p>I think the problem is that your Relay Route is too deep. Instead, define your route to just query against <code>viewer</code>:</p>&#xA;&#xA;<pre><code>class SearchPlacesRoute extends Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      query {&#xA;        viewer&#xA;      }&#xA;      `&#xA;  }&#xA;  static routeName = 'SearchPlacesRoute'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then, inside of your component, define it as a <code>fragment on viewer</code>, instead of on <code>PlaceConnection</code>:</p>&#xA;&#xA;<pre><code>SearchPlacesComponent = Relay.createContainer(SearchPlacesComponent, {&#xA;  initialVariables: { lat: ""..."" /* TODO */ },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on viewer {&#xA;        search_places(lat: $lat, lng: $lng, searchType: $searchType, searchTerm: $searchTerm) {&#xA;            edges &#xA;            {&#xA;              node &#xA;              {&#xA;                id,&#xA;                name,&#xA;                lat,&#xA;                lng&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      `&#xA;  }&#xA;}) &#xA;</code></pre>&#xA;&#xA;<p>You'll need to move the variables (<code>$lag</code>, <code>$lng</code>, etc) to be defined as part of the container, instead of being defined as part of the route. But I think that should fix your problem.</p>&#xA;",490561,,,,2016-08-18 13:57:03,"",,0,2,0,2016-08-18 13:57:03
39040741,1,,,0,759,"<p>I have query related to Relay mutation please have a look&#xA;I am trying to update amount field from a settings collection but without page refresh .Value got updated but page is refreshing every time.&#xA;Can anyone give me any suggestions?</p>&#xA;&#xA;<p>Below is my schema.js</p>&#xA;&#xA;<pre><code>var settingType = new GraphQLObjectType({&#xA;  name: 'Setting',&#xA;  fields: {&#xA;    _id: {&#xA;      type: new GraphQLNonNull(GraphQLID)&#xA;    },&#xA;    id: globalIdField('Setting'),&#xA;    amount: {&#xA;      type: GraphQLString&#xA;    },&#xA;  },&#xA;  interfaces: [nodeInterface]&#xA;});&#xA;&#xA;var Root = new GraphQLObjectType({&#xA;  name: 'Root',&#xA;  fields: () =&gt; ({&#xA;    setting: {&#xA;      type: settingType,&#xA;      args: {&#xA;         ...connectionArgs,&#xA;          currency: {type: GraphQLString}&#xA;        },&#xA;      resolve: (rootValue, args) =&gt; {&#xA;       return getSetting(args.currency).then(function(data){&#xA;        return data[0];&#xA;       }).then(null,function(err){&#xA;        return err;&#xA;       });&#xA;      }&#xA;    },&#xA;  })&#xA;});&#xA;&#xA;let EditAmountMutation = mutationWithClientMutationId({&#xA;  name: 'EditAmount',&#xA;  inputFields: {&#xA;    amount: { type: new GraphQLNonNull(GraphQLString) },&#xA;  },&#xA;  outputFields: {&#xA;    viewer: {&#xA;      type: settingType,&#xA;      resolve: () =&gt; {&#xA;        return getSettingedit().then(function(data){&#xA;          return data.setting[0]&#xA;        })&#xA;      },&#xA;    },&#xA;  },&#xA;  mutateAndGetPayload: ({amount}) =&gt; {&#xA;     return  EditAmount({amount}).then(function(data){&#xA;      return data.setting&#xA;     })&#xA;  },&#xA;});&#xA;&#xA;export var schema = new GraphQLSchema({&#xA;  query: Root,&#xA;  mutation: new GraphQLObjectType({&#xA;    name: 'Mutation',&#xA;    fields: () =&gt; ({&#xA;      EditAmount: EditAmountMutation,&#xA;    })&#xA;  })&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And below is my EditAmountMutation.js file</p>&#xA;&#xA;<pre><code>import Relay from ""react-relay"";&#xA;&#xA;class EditAmountMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Setting {&#xA;        amount,&#xA;      }&#xA;    `,&#xA;  };&#xA;  getMutation() {&#xA;    return Relay.QL`&#xA;      mutation { EditAmount }&#xA;    `;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      amount: this.props.amount,&#xA;    }&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on EditAmountPayload{&#xA;        viewer{&#xA;          id,&#xA;          amount&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {&#xA;        viewer: this.props.viewer,&#xA;      },&#xA;    }]&#xA;  }&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      viewer: {&#xA;        amount: this.props.amount,&#xA;      },&#xA;    };&#xA;  }&#xA;}&#xA;&#xA;export default EditAmountMutation;&#xA;</code></pre>&#xA;&#xA;<p>and below is my view page Setting.js</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import EditAmountMutation from ""../mutations/EditAmountMutation"";&#xA;import Relay from 'react-relay';&#xA;&#xA;class Setting extends Component {&#xA;&#xA;    handleSubmitt = (e) =&gt; {&#xA;    Relay.Store.commitUpdate(&#xA;      new EditAmountMutation({&#xA;        viewer: this.props.viewer,&#xA;        amount: this.refs.amount.value,&#xA;      }),&#xA;    );&#xA;    this.refs.amount.value = """";&#xA;  }&#xA;  render() {&#xA;    let viewer =this.props.viewer;&#xA;    return (&#xA;      &lt;div className=""col-md-4 col-md-offset-4""&gt;&#xA;        &lt;form onSubmit={this.handleSubmitt} className=""settingForm photo-gallry""&gt;&#xA;            &lt;div className=""form-group""&gt;&#xA;                &lt;label&gt;Current Amount:&amp;nbsp;&amp;nbsp;&lt;/label&gt;&#xA;                &lt;span&gt;{viewer.amount}&lt;/span&gt;&#xA;              &lt;/div&gt;&#xA;              &lt;div className=""form-group""&gt;&#xA;                &lt;label&gt;Change Amount&lt;/label&gt;&#xA;                &lt;input className=""form-control"" type=""text"" required placeholder=""Amount"" ref=""amount"" /&gt;&#xA;              &lt;/div&gt;&#xA;              &lt;button className=""btn btn-primary allbtn-btn"" type=""submit""&gt;Submit&lt;/button&gt;&#xA;            &lt;/form&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(Setting, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Setting {&#xA;        id,&#xA;        amount,&#xA;        ${EditAmountMutation.getFragment('viewer')}&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And below is route.js file</p>&#xA;&#xA;<pre><code>const SettingQueries = {&#xA; viewer: () =&gt; Relay.QL`query{&#xA;  setting(currency: ""USD"")&#xA; }`,&#xA;}&#xA;&#xA;export default [{&#xA;  path: '/',&#xA;  component: App,&#xA;  queries: UserQueries,PostQueries,SettingQueries,&#xA;  indexRoute: {&#xA;    component: IndexBody,&#xA;  },&#xA;  childRoutes: [{&#xA;    path: 'settings',&#xA;    component: Setting,&#xA;    queries: SettingQueries,&#xA;  }]&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>below is database.js</p>&#xA;&#xA;<pre><code>export function getSetting(params) {&#xA;  // console.log(""getSetting"",params)&#xA;  return Setting.find({currency: ""USD""})&#xA;  .exec()&#xA;  .then(function(setting) {&#xA;    return setting;&#xA;  });&#xA;}&#xA;&#xA;export function EditAmount(params) {&#xA;  // console.log(params)&#xA;  return Setting.findOneAndUpdate({currency: ""USD""}, {$set:{amount:params.amount}}, {new: true}, function(err, setting){&#xA;    if (err) return err;&#xA;      return setting;&#xA;  });&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Also things are working on /graphql As</p>&#xA;&#xA;<pre><code>mutation EditAmountMutation($input:EditAmountInput!) {&#xA;  EditAmount(input:$input) {&#xA;    clientMutationId,&#xA;    viewer{&#xA;      amount&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;{&#xA;  ""input"": {&#xA;    ""clientMutationId"": ""32"",&#xA;    ""amount"": ""222""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and got output as below</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""EditAmount"": {&#xA;      ""clientMutationId"": ""32"",&#xA;      ""viewer"": {&#xA;        ""amount"": ""222""&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but network tab of my JavaScript console shows this as post request&#xA;<a href=""https://i.stack.imgur.com/LXeI4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LXeI4.png"" alt=""console log""></a></p>&#xA;",3668479,,3668479,2016-08-19 14:01:32,2016-08-22 18:04:01,Relay Mutation is not working dynamically,<node.js><reactjs><graphql><relayjs><relay>,1,4,0,2016-08-19 13:49:55
39076905,2,,39040741,2,,"<p>In <em>EditAmountMutation.js</em> file, fix the <code>getConfigs</code> function. Instead of providing an ID of viewer, you have provided the whole object. Change to this:</p>&#xA;&#xA;<pre><code>fieldIDs: {&#xA;  viewer: this.props.viewer.id,&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>Also, include <code>id</code> to the <code>fragments</code> property, because the mutation has a dependency on viewer:</p>&#xA;&#xA;<pre><code>static fragments = {&#xA;  viewer: () =&gt; Relay.QL`&#xA;      fragment on Setting {&#xA;        id,&#xA;        amount,&#xA;    }&#xA;  `,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>See <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#a-complete-example"" rel=""nofollow"">the mutation example</a> in the documentation.</p>&#xA;",2821632,,2821632,2016-08-22 18:04:01,2016-08-22 18:04:01,"",,0,3,0,2016-08-22 10:15:57
39104307,1,,,0,209,"<p>My question is: i have a mutations config where i have a REQUIRE_CHILDREN config with children array of queries. How can i get all possible fields from a payload object? </p>&#xA;&#xA;<pre><code>{&#xA; type: 'REQUIRED_CHILDREN',&#xA; children: [&#xA;  Relay.QL`&#xA;   fragment on MyPayload {&#xA;     me {&#xA;       id&#xA;       ...others field&#xA;     }&#xA;   }`]&#xA;</code></pre>&#xA;&#xA;<p>So how can i ask all possible fields from <code>me</code> object? If i point only <code>fragment on MePayload { me }</code> object relay still returns me <code>me { id }</code>. I want relay to return me all fields in <code>me</code> object. Thanks.</p>&#xA;",3683376,,3683376,2016-08-23 16:40:01,2016-08-25 03:07:17,Relay mutation. FatQuery. Ask all fields in REQUIRED_CHILDREN,<reactjs><graphql><relayjs>,1,0,0,2016-08-23 14:45:16
39112272,1,39133447,,2,707,"<p>I'm working on converting a Flux app to Relay.js and I'm running into some issues. I can't seem to get component fragment composition to work properly. The correct data comes back from the server, but the composed data is never passed back into the props of the parent component for some reason.</p>&#xA;&#xA;<p>here's my code so far: </p>&#xA;&#xA;<p><strong>LibraryLongDescription.js</strong></p>&#xA;&#xA;<pre><code>import React, {Component, PropTypes} from 'react';&#xA;import Relay from 'react-relay';&#xA;import DocumentTitle from 'react-document-title';&#xA;import Address from '../components/Address';&#xA;import Orders from '../pages/Orders';&#xA;&#xA;export default class LibraryLongDescription extends Component {&#xA;    constructor(props)&#xA;    {&#xA;        super(props);&#xA;&#xA;        this.state = {&#xA;            library: {}&#xA;        };&#xA;&#xA;        console.log(props);&#xA;        if(props.library){&#xA;            this.state.library = props.library;&#xA;        }&#xA;    }&#xA;&#xA;    render()&#xA;    {&#xA;        return (&#xA;            &lt;DocumentTitle title=""Libraries""&gt;&#xA;                &lt;div&gt;&#xA;                    {this.state.library.name}&#xA;                    &lt;div className=""row""&gt;&#xA;                        &lt;Address type={""Address""} address={this.state.library.address} /&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div className=""top-space-60""&gt;&#xA;                        &lt;h3&gt;Orders&lt;/h3&gt;&#xA;                        &lt;Orders /&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/DocumentTitle&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;&#xA;export default Relay.createContainer(LibraryLongDescription, {&#xA;    fragments: {&#xA;        library: () =&gt; Relay.QL`fragment on Library {&#xA;            id,&#xA;            name,&#xA;            address{&#xA;                id&#xA;                sanNumber,&#xA;                addressLine1,&#xA;                addressLine2,&#xA;                city,&#xA;                state,&#xA;                zip&#xA;            },&#xA;            ${Orders.getFragment('orders')}&#xA;        }`,&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>Orders.js</strong></p>&#xA;&#xA;<pre><code>import React, {Component, PropTypes} from 'react';&#xA;import Relay from 'react-relay';&#xA;&#xA;class Orders extends Component {&#xA;    constructor(props)&#xA;    {&#xA;        super(props);&#xA;        console.log(props);&#xA;    }&#xA;&#xA;    render()&#xA;    {&#xA;        return (&lt;h1&gt;This is where the order goes&lt;/h1&gt;);&#xA;    }&#xA;}&#xA;&#xA;export default Relay.createContainer(Orders, {&#xA;    fragments: {&#xA;        orders: () =&gt; Relay.QL`fragment on Library {&#xA;            orders(first: 10){&#xA;                edges{&#xA;                    node{&#xA;                        id,&#xA;                        message_number,&#xA;                        order_total&#xA;                    }&#xA;                }&#xA;                pageInfo{&#xA;                    hasPreviousPage,&#xA;                    hasNextPage&#xA;                }&#xA;            }&#xA;        }`&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>This does not resolve correctly. When I console log props in LibraryLongDescription.js I get all the values from that query, but I don't get anything from the Orders fragment. When I look to see what came over the network I get data in this form: </p>&#xA;&#xA;<pre><code>{  &#xA;   ""data"":{  &#xA;      ""library"":{  &#xA;         ""id"":""valid"",&#xA;         ""name"":""valid"",&#xA;         ""address"":{  &#xA;            correct data&#xA;         },&#xA;         ""_orders1mpmPX"":{  &#xA;            ""edges"":[  &#xA;               {  &#xA;                  ""node"":{  &#xA;                     correct data&#xA;                  },&#xA;                  ""cursor"":""correct data""&#xA;               },&#xA;            ],&#xA;            ""pageInfo"":{  &#xA;               correct data&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but when I console log props from library Long description I don't see anything for orders. I also get this property: <code>__fragment__</code> which seems to not really have anything useful on it. Any help with this would be greatly appreciated. I've been searching the internet for solutions for hours. If there's any info I did not provide that would be of use let me know. </p>&#xA;",348671,,348671,2016-08-29 16:25:59,2016-08-29 16:25:59,Relay.js is not resolving composed fragment correctly,<javascript><reactjs><graphql><relayjs>,1,4,0,2016-08-23 23:35:17
39133447,2,,39112272,5,,"<p>After spending a stupid amount of time trying to solve this issue I have discovered relay does not like you defining a type field in a fragment query. here's what I mean... the library query changed to this: </p>&#xA;&#xA;<pre><code>export default Relay.createContainer(LibraryLongDescription, {&#xA;    fragments: {&#xA;        library: () =&gt; Relay.QL`&#xA;            fragment on Library {&#xA;                id,&#xA;                name,&#xA;                address{&#xA;                    id&#xA;                    sanNumber,&#xA;                    addressLine1,&#xA;                    addressLine2,&#xA;                    city,&#xA;                    state,&#xA;                    zip&#xA;                },&#xA;                orders(first: 500){&#xA;                    ${Orders.getFragment('orders')}&#xA;                }&#xA;            }&#xA;        `,&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>and the orders query changed to this: </p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Orders, {&#xA;    fragments: {&#xA;        orders: () =&gt; Relay.QL`fragment on OrderConnection {&#xA;            edges{&#xA;                node{&#xA;                    id&#xA;                    purchaseDate&#xA;                }&#xA;            }&#xA;            pageInfo{&#xA;                hasPreviousPage&#xA;                hasNextPage&#xA;            }&#xA;        }`&#xA;    },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>if you don't have some sort of root field like orders defined on the parent, relay won't know how to resolve that field back to the parent to be passed back into your child component. by doing this: <code>orders(first: 500)</code> you are declaring that name as a dependency for relay to pass it into that component. Without that name relay does not see your component requiring that name and it won't pass it.  I hope this helps someone else out someday. I spent more than a full day trying to figure this one out. </p>&#xA;",348671,,,,2016-08-24 21:40:06,"",,0,0,0,2016-08-24 21:40:06
39136082,2,,39104307,0,,"<p>You can't - your client code needs to specify all the fields you want to fetch explicitly. Those fields are then statically validated by the <code>babel-relay-plugin</code>, etc.</p>&#xA;&#xA;<p>You probably don't want to be using <code>REQUIRED_CHILDREN</code> either, by the way. That's only useful to fetch fields that are <em>only</em> accessible in the <code>onSuccess</code> callback of the mutation, and therefore are never written to the Relay store and accessible to Relay containers...</p>&#xA;",1750095,,,,2016-08-25 03:07:17,"",,0,3,0,2016-08-25 03:07:17
39142921,2,,39133634,2,,"<p>Is your Relay container fetching the <code>User</code> fragment correctly? I see in your <code>static fragments</code> definition fragment on User is only id field, so I wonder if your parent Relay component is fetching them all.</p>&#xA;&#xA;<p>Since your mutation is really dependent on those fields, add them to <code>fragments</code> property.</p>&#xA;&#xA;<pre><code>class UserMutation extends Relay.Mutation {&#xA;    public getMutation() { ... }&#xA;&#xA;    // getVariables, FatQuery and Configs ...&#xA;&#xA;    static fragments = {&#xA;      user: () =&gt; Relay.QL`&#xA;          fragment on User {&#xA;              id,&#xA;              loginName,&#xA;              firstName,&#xA;              lastName,&#xA;              mail&#xA;          }&#xA;      `&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then try including this fragment in Relay component, which uses your mutation.&#xA;Example React-Relay component:</p>&#xA;&#xA;<pre><code>import UserMutation from 'mutations/user';&#xA;&#xA;class User extends Component {&#xA;  commit(e) {&#xA;    Relay.Store.commitUpdate(&#xA;      new UserMutation({&#xA;        user: this.props.user&#xA;      })&#xA;    );&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;Hello&lt;/div&gt;&#xA;    );&#xA;  }&#xA;};&#xA;&#xA;export default Relay.createContainer(User, {&#xA;  fragments: {&#xA;    user: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        ${UserMutation.getFragment('user')}&#xA;      }&#xA;    `,&#xA;  }&#xA;});&#xA;</code></pre>&#xA;",3042366,,,,2016-08-25 10:32:53,"",,0,3,0,2016-08-25 10:32:53
39289131,1,39302914,,1,179,"<p>I have the following query:</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer{&#xA;    place(id: ""1a4871311fe990d6d94cf1eed9fd65008856e118b790e7dcf728d86bc3aef7ec""){&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which of course works correctly on GraphiQL. I would like to use this query in a Relay container so I've created a RootContainer:</p>&#xA;&#xA;<pre><code>&lt;RootContainer&#xA;  Component={PlaceDetailsComponent}&#xA;  route={new PlaceDetailsRoute({placeID: this.props.id})}&#xA;  renderFetched={(data) =&gt; {&#xA;    console.log('data: ', data);&#xA;    return (&#xA;      &lt;PlaceDetailsComponent {...this.props} {...data}/&gt;&#xA;    )&#xA;  } }&#xA;  renderLoading={() =&gt; &lt;ProgressBar visible={true} /&gt;}/&gt;&#xA;</code></pre>&#xA;&#xA;<p>which successfully fetches the data but all I can see on console is this:</p>&#xA;&#xA;<pre><code>data:  { placeID: '1a4871311fe990d6d94cf1eed9fd65008856e118b790e7dcf728d86bc3aef7ec',&#xA;  viewer: &#xA;   { __dataID__: 'Vmlld2VyLXs6aWQ9PiJ2aWV3ZXIifQ==',&#xA;     __fragments__: { '1::client': [ {} ] } } }&#xA;</code></pre>&#xA;&#xA;<p>So I checked out what's actually sent to server and what's received and all seems right to me:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/pcHzt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pcHzt.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>Here is my route:</p>&#xA;&#xA;<pre><code>import Relay, { &#xA;  Route&#xA;} from 'react-relay';&#xA;&#xA;class PlaceDetailsRoute extends Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      query {&#xA;        viewer &#xA;      }&#xA;      `&#xA;  }&#xA;  static routeName = 'PlaceDetailsRoute'&#xA;}&#xA;&#xA;export default PlaceDetailsRoute;&#xA;</code></pre>&#xA;&#xA;<p>and here is my fragment:</p>&#xA;&#xA;<pre><code>Relay.createContainer(PlaceDetailsContainer, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer  {&#xA;        place(id: ""1a4871311fe990d6d94cf1eed9fd65008856e118b790e7dcf728d86bc3aef7ec"") {&#xA;          name,&#xA;        }&#xA;      }&#xA;      `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Any suggestions what should I change? Thanks in advance for any help!</p>&#xA;",851490,,851490,2016-09-02 09:43:28,2016-09-03 03:19:22,React Native graphql query with relay: fetched data not received,<react-native><graphql><relayjs><relay>,1,2,0,2016-09-02 09:34:56
39302914,2,,39289131,2,,"<p>That's actually expected behavior. The <a href=""https://facebook.github.io/relay/docs/guides-root-container.html#renderfetched"" rel=""nofollow"">Relay documentation of <code>renderFetched</code></a> has a note:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Even though we have access to the <code>data</code> object in <code>renderFetched</code>, the actual data is intentionally opaque. This prevents the <code>renderFetched</code> from creating an implicit dependency on the fragments declared by <code>Component</code>.</p>&#xA;</blockquote>&#xA;&#xA;<p>Hope this clears up your confusion.</p>&#xA;",2821632,,,,2016-09-03 03:19:22,"",,0,1,0,2016-09-03 03:19:22
39364586,2,,39354743,0,,"<p>The <a href=""https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getfatquery-abstract-method"" rel=""nofollow""><code>getFatQuery</code></a> method in a mutation tells relay what could change as a result of a mutation. Together with <a href=""https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getconfigs-abstract-method"" rel=""nofollow""><code>getConfigs</code></a> and your <strong>local graph</strong> data it will construct a mutation query that will get the data you need (without over-/underfetching).</p>&#xA;&#xA;<p>Depending on your graph structure this could look different but here is an example to illustrate. Lets assume that d2 is a todo item and d1 is the List of todos.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class UpdateTodoMutation extends Relay.Mutation {&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on updateTodoPayload {&#xA;        todo {&#xA;          title,&#xA;          dueDate,&#xA;          completed,&#xA;        }&#xA;        viewer {&#xA;          todos,&#xA;        },&#xA;      }&#xA;    `;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For an extensive look at Relay mutation take a look at this blog post — <a href=""http://blog.pathgather.com/blog/a-beginners-guide-to-relay-mutations"" rel=""nofollow"">http://blog.pathgather.com/blog/a-beginners-guide-to-relay-mutations</a> and the relay <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#content"" rel=""nofollow"">documentation</a>.</p>&#xA;",1140494,,,,2016-09-07 08:13:50,"",,0,2,0,2016-09-07 08:13:50
39469307,1,,,1,84,"<p>I recently start using React.js I start using the flux pattern which make it easy for me to create project structure and development workflow I mean am confidant to start by </p>&#xA;&#xA;<ol>&#xA;<li>creating an action</li>&#xA;<li>dispatch it to dispatcher </li>&#xA;<li>call a store</li>&#xA;<li>update view</li>&#xA;</ol>&#xA;&#xA;<p>However, when start using Relay am not sure about the development flow any more, I can start by creating component then GraphQL schema or the reverse. I did not find any digram explain the flow so my question is what the Relay development workflow !</p>&#xA;",3462064,,3462064,2016-09-13 11:53:41,2016-09-13 11:53:41,What is the work flow for Relay and React,<reactjs><graphql><relay>,0,0,0,2016-09-13 11:48:29
39474672,1,,,0,523,"<p>I don't use Relay container, because I'd like to have more control over components. Instead of it I use HOC + <code>Relay.Store.forceFetch</code>, that fetches any given query with variables. So I have the following query:</p>&#xA;&#xA;<pre><code>query {&#xA;    root {&#xA;      search(filter: $filter) {&#xA;        selectors {&#xA;          _id,&#xA;          data {&#xA;            title,&#xA;            status&#xA;          }&#xA;        },&#xA;        selectorGroups {&#xA;          _id,&#xA;          data {&#xA;            title,&#xA;          }&#xA;        }&#xA;      }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I have to do some mutation on <code>selector</code> type. </p>&#xA;&#xA;<pre><code>export default class ChangeStatusMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {selectors_status_mutation}`;&#xA;  }&#xA;  getVariables() {&#xA;    return {&#xA;      id: this.props.id,&#xA;      status: this.props.status&#xA;    };&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on selectors_status_mutationPayload{&#xA;        result {&#xA;          data {&#xA;            status&#xA;          }&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;  static fragments = {&#xA;    result: () =&gt; Relay.QL`&#xA;      fragment on selector {&#xA;        _id,&#xA;        data {&#xA;          title,&#xA;          status&#xA;        }&#xA;      }`,&#xA;  };&#xA;&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      result: {&#xA;        _id: this.props.id,&#xA;        data: {&#xA;          status: this.props.status&#xA;        }&#xA;      }&#xA;    };&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {&#xA;        result: this.props.id&#xA;      },&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Call mutation in component:</p>&#xA;&#xA;<pre><code>const mutation = new ChangeStatusMutation({id, status, result: selector});&#xA;Relay.Store.commitUpdate(mutation);&#xA;</code></pre>&#xA;&#xA;<p>After mutation commitment selector in Relay storage is not changed. I guess that's because of empty <code>Tracked Fragment Query</code> and mutation performs without any fields:</p>&#xA;&#xA;<pre><code>ChangeStatusMutation($input_0:selectors_statusInput!) {&#xA;  selectors_status_mutation(input:$input_0) {&#xA;    clientMutationId&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But the modifying selector was already fetched by Relay, and I pass it to the mutation with props. So Relay knows the type, that should be changed, how to find the item and which fields should be replaced. But can not intersect. What's wrong?</p>&#xA;",1230175,,,,2016-09-15 00:14:47,Relay mutation fragments intersection,<graphql><relayjs><relay>,1,0,0,2016-09-13 16:16:19
39501442,2,,39474672,1,,"<p>So, you're definitely a bit ""off the ranch"" here by avoiding Relay container, but I think this should still work...</p>&#xA;&#xA;<p>Relay performs the query intersection by looking up the node indicated by your <code>FIELDS_CHANGE</code> config. In this case, your <code>fieldIDs</code> points it at the  <code>result</code> node with ID <code>this.props.id</code>.</p>&#xA;&#xA;<p>Are you sure you have a node with that ID in your store? I'm noticing that in your <code>forceFetch</code> query you fetch some kind of alternative <code>_id</code> but not actually fetching <code>id</code>. Relay requires an <code>id</code> field to be present on anything that you later want to refetch or use the declarative mutation API on...</p>&#xA;&#xA;<p>I'd start by checking the query you're sending to fetch whatever this <code>result</code> type is. I don't see you fetching that anywhere in your question description, so I'm just assuming that maybe you aren't fetching that right now?</p>&#xA;",1750095,,,,2016-09-15 00:14:47,"",,0,3,0,2016-09-15 00:14:47
39505284,1,,,0,934,"<p>I am having a really hard time trying to get my head around Relay routes, react-router params and building the queries and containers in general! </p>&#xA;&#xA;<p>I want to edit a Feature when the user clicks on a specific Feature in a FeatureList. It passes a param called ""id"" which is the id of the Feature in Route.js </p>&#xA;&#xA;<pre><code>  &lt;Route path='/' component={AppComponent} queries={ViewerQuery}&gt;&#xA;    &lt;IndexRoute component={FeaturesContainer} queries={ViewerQuery} /&gt;&#xA;    &lt;Route path='/feature' component={FeatureComponent} queries={ViewerQuery} /&gt;&#xA;    &lt;Route path=""/feature/edit/:id"" component={FeatureEditComponent} queries={FeatureQuery}/&gt;&#xA;    &lt;Redirect from='*' to='/' /&gt;&#xA;  &lt;/Route&gt;&#xA;</code></pre>&#xA;&#xA;<p>In my FeatureQuery file I have the following query:</p>&#xA;&#xA;<pre><code>export default {&#xA;  viewer: (Component) =&gt; Relay.QL`&#xA;    query {&#xA;      viewer {&#xA;        ${Component.getFragment('viewer')}&#xA;      }&#xA;    }&#xA;  `&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>At this point I am completely stuck. How do I expand this to include the ""id"" and query the features using the ""id""?&#xA;And what would the relating relay container fragment be shaped like? I only see examples going one level deep. </p>&#xA;&#xA;<p>I tried this but I know it isn't right:</p>&#xA;&#xA;<pre><code>export default {&#xA;    feature: (Component) =&gt; Relay.QL`&#xA;        query {&#xA;            viewer {&#xA;                features(id:$id) {&#xA;                  ${Component.getFragment('feature')}&#xA;                }&#xA;            }&#xA;        }&#xA;    `&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>This is the current relay container that gets a list of the Features, how would this be modified to just return the 1 feature by id? :</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(CreativeEditComponent, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;        fragment on User {&#xA;        id,&#xA;        features(first: 20) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;              description&#xA;&#xA;            }&#xA;          }&#xA;        }&#xA;      }`&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>I have tested a query in GraphiQL and it works as expected:</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    features(id:""1"") {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          name&#xA;          description&#xA;        } &#xA;      }&#xA;    } &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Result:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""features"": {&#xA;        ""edges"": [&#xA;          {&#xA;            ""node"": {&#xA;              ""id"": ""Q3JlYXRpdmU6MQ=="",&#xA;              ""name"": ""React"",&#xA;              ""description"": ""A JavaScript library for building user interfaces.""&#xA;            }&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>schema.js:</p>&#xA;&#xA;<pre><code>const userType = new GraphQLObjectType({&#xA;  name: 'User',&#xA;  description: 'A person who uses our app',&#xA;  fields: () =&gt; ({&#xA;    id: globalIdField('User'),&#xA;&#xA;    features: {&#xA;      type: featureConnection,&#xA;      description: 'Features that I have',&#xA;      //args: connectionArgs,&#xA;&#xA;      args: {&#xA;        id: {&#xA;          type: GraphQLString,&#xA;        },&#xA;        after: {&#xA;          type: GraphQLString,&#xA;        },&#xA;        first: {&#xA;          type: GraphQLInt,&#xA;        },&#xA;        before: {&#xA;          type: GraphQLString,&#xA;        },&#xA;        last: {&#xA;          type: GraphQLInt,&#xA;        },&#xA;      },&#xA;&#xA;      resolve: (_, args) =&gt; {&#xA;        return resolveGetFeatures(args)&#xA;      },&#xA;    },&#xA;&#xA;&#xA;  }),&#xA;  interfaces: [nodeInterface]&#xA;});&#xA;&#xA;&#xA;&#xA;const featureType = new GraphQLObjectType({&#xA;  name: 'Feature',&#xA;  description: 'Feature integrated in our starter kit',&#xA;  fields: () =&gt; ({&#xA;    id: globalIdField('Feature'),&#xA;    name: {&#xA;      type: GraphQLString,&#xA;      description: 'Name of the feature'&#xA;    },&#xA;    description: {&#xA;      type: GraphQLString,&#xA;      description: 'Description of the feature'&#xA;    }&#xA;  }),&#xA;  interfaces: [nodeInterface]&#xA;});&#xA;</code></pre>&#xA;",2970221,,2030321,2017-10-09 15:04:23,2017-10-09 15:04:23,"How to fetch and display item by id using Relay container, react-router and GraphQL",<javascript><react-router><graphql><relayjs><react-router-relay>,1,0,0,2016-09-15 07:26:58
39545844,1,39579447,,3,1163,"<p>I'm attempting to make a infinite scroll pagination in my React-Relay frontend, but without a success.</p>&#xA;&#xA;<p>At this moment, I have this React component ...</p>&#xA;&#xA;<pre><code>class List extends Component {&#xA;  state = { loading: false };&#xA;&#xA;  componentDidMount() {&#xA;    window.onscroll = () =&gt; {&#xA;      if (!this.state.loading&#xA;              &amp;&amp; (window.innerHeight + window.scrollY)&#xA;              &gt;= document.body.offsetHeight) {&#xA;&#xA;        this.setState({loading: true}, () =&gt; {&#xA;          this.props.relay.setVariables({&#xA;            count: this.props.relay.variables.count + 5&#xA;          }, (readyState) =&gt; {&#xA;            if (readyState.done) {&#xA;              this.setState({ loading: false });&#xA;            }&#xA;          });&#xA;        });&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {this.props.viewer.products.edges.map(function(product, i) {&#xA;          return (&lt;Item key={i} product={product.node} /&gt;);&#xA;        })}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>... wrapped in Relay container</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(List, {&#xA;  initialVariables: {&#xA;    count: 5&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        products(first: $count) {&#xA;          total&#xA;          edges {&#xA;            node {&#xA;              ${Item.getFragment('product')}&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The logic behind this seems quite easy. If you reach a certain <code>scrollY</code> position, set to <code>count</code> variable a new inceremented value, which extends your list of Edges.</p>&#xA;&#xA;<p>But this concept will lead to a situation, where in the beginning I query the database for first 5 records, but lately while I keep scrolling a will query for N+5 records. In the end I will query the database for a whole table (thousands of records)! Which is quite unacceptable.</p>&#xA;&#xA;<p>So I'm trying to implement a <code>cursors</code>, but I don't know how to just fetch data from a connection and extend the result. This approach returns me a <em>""paginated""</em> list.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>Also, the above code gives me this error, when I scroll down</p>&#xA;&#xA;<blockquote>&#xA;  <p>resolveImmediate.js?39d8:27 Uncaught Invariant Violation: performUpdateIfNecessary: Unexpected batch number (current 19, pending 18)</p>&#xA;</blockquote>&#xA;&#xA;<p>I will be very thankful for any help or example!</p>&#xA;",3042366,,3042366,2016-09-17 18:08:55,2016-09-19 18:03:35,RelayJS infinite scroll,<javascript><reactjs><graphql><relayjs>,1,0,0,2016-09-17 10:39:40
39551463,2,,38043757,7,,"<ol>&#xA;<li>You need schema only on the backend and you can download schema.json from your backend using example at the bottom part of this document:  <a href=""https://facebook.github.io/relay/docs/guides-babel-plugin.html"" rel=""noreferrer"">https://facebook.github.io/relay/docs/guides-babel-plugin.html</a></li>&#xA;<li>Relay need schema to correctly construct queries and understand types of returned data.</li>&#xA;<li>Relay wraps your React components and fetch/provide all necessary data for rendering. Have many features out of the box like data caching, query consolidation, so with Relay you don't need to fetch anything and worry about how data provided to your component, you just need to write queries and components.</li>&#xA;</ol>&#xA;",3200476,,,,2016-09-17 20:34:07,"",,0,1,0,2016-09-17 20:34:07
39563484,1,40012549,,2,638,"<p>Im trying to do something like <a href=""https://dribbble.com/shots/2545580-Simple-Profile-Page"" rel=""nofollow noreferrer"">this</a> with React and Relay - smooth animation from list to single item.</p>&#xA;<p>I currently have list component (list query) and single item component (node query) but there's a problem: these are two different, isolated views and queries, I can't think of an easy way to smootly animate between these two views.</p>&#xA;<hr />&#xA;<h2>Easiest way would probably be to transform / scale that same list item:</h2>&#xA;<p>React part is simple, I'll calculate screen size on click and transform the list item to full-screen size.</p>&#xA;<hr />&#xA;<p>How about data? Is something like this possible with Relay? Can I fetch more data for single item in list query or could I use node query in same component, <em>a'la</em> use two queries per component?</p>&#xA;<hr />&#xA;<pre class=""lang-js prettyprint-override""><code>// Simple list query example&#xA;&#xA;export default Relay.createContainer(PostList, {&#xA;    initialVariables: {&#xA;        count: 10&#xA;    },&#xA;    fragments: {&#xA;        viewer: () =&gt; Relay.QL`&#xA;            fragment on Viewer {&#xA;                posts(first: $count) {&#xA;                    edges {&#xA;                        node {&#xA;                            id&#xA;                            title&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }`&#xA;    }&#xA;})&#xA;&#xA;// What if I needed to fetch &quot;content&quot; for a single item as well?&#xA;</code></pre>&#xA;",5383767,,-1,2020-06-20 09:12:55,2016-10-13 04:53:08,Fetch additional data for a single item in a list query,<reactjs><relayjs><graphql-js>,1,0,0,2016-09-18 23:08:51
39579447,2,,39545844,2,,"<p><strong>Problem solved!</strong></p>&#xA;&#xA;<p>About my concern of fetching N+5 records over and over again with each scroll, it seems that Relay is quite intelligent, because it automatically ""<em>paginate</em>"" my connection by querying <code>cursor</code> and managing the <code>after</code> arg in my connection.</p>&#xA;&#xA;<p>And with little help from <code>graphql-sequelize</code> on my backend, it simply turns into this query</p>&#xA;&#xA;<pre><code>SELECT ... FROM product ORDER BY product.id ASC LIMIT 5 OFFSET 10&#xA;</code></pre>&#xA;&#xA;<p>Which actually solves my first problem about the performance. :)</p>&#xA;&#xA;<p>So my <code>Relay.QL</code> query has underhood transpiled into this</p>&#xA;&#xA;<pre><code>query ListPage_ViewerRelayQL($id_0:ID!) {&#xA;  node(id:$id_0) {&#xA;    ...F1&#xA;  }&#xA;}&#xA;fragment F0 on Product {&#xA;  id,&#xA;  title,&#xA;  price&#xA;}&#xA;fragment F1 on Viewer {&#xA;  _products4tSFq4:products(after:""YXJyYXljb25uZWN0aW9uJDUkNA=="",first:5) {&#xA;    edges {&#xA;      cursor,&#xA;      node {&#xA;        id,&#xA;        ...F0&#xA;      }&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage&#xA;    }&#xA;  },&#xA;  id&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and when I ran this query on my GraphQL backend, it returned me empty result</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""node"": null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I immediately realized where is the problem and why my Relay crashes down.</p>&#xA;&#xA;<p>The problem is with <strong>refetching the viewer</strong>. I did not properly implemented <code>nodeDefinitions</code> and when the viewer <code>ID</code> hit <code>idFetcher</code> and <code>typeResolver</code>, it failed and returned a <code>null</code>. After that on the client side, Relay was unable to finish the refetching of my connection and crashed down!</p>&#xA;&#xA;<p>After small repairment and <strong>fixes on the Backend-side</strong>, my infinite scroll works like a charm! :)</p>&#xA;",3042366,,,,2016-09-19 18:03:35,"",,0,1,0,2016-09-19 18:03:35
39599393,2,,39598124,0,,"<p>It looks like your <code>taskNodes</code> field takes an <code>orderBy</code> argument in the form of an Enum. GraphQL doesn't have generic sort functionality--it's all done through arguments passed into the fields.</p>&#xA;&#xA;<p>When you use GraphiQL, the interactive query explorer for GraphQL, it should tell you what the available options for <code>orderBy</code> are. If there isn't anything that looks like <code>TEAM_NAME</code> or similar, you'll need to ask your API developer to add a new option.</p>&#xA;",3280944,,,,2016-09-20 16:30:55,"",,0,0,0,2016-09-20 16:30:55
39644286,1,39644650,,4,1245,"<p>Suppose a GraphQL schema supports the following queries:</p>&#xA;&#xA;<pre><code>{&#xA;    person(id: String) {&#xA;        locationId&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and</p>&#xA;&#xA;<pre><code>{&#xA;    location(id: String) {&#xA;        country&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to find a <code>person</code> by <code>id</code>, then use the resulting <code>locationid</code> to find their <code>location</code> by <code>id</code> (returning the <code>country</code> corresponding to that <code>location</code>) all the in a single query?</p>&#xA;&#xA;<p>Or would I have to make two separate queries?</p>&#xA;",4905625,,,,2016-09-22 16:50:36,Composing GraphQL queries,<graphql>,2,0,0,2016-09-22 16:27:40
39644650,2,,39644286,3,,"<p>If that is the only information on a <code>location</code> that you can get from a <code>person</code> then yes, you will need to perform two queries in separate requests.</p>&#xA;&#xA;<p>It would be more normal for a GraphQL schema to present the whole <code>location</code> node as visible from the <code>person</code> (i.e. the id's would be dereferenced, though perhaps still available), and if a <code>person</code> could have more than one <code>location</code> then you would follow the <code>locations</code> edge to get to each <code>location</code> node.</p>&#xA;",139404,,,,2016-09-22 16:47:16,"",,0,0,0,2016-09-22 16:47:16
39644714,2,,39644286,5,,"<p>The query would look like this;</p>&#xA;&#xA;<pre><code>{&#xA;    person(id: string){&#xA;        location{&#xA;            country&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In your person type, you can apply a resolver to the <code>location</code> field which gets the location based on the locationId of the person which the query is performed against.</p>&#xA;",4697675,,,,2016-09-22 16:50:36,"",,0,0,0,2016-09-22 16:50:36
39661121,2,,39607391,0,,"<p>You can define <code>ViewerQueires</code> as a constant and pass language as params like this</p>&#xA;&#xA;<pre><code>const ViewerQueries = {&#xA;  viewer: () =&gt; Relay.QL `query{post(postID: $language)}`,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>And you should define fragment on Component page as below</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Home, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on JobSeekerEntry {&#xA;        language&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",3668479,,,,2016-09-23 12:45:11,"",,0,1,0,2016-09-23 12:45:11
39733044,1,,,2,1360,"<p>I'm learn Relay, and I got it working, but sometimes it feels like it was by chance :)</p>&#xA;&#xA;<p>I'm sorry if I am making beginners mistakes here, I've read the manual and all the examples, but I just can't seem to wrap my head around it all.</p>&#xA;&#xA;<p>Anyway, I have the following problem right now.</p>&#xA;&#xA;<p>My schema looks like this:</p>&#xA;&#xA;<pre><code>{&#xA;    viewer(token:$anAuthToken) {&#xA;        actor {&#xA;          id,&#xA;          email,&#xA;          ...&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>All data is accessed under { viewer }, which takes care of authentication. The actor field is just one of many.</p>&#xA;&#xA;<p>Actor is an instance of UserType, the currently logged in user.</p>&#xA;&#xA;<p>I want a sane component hierarchy, where the top component only gets a user as props (and provides a fragment for the properties it needs). But I'm not doing it right, according to Relay, and I'm not sure what I'm doing wrong.</p>&#xA;&#xA;<p>My code looks like this (quite chaotic at the moment, due to me testing things out):</p>&#xA;&#xA;<pre><code>class UserRegistrationPage extends React.Component {&#xA;&#xA;    render() {&#xA;        const user = this.props.user;&#xA;        return (&#xA;            &lt;View&gt;&#xA;                &lt;Text&gt;Email: {user.email}&lt;/Text&gt;&#xA;            &lt;/View&gt;&#xA;        );&#xA;    }&#xA;&#xA;    submit(model) {&#xA;        const user = this.props.user;&#xA;&#xA;        this.props.relay.commitUpdate(&#xA;            new UpdateUserMutation({&#xA;                id: user.id,&#xA;                ...model&#xA;            }, {&#xA;                onSuccess: response =&gt; {&#xA;                    console.log(""SUCCESS!"");&#xA;                    console.log(response);&#xA;                },&#xA;                onFailure: () =&gt; {&#xA;                    console.log(""FAIL!"");&#xA;                }&#xA;            }));&#xA;    }&#xA;&#xA;}&#xA;&#xA;UserRegistrationPage = Relay.createContainer(UserRegistrationPage, {&#xA;    fragments: {&#xA;        user: () =&gt; Relay.QL`&#xA;            fragment on User {&#xA;                email&#xA;            }&#xA;        `,&#xA;    },&#xA;});&#xA;&#xA;//////////////////////////////&#xA;&#xA;class UserRegistrationViewer extends React.Component {&#xA;&#xA;    render() {&#xA;        return &lt;UserRegistrationPage user={this.props.actor} /&gt;&#xA;    }&#xA;&#xA;}&#xA;&#xA;UserRegistrationViewer = Relay.createContainer(UserRegistrationViewer, {&#xA;    fragments: {&#xA;        actor: () =&gt; Relay.QL`&#xA;            fragment on Viewer {&#xA;                actor {&#xA;                    ${UserRegistrationPage.getFragment('user')},&#xA;                }&#xA;            }&#xA;        `,&#xA;    },&#xA;});&#xA;&#xA;/////////////////////////////////&#xA;&#xA;class QueryConfig extends Relay.Route {&#xA;    static routeName = 'UserRegistrationRoute';&#xA;    static prepareParams = routeConfigParamsBuilder;&#xA;    static queries = {&#xA;        actor: (Component) =&gt;&#xA;            Relay.QL`&#xA;                     query {&#xA;                        viewer(token:$token) {&#xA;                            ${Component.getFragment('actor')},&#xA;                        }&#xA;                     }&#xA;        `,&#xA;    };&#xA;}&#xA;&#xA;export const UserRegistrationPageComponent = (parentProps) =&gt; {&#xA;    return (&#xA;        &lt;Relay.Renderer&#xA;            environment={Relay.Store}&#xA;            Container={UserRegistrationViewer}&#xA;            queryConfig={new QueryConfig()}&#xA;            render={({done, error, props, retry, stale}) =&gt; {&#xA;        if (error) {&#xA;          return &lt;View&gt;&lt;Text&gt;Error!&lt;/Text&gt;&lt;/View&gt;;&#xA;        } else if (props) {&#xA;          return &lt;UserRegistrationViewer {...parentProps} {...props} /&gt;;&#xA;        } else {&#xA;          return &lt;View&gt;&lt;Text&gt;Loading...&lt;/Text&gt;&lt;/View&gt;;&#xA;        }&#xA;      }}&#xA;        /&gt;&#xA;    )&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>And I'm getting the following error.</p>&#xA;&#xA;<blockquote>&#xA;  <p>Warning: RelayContainer: component <code>UserRegistrationPage</code> was rendered&#xA;  with variables that differ from the variables used to fetch fragment&#xA;  <code>user</code>. The fragment was fetched with variables <code>(not fetched)</code>, but&#xA;  rendered with variables <code>{}</code>. This can indicate one of two&#xA;  possibilities: &#xA;   - The parent set the correct variables in the query - <code>UserRegistrationPage.getFragment('user', {...})</code> - but did not pass&#xA;  the same variables when rendering the component. Be sure to tell the&#xA;  component what variables to use by passing them as props:&#xA;  <code>&lt;UserRegistrationPage ...  /&gt;</code>.&#xA;   - You are intentionally passing fake data to this component, in which case ignore this warning.</p>&#xA;</blockquote>&#xA;&#xA;<p>So I have a couple of questions.</p>&#xA;&#xA;<p>1) Why do I get that error, and how do I fix it?&#xA;I don't understand why it would complain about fragment variables when none of the fragments have any variables.</p>&#xA;&#xA;<p>2) How can I make it so that UserRegistrationPage gets this.props.user?&#xA;Should I make a component tree hierarchy that maps the query response?&#xA;At some point I had this.props.actor.user, but I don't want the component to know about the query response structure, only the object that it is interested in.</p>&#xA;&#xA;<p>3) Is the name of the query coupled with the name of the fragments in some way?</p>&#xA;&#xA;<p>Any help, suggestions for improvements, tips and answers are very welcome, I'm starting to bang my head against the wall here :)</p>&#xA;",2300286,,710693,2017-08-11 00:31:42,2017-08-11 00:31:42,"Relay complains about fragment variables, but none of the fragments have variables",<graphql><relayjs>,1,0,0,2016-09-27 19:42:30
39741186,2,,39733044,6,,"<p>I finally understood a few details that eluded me before.&#xA;I'll post them here, in case it helps anyone else that is struggling with Relay.</p>&#xA;&#xA;<pre><code>class QueryConfig extends Relay.Route {&#xA;    static routeName = 'UserRegistrationRoute';&#xA;    static prepareParams = routeConfigParamsBuilder;&#xA;    static queries = {&#xA;        actor: (Component) =&gt;&#xA;            Relay.QL`&#xA;                     query {&#xA;                        viewer(token:$token) {&#xA;                            ${Component.getFragment('actor')},&#xA;                        }&#xA;                     }&#xA;        `,&#xA;    };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The query here is misleading when named ""actor"", because it doesn't return the actor. It returns the root of the query which is the viewer.&#xA;Also, the fragment that is included is for viewer, not for actor.</p>&#xA;&#xA;<p>Let's update it.</p>&#xA;&#xA;<pre><code>class QueryConfig extends Relay.Route {&#xA;    static routeName = 'UserRegistrationRoute';&#xA;    static prepareParams = routeConfigParamsBuilder;&#xA;    static queries = {&#xA;        viewer: (Component) =&gt;&#xA;            Relay.QL`&#xA;                     query {&#xA;                        viewer(token:$token) {&#xA;                            ${Component.getFragment('viewer')},&#xA;                        }&#xA;                     }&#xA;        `,&#xA;    };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Done. Let's see what's wrong with the first container.</p>&#xA;&#xA;<pre><code>UserRegistrationViewer = Relay.createContainer(UserRegistrationViewer, {&#xA;    fragments: {&#xA;        actor: () =&gt; Relay.QL`&#xA;            fragment on Viewer {&#xA;                actor {&#xA;                    ${UserRegistrationPage.getFragment('user')},&#xA;                }&#xA;            }&#xA;        `,&#xA;    },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Same thing here, names are misleading. This container doesn't feed an actor into the component, it feeds the viewer.</p>&#xA;&#xA;<p>Let's update it.</p>&#xA;&#xA;<pre><code>UserRegistrationViewer = Relay.createContainer(UserRegistrationViewer, {&#xA;    fragments: {&#xA;        viewer: () =&gt; Relay.QL`&#xA;            fragment on Viewer {&#xA;                actor {&#xA;                    ${UserRegistrationPage.getFragment('user')},&#xA;                }&#xA;            }&#xA;        `,&#xA;    },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>So, only the name of the fragment changed here.</p>&#xA;&#xA;<p>Now, the UserRegistrationViewer component gets a prop ""viewer"" (as specified by fragments) that is of type ViewerType. And we know that the viewer contains ""actor"" which is an instance of UserType.&#xA;UserRegistrationPage requires a prop ""user"" that is of UserType, as specified by its fragments.</p>&#xA;&#xA;<p>So lets update the component.</p>&#xA;&#xA;<pre><code>class UserRegistrationViewer extends React.Component {&#xA;&#xA;    render() {&#xA;        return &lt;UserRegistrationPage user={this.props.viewer.actor} /&gt;&#xA;    }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now we have a UI component that doesn't know about the query response hierarchy, and everything is working!</p>&#xA;&#xA;<p>I'm still not exactly sure why I got that error though :)</p>&#xA;&#xA;<p>Hope this can help someone!</p>&#xA;",2300286,,,,2016-09-28 07:48:41,"",,0,0,0,2016-09-28 07:48:41
39844160,1,,,0,61,"<p>I have 2 components with relay container, each container has a graphql query to fetch data. This two queries all fetch data from same table but different fields. The problem is if I write the fields what I need in each component it will not show any data when click the page link. If I write all fields in both of them then it will be working fine. So what can I do? is that means I can not one table twice? even in different component? Here is the part codes of relay container. Please help. Thanks! :)</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>export default Relay.createContainer(ParcelDetails, {&#xD;&#xA;  initialVariables: {&#xD;&#xA;    tracking_number: null,&#xD;&#xA;  },&#xD;&#xA;&#xD;&#xA;  fragments: {&#xD;&#xA;    viewer: () =&gt; Relay.QL`&#xD;&#xA;      fragment on User {&#xD;&#xA;        parcels(tracking_number: $tracking_number, first: 9999) {&#xD;&#xA;          edges {&#xD;&#xA;            node {&#xD;&#xA;              id,&#xD;&#xA;              tracking_number,&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    `&#xD;&#xA;  },&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>export default Relay.createContainer(LongOrderList, {&#xD;&#xA;  &#xD;&#xA;  fragments: {&#xD;&#xA;    viewer: () =&gt; Relay.QL`&#xD;&#xA;      fragment on User {&#xD;&#xA;        parcels(first: 99999) {&#xD;&#xA;          edges {&#xD;&#xA;            node {&#xD;&#xA;              id,&#xD;&#xA;              status,&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    `&#xD;&#xA;  },&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",6902110,,,,2016-10-04 04:27:03,About the GraphQL query under React Relay,<reactjs><graphql><relay>,0,4,0,2016-10-04 04:27:03
39846255,1,,,0,462,"<pre><code>**-- Relay Transform Error -- delete-customer-mutation.js --**&#xA;&#xA;Error: types.getNamedType(...).getFields is not a function&#xA;File:  D:/development/wfc_admin/js/mutations/delete-customer-mutation.js&#xA;&#xA;&#xA;**-- GraphQL Validation Error -- delete-customer-mutation.js --**&#xA;&#xA;Error: Unknown type ""DeleteWidgetPayload"".&#xA;File:  D:/development/wfc_admin/js/mutations/delete-customer-mutation.js&#xA;Source:&#xA;&gt;&#xA;&gt; fragment Delete on DeleteWidgetPayload @relay(pattern: true) {&#xA;&gt;                    ^^^&#xA;&#xA;&#xA;**Package file:**&#xA; **dependencies**&#xA;&#xA;    ""babel"": ""5.8.21"",&#xA;    ""babel-loader"": ""5.3.2"",&#xA;    ""babel-relay-plugin"": ""^0.1.1"",&#xA;    ""classnames"": ""^2.1.3"",&#xA;    ""express"": ""^4.13.1"",&#xA;    ""express-graphql"": ""^0.5.3"",&#xA;    ""graphql"": ""^0.6.0"",&#xA;    ""graphql-relay"": ""^0.4.2"",&#xA;    ""mongoose"": ""~4.1.7"",&#xA;    ""react"": ""^0.14.0-rc"",&#xA;    ""react-dom"": ""^0.14.0-rc"",&#xA;    ""react-relay"": ""^0.3.1"",&#xA;    ""react-router"": ""^2.8.1"",&#xA;    ""webpack"": ""^1.10.5"",&#xA;    ""webpack-dev-server"": ""^1.10.1""&#xA;&#xA;**Container file Code**&#xA;ReactDOM.render(&#xA;  &lt;Relay.RootContainer&#xA;    Component={CustomerToolContainer}&#xA;    //TODO Update userId&#xA;    route={new AppViewRoute()}&#xA;  /&gt;,&#xA;  document.getElementById('root')&#xA;);&#xA;&#xA;&#xA;**CustomerToolContainer is calling from customer-tool-container.js**&#xA;&#xA;import Relay from 'react-relay';&#xA;import CustomerTool from '../components/Customer_tool';&#xA;import DeleteCustomerMutationType from '../mutations/delete-customer-mutation';&#xA;export default Relay.createContainer(CustomerTool, {&#xA;  fragments: {&#xA;        viewer: () =&gt; Relay.QL`&#xA;            fragment on Viewer {&#xA;                id&#xA;&#xA;                customers {&#xA;                  id&#xA;                  name&#xA;                  address&#xA;                }&#xA;&#xA;                ${DeleteCustomerMutationType.getFragment('viewer')}&#xA;            }&#xA;        `&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>Customer_tool is calling from Customer_tool.js</strong>&#xA;Here it is the code that call DeleteCustomerMutation.&#xA;and i am getting error , can any one please guide me what i need to do for this issue. also getting error  fragment Delete on DeleteWidgetPayload</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;import React from 'react';&#xA;import CustomerList from './CustomerList.js';&#xA;import Customer from './Customer.js';&#xA;import CustomerRowComponent from './Customer_row';&#xA;import CustomerTableComponent from './Customer_table';&#xA;import DeleteCustomerMutation  from '../mutation/delete-customer-mutation';&#xA;&#xA;&#xA;export default class  CustomerTool extends React.Component {&#xA;    constructor(props) {&#xA;        super(props);&#xA;&#xA;        this.state = {  editCustomerId: null };&#xA;        this._saveCustomer = this._saveCustomer.bind(this);&#xA;        this._editCustomer = this._editCustomer.bind(this);&#xA;        this._cancelEditCustomer = this._cancelEditCustomer.bind(this);&#xA;        this._deleteCustomer = this._deleteCustomer.bind(this);&#xA;&#xA;    }&#xA;    _appendCustomer(customer) {&#xA;        Relay.Store.commitUpdate(new InsertCustomerMutation(Object.assign({&#xA;            viewer: this.props.viewer, customer: null }, customer)));&#xA;    }&#xA;&#xA;    _updateCustomer(customer) {&#xA;        //Relay.Store.commitUpdate(new UpdateWidgetMutation(&#xA;            //Object.assign({   viewer: this.props.viewer, customer: customer }, customer)&#xA;        //));       &#xA;    }&#xA;&#xA;    _saveCustomer(customer) {&#xA;&#xA;        if (customer.id !== -1) &#xA;        {&#xA;&#xA;            this._updateCustomer(customer);&#xA;        } &#xA;        else &#xA;        {   &#xA;            alert(customer);&#xA;            //this._appendCustomer(customer);&#xA;        }&#xA;        this.setState({ editCustomerId: null });&#xA;    }&#xA;&#xA;    _editCustomer(customer) {&#xA;        alert(customer.id);&#xA;        this.setState({ editCustomerId: customer.id });&#xA;    }&#xA;&#xA;    _cancelEditCustomer() {&#xA;        this.setState({ editCustomerId: null });&#xA;    }&#xA;&#xA;    _deleteCustomer(customer) {&#xA;        //alert(customer.name);&#xA;        Relay.Store.commitUpdate(new DeleteCustomerMutation ({&#xA;            viewer: this.props.viewer, &#xA;            customer, &#xA;            customerId: customer.id&#xA;        }));            &#xA;&#xA;    }&#xA;&#xA;  render() {&#xA;    let viewer = this.props.viewer;&#xA;        return (&#xA;                &lt;div&gt;&#xA;                    &lt;CustomerTableComponent  &#xA;                    editCustomerId={this.state.editCustomerId}&#xA;                    onSave={this._saveCustomer}&#xA;                    onEdit={this._editCustomer}&#xA;                    onCancelEdit={this._cancelEditCustomer} &#xA;                    onDelete={this._deleteCustomer}&#xA;                    customers={viewer.customers}/&gt;&#xA;                &lt;/div&gt;&#xA;            );  &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is a code for delete-customer-mutation.js</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default class extends Relay.Mutation {&#xA;&#xA;    static fragments = {&#xA;        viewer: () =&gt; Relay.QL`fragment on Viewer { id }`&#xA;    }&#xA;&#xA;    getMutation() {&#xA;        return Relay.QL`mutation { deleteCustomer }`;&#xA;    }&#xA;&#xA;    // receives the parameters from the constructor, builds&#xA;    // the variables to send the GraphQL server&#xA;    getVariables() {&#xA;        return {&#xA;            customerId: this.props.customerId&#xA;        };&#xA;    }   &#xA;&#xA;    getConfigs() {&#xA;        return [{&#xA;            // delete operation&#xA;            type: 'NODE_DELETE',&#xA;            // triggers update from container fragment viewer id&#xA;            // this is the name of property from the output field&#xA;            parentName: 'viewer', &#xA;            // id of viewer being updated&#xA;            parentID: this.props.viewer.id,&#xA;            // name of the connection on the viewer&#xA;            connectionName: 'customers', &#xA;            // fat query payload field name of the id for the deleted node&#xA;            deletedIDFieldName: 'customerId'&#xA;        }];&#xA;    }&#xA;&#xA;    getFatQuery() {&#xA;        // corresponds to the structure of the output types&#xA;        // patten is used to not specify the parameters for the connections&#xA;        return Relay.QL`&#xA;            fragment on DeleteCustomerPayload @relay(pattern: true) {&#xA;                viewer {&#xA;                    customers {&#xA;                        edges {&#xA;                            node {&#xA;                                id&#xA;                                name&#xA;                                description&#xA;                                color&#xA;                                size&#xA;                                quantity&#xA;                                owner {&#xA;                                    id&#xA;                                    firstName&#xA;                                    lastName&#xA;                                }&#xA;                            }&#xA;                        }&#xA;                    }&#xA;                }&#xA;                customerId&#xA;            }&#xA;        `;&#xA;    }&#xA;} &#xA;</code></pre>&#xA;",830892,,3354657,2016-10-09 15:09:02,2016-10-09 15:09:02,How to fix issue Error: types.getNamedType(...).getFields is not a function,<javascript><reactjs><graphql><relay>,0,4,0,2016-10-04 07:12:07
39902094,1,39906777,,0,214,"<p>I'm need help passing arguments to collections/connections/arrays in GraphQL syntax. </p>&#xA;&#xA;<p>I'm just learning it, playing with the SWAPI at <a href=""http://graphql.org/swapi-graphql/"" rel=""nofollow noreferrer"">http://graphql.org/swapi-graphql/</a></p>&#xA;&#xA;<p>I can pass an id argument to a single type, like this:</p>&#xA;&#xA;<pre><code>query getANewHope {&#xA;  film(id: ""ZmlsbXM6MQ=="") {&#xA;    id&#xA;    title&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I don't know how to query the results of a collection/connection    </p>&#xA;&#xA;<pre><code>query starships {&#xA;  allStarships(id: ""c3RhcnNoaXBzOjI="") { # this doesn't work&#xA;    edges {&#xA;      node(id: ""c3RhcnNoaXBzOjI="") { # ...nor this.&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to query collections because, I'd like to connect the two ideas like ""All Starfighter type ships in A New Hope""?</p>&#xA;&#xA;<pre><code>query filmStarships {&#xA;  film(id: ""ZmlsbXM6MQ=="") {&#xA;    title&#xA;    starshipConnection { #How to limit this?  I can't use (starshipClass: ""Starfighter"") here...&#xA;      edges {&#xA;        node { # ...nor here..&#xA;          starshipClass # ...nor here.&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;query starships2 {&#xA;  starship (id:  ""c3RhcnNoaXBzOjI="") { # This doesn't work either&#xA;    id # even without an arugment abovce, it says ""Unknown argument \""id\"" on field \""node\"" of type \""StarshipsEdge\"".""&#xA;  } &#xA;}&#xA;</code></pre>&#xA;",1858,,2103996,2017-02-01 17:37:10,2017-02-01 17:37:10,GraphQL arguments to connection sub results,<graphql>,1,0,0,2016-10-06 17:19:48
39950649,1,,,1,1198,"<p>i'm using ReactJS, Relay Framework and GrapthQL. This is the layout component where i use relay to get data:</p>&#xA;&#xA;<pre><code>import React, { PropTypes } from 'react';&#xA;import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';&#xA;&#xA;import Header from '../Header';&#xA;import Footer from '../Footer';&#xA;import Sidebar from '../Sidebar';&#xA;import Relay from 'react-relay';&#xA;&#xA;import injectTapEventPlugin from 'react-tap-event-plugin';&#xA;injectTapEventPlugin();&#xA;&#xA;class Layout extends React.Component{&#xA;    render(){&#xA;        const {children} = this.props;&#xA;        var communityList = this.props.communityList;&#xA;        return (&#xA;            &lt;MuiThemeProvider&gt;&#xA;                &lt;div&gt;&#xA;                    &lt;Header/&gt;&#xA;                    &lt;Sidebar/&gt;&#xA;                    {React.Children.only(children)}&#xA;                    &lt;Footer /&gt;&#xA;                &lt;/div&gt;&#xA;            &lt;/MuiThemeProvider&gt;&#xA;        )&#xA;    }&#xA;}&#xA;&#xA;Layout.propTypes = {&#xA;    children: PropTypes.element.isRequired,&#xA;};&#xA;&#xA;var RelayLayout =  Relay.createContainer(Layout, {&#xA;    fragments: {&#xA;        communityList: () =&gt; Relay.QL`&#xA;        fragment on Layout {&#xA;    user(id: 11) {&#xA;        connections{&#xA;          community{&#xA;            name&#xA;            }&#xA;        }&#xA;    }&#xA;  }&#xA;    `,&#xA;    },&#xA;});&#xA;&#xA;&#xA;export default RelayLayout;&#xA;</code></pre>&#xA;&#xA;<p>The problem is: when i run the page, it show the error message:</p>&#xA;&#xA;<blockquote>&#xA;  <p><em>Invariant Violation RelayContainer: <code>Relay(Layout)</code> was rendered with invalid Relay context <code>undefined</code>. Make sure the <code>relay</code> property on&#xA;  the React context conforms to the <code>RelayEnvironment</code> interface.</em></p>&#xA;</blockquote>&#xA;&#xA;<p>The query using GrapthQL return valid data so i don't think problem is the query</p>&#xA;",4827693,,4827693,2016-10-10 05:15:01,2016-12-01 06:01:26,RelayContainer: `Relay` was rendered with invalid Relay context `undefined`,<reactjs><graphql><relay>,1,0,0,2016-10-10 02:47:29
39959782,1,,,6,129,"<p>So I'm trying to figure out Relay.js. I conjured simple app that basically imitates example on Relay's website. However although I've managed to get rid of errors in both consoles (node and chrome), my component doesn't receive fragments I specified in Raley.Container. I have no idea, where the problem could be, as my app looks pretty much like Relay's example. </p>&#xA;&#xA;<p>Note that map method on <code>this.props.companies</code> isn't available as it is an object, with 1 property, that is __dataId__.</p>&#xA;&#xA;<p>First Component</p>&#xA;&#xA;<pre><code>class App extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {this.props.companies.map((comapny =&gt; &lt;Company company={company} /&gt;))}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(App, {&#xA;  fragments: {&#xA;    companies: () =&gt; Relay.QL`&#xA;      fragment on Companies {&#xA;        companies { ${Company.getFragment('company')} }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Second component</p>&#xA;&#xA;<pre><code>class Company extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;h1&gt;{this.props.comapany.name}&lt;/h1&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(Company, {&#xA;  fragments: {&#xA;    company: () =&gt; Relay.QL`&#xA;      fragment on Company {&#xA;        __id,&#xA;        name&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And my Route</p>&#xA;&#xA;<pre><code>class AppHomeRoute extends Relay.Route {&#xA;  static routeName = 'Comapnies';&#xA;  static queries = {&#xA;    companies: (Component) =&gt; Relay.QL`&#xA;      query {&#xA;        companies { ${Component.getFragment('companies')} }&#xA;      }&#xA;    `,&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any ideas?</p>&#xA;",6416743,,,,2016-10-10 13:45:06,"Relay.js - Not receiving props, only __dataId__",<javascript><reactjs><relay><graphql-js>,0,3,0,2016-10-10 13:45:06
39986438,1,,,1,1761,"<p>Edit: @helfer suggested this might be a bug. <a href=""https://github.com/apollostack/apollo-client/issues/763"" rel=""nofollow"">Github issue</a></p>&#xA;&#xA;<p>For a new application I am using Apollo to do the graphql management for me.&#xA;I have multiple types that can also contain other types.</p>&#xA;&#xA;<p>To simplify my life as a developer I want to use fragments to avoid duplicated code.</p>&#xA;&#xA;<p>I am trying to use fragments for different types together.</p>&#xA;&#xA;<p>but the query results in an error, because Subject fragments cannot be used for the BusinessArea type.</p>&#xA;&#xA;<p>Is this a bug or did I miss something?</p>&#xA;&#xA;<p>Def:</p>&#xA;&#xA;<pre><code>const subjectInfo = createFragment(gql`&#xA;  fragment subjectInfo on Subject {&#xA;    id&#xA;    name&#xA;  }`&#xA;)&#xA;&#xA;const businessAreaInfo = createFragment(gql`&#xA;  fragment businessAreaInfo on BusinessArea {&#xA;    id&#xA;    name&#xA;    subjects {&#xA;      ...subjectInfo&#xA;    }&#xA;  }`,&#xA;  [subjectInfo]&#xA;)&#xA;&#xA;graphql(gql`&#xA;query {&#xA;  businessAreas {&#xA;    ...businessAreaInfo&#xA;  }&#xA;}&#xA;`, {&#xA;  fragments: businessAreaInfo&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Resulting query:</p>&#xA;&#xA;<pre><code>{&#xA;  businessAreas {&#xA;    ...businessAreaInfo&#xA;    ...subjectInfo&#xA;  }&#xA;}&#xA;&#xA;fragment businessAreaInfo on BusinessArea {&#xA;  id&#xA;  name&#xA;  subjects {&#xA;    ...subjectInfo&#xA;  }&#xA;}&#xA;&#xA;fragment subjectInfo on Subject {&#xA;  id&#xA;  name&#xA;}&#xA;</code></pre>&#xA;",4797532,,4797532,2016-10-11 22:18:21,2016-10-11 22:18:21,GraphQL fragments of different types in apollo,<reactjs><graphql><apollo><apollostack>,0,5,0,2016-10-11 20:46:34
40012549,2,,39563484,1,,"&#xA;&#xA;<p>Yes, you can fetch multiple fragments per component. My suggestion here would be to have a separate fragment for the selected post, and to make use of it in a route dedicated for the post's detail (permalink) view.</p>&#xA;&#xA;<p>First, add a fragment to represent the selected post.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default Relay.createContainer(PostList, {&#xA;  initialVariables: {&#xA;    count: 10,&#xA;  },&#xA;  fragments: {&#xA;    selectedPost: () =&gt; Relay.QL`&#xA;      fragment on Post {&#xA;        id&#xA;        title&#xA;        description&#xA;      }&#xA;    `,&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        posts(first: $count) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              title&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Then create two routes. One will represent only the index view's queries, and one the permalink view's queries.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class IndexRoute extends Relay.Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`query { viewer }`,&#xA;  };&#xA;  static routeName = 'IndexRoute';&#xA;}&#xA;&#xA;class PostPermalinkRoute extends Relay.Route {&#xA;  static queries = {&#xA;    selectedPost: () =&gt; Relay.QL`query { node(id: $postID) }`,&#xA;    viewer: () =&gt; Relay.QL`query { viewer }`,&#xA;  };&#xA;  static paramDefinitions = {&#xA;    // By setting `required` to true, `PostPermalinkRoute` &#xA;    // will throw if a `postID` is not supplied when instantiated.&#xA;    postID: {required: true},&#xA;  };&#xA;  static routeName = 'PostPermalinkRoute';&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, you need to write some code that rerenders the app with a new route when you want to switch between the index and the permalink views. By default, Relay will keep rendering the old route while the data for the next route loads, so you should be able to perform your transitions while you wait on the data.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>function render(route) {&#xA;  ReactDOM.render(&#xA;    &lt;Relay.RootContainer&#xA;      Component={PostList}&#xA;      route={route}&#xA;    /&gt;,&#xA;    container,&#xA;  );&#xA;}&#xA;&#xA;// When it's time to render the index...&#xA;render(new IndexRoute());&#xA;&#xA;// Upon selecting a post...&#xA;render(new PostPermalinkRoute({postID: 123}));&#xA;</code></pre>&#xA;&#xA;<p>The current route is available to you as <code>this.props.relay.route</code>, so you should be able to make some inferences about what state you should be in using <code>this.props.relay.route.name</code> and <code>this.props.relay.route.params</code>.</p>&#xA;",802047,,,,2016-10-13 04:53:08,"",,0,0,0,2016-10-13 04:53:08
40095362,1,40108241,,0,337,"<p>Being very new to GraphQL, I have a graphene django implementation of a server with two models, following rather closely the <a href=""http://docs.graphene-python.org/projects/django/en/latest/tutorial.html"" rel=""nofollow"">graphene docs' example</a>.</p>&#xA;&#xA;<p>In graphiql, I can do this, and get a result back.</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/TUy48.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/TUy48.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>Following another <a href=""https://medium.com/@clayallsopp/relay-101-building-a-hacker-news-client-bb8b2bdc76e6#.vephqa6ww"" rel=""nofollow"">relay tutorial</a>, I'm intending to render the result of this query on screen.</p>&#xA;&#xA;<p>My attempt looks like this:</p>&#xA;&#xA;<pre><code>class Note extends Component {&#xA;  render() {&#xA;    return(&#xA;      &lt;div&gt; {this.props.store.title} &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;Note = Relay.createContainer(Note, {&#xA;  fragments: {&#xA;    store: () =&gt; Relay.QL`&#xA;      fragment on Query {&#xA;        note(id: ""Tm90ZU5vZGU6MQ=="") {&#xA;          id&#xA;          title&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;&#xA;class NoteRoute extends Relay.Route {&#xA;  static routeName = 'NoteRoute';&#xA;  static queries = {&#xA;    store: Component =&gt; {&#xA;&#xA;      return Relay.QL`&#xA;      query {&#xA;        ${Component.getFragment('store')}&#xA;      }&#xA;    `},&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My browser's console shows the following error:</p>&#xA;&#xA;<p><code>Uncaught Error: Relay transform error ``There are 0 fields supplied to the query named `Index`, but queries must have exactly one field.`` in file `/Users/.../src/index.js`. Try updating your GraphQL schema if an argument/field/type was recently added.&#xA;</code></p>&#xA;&#xA;<p>I've been trying to figure it out on my own with limited success.</p>&#xA;&#xA;<p>Can someone point me in the right direction?</p>&#xA;",1909378,,,,2016-10-18 12:26:27,graphene django relay: Relay transform error,<python><django><reactjs><graphql><relay>,1,1,0,2016-10-17 20:44:48
40099884,2,,40099580,0,,"<p>According to section 5.1 of <a href=""https://facebook.github.io/relay/graphql/objectidentification.htm#sec-Fields"" rel=""nofollow noreferrer"">this document</a>, the ""Relay Object Identification Specification"":</p>&#xA;&#xA;<blockquote>&#xA;  <p>Relay‐compliant servers may expose root fields that are not plural identifying root fields; the Relay client will just be unable to use those fields as root fields in its queries.</p>&#xA;</blockquote>&#xA;&#xA;<p>Based on this specification, Relay can not query plural fields at the root of a query unless the field takes a list of arguments that exactly maps to the results. That means the <code>allFilms</code> field cannot be used with Relay. You can read more about the limitations in this other StackOverflow answer: <a href=""https://stackoverflow.com/questions/32491117/how-to-get-relayjs-to-understand-that-a-response-from-graphql-is-an-array-of-ite"">How to get RelayJS to understand that a response from GraphQL is an array of items, not just a single item</a></p>&#xA;&#xA;<p>If you would like to have a GraphQL schema with root fields that return arrays, you might want to use a different GraphQL client, since Relay is particularly restrictive in what kinds of schemas it works with. graphql.org has a list: <a href=""http://graphql.org/code/#graphql-clients"" rel=""nofollow noreferrer"">http://graphql.org/code/#graphql-clients</a></p>&#xA;",3280944,,-1,2017-05-23 12:33:25,2016-10-18 05:06:27,"",,0,5,0,2016-10-18 05:00:29
40108241,2,,40095362,0,,"<p>Thanks @stubailo for pointing me in the right direction. I made some adjustments, and now have a minimum example running like this:</p>&#xA;&#xA;<pre><code>NoteList = Relay.createContainer(NoteList, {&#xA;  fragments: {&#xA;    store: () =&gt; Relay.QL`&#xA;      fragment N on NoteNodeConnection {&#xA;        edges {&#xA;          node{&#xA;            id&#xA;            title&#xA;            note&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;&#xA;class NoteRoute extends Relay.Route {&#xA;  static routeName = 'NoteRoute';&#xA;  static queries = {&#xA;    store: Component =&gt; {&#xA;&#xA;      return Relay.QL`&#xA;      query {&#xA;        notes {&#xA;          ${Component.getFragment('store')}&#xA;        }&#xA;      }&#xA;    `},&#xA;  };&#xA;}&#xA;</code></pre>&#xA;",1909378,,,,2016-10-18 12:26:27,"",,0,0,0,2016-10-18 12:26:27
40143763,1,,,0,161,"<p>I'm trying to finish up a RelayMutation. And I am having a issue.</p>&#xA;&#xA;<p>I'm trying to pass a variable value into my RelayMutation But I am not able to do it. </p>&#xA;&#xA;<p>My Goal: When I press Accept, take the inviteAnswer variable and pass it to my RelayMutation as an input.</p>&#xA;&#xA;<p>Right Now, I am just getting inviteAnswer as ""undefined"".</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>RelayMutation.js(EventEditMutation.js)&#xA;&#xA;&#xA;import Relay from 'react-relay';&#xA;&#xA;&#xA;export default class EventEditMutation extends Relay.Mutation {&#xA; static fragments = {&#xA;    event: () =&gt; Relay.QL`&#xA;        fragment on Event {&#xA;            id&#xA;            guests {&#xA;                user&#xA;                status&#xA;            }&#xA;        },&#xA;&#xA;    `,&#xA;};&#xA;&#xA;getVariables(inviteAnswer) {&#xA;    console.log(inviteAnswer);&#xA;    return {&#xA;        id: this.props.event.id,&#xA;        inviteAnswer: true,&#xA;    }&#xA;}&#xA;&#xA;getMutation() {&#xA;    return Relay.QL`mutation {&#xA;        EventEdit,&#xA;    }`;&#xA;}&#xA;&#xA;getFatQuery() {&#xA;    return Relay.QL`&#xA;        fragment on EventEditPayload {&#xA;            Event {&#xA;                guests&#xA;            }&#xA;        }&#xA;    `;&#xA;}&#xA;&#xA;getConfigs() {&#xA;    return [{&#xA;        type: 'FIELDS_CHANGE',&#xA;        fieldIDs: {&#xA;            Event: {&#xA;                guests: this.props.event.guests,&#xA;            }&#xA;        }&#xA;    }];&#xA;}&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>AcceptFunction on Component</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>accept = () =&gt; {&#xA;&#xA;const inviteAnswer = true; &lt;&lt;&lt;--- I want this value here!&#xA;console.log(inviteAnswer);&#xA;const { event } = this.props.viewer;&#xA;console.log(event);&#xA;&#xA;&#xA;const mutation = new EventEditMutation({&#xA;  event: event,&#xA;  inviteAnswer: inviteAnswer,&#xA;&#xA;});&#xA;&#xA;console.log(inviteAnswer)&#xA;&#xA;&#xA;&#xA;&#xA;const callbacks = {&#xA;  onSuccess: (payload) =&gt; {&#xA;    console.log('success: ', payload);&#xA;  },&#xA;  onFailure: (err) =&gt; {&#xA;    console.log('failure: ', err);&#xA;  },&#xA;};&#xA;&#xA;RelayStore.commitUpdate(mutation, callbacks);&#xA;Actions.chat({eventId: event.id});&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>InputFields of my GraphqlMutation(EventEditMutation)</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default mutationWithClientMutationId ({&#xA;name: 'EventEdit',&#xA;inputFields:{&#xA;        id: {&#xA;            type: new GraphQLNonNull(GraphQLID)&#xA;        },&#xA;        inviteAnswer: {&#xA;            type: GraphQLBoolean,&#xA;        }&#xA;    },&#xA;</code></pre>&#xA;&#xA;<p>I appreciate if you guys could help me out. Thanks! Also, if you think that there is a better way to do it, please let me know.</p>&#xA;",5623786,,25724,2016-10-20 08:32:53,2016-10-23 11:42:51,How to get a variable value and Pass inside a RelayMutation?,<relayjs><relay><graphql-js>,1,1,0,2016-10-20 00:49:30
40170768,2,,40143763,0,,"<p>You are calling the mutation incorrectly.</p>&#xA;&#xA;<p>Your mutation variable should match the input fields on the getVariables() and likewise the input fields on the receiving mutation.</p>&#xA;&#xA;<pre><code>const mutation = new EventEditMutation({&#xA;  id: event,&#xA;  inviteAnswer: inviteAnswer,&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And the getVariables does not need to take an argument:</p>&#xA;&#xA;<pre><code>getVariables() {&#xA;    return {&#xA;        id: this.props.event.id,&#xA;        inviteAnswer: this.props.inviteAnswer,&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",6060774,,6060774,2016-10-23 11:42:51,2016-10-23 11:42:51,"",,0,4,0,2016-10-21 07:29:02
40214499,1,,,1,428,"<p>I'm using PostgraphQL (<a href=""https://github.com/calebmer/postgraphql"" rel=""nofollow"">https://github.com/calebmer/postgraphql</a>) with Relay and wired a UpdateQuestionMutation into my app. However, I do not get optimistic updating to work.<br>(When I enable network throttling in chrome I can see that the the optimistic update gets handled but the component still shows the old title).<br><br>Do I miss something? I have following pieces :</p>&#xA;&#xA;<pre><code>class QuestionClass extends Component&lt;IQuestion, void&gt; {&#xA;&#xA;save = (item) =&gt; {&#xA;    this.props.relay.commitUpdate(&#xA;        new UpdateQuestionMutation({store: this.props.store, patch: item})&#xA;    );&#xA;    this.isEditing = false;&#xA;};&#xA;&#xA;public render(): JSX.Element {&#xA;    const item = this.props.store;&#xA;    console.log(item);&#xA;</code></pre>&#xA;&#xA;<p>...</p>&#xA;&#xA;<pre><code>const Question = Relay.createContainer(QuestionClass, {&#xA;    fragments: {&#xA;        // The property name here reflects what is added to `this.props` above.&#xA;        // This template string will be parsed by babel-relay-plugin.&#xA;        store: () =&gt; Relay.QL`&#xA;            fragment on Question {&#xA;                ${UpdateQuestionMutation.getFragment('store')}&#xA;                title&#xA;                description&#xA;                userByAuthor {&#xA;                    ${User.getFragment('store')}&#xA;                }&#xA;            }`,&#xA;    },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>...</p>&#xA;&#xA;<pre><code>export default class UpdateQuestionMutation extends Relay.Mutation&lt;any, any&gt; {&#xA;    getMutation() {&#xA;        return Relay.QL `mutation { updateQuestion }`&#xA;    }&#xA;&#xA;    getVariables() {&#xA;        console.log(this.props);&#xA;        return {&#xA;            id: this.props.store.id,&#xA;            questionPatch: this.props.patch&#xA;        }&#xA;    }&#xA;&#xA;    getFatQuery() {&#xA;        return Relay.QL `fragment on UpdateQuestionPayload { question }`&#xA;    }&#xA;&#xA;    getConfigs() {&#xA;        return [{&#xA;            type: ""FIELDS_CHANGE"",&#xA;            fieldIDs: {&#xA;                question: this.props.store.id&#xA;            }&#xA;        }]&#xA;    }&#xA;&#xA;    getOptimisticResponse() {&#xA;        return {&#xA;            store: this.props.patch&#xA;        }&#xA;    }&#xA;&#xA;    // This mutation has a hard dependency on the question's ID. We specify this&#xA;    // dependency declaratively here as a GraphQL query fragment. Relay will&#xA;    // use this fragment to ensure that the question's ID is available wherever&#xA;    // this mutation is used.&#xA;    static fragments = {&#xA;        store: () =&gt; Relay.QL`&#xA;          fragment on Question {&#xA;            id&#xA;          }&#xA;        `,&#xA;    };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Edit: That's what I see in the postgraphql logs:&#xA;<code>mutation UpdateQuestion($input_0: UpdateQuestionInput!) { updateQuestion(input: $input_0) { clientMutationId ...F1 } } fragment F0 on Question { id rowId title description userByAuthor { id rowId username } } fragment F1 on UpdateQuestionPayload { question { id ...F0 } }</code></p>&#xA;",2080707,,2080707,2016-10-27 12:32:45,2016-10-27 12:32:45,Relay: Optimistic update not causing a component rerender,<graphql><relayjs><relay>,0,4,0,2016-10-24 09:05:16
40261075,2,,40244124,2,,"<p>Relay tracks all the data requirements of components that are (or were) rendered. When a mutation is sent, it also queries all of the data that might change (given through the FatQuery) and that is tracked. In other words, if your mutation's FatQuery contains nodes/fields that aren't tracked by Relay yet, they won't be included in the mutation's query (as the component's that need that data would just simply request it, when rendered for the first time).&#xA;<code>REQUIRED_CHILDREN</code> forces the mutation to query for certain fields, even when they are not tracked. It's really just an escape hatch for cases where you need to handle data outside of Relay. It's to Relay as <code>ref</code> is to React.</p>&#xA;&#xA;<p>The graphcool API gives you a viewer root field with an ID. It should be possible to have a <code>FIELDS_CHANGE</code> mutation (with the viewer ID) for the field user.</p>&#xA;",1501916,,,,2016-10-26 11:25:58,"",,0,0,0,2016-10-26 11:25:58
40280600,2,,40275008,0,,"<p>I believe you want to define an <code>InputObjectType</code> and not an <code>ObjectType</code> as stated.</p>&#xA;&#xA;<p>With that said, what you can do is to declare <code>personalizedDateSelection</code> as a string for now, and then later adapt it as needed with a custom input object, once you know what it should contain. <code>GraphQLInputObjectType</code> is used to define <strong>new</strong> input object types, it isn't a type <em>per se</em>.</p>&#xA;",860294,,,,2016-10-27 09:09:41,"",,0,0,0,2016-10-27 09:09:41
40340174,1,40415533,,1,457,"<p>I am new to react-native.My application currently uses <strong>redux,<a href=""https://github.com/reactjs/react-redux"" rel=""nofollow"">react-redux</a>,</strong><a href=""https://github.com/aksonov/react-native-router-flux"" rel=""nofollow"">router flux</a> &amp; navigator. </p>&#xA;&#xA;<p>The back end i need to work with is <strong>GraphQL</strong>. What should i do now? </p>&#xA;&#xA;<p>Can i integrate Relay to my app without affecting anything related to redux or should i dump redux and use relay?. What about <a href=""https://github.com/kadirahq/lokka"" rel=""nofollow"">lokka</a>? Really confused!! Can someone help me with code examples or anything related to this issue?</p>&#xA;&#xA;<p>Thanks in Advance :)</p>&#xA;",3261825,,3261825,2016-11-15 05:11:21,2016-11-15 05:11:21,Integrating Relay with Redux in React Native App,<reactjs><react-native><relayjs><graphql-js><redux-framework>,1,1,0,2016-10-31 10:13:49
40392045,1,,,1,55,"<p>For some reason, if I generate a root query which takes in parameters before injecting the child component, like so:</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default {&#xA;  production: (Component) =&gt; Relay.QL`&#xA;    query {&#xA;      getProduction(id: $productionId) {&#xA;        ${Component.getFragment('production')}&#xA;      }&#xA;    }&#xA;  `&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Relay originally generates this query:</p>&#xA;&#xA;<pre><code>query MyProductionDetailsQuery($id_0:ID!,$where_1:ProductionRoleWhereArgs!) {&#xA;  getProduction(id:$id_0) {&#xA;    id,&#xA;    ...F0&#xA;  }&#xA;}&#xA;fragment F0 on Production {&#xA;  id,&#xA;  ...&#xA;  _roles4oPiwv:roles(first:10,where:$where_1) {&#xA;    edges {&#xA;      node {&#xA;        id,&#xA;        ...&#xA;      },&#xA;      cursor&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>variables:</p>&#xA;&#xA;<pre><code>{id_0: ""UHJvZHVjdGlvbjoxNg=="", where_1: {archived: {eq: true}}}&#xA;</code></pre>&#xA;&#xA;<p>However, If the Component's relay container has variables of its own, running <code>this.props.relay.setVariables({...variables})</code> completely changes the request query generated by relay into something like this:</p>&#xA;&#xA;<pre><code>query My_production_details_page_ProductionRelayQL($id_0:ID!,$where_1:ProductionRoleWhereArgs!) {&#xA;  node(id:$id_0) {&#xA;    ...F0&#xA;  }&#xA;}&#xA;fragment F0 on Production {&#xA;  id,&#xA;  _roles6J5gK:roles(first:10,where:$where_1) {&#xA;    edges {&#xA;      node {&#xA;        id,&#xA;        ...&#xA;      },&#xA;      cursor&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>variables:</h2>&#xA;&#xA;<pre><code>{id_0: ""UHJvZHVjdGlvbjoxNg=="", where_1: {archived: {eq: false}}}&#xA;</code></pre>&#xA;&#xA;<p>However, setVariables works fine if I have a root query with no parameters:</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default {&#xA;  viewer: (Component, variables) =&gt; Relay.QL`&#xA;    query {&#xA;      viewer {&#xA;        ${Component.getFragment('viewer', { ...variables })}&#xA;      }&#xA;    }&#xA;  `&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Here's the generated query:</p>&#xA;&#xA;<pre><code>query ViewerQuery($where_0:ProductionWhereArgs!) {&#xA;  viewer {&#xA;    ...F0&#xA;  }&#xA;}&#xA;fragment F0 on Viewer {&#xA;  user {&#xA;    _productions2IPZAw:productions(first:10,where:$where_0) {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          ...&#xA;        },&#xA;        cursor&#xA;      },&#xA;      pageInfo {&#xA;        hasNextPage,&#xA;        hasPreviousPage&#xA;      }&#xA;    },&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>variables:</h2>&#xA;&#xA;<pre><code>{where_0: {expDate: {gt: ""2016-11-04T16:29:11.677Z""}, archived: {eq: false}}}&#xA;</code></pre>&#xA;&#xA;<p>After setVariables in the working setup:</p>&#xA;&#xA;<pre><code>query ViewerQuery($where_0:ProductionWhereArgs!) {&#xA;  viewer {&#xA;    ...F0&#xA;  }&#xA;}&#xA;fragment F0 on Viewer {&#xA;  user {&#xA;    _productions1CyNvL:productions(first:10,where:$where_0) {&#xA;      edges {&#xA;        node {&#xA;          id,&#xA;          ...&#xA;        },&#xA;        cursor&#xA;      },&#xA;      pageInfo {&#xA;        hasNextPage,&#xA;        hasPreviousPage&#xA;      }&#xA;    },&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>variables:</h2>&#xA;&#xA;<pre><code>{where_0: {expDate: {lt: ""2016-11-04T16:34:12.537Z""}, archived: {eq: false}}}&#xA;</code></pre>&#xA;&#xA;<p><strong>versions:</strong></p>&#xA;&#xA;<pre><code>""react-relay"": ""^0.9.3"",&#xA;""react-router-relay"": ""^0.13.5""&#xA;</code></pre>&#xA;&#xA;<p>I'm not sure if I'm doing something wrong with the configuration, or if it's just a bug on Relay's end.</p>&#xA;&#xA;<p>Does anyone know what might be causing this issue?</p>&#xA;",5583860,,5583860,2016-11-04 16:38:01,2016-11-04 16:38:01,Relay generating invalid query after using `setVariables`-- am I doing something wrong?,<reactjs><graphql><relayjs><graphql-js><react-router-relay>,1,2,0,2016-11-03 00:40:05
40407242,2,,40406236,1,,"<p>Have you tried using this package?</p>&#xA;&#xA;<p><a href=""https://github.com/taion/graphql-relay-subscription"" rel=""nofollow noreferrer"">GraphQL Relay Subscription</a></p>&#xA;&#xA;<p>Seems promising, but I haven't actually tried it out myself.</p>&#xA;",6452097,,,,2016-11-03 16:58:00,"",,0,0,0,2016-11-03 16:58:00
40407967,1,40430610,,1,365,"<p>I have two GraphQL/Relay mutations that work fine separately. The first one creates an item. The second one runs a procedure for connecting two items.</p>&#xA;&#xA;<h3>GraphQL</h3>&#xA;&#xA;<pre><code>createOrganization(&#xA;  input: CreateOrganizationInput!&#xA;): CreateOrganizationPayload&#xA;&#xA;createOrganizationMember(&#xA;  input: CreateOrganizationMemberInput!&#xA;): CreateOrganizationMemberPayload&#xA;&#xA;input CreateOrganizationInput {&#xA;  clientMutationId: String&#xA;  organization: OrganizationInput!&#xA;}&#xA;&#xA;input CreateOrganizationMemberInput {&#xA;  clientMutationId: String&#xA;  organizationMember: OrganizationMemberInput!&#xA;}&#xA;&#xA;# Represents a user’s membership in an organization.&#xA;input OrganizationMemberInput {&#xA;  # The organization which the user is a part of.&#xA;  organizationId: Uuid!&#xA;&#xA;  # The user who is a member of the given organization.&#xA;  memberId: Uuid!&#xA;}&#xA;&#xA;type CreateOrganizationPayload {&#xA;  clientMutationId: String&#xA;&#xA;  # The `Organization` that was created by this mutation.&#xA;  organization: Organization&#xA;&#xA;  # An edge for our `Organization`. May be used by Relay 1.&#xA;  organizationEdge(&#xA;    orderBy: OrganizationsOrderBy = PRIMARY_KEY_ASC&#xA;  ): OrganizationsEdge&#xA;&#xA;  # Our root query field type. Allows us to run any query from our mutation payload.&#xA;  query: Query&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would like to be able to run the <code>createOrganization</code> mutation and then connect the user to the organization with the <code>createOrganizationMember</code> mutation. The second mutation takes two arguments, one of which is the newly created edge.</p>&#xA;&#xA;<p>I tried passing the edge into the mutation, but it expects the mutation to be able to <code>getFragment</code>. How can I get the fragment for the payload edge so it can be passed into a mutation?</p>&#xA;&#xA;<h3>React-Relay</h3>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(&#xA;      new CreateOrganizationMutation({&#xA;        organizationData: data,&#xA;        user,&#xA;        query,&#xA;      }), {&#xA;        onSuccess: response =&gt; {&#xA;          Relay.Store.commitUpdate(&#xA;            new CreateOrganizationMemberMutation({&#xA;              organization: response.createOrganization.organizationEdge.node,&#xA;              user,&#xA;            })&#xA;          );&#xA;        },&#xA;      }&#xA;    );&#xA;&#xA;  fragments: {&#xA;    user: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        ${CreateOrganizationMutation.getFragment('user')},&#xA;        ${CreateOrganizationMemberMutation.getFragment('user')},&#xA;      }&#xA;    `,&#xA;</code></pre>&#xA;",1338065,,,,2016-11-04 19:47:48,Relay commitUpdate callback with follow-up mutation and missing fragment,<graphql><relayjs>,1,0,0,2016-11-03 17:38:55
40413469,2,,40392045,0,,"<p>When you run setVariables it leads to refetching only necessary data.&#xA;Relay looks which part of query could be affected by changing variable and requests from GraphQL server needed fragment.&#xA;It is possible because of Node interface(i.e. fetching object by opaque Relay id). See more in <a href=""https://facebook.github.io/relay/docs/graphql-object-identification.html"" rel=""nofollow noreferrer"">documentation</a>.</p>&#xA;&#xA;<p>I think, in your case you should implement Node Interface for Production type on GraphQL server.</p>&#xA;",6571196,,,,2016-11-04 00:28:14,"",,0,1,0,2016-11-04 00:28:14
40415533,2,,40340174,1,,"<p>I use relay and redux in same application without much(I dont have any till today) issues(the App will be in production after few weeks). I could explain how I achieved it. (I am also new react-native and Js development, I don't claim this as the best approach, but at least it works for me as I intended)</p>&#xA;&#xA;<p>Setting up of relay and graphQL almost took a day of effort. For this use following commands:-</p>&#xA;&#xA;<pre><code>npm install babel-core --save-dev&#xA;npm install babel-preset-react-native --save-dev&#xA;npm install babel-relay-plugin --save-dev&#xA;npm install react-relay --save&#xA;npm install graphql --save-dev&#xA;npm install sync-request --save-dev&#xA;</code></pre>&#xA;&#xA;<p>then create a file named <code>babelRelayPlugin.js</code> and copy the below code.</p>&#xA;&#xA;<pre><code>const getBabelRelayPlugin = require('babel-relay-plugin')&#xA;const introspectionQuery = require('graphql/utilities').introspectionQuery&#xA;const request = require('sync-request')&#xA;&#xA;const url = 'your_api_here'&#xA;&#xA;const response = request('POST', url, {&#xA;  qs: {&#xA;    query: introspectionQuery&#xA;  }&#xA;})&#xA;&#xA;const schema = JSON.parse(response.body.toString('utf-8'))&#xA;&#xA;module.exports = { plugins: [getBabelRelayPlugin(schema.data, { abortOnError: true })] }&#xA;</code></pre>&#xA;&#xA;<p>and replace the code your .babelrc with this:- </p>&#xA;&#xA;<pre><code>{&#xA;  ""passPerPreset"": true,&#xA;  ""presets"": [&#xA;    ""./scripts/babelRelayPlugin"",&#xA;    ""react-native""&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>following classes may need to use this import statement:-</p>&#xA;&#xA;<pre><code>import Relay, {&#xA;  Route,&#xA;  DefaultNetworkLayer&#xA;} from 'react-relay'&#xA;</code></pre>&#xA;&#xA;<p>And my App.js file look like:-</p>&#xA;&#xA;<pre><code>  function configureStore(initialState){&#xA;      const enhancer = compose(applyMiddleware(&#xA;        thunkMiddleware,&#xA;        loggerMiddleware&#xA;        ),&#xA;        autoRehydrate()&#xA;      );&#xA;&#xA;        return createStore(reducer,initialState,enhancer);&#xA;    }&#xA;&#xA;    const store = configureStore({});&#xA;    persistStore(store, {storage: AsyncStorage})&#xA;    ////relay network layer injecting&#xA;    Relay.injectNetworkLayer(new DefaultNetworkLayer('your_api'))&#xA;    export default class App extends Component {&#xA;      render() {&#xA;        return (&#xA;          &lt;Provider store={store}&gt;&#xA;            {//here is your react-native-router-flux Navigation router}&#xA;            &lt;NavigationRouter/&gt;&#xA;          &lt;/Provider&gt;&#xA;        );&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>After injecting relay network layer, you could use the following code in any containers to call from relay. Here is an example render method of one of my containers:-</p>&#xA;&#xA;<pre><code>render() {&#xA;    var value = 'some_value';&#xA;    return (&#xA;      &lt;View style={{flex:1,justifyContent:'center',alignItems:'center'}}&gt;&#xA;        &lt;Relay.RootContainer&#xA;        Component={TestComponent}&#xA;        //relay_route is imported from relay_route.js&#xA;        route={new relay_route({id:value})}&#xA;        renderFetched={(data)=&gt; {&#xA;          return (&#xA;            &lt;TestComponent parentProps={this.props} {...data} /&gt;&#xA;          );}}&#xA;        /&gt;&#xA;      &lt;/View&gt;&#xA;    ); &#xA;</code></pre>&#xA;&#xA;<p>the relay_route.js should look something like</p>&#xA;&#xA;<pre><code>class relay_route extends Route {&#xA;  static paramDefinitions = {&#xA;    userID: { required: true }&#xA;  }&#xA;  static queries = {&#xA;    user: () =&gt; Relay.QL`&#xA;      query { &#xA;        user(id: $userID)&#xA;      }&#xA;    `&#xA;  }&#xA;  static routeName = 'UserRoute'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And My TestComponent looks like:-</p>&#xA;&#xA;<pre><code>class TestComponent extends Component {&#xA;  render () {&#xA;    const user = this.props.user&#xA;    return (&#xA;      &lt;Text&gt;name: {user.name}&lt;/Text&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;export default TestComponent = Relay.createContainer(TestComponent, {&#xA;  fragments: {&#xA;      user: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        id,&#xA;        name&#xA;      }&#xA;    `&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>For any doubts regarding relay, <a href=""https://facebook.github.io/relay/docs/getting-started.html#content"" rel=""nofollow noreferrer"">this</a> documentation is classy to help us </p>&#xA;",4682365,,,,2016-11-04 04:54:10,"",,0,0,0,2016-11-04 04:54:10
40430610,2,,40407967,0,,"<p>I solved this problem without changing any GraphQL:</p>&#xA;&#xA;<p>I created a new Relay container, route, and queries object. It is configured as a&#xA;child route for the container where the first of two mutation occurs. The <code>id</code> for&#xA;the new edge is passed as a parameter via the route pathname. A router state&#xA;variable is also passed.</p>&#xA;&#xA;<h3>Routes</h3>&#xA;&#xA;<pre><code>import {Route} from 'react-router';&#xA;&#xA;function prepareProfileParams (params, {location}) {&#xA;  return {&#xA;    ...params,&#xA;    userId: localStorage.getItem('user_uuid'),&#xA;  };&#xA;}&#xA;    // ProfileContainer has the component CreateOrganizationForm, which calls&#xA;    // the createOrganization mutation&#xA;    &lt;Route&#xA;      path={'profile'}&#xA;      component={ProfileContainer}&#xA;      queries={ProfileQueries}&#xA;      prepareParams={prepareProfileParams}&#xA;      onEnter={loginBouncer}&#xA;      renderLoading={renderLoading}&#xA;    &gt;&#xA;      &lt;Route path={'join-organization'}&gt;&#xA;        &lt;Route&#xA;          path={':organizationId'}&#xA;          component={JoinOrganizationContainer}&#xA;          queries={JoinOrganizationQueries}&#xA;          renderLoading={renderLoading}&#xA;        /&gt;&#xA;      &lt;/Route&gt;&#xA;    &lt;/Route&gt;&#xA;</code></pre>&#xA;&#xA;<h3>CreateOrganizationForm.js</h3>&#xA;&#xA;<pre><code>    Relay.Store.commitUpdate(&#xA;      new CreateOrganizationMutation({&#xA;        organizationData: data,&#xA;        user,&#xA;        query,&#xA;      }), {&#xA;        onSuccess: response =&gt; {&#xA;          const organizationId = response.createOrganization.organizationEdge.node.rowId;&#xA;          router.push({&#xA;            pathname: `/profile/join-organization/${organizationId}`,&#xA;            state: {&#xA;              isAdmin: true,&#xA;            },&#xA;          });&#xA;        },&#xA;      }&#xA;    );&#xA;</code></pre>&#xA;&#xA;<p>The new Relay container <code>JoinOrganizationContainer</code> will hook into a lifecycle&#xA;method to call the second mutation that we needed. The second mutation has an&#xA;<code>onSuccess</code> callback which does <code>router.push</code> to the page for the new object we&#xA;created with the first mutation.</p>&#xA;&#xA;<h3>JoinOrganizationContainer.js</h3>&#xA;&#xA;<pre><code>    import React from 'react';&#xA;    import Relay from 'react-relay';&#xA;    import CreateOrganizationMemberMutation from './mutations/CreateOrganizationMemberMutation';&#xA;&#xA;    class JoinOrganizationContainer extends React.Component {&#xA;      static propTypes = {&#xA;        user: React.PropTypes.object,&#xA;        organization: React.PropTypes.object,&#xA;      };&#xA;      static contextTypes = {&#xA;        router: React.PropTypes.object,&#xA;        location: React.PropTypes.object,&#xA;      };&#xA;      componentWillMount () {&#xA;        const {user, organization} = this.props;&#xA;        const {router, location} = this.context;&#xA;&#xA;        Relay.Store.commitUpdate(&#xA;          new CreateOrganizationMemberMutation({&#xA;            user,&#xA;            organization,&#xA;            isAdmin: location.state.isAdmin,&#xA;          }), {&#xA;            onSuccess: response =&gt; {&#xA;              router.replace(`/organization/${organization.id}`);&#xA;            },&#xA;          }&#xA;        );&#xA;      }&#xA;      render () {&#xA;        console.log('Joining organization...');&#xA;        return null;&#xA;      }&#xA;    }&#xA;&#xA;    export default Relay.createContainer(JoinOrganizationContainer, {&#xA;      initialVariables: {&#xA;        userId: null,&#xA;        organizationId: null,&#xA;      },&#xA;      fragments: {&#xA;        user: () =&gt; Relay.QL`&#xA;          fragment on User {&#xA;            ${CreateOrganizationMemberMutation.getFragment('user')},&#xA;          }&#xA;        `,&#xA;        organization: () =&gt; Relay.QL`&#xA;          fragment on Organization {&#xA;            id,&#xA;            ${CreateOrganizationMemberMutation.getFragment('organization')},&#xA;          }&#xA;        `,&#xA;      },&#xA;    });&#xA;</code></pre>&#xA;&#xA;<h3>JoinOrganizationQueries.js</h3>&#xA;&#xA;<pre><code>    import Relay from 'react-relay';&#xA;&#xA;    export default {&#xA;      user: () =&gt; Relay.QL`&#xA;        query { userByRowId(rowId: $userId) }&#xA;      `,&#xA;      organization: () =&gt; Relay.QL`&#xA;        query { organizationByRowId(rowId: $organizationId) }&#xA;      `,&#xA;    };&#xA;</code></pre>&#xA;&#xA;<p>One unexpected benefit of doing things this way is that there is now a shareable url that can be used as an invite link for joining an organization in this app. If the user is logged in and goes to the link: <code>&lt;host&gt;/profile/join-organization/&lt;organizationRowId&gt;</code>, the mutation will run that joins the person as a member. In this use case, <code>router.state.isAdmin</code> is <code>false</code>, so the new membership will be disabled as an admin.</p>&#xA;",1338065,,1338065,2016-11-04 19:47:48,2016-11-04 19:47:48,"",,0,0,0,2016-11-04 19:40:48
40434746,1,40621077,,3,646,"<p>I'm currently learning GraphQL via the tutorial on graphene, however I got this error message when I tried to run: </p>&#xA;&#xA;<pre class=""lang-none prettyprint-override""><code>python3 manage.py graphql_schema&#xA;</code></pre>&#xA;&#xA;<p>Error:</p>&#xA;&#xA;<pre class=""lang-none prettyprint-override""><code>Traceback (most recent call last):&#xA;  File ""manage.py"", line 10, in &lt;module&gt;&#xA;    execute_from_command_line(sys.argv)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django/core/management/__init__.py"", line 354, in execute_from_command_line&#xA;utility.execute()&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django/core/management/__init__.py"", line 346, in execute&#xA;self.fetch_command(subcommand).run_from_argv(self.argv)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django/core/management/base.py"", line 382, in run_from_argv&#xA;parser = self.create_parser(argv[0], argv[1])&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django/core/management/base.py"", line 355, in create_parser&#xA;self.add_arguments(parser)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/management/commands/graphql_schema.py"", line 39, in add_arguments&#xA;default=graphene_settings.SCHEMA,&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/settings.py"", line 110, in __getattr__&#xA;    val = perform_import(val, attr)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/settings.py"", line 54, in perform_import&#xA;    return import_from_string(val, setting_name)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/settings.py"", line 68, in import_from_string&#xA;    module = importlib.import_module(module_path)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/importlib/__init__.py"", line 126, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 986, in _gcd_import&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 969, in _find_and_load&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 958, in _find_and_load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 673, in _load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap_external&gt;"", line 662, in exec_module&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 222, in _call_with_frames_removed&#xA;  File ""/Users/lebeier/Documents/cookbook/schema.py"", line 3, in &lt;module&gt;&#xA;import ingredients.schema&#xA;  File ""/Users/lebeier/Documents/cookbook/ingredients/schema.py"", line 33, in &lt;module&gt;&#xA;class Query(AbstractType):&#xA;  File ""/Users/lebeier/Documents/cookbook/ingredients/schema.py"", line 38, in Query&#xA;all_ingredients = DjangoFilterConnectionField(IngredientNode)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/filter/fields.py"", line 20, in __init__&#xA;self.filterset_class = get_filterset_class(filterset_class, **meta)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/filter/utils.py"", line 32, in get_filterset_class&#xA;return custom_filterset_factory(**meta)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/filter/filterset.py"", line 127, in custom_filterset_factory&#xA;    'Meta': meta_class&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/graphene_django/filter/filterset.py"", line 55, in __new__&#xA;    new_class = super(GrapheneFilterSetMetaclass, cls).__new__(cls, name, bases, attrs)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django_filters/filterset.py"", line 224, in __new__&#xA;    filters[order_by_field] = new_class.get_ordering_filter(opts, filters)&#xA;  File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/django_filters/filterset.py"", line 375, in get_ordering_filter&#xA;    ""'order_by' is not compatible with the 'fields' dict syntax. Use OrderingFilter instead.""&#xA;AssertionError: 'order_by' is not compatible with the 'fields' dict syntax. Use OrderingFilter instead.&#xA;</code></pre>&#xA;&#xA;<p>In my ingredient/schema.py:</p>&#xA;&#xA;<pre><code># cookbook/ingredients/schema.py&#xA;from graphene import relay, ObjectType, AbstractType&#xA;from graphene_django import DjangoObjectType&#xA;from graphene_django.filter import DjangoFilterConnectionField&#xA;&#xA;from .models import Category, Ingredient&#xA;&#xA;# Graphene will automatically map the Category model's fields onto the CategoryNode.&#xA;# This is configured in the CategoryNode's Meta class (as you can see below)&#xA;class CategoryNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Category&#xA;        filter_fields = ['name', 'ingredients']&#xA;        filter_order_by_field = ['name']&#xA;        interfaces = (relay.Node, )&#xA;&#xA;&#xA;class IngredientNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Ingredient&#xA;        # Allow for some more advanced filtering here&#xA;        filter_fields = {&#xA;            'name': ['exact', 'icontains', 'istartswith'],&#xA;            'notes': ['exact', 'icontains'],&#xA;            'category': ['exact'],&#xA;            'category__name': ['exact'],&#xA;        }&#xA;        order_by_field = ['name', 'category__name']&#xA;        interfaces = (relay.Node, )&#xA;&#xA;&#xA;class Query(AbstractType):&#xA;    category = relay.Node.Field(CategoryNode)&#xA;    all_categories = DjangoFilterConnectionField(CategoryNode)&#xA;&#xA;    ingredient = relay.Node.Field(IngredientNode)&#xA;    all_ingredients = DjangoFilterConnectionField(IngredientNode)&#xA;</code></pre>&#xA;&#xA;<p>django-filter version 0.15.3</p>&#xA;&#xA;<p>I have tried to clone the example from the official graphene repo and it worked fine on python2.7. However in python3.5, the same code failed to work. I am suspecting that something has changed in django-filter that resulted in incompatibility. In python2.7, django-filter version is 0.11.0. Does anyone know how to make it work in 0.15.3? </p>&#xA;",4415502,,1940850,2019-03-31 05:10:29,2019-03-31 05:10:29,Django filter error in GraphQL cookbook example,<python><django><graphql><graphene-python>,2,0,0,2016-11-05 04:24:29
40483094,1,40496096,,1,738,"<p>I use django and django graphene for make a graphql API.</p>&#xA;&#xA;<p>In the view of my application, I use reactJS and <a href=""http://allenfang.github.io/react-bootstrap-table/"" rel=""nofollow noreferrer"">react-bootstrap-table</a>. React-bootstrap-table expects that I pass it an object array but does not support <a href=""https://github.com/AllenFang/react-bootstrap-table/issues/444"" rel=""nofollow noreferrer"">nested objects</a>. </p>&#xA;&#xA;<p>I created query in my <strong>schema.py</strong>:</p>&#xA;&#xA;<pre><code>class ApplicationNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Application&#xA;        filter_fields = ['name', 'sonarQube_URL']&#xA;        interfaces = (relay.Node,)&#xA;&#xA;class Query(ObjectType):&#xA;    application = relay.Node.Field(ApplicationNode)&#xA;    all_applications = DjangoFilterConnectionField(ApplicationNode)&#xA;</code></pre>&#xA;&#xA;<p>The answers to these queries are JSON nested objects like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""allApplications"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""QXBwbGljYXRpb25Ob2RlOjE="",&#xA;            ""name"": ""foo"",&#xA;            ""sonarQubeUrl"": ""foo.com"",&#xA;            ""flow"":{ &#xA;                ""id"": ""QYBwbGljYXRpb45Ob2RlOjE="",&#xA;                ""name"": ""flow_foo""&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""QXBwbGljYXRpb25Ob2RlOjI="",&#xA;            ""name"": ""bar"",&#xA;            ""sonarQubeUrl"": ""bar.com""&#xA;            ""flow"":{ &#xA;                ""id"": ""QXBwbGljYXRpb26Ob2RlOjA="",&#xA;                ""name"": ""flow_bar""&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have to put them flat before giving them to React-bootstrap-table.</p>&#xA;&#xA;<p>What is the better way, intercept the results of graphene-django queries to put them flat or make this job in ReactJS view?</p>&#xA;&#xA;<p>If the first way is better, how to intercept the results of graphene-django queries to put them flat?</p>&#xA;",4461034,,,,2016-11-08 20:46:01,Graphene-django - How to catch response of query?,<python><django><reactjs><graphql><graphene-python>,1,0,0,2016-11-08 09:20:26
40483614,1,,,0,276,"<p>I can't figure out what I'm doing wrong, but I can't make work refetching new range via change variable. </p>&#xA;&#xA;<p>Here is part of my relay container code (on initial it works well and fetch first 5 results):</p>&#xA;&#xA;<pre><code>export const Account = Relay.createContainer(_Account, {&#xA;  initialVariables: {&#xA;    activities: 5&#xA;  },&#xA;&#xA;  fragments: {&#xA;    account: () =&gt; Relay.QL`&#xA;      fragment on NodeInterface {&#xA;        id&#xA;        ... on Member {&#xA;          activities(first: $activities) {&#xA;            totalCount&#xA;            edges {&#xA;              node {&#xA;                id&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Here is part of React component what changes relay variable:</p>&#xA;&#xA;<pre><code>export class _Account extends React.Component {&#xA;&#xA;  constructor(props) {&#xA;    super(props);&#xA;    this.state = {&#xA;      activities: 5&#xA;    };&#xA;  }&#xA;&#xA;  loadMoreActivities(e) {&#xA;    e.preventDefault();&#xA;    this.setState((state,props) =&gt; {&#xA;      const next = state.activities + 5;&#xA;      this.props.relay.setVariables({&#xA;        activities: next&#xA;      });&#xA;      return { activities: next }&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;&#xA;                &lt;div&gt;{ this.state.activities.toString() } - { this.props.relay.variables.activities.toString() }&lt;/div&gt;&#xA;                &lt;ProfileActivityList &#xA;                 activities={this.props.account.activities} &#xA;                 loadMore={this.loadMoreActivities.bind(this)} /&gt;&#xA;                }&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",738375,,,,2016-11-08 10:59:17,this.props.relay.setVariables() doesnt fetch new results (but change variable as well),<reactjs><graphql><relay>,1,0,0,2016-11-08 09:45:57
40485153,2,,40483614,0,,<p>I figure out what is wrong. <code>pageInfo</code> data is important to pagination. I just add <code>pageInfo</code> to query and everything works as excepted.</p>&#xA;,738375,,,,2016-11-08 10:59:17,"",,0,0,0,2016-11-08 10:59:17
40496096,2,,40483094,2,,"<p>The best thing to do is to wrap react-bootstrap-table in a new component. In the component massage the relay props into a flat structure as needed for react bootstrap table.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>MyReactTable = ({allApplications}) =&gt; {&#xA;  let flatApplications = allApplications.edges.map(({node: app}) =&gt; {&#xA;    return {&#xA;      name: app.name,&#xA;      sonarQubeUrl: app.sonarQubeUrl,&#xA;      flowName: app.flow.name&#xA;    };&#xA;  });&#xA;  return (&#xA;    &lt;BootstrapTable data={flatApplications} striped={true} hover={true}&gt;&#xA;      &lt;TableHeaderColumn dataField=""name"" isKey={true} dataAlign=""center"" dataSort={true}&gt;Name&lt;/TableHeaderColumn&gt;&#xA;      &lt;TableHeaderColumn dataField=""sonarQubeUrl"" dataSort={true}&gt;Sonar Qube Url&lt;/TableHeaderColumn&gt;&#xA;      &lt;TableHeaderColumn dataField=""flowName"" dataFormat={priceFormatter}&gt;Flow Name&lt;/TableHeaderColumn&gt;&#xA;    &lt;/BootstrapTable&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;",476414,,,,2016-11-08 20:46:01,"",,0,0,0,2016-11-08 20:46:01
40547164,1,40553857,,6,2371,"<p>I'm trying to build a mutation within relay that includes a file. As soon as I implement the <code>getFiles()</code> method referenced here: <a href=""https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getfiles"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getfiles</a></p>&#xA;&#xA;<p>Relay sends a multipart request causing a 415 error from ASP.NET Core MVC.</p>&#xA;&#xA;<p>I'm looking for a working example, similar to ""<a href=""https://stackoverflow.com/questions/33060182/how-would-you-do-file-uploads-in-a-react-relay-app"">How would you do file uploads in a React-Relay app?</a>"" with the <a href=""https://github.com/graphql-dotnet/graphql-dotnet"" rel=""nofollow noreferrer"">graphql-dotnet library</a>.</p>&#xA;",291793,,279764,2017-09-07 16:19:22,2017-09-07 16:19:22,File Upload with Relay and graphql-dotnet,<asp.net><asp.net-mvc><graphql><relayjs><graphql-dotnet>,2,0,0,2016-11-11 11:34:57
40651943,1,40695318,,4,871,"<p>I'm having a little bit more complex data structure resulting in a deeply nested graph. Right now I'm always fetching/reloading through root queries. However I think this is not the best way since it always requires the server to resolve the whole tree. </p>&#xA;&#xA;<p>Is it possible to fetch / reload additional data/edges of sub edges in an nested graph in a second request without traversing the whole tree?</p>&#xA;&#xA;<p>If yes how?</p>&#xA;&#xA;<p>Eg: I have a</p>&#xA;&#xA;<pre><code>RootQuery Spaces&#xA; + ... Other Layers&#xA;    + Project&#xA;        + Edge Tasks&#xA;            + Edge SubTasks&#xA;                + Edge Assigned User&#xA;</code></pre>&#xA;&#xA;<p>Showing the Project list I'm not loading Tasks on initial request. If the user opens a Project I'd like to lacy load the tasks of only this project, without reloading the parent/root or the whole tree starting from the RootQuery. </p>&#xA;",827148,,13302,2018-01-24 19:05:26,2018-01-24 19:05:26,GraphQL fetching additional data of subedges in a nested graph,<facebook-graph-api><graphql><graphql-js><apollostack><apollo-server>,1,0,0,2016-11-17 10:06:10
40653773,1,,,12,4962,"<p>Suppose I have a model like this</p>&#xA;&#xA;<pre><code>class Order(models.Model):&#xA;    STATES = [&#xA;        (1, 'Initiate'),&#xA;        (2, ""Brief""),&#xA;        (3, ""Planning""),&#xA;        (4, ""Price Negotiate""),&#xA;        (5, ""Executing""),&#xA;        (6, ""Pending""),&#xA;        (7, ""Completed""),&#xA;        (8, ""Canceled""),&#xA;        (9, ""Failed""),&#xA;        (10, ""Paid""),&#xA;    ]&#xA;&#xA;    state = models.PositiveSmallIntegerField(&#xA;        choices=STATES,&#xA;        default=1&#xA;    )&#xA;</code></pre>&#xA;&#xA;<p>When I pair this model with its Graphene object type companion</p>&#xA;&#xA;<pre><code>class OrderNode(graphene_django.DjangoObjectType):&#xA;    class Meta:&#xA;        model = Order&#xA;        interfaces = (relay.Node,)&#xA;</code></pre>&#xA;&#xA;<p>An enum type with name <code>OrderState!</code> is created.</p>&#xA;&#xA;<p>I am concerned with</p>&#xA;&#xA;<ol>&#xA;<li>How can I query for the enums</li>&#xA;<li>How can I manage enums in React with Apollo client</li>&#xA;</ol>&#xA;&#xA;<p>For the first question, I have this query</p>&#xA;&#xA;<pre><code>{&#xA;  customer(id: ""Q3VzdG9tZXJOb2RlOjE="") {&#xA;    name&#xA;    orders {&#xA;      edges {&#xA;        node {&#xA;          state&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It gives me a weird state value like <code>A_1</code> and <code>A_2</code>. I was expecting it to give me some meaningful value like ""Initiate"". How can I get the value of the kv pair enum?</p>&#xA;&#xA;<p>For the second question, if I want to present to user a list of possible value for this enum, how can I do so?</p>&#xA;",1196906,,,,2016-11-17 13:32:57,Query for enum value in GraphQL,<django><graphql><react-apollo><graphene-python>,1,1,0,2016-11-17 11:30:26
40699069,2,,40680185,0,,"<p>It doesn't matter at all if query structure or data is the same for each item. Items <strong>are cached by IDs</strong> and if IDs are different (node interface requires IDs as we know), Relay requires data for each ID.</p>&#xA;&#xA;<p>Why IDs? Because that enables data flattening and results in much efficient and granular caching. It also lets Relay to make efficient diffing which means that only the missing fields per ID are requested.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>If in your particular case each of the components end up needing the same set of data, consider using a single Relay Container for parent component and pass the same data to each row. Problem solved! </p>&#xA;",5383767,,,,2016-11-19 23:34:24,"",,0,1,0,2016-11-19 23:34:24
40729657,1,,,12,3774,"<p>I would like to use <code>create-react-app</code> without ejecting my Relay app.</p>&#xA;&#xA;<p>According to <a href=""https://facebook.github.io/relay/docs/guides-babel-plugin.html#usage"" rel=""noreferrer"">Relay documentation</a> I will need the <code>babel-relay-plugin</code>. The <code>relay-starter-kit</code> configures this in a <a href=""https://github.com/relayjs/relay-starter-kit/blob/f3025cee82eacc0fbfb66cec075b3691663d0b9f/.babelrc"" rel=""noreferrer"">.babelrc</a>.</p>&#xA;&#xA;<p>What would be the easiest way to accomplish this? Is there a way to enable <code>relay</code> without ejecting?</p>&#xA;",4149575,,710693,2017-08-11 00:17:34,2018-12-07 08:53:00,What's the easiest way to use Create React App with Relay?,<reactjs><graphql><relayjs><create-react-app>,4,0,0,2016-11-21 21:24:31
40837198,2,,40833876,2,,<p>You could try putting the logic in componentDidUpdate if the only issue is the warning.</p>&#xA;,7193872,,,,2016-11-28 04:28:15,"",,0,1,0,2016-11-28 04:28:15
40897711,1,41023848,,0,211,"<p>I am starting to develop for relay coming from Apollo.&#xA;I have a dumb server running on a SQLITE3 database just for testing while I am refactoring.&#xA;Using <a href=""https://github.com/graphql/graphql-relay-js"" rel=""nofollow noreferrer"">graphql-relay</a> on the backen.</p>&#xA;&#xA;<p>Currently I have something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  root: {&#xA;    allFoo: [FooType]&#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I was wondering how I would add a new FooType item to the allFoo list.&#xA;On the <a href=""https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getconfigs-abstract-method"" rel=""nofollow noreferrer"">getConfigs</a> the <a href=""https://facebook.github.io/relay/docs/guides-mutations.html#mutator-configuration"" rel=""nofollow noreferrer"">RANGE_ADD</a> only acts upon connections.&#xA;So do I need to make my allFoo type a connection instead of a GraphqlList(FooType) ? Or can I use FIELD_CHANGE somehow?</p>&#xA;",1440762,,,,2017-01-15 03:53:54,Graphql relay array field,<graphql><relayjs><mutation>,1,0,0,2016-11-30 20:36:37
40914883,1,43638901,,2,355,"<p>I'm trying to achieve a mutation which is a RANGE_DELETE on a connection, but only on the specified arguments.</p>&#xA;&#xA;<p>Scenario : the logged user, <code>Viewer</code> can see requests from others users and approve them.</p>&#xA;&#xA;<p>The <code>User</code> type has a field <code>viewableRequests</code>, which is a relay connection, and with an extra optional argument <code>state</code>, which will filter the requests and only keep the one with the corresponding state.</p>&#xA;&#xA;<p>Schema :</p>&#xA;&#xA;<pre><code>type User {&#xA;  id: ID&#xA;  viewableRequests(first: Int, [...], state: RequestStateEnum): ViewableRequestsConnection&#xA;}&#xA;&#xA;type ViewableRequestsConnection {&#xA;  edges: [RequestEdge]&#xA;  ...&#xA;}&#xA;&#xA;type RequestEdge {&#xA;  cursor: GraphQLString&#xA;  node: Request&#xA;}&#xA;&#xA;type Request {&#xA;  id: ID&#xA;  user_id: Int&#xA;  state: RequestStateEnum&#xA;}&#xA;&#xA;enum RequestStateEnum {&#xA;  pending&#xA;  approved&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So if I call <code>viewableRequests(state: pending)</code>, I only get requests with the pending state, and if I call <code>viewableRequests(state: approved)</code>, I only get the the requests with the approved state.</p>&#xA;&#xA;<p>How can I write a <code>ApproveRequest</code> mutation that will do a RANGE_DELETE on the <code>viewableRequests(state: pending)</code> connection, and a RANGE_ADD on the <code>viewableRequests(state: approved)</code> connection, and how should I shape the <code>getOptimisticResponse()</code> method ?</p>&#xA;&#xA;<p>Here is my mutation schema :</p>&#xA;&#xA;<pre><code>type ApproveRequestInput {&#xA;  requestId: ID&#xA;}&#xA;&#xA;type ApproveRequestPayload {&#xA;  viewer: User&#xA;  approvedRequest: Request&#xA;}&#xA;&#xA;mutation {&#xA;  approveRequest($input: ApproveRequestInput): ApproveRequestPayload&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is my current code :</p>&#xA;&#xA;<pre><code>import Relay, {&#xA;  Mutation,&#xA;} from 'react-relay';&#xA;&#xA;export default class ApproveRequestMutation extends Mutation {&#xA;  static fragments = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        id&#xA;      }&#xA;    `,&#xA;    request: () =&gt; Relay.QL`&#xA;      fragment on Request {&#xA;        id&#xA;      }&#xA;    `,&#xA;  };&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { approveRequest }`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      requestId: this.props.request.id,&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on ApproveRequestPayload @relay(pattern: true) {&#xA;        viewer {&#xA;          pendingRequests: viewableRequests(state: pending)&#xA;          approvedRequests: viewableRequests(state: approved)&#xA;        }&#xA;        approvedRequest&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      // What should I write here ?&#xA;    };&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    // The RANGE_DELETE config is not working ; how can I make it work ?&#xA;    return [{&#xA;      type: 'RANGE_DELETE',&#xA;      parentName: 'viewer',&#xA;      parentID: this.props.viewer.id,&#xA;      connectionName: 'pendingRequests',&#xA;      deletedIDFieldName: ['approvedRequest'],&#xA;      pathToConnection: ['viewer', 'pendingRequests'],&#xA;    }];&#xA;    // How can I can add here a RANGE_ADD config for the `approvedRequests` connection ?&#xA;    // I guess I must add an `approvedRequestEdge` on the mutation payload, but what is the config then ?&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;",3076424,,,,2017-04-26 15:45:24,RANGE_DELETE and RANGE_ADD on connections with arguments,<graphql><relayjs>,1,0,0,2016-12-01 15:45:42
40954715,1,,,0,49,"<p>Is relay capable of knowing that a field should be a <code>Date</code>, for example, and converting that value from a <code>string</code> to a <code>Date</code>? Is there a place that this kind of logic can be placed?</p>&#xA;",294120,,,,2017-04-18 15:48:17,How to perform type coercion with Relay?,<reactjs><graphql><relay>,1,1,0,2016-12-04 02:21:36
41023848,2,,40897711,1,,"<p>Take a look at this example: &#xA;<a href=""https://github.com/bfwg/relay-gallery/blob/master/frontend/src/app/mutation/AddImageMutation.js#L47"" rel=""nofollow noreferrer"">https://github.com/bfwg/relay-gallery/blob/master/frontend/src/app/mutation/AddImageMutation.js#L47</a></p>&#xA;&#xA;<p>The below example is a demo on how to add an image to the image list.</p>&#xA;&#xA;<pre><code>getConfigs() {&#xA;  return [{&#xA;    type: 'RANGE_ADD',&#xA;    parentName: 'User',&#xA;    parentID: this.props.images.id,&#xA;    connectionName: 'images',&#xA;    edgeName: 'newImageEdge',&#xA;    rangeBehaviors: {&#xA;      '': 'prepend',&#xA;    },&#xA;  }];&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Hope this helps!</p>&#xA;",5718107,,5718107,2017-01-15 03:53:54,2017-01-15 03:53:54,"",,0,0,0,2016-12-07 17:34:51
41039430,1,,,1,54,"<p>I have:</p>&#xA;&#xA;<pre><code> ChildItem = Relay.createContainer(ChildItem , {&#xA; fragments: {&#xA; childItem: () =&gt; Relay.QL`&#xA;   fragment on Item&#xA;  {&#xA;    name&#xA;    color&#xA;  }`&#xA;}});&#xA;&#xA; ItemList = Relay.createContainer(ItemList, {&#xA; fragments: {&#xA; list: () =&gt; Relay.QL `&#xA;   fragment on Item{&#xA;     id&#xA;     ${ChildItem.getFragment('childItem')}&#xA;   }`&#xA;}});&#xA;</code></pre>&#xA;&#xA;<p>Using React.injectNetworkLayer() I send a request to the back-end server where I'm trying to receive the result of the GraphQL query which looks like this:</p>&#xA;&#xA;<pre><code> {""query"":""query GraphQLObjQueryType {&#xA;    GraphQLObj_query {&#xA;    ...F1&#xA;    }&#xA; }&#xA;   fragment F0 on GraphQLObj &#xA;   {&#xA;     name,&#xA;     color {&#xA;         id&#xA;     },&#xA;     id&#xA;      }&#xA;     fragment F1 on GraphQLObj  {&#xA;         id,&#xA;          ...F0&#xA;     }"",&#xA;""variables"":{}}&#xA;</code></pre>&#xA;&#xA;<p>GraphQLObjQueryType is a GraphQLObjectType(query) with name field GraphQLObj_query of the object GraphQLObj.</p>&#xA;&#xA;<p>Is there a additional setting for relay or GraphQL that tells how  the response should be sent.</p>&#xA;",7041216,,7041216,2016-12-09 08:02:43,2016-12-09 08:02:43,I'm trying to send a request through Relay.injectNetworkLayer() to a java server,<java><reactjs><webpack><graphql><relayjs>,0,2,0,2016-12-08 12:22:03
41051401,1,41269498,,6,978,"<p><strong>THE PROMPT</strong></p>&#xA;&#xA;<p>If you were to build Google Calendar using relay, how would you structure the GraphQL schema and the Relay containers/components to properly handle showing &amp; hiding multiple calendars?</p>&#xA;&#xA;<p><strong>THE ATTEMPT</strong></p>&#xA;&#xA;<p>One might imagine a schema like this:</p>&#xA;&#xA;<pre><code>viewer {&#xA;  user {&#xA;    calendars(calendarIds: [String]) {&#xA;      edges,&#xA;        node {&#xA;          name,&#xA;          id,&#xA;          events(dates: [Date]) {&#xA;            ... edges, node, eventinfo...&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So, I can pull down all the calendars and all the events, or a specific calendar, or what have you.</p>&#xA;&#xA;<p>Structuring the Relay Containers and components, I would imagine the following:</p>&#xA;&#xA;<pre><code>&lt;CalendarView Container&gt;&#xA;  &lt;CalendarView&gt;&#xA;    &lt;WeekView&gt; or &lt;MonthView&gt; or &lt;Agenda&gt; etc...&#xA;      &lt;Event&gt;&#xA;</code></pre>&#xA;&#xA;<p>Such that the CalendarView relay container sets up the fragment requesting the calendars, and the <code>CalenderView</code> component uses <code>setVariables</code> to toggle the showing/hiding of that calendar in the view.</p>&#xA;&#xA;<p>The problem that I'm encountering (and that's making my head spin) is that the <code>Day</code>/<code>Week</code>/<code>Month</code>/<code>Agenda</code> components are combinatorial views — that is, they require the data from all selected events.</p>&#xA;&#xA;<p><strong>THE PLOT THICKENS</strong></p>&#xA;&#xA;<p>Now, that sounds just fine — have the <code>CalendarView</code> set the calendarId variables and pass the resulting events down, right? Well... kind of. Now the fragment for <code>CalendarView</code> is constructed with a set of <code>calendarIds</code>, such that toggling one <code>calendar</code> on or off changes the entire tree of what is to be fetched.</p>&#xA;&#xA;<p><strong>THE GOTCHA?</strong></p>&#xA;&#xA;<p>As far as I can tell, relay sees each combination of <code>calendarIds</code> as an entirely different fetch. So, when I toggle on a new <code>id</code> it fetches <em>all</em> the events, even for those calendars I've already fetched.</p>&#xA;&#xA;<p>Put code-wise:</p>&#xA;&#xA;<pre><code>fragment calendar(calendarIds: [1, 2]) { ... } &#xA;</code></pre>&#xA;&#xA;<p>Is an <em>entirely</em> different fetch from:</p>&#xA;&#xA;<pre><code>fragment calendar(calendarIds: [1, 2, 3]) { ... }&#xA;</code></pre>&#xA;&#xA;<p>This is ... bad. There can be a lot of events on those calendars and the over-fetching is a killer.</p>&#xA;&#xA;<p>In theory, I could create a container per calendar, but then how would I combine the events on those calendars and pipe them into a common sub-component? The calendars can't be layered because events need to move around in reaction to other events, even those on separate calendars (shifting left/right to show them side-by-side).</p>&#xA;&#xA;<p>Thoughts? My brain hurts.</p>&#xA;",1162945,,,,2016-12-21 18:25:05,GraphQL & Relay Filtering UI,<reactjs><graphql><relayjs>,1,0,0,2016-12-09 00:52:12
41110918,2,,41103597,7,,"<p>First, you can separate the definition of your component from the wrapping of it in Apollo's <code>graphql()</code> HOC.  Then, you can continue to <code>export default</code> the Apollo-ized component, but you can <code>export</code> the bare component as a named export:</p>&#xA;&#xA;<pre><code>export const ReviewList = React.createClass({&#xA;  // ...&#xA;});&#xA;&#xA;export default graphql(allCodeReviews)(ReviewList);&#xA;</code></pre>&#xA;&#xA;<p>...in your normal code, where you want it to be connected through Apollo, you'd continue to import the default like this:</p>&#xA;&#xA;<pre><code>import ReviewList from 'components/tibco/review-list/review-list';&#xA;</code></pre>&#xA;&#xA;<p>...but in your unit test code, you'd used the named import like this:</p>&#xA;&#xA;<pre><code>import { ReviewList } from 'components/tibco/review-list/review-list';&#xA;</code></pre>&#xA;",6901631,,,,2016-12-12 22:41:23,"",,0,2,0,2016-12-12 22:41:23
41118286,1,41128168,,1,284,"<p>I am using Relay and Graphql and I have a hard time figuring out how to fetch more fields on one object in a connection.</p>&#xA;&#xA;<p>Suppose we have the following query to populate a list of a viewer's tasks:</p>&#xA;&#xA;<pre><code>viewer {&#xA;  id&#xA;  tasks(first:10) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When the user then selects one in the list, I want to fetch more fields on the selected one.</p>&#xA;&#xA;<p>Here are my thoughts:</p>&#xA;&#xA;<ol>&#xA;<li>I implement a new field/method on the viewer object that is called ""task"" and that takes an id as input and returns just the one task. Like this answer: <a href=""https://stackoverflow.com/a/40712653/5820184"">https://stackoverflow.com/a/40712653/5820184</a></li>&#xA;<li>Use the node root query to fetch the missing data. (I am not sure how to do this in relay. Do I make the root container dependent on on both queries?)</li>&#xA;<li>Make the connection take an input of id and then only return that one task.</li>&#xA;</ol>&#xA;&#xA;<p>Now 1. seems to go against the whole ""graph"" model thinking by adding a ""function"" to fetching one element to the graph.</p>&#xA;&#xA;<p>For number 2, I am not quite sure that using the node root query is a good practice, since it seems to be an internal relay thing?</p>&#xA;&#xA;<p>I don't know if number 3 is a viable solution since it is kind of filtering the list which may have an impact on the list view?</p>&#xA;&#xA;<p><strong>UPDATE</strong></p>&#xA;&#xA;<p>We ended up making a field for each connection that takes an id as input an returns one element from the list. This was inspired by the way Graphcool, GitHub and others do it in their endpoints. Thanks for pointing me in the right direction.</p>&#xA;",5820184,,5820184,2016-12-27 15:19:10,2017-03-24 09:54:30,More info on an element of a relay connection,<graphql><relayjs><relay>,2,0,0,2016-12-13 10:03:22
41128213,2,,41118286,0,,"<p>You can do that with the help of <code>@include</code> directive. Relay will take care of everything!</p>&#xA;&#xA;<p>Assuming you have designed <code>task</code> as a separate React component, the exported Relay container will look like this:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(Task, {&#xA;  initialVariables: {&#xA;    taskSelected: false,&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        id&#xA;        tasks(first:10) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;              additionalInfo @include(if: $taskSelected) {&#xA;                where,&#xA;                when,&#xA;                who,&#xA;                priority&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Fetching of <code>additionalInfo</code> is made conditional by using <code>@include(if: $taskSelected)</code>, where <code>taskSelected</code> is a Relay variable and initialized under <code>initialVariables</code> property. When a viewer selects a task for more info, set <code>taskSelected</code> to true with:</p>&#xA;&#xA;<pre><code>this.props.relay.setVariables({ taskSelected: true });&#xA;</code></pre>&#xA;",2821632,,2821632,2016-12-13 20:07:57,2016-12-13 20:07:57,"",,0,0,0,2016-12-13 18:35:56
41146840,1,41152417,,0,469,"<p>I've got a graphql-java implementation and a schema defined.&#xA;Is it possible to create a field of type GraphQLList(SomeGraphQLObjectType) in a GraphQL query and use it in a Relay.QL {} declaration fragment, so I can receive a list of the desired object? Is this the place where Relay ""Connections"" work? </p>&#xA;&#xA;<pre><code>export default Relay.createContainer(ChildComponent, {&#xA;  fragments: {&#xA;    item: () =&gt; Relay.QL`&#xA;      fragment on Item&#xA;      {&#xA;        id,&#xA;        name,&#xA;        color{&#xA;          id,&#xA;          name&#xA;        }&#xA;      }`&#xA;  }});&#xA;&#xA;&#xA;export default Relay.createContainer(ParentComponent, {&#xA;  fragments: {&#xA;    list: () =&gt; Relay.QL`&#xA;    fragment on ListOfItems{&#xA;       allItems&#xA;       {&#xA;         ${ChildComponent.getFragment('item')}&#xA;       }&#xA;    }`&#xA;  }&#xA;});&#xA;</code></pre>&#xA;",7041216,,2821632,2016-12-14 22:43:50,2016-12-14 22:43:50,How to define Relay fragment for GraphQLList of GraphQLObjectType?,<java><reactjs><graphql><relayjs>,1,0,0,2016-12-14 15:54:39
41152417,2,,41146840,2,,"<blockquote>&#xA;  <p>Is it possible to create a field of type&#xA;  <strong>GraphQLList(SomeGraphQLObjectType)</strong> in a GraphQL query and use it in a&#xA;  Relay.QL {} declaration fragment?</p>&#xA;</blockquote>&#xA;&#xA;<p>Yes, it's possible with the help of <a href=""https://github.com/facebook/relay/blob/bb364a713affb1cad073c412283c3bd2f4650b9a/docs/APIReference-QL.md#array-fields"" rel=""nofollow noreferrer""><code>@relay(plural: true)</code></a> directive. It tells Relay that this field is a list, instead of a single item.</p>&#xA;&#xA;<p>Define the field like this, where <code>Item</code> is a GraphQLObjectType with the same <code>name</code>:</p>&#xA;&#xA;<pre><code>itemList: {&#xA;  type: new GraphQLList(Item),&#xA;  // other stuff including resolve function&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>Since you have divided your Relay containers as parent and child, define the parent container like this:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(ParentComponent, {&#xA;  fragments: {&#xA;    itemList: () =&gt; Relay.QL`&#xA;      fragment on Item @relay(plural:true) {&#xA;        ${ChildComponent.getFragment('item')}&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>and the child container like this:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(ChildComponent, {&#xA;  fragments: {&#xA;    item: () =&gt; Relay.QL`&#xA;      fragment on Item {&#xA;        id,&#xA;        name,&#xA;        color {&#xA;          id,&#xA;          name,&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>You can learn more about Relay directives in <a href=""https://medium.com/the-graphqlhub/graphql-tour-directives-558dee4fa903#.a6ce9wdqn"" rel=""nofollow noreferrer"">this article</a> by Clay Allsopp.</p>&#xA;&#xA;<p>There's a <a href=""https://stackoverflow.com/questions/32491117/how-to-get-relayjs-to-understand-that-a-response-from-graphql-is-an-array-of-ite"">similar question</a> which you can take a look at too.</p>&#xA;&#xA;<blockquote>&#xA;  <p>Is this the place where Relay ""Connections"" work?</p>&#xA;</blockquote>&#xA;&#xA;<p>It depends. If you do not want all items in one shot, then connection is the way to go. It enables fetching data incrementally. </p>&#xA;",2821632,,,,2016-12-14 21:23:07,"",,0,1,0,2016-12-14 21:23:07
41157326,1,41211117,,0,113,"<p>Using a <a href=""https://facebook.github.io/relay/docs/api-reference-relay-container.html#content"" rel=""nofollow noreferrer"">Relay Container</a> and <a href=""https://developer.github.com/early-access/graphql/"" rel=""nofollow noreferrer"">Github's GraphQL API</a> if I have <code>fragment on User { id }</code> it successfully loads my github account id . However if I try <code>fragment on Repository {}</code> it says ""GraphQL unknown type"". </p>&#xA;&#xA;<p>What is the best way to reliably query fragments from GitHub's API using Relay? </p>&#xA;",2203803,,,,2016-12-18 17:43:01,Relay and ReactJS give an error when connecting to Github's GraphQL,<reactjs><github-api><graphql><relay>,1,2,0,2016-12-15 05:54:15
41210780,1,41222088,,3,211,"<p>I am attempting to fetch some of <a href=""https://developer.github.com/early-access/graphql/object/query/"" rel=""nofollow noreferrer"">Github's GraphQL data</a> and display it using React &amp; Relay. The two problems I have are that it appears relay is adding aliases to the response (making it difficult to reference), and not all the item's queried are getting passed into my component <code>props</code>. In the code below I can render <code>this.props.relay.variables.name</code> but get undefined when trying to loop over <code>this.props.relay.variables.issues</code></p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""true"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>// AppQuery.js&#xD;&#xA;import Relay from 'react-relay'&#xD;&#xA;export default {&#xD;&#xA;  relay : Component =&gt; Relay.QL `&#xD;&#xA;    query {&#xD;&#xA;      relay {&#xD;&#xA;        ${Component.getFragment('relay')}&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  `&#xD;&#xA;};</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>// AppContainer.js&#xD;&#xA;import Relay from 'react-relay'&#xD;&#xA;import App from './AppComponent'&#xD;&#xA;&#xD;&#xA;export default Relay.createContainer(App, {&#xD;&#xA;  initialVariables: {&#xD;&#xA;    owner: ""rails"",&#xD;&#xA;    name: ""rails"",&#xD;&#xA;    count: 10&#xD;&#xA;  },&#xD;&#xA;  fragments: {&#xD;&#xA;    relay: () =&gt; Relay.QL `&#xD;&#xA;      fragment on Query {&#xD;&#xA;        repository(owner: $owner, name: $name) {&#xD;&#xA;          name&#xD;&#xA;          owner&#xD;&#xA;          description&#xD;&#xA;          issues(first: 20) {&#xD;&#xA;            edges {&#xD;&#xA;              node {&#xD;&#xA;                title&#xD;&#xA;              }&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }`&#xD;&#xA;  }&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>//AppComponent.js&#xD;&#xA;export default class App extends React.Component {&#xD;&#xA;  render() {&#xD;&#xA;    return (&#xD;&#xA;      &lt;div&gt;&#xD;&#xA;        &lt;h1&gt;{this.props.relay.variables.name}&lt;/h1&gt;&#xD;&#xA;        &lt;ul&gt;&#xD;&#xA;          { this.props.relay.variables.issues.edges.map((issue) =&gt; {&#xD;&#xA;            return(&lt;li&gt;{issue.node.title}&lt;/li&gt;)&#xD;&#xA;          })}&#xD;&#xA;        &lt;/ul&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>In the response preview it appears that I am successfully fetching the specified data.</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/oI61T.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oI61T.png"" alt=""github graphQL response object""></a></p>&#xA;&#xA;<p>But when I console log <code>this.props</code> some properties from the fetch are missing. </p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/2QvLa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2QvLa.png"" alt=""result after console logging this.props ""></a></p>&#xA;",2203803,,2203803,2016-12-18 22:20:59,2016-12-19 22:52:28,unable to render nested props from Github's GraphQL,<javascript><reactjs><github-api><graphql><relayjs>,1,0,0,2016-12-18 17:05:56
41211117,2,,41157326,0,,"<p>I was getting the error because graphQL has specific properties accessible to the client. Trying to fetch an erroneous fragment (or in my case incorrectly nested fragment names) results in ""GraphQL unknown type"". The solution is to use Github's GraphQL root node called <code>relay</code> which re-exposes all root queries such as <code>repository</code> see <a href=""https://developer.github.com/early-access/graphql/object/query/"" rel=""nofollow noreferrer"">the docs</a> for more details. &#xA;Here is my parent query:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import Relay from 'react-relay'&#xD;&#xA;&#xD;&#xA;export default {&#xD;&#xA;  relay : Component =&gt; Relay.QL `&#xD;&#xA;    query {&#xD;&#xA;      relay {&#xD;&#xA;        ${Component.getFragment('relay')}&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  `&#xD;&#xA;};</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>and here is my container component </p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import Relay from 'react-relay'&#xD;&#xA;import App from './AppComponent'&#xD;&#xA;&#xD;&#xA;export default Relay.createContainer(App, {&#xD;&#xA;  initialVariables: {&#xD;&#xA;    owner: ""rails"",&#xD;&#xA;    name: ""rails"",&#xD;&#xA;    count: 10&#xD;&#xA;  },&#xD;&#xA;  fragments: {&#xD;&#xA;    relay: () =&gt; Relay.QL `&#xD;&#xA;      fragment on Query {&#xD;&#xA;        repository(owner: $owner, name: $name) {&#xD;&#xA;          name&#xD;&#xA;          owner&#xD;&#xA;          description&#xD;&#xA;          issues(first: 20) {&#xD;&#xA;            edges {&#xD;&#xA;              node {&#xD;&#xA;                title&#xD;&#xA;              }&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }`&#xD;&#xA;  }&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",2203803,,,,2016-12-18 17:43:01,"",,0,0,0,2016-12-18 17:43:01
41212483,1,,,1,347,<p>I use graphql-java library and I send a Relay request and I'm expecting a result(response) from the GraphQL server(implemented in java). How exactly does the GraphQL.execute() executes queries sent from Relay(queries are used with fragments) ?&#xA;How should DataFetcher understand a Relay request?</p>&#xA;,7041216,,1909531,2017-02-05 11:01:26,2017-02-05 11:01:26,How does graphql-java library execute Relay requests?,<java><graphql><relayjs><graphql-java>,0,1,0,2016-12-18 20:22:14
41212653,1,,,0,101,"<p>I'm currently experimenting with a single page application implementation that consists of a Layout component and swapping numerous Page components nested inside. The Relay containers on the Layout and numerous Pages share variables (in this example, <code>$groupId</code>) that are used to filter queries in their fragments.</p>&#xA;&#xA;<p>The problem is that the current implementation dispatches two requests for each active route instead of just one. I may be approaching this wrong but how can I combine the requests or structure the application so issuing only one <code>setVariable({groupId: ... })</code> will update both components instead of having to set the variables on both components separately. </p>&#xA;&#xA;<h3>Route Configuration</h3>&#xA;&#xA;<pre><code>&lt;Route path=""/"" component={Layout} queries={ViewerQuery} render=  {renderer(Layout)}&gt;&#xA;  &lt;IndexRoute component={DashboardPage} queries={ViewerQuery}/&gt;&#xA;  ...&#xA;&lt;/Route&gt;&#xA;</code></pre>&#xA;&#xA;<h3>Viewer Query</h3>&#xA;&#xA;<pre><code>export default {&#xA;  viewer: (Component, variables) =&gt; Relay.QL`query { &#xA;    viewer {&#xA;      ${Component.getFragment(""viewer"", variables)}&#xA;    }&#xA;  } &#xA;  `&#xA;};&#xA;</code></pre>&#xA;&#xA;<h3>Layout</h3>&#xA;&#xA;<pre><code>export default Relay.createContainer(Layout, {&#xA;  initialVariables: {&#xA;    groupId: null&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        username&#xA;        group(id: $groupId) {&#xA;          description&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<h3>Dashboard Page</h3>&#xA;&#xA;<pre><code>export default Relay.createContainer(DashboardPage, {&#xA;  initialVariables: {&#xA;    groupId: null&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        group(id: $groupId) {&#xA;          ${SubComponent.getFragment('data')}&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;",1256074,,,,2016-12-18 21:48:37,Single-Page App Sharing Relay Variables,<reactjs><graphql><relay><react-router-relay>,1,0,0,2016-12-18 20:41:17
41219448,1,,,2,1395,"<p>I'm using Sequelize in Node.js with Apollo-Server and Express.js.</p>&#xA;&#xA;<p>When making queries that go deeper and deeper, GraphQL is looping my models and doing a separate query by ID on each of those.</p>&#xA;&#xA;<p>For example, if I get <code>user(userId) &gt; playthroughs &gt; scores</code>, this will do a lookup for that user (no problem), then a lookup for all the playthroughs with that <code>userId</code> (still no a big deal), but then to get the scores, it loops each <code>playthroughId</code> and does a completely separate query on each. This is ridiculously inefficient and causes my queries to take way longer than they should.</p>&#xA;&#xA;<p>Instead of looping:</p>&#xA;&#xA;<pre><code>SELECT scoreValue&#xA;FROM scores&#xA;WHERE playthroughId = id&#xA;</code></pre>&#xA;&#xA;<p>I'd really like to grab the array myself and do that loop like this:</p>&#xA;&#xA;<pre><code>SELECT scoreValue&#xA;FROM scores&#xA;WHERE playthroughId IN (...ids)&#xA;</code></pre>&#xA;&#xA;<p>This also happened when I used the reference GraphQL from Facebook last year, so I don't think it's specific to Apollo's implementation.</p>&#xA;&#xA;<p>I'd like to know how I can tweak these queries so they're not taking such a performance hit.</p>&#xA;&#xA;<p>Example resolvers:</p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;    Query: {&#xA;        user: (_, values) =&gt; User.findOne(formatQuery(values))&#xA;            .then(getDataValues),&#xA;    },&#xA;&#xA;    Playthrough: {&#xA;        score: ({ playthroughId }) =&gt; Score.findOne(formatQuery({ playthroughId }))&#xA;            .then(getDataValues),&#xA;    },&#xA;&#xA;    User: {&#xA;        playthroughs: ({ userId }, { take }) =&gt; Playthrough.findAll(formatQuery({ userId, take, order: 'playthroughId DESC' }))&#xA;            .then(getAllDataValues),&#xA;    },&#xA;}&#xA;</code></pre>&#xA;",1624862,,,,2016-12-19 12:49:15,"In Apollo GraphQL, how do I setup a resolver to not loop values?",<mysql><sequelize.js><graphql-js><apollostack><apollo-server>,1,0,0,2016-12-19 09:29:45
41221994,2,,41214326,5,,"<p>After a lot of trial and error, I managed to solve a get all with the following:</p>&#xA;&#xA;<pre><code>field :users, types[IndexUserType] do&#xA;  resolve -&gt; (obj, args, ctx) {&#xA;    User.all&#xA;  }&#xA;end&#xA;</code></pre>&#xA;",1213904,,,,2016-12-19 11:52:29,"",,0,0,0,2016-12-19 11:52:29
41269498,2,,41051401,3,,"<blockquote>&#xA;  <p>Put code-wise, <code>calendar(calendarIds: [1, 2])</code> is an entirely different query from <code>calendar(calendarIds: [1, 2, 3])</code></p>&#xA;</blockquote>&#xA;&#xA;<p>Yup. GraphQL doesn't assign semantics to field arguments, so Relay (nor any other GraphQL client) doesn't know that the <code>calendarIds</code> arguments correspond to the ids of the results. This is a common enough use-case, though, that Relay supports a special <code>nodes(ids: [ID!])</code> root field (on the Query type) that is treated as you were expecting. To use it, implement a <code>nodes</code> field in your schema that returns results as an array whose order matches that of the input ids, with null entries for any results that couldn't be loaded. E.g. if the input ids are <code>[1,2,3]</code>, you'd return <code>[result1, result2, result3]</code>. When using this field, Relay will diff arguments arguments against previously fetched data (because it makes the assumption that the arguments of this particular field have a semantic meaning as ids).</p>&#xA;",4690687,,,,2016-12-21 18:25:05,"",,0,4,0,2016-12-21 18:25:05
41345377,1,,,1,613,<p>I have a database schema that has a one to many relationship. For e.g. one department has many customer. Is it possible to have a mutation that create a customer and a department and associate them? Or the correct way is to create a customer than a department and then associate each other?</p>&#xA;&#xA;<p>In the second approach I need to make three trips instead of one. &#xA;Can someone provide me a GraphQL handling this situation?</p>&#xA;,312444,,,,2017-07-28 08:33:15,GraphQL and Graphene,<graphql><graphene-python>,1,0,0,2016-12-27 12:38:19
41370415,1,41372046,,1,362,"<p>I want to do something like this in a component:</p>&#xA;&#xA;<pre><code>Relay.createContainer(Component, {&#xA;  fragments: {&#xA;    thing: AnotherComponent.getFragment('thing')&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This would ideally set the fragment <code>thing</code> on my current component to use the fragment <code>thing</code> on one of it's child components. Effectively delegating the responsibility of knowing what <code>thing</code> is down to whatever uses it. Then the component that includes <code>Component</code> can call <code>Component.getFragment('thing')</code> which will call <code>AnotherComponent.getFragment('thing')</code>. </p>&#xA;&#xA;<p>Does anyone know how to do this?</p>&#xA;&#xA;<h3>UPDATE</h3>&#xA;&#xA;<p>The only way I've found to make this work is via syntax like </p>&#xA;&#xA;<pre><code>Relay.createContainer(Component, {&#xA;  fragments: {&#xA;    thing: Relay.QL`&#xA;      ${AnotherComponent.getFragment('thing')}&#xA;    `&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This hits the server correctly, and the server executes the query specified by <code>AnotherComponent</code>, but now the return value of the query is not provided in the props of <code>Component</code></p>&#xA;&#xA;UPDATE 2&#xA;&#xA;<p>I've found that repeated nesting of this type produces a query like:</p>&#xA;&#xA;<pre><code>query Router {&#xA;&#xA;  store {&#xA;&#xA;    ...F3&#xA;&#xA;  }&#xA;&#xA;}&#xA;fragment F0 on Store {&#xA;&#xA;  _fields2w4En2:fields(labels:[""Country"",""Function""],owner_type:""requisitions"") {&#xA;&#xA;    choices {&#xA;&#xA;      id,&#xA;&#xA;      label&#xA;&#xA;    },&#xA;&#xA;    id&#xA;,&#xA;&#xA;    label&#xA;  }&#xA;&#xA;}&#xA;fragment F1 on Store {&#xA;&#xA;  ...F0&#xA;&#xA;}&#xA;fragment F2 on Store {&#xA;&#xA;  ...F1&#xA;&#xA;}&#xA;fragment F3 on Store {&#xA;&#xA;  ...F2&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Where at the base level I had a query like this: </p>&#xA;&#xA;<pre><code>export default Relay.createContainer(SearchBar, {&#xA;  fragments: {&#xA;    searchFields: () =&gt; Relay.QL`&#xA;      fragment searchFields on Store {&#xA;        searchFields: fields(labels: [""Country"", ""Function""], owner_type: ""requisitions"") {&#xA;          label&#xA;          choices {&#xA;            id&#xA;            label&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",1226063,,710693,2017-08-11 01:10:41,2017-08-11 01:10:41,Delegating fragments to children with Relay,<reactjs><graphql><relayjs>,1,0,0,2016-12-28 22:11:16
41372046,2,,41370415,3,,"<p>So the reason the straight forward approach doesn't work is becasue <code>getFragment</code> doesn't actually return a fragment (ugh), but a reference to a fragment that is specific to the container that declares it. Luckily tho you can get the plain fragment from that, &#xA;with: <code>AnotherComponent.getFragment('thing').getFragment()</code>. </p>&#xA;&#xA;<p>see <a href=""https://facebook.github.io/relay/prototyping/playground.html#source=let%20Nested%20%3D%20(%7B%20greetings%20%7D)%20%3D%3E%20%7B%0A%20%20return%20%3Ch1%3E%7Bgreetings.hello%7D%3C%2Fh1%3E%3B%0A%7D%20%20%0A%0ANested%20%3D%20Relay.createContainer(Nested%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20greetings%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20hello%20%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%20%20%0Alet%20Example%20%3D%20(props)%20%3D%3E%20%3CNested%20%7B...props%7D%20%2F%3E%0A%0AExample%20%3D%20Relay.createContainer(Example%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20greetings%3A%20(vars)%20%3D%3E%20Nested.getFragment(&#39;greetings&#39;).getFragment(vars)%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A%0A%0A%0A%0Aclass%20HelloRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20&#39;Hello&#39;%3B%20%20%2F%2F%20A%20unique%20name%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20greetings%3A%20(Component)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20GreetingsQuery%20%7B%0A%20%20%20%20%20%20%20%20greetings%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BComponent.getFragment(&#39;greetings&#39;)%7D%2C%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0A%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BExample%7D%0A%20%20%20%20route%3D%7Bnew%20HelloRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B%0A"" rel=""nofollow noreferrer"">this playground example</a> for a demonstration</p>&#xA;",2108893,,,,2016-12-29 01:34:34,"",,0,3,0,2016-12-29 01:34:34
41415291,1,,,1,252,"<p>I've been looking at GraphQL for use in a project I'm working on. For the project, we've defined the overall data structure using Haskell data types (for illustrative purposes). This contains types such as this:</p>&#xA;&#xA;<pre><code>data Requirement&#xA;  = Purchased PurchaseId&#xA;  | Attained Outcome Real&#xA;  | Invited&#xA;</code></pre>&#xA;&#xA;<p>So, a requirement for something might be that the user has <em>bought</em> a certain item, <em>attained</em> a certain score, or been invited.</p>&#xA;&#xA;<p>From reading the docs, I'd guess that a <code>union</code> is what I'd want to express the <em>type</em> of requirement, but is there an elegant way to deal with the differences in <strong>content</strong> for each member of the union?</p>&#xA;&#xA;<p>Thanks in advance!</p>&#xA;",4022180,,,,2017-01-02 18:43:03,Mimic tagged unions in GraphQL?,<graphql>,1,0,0,2017-01-01 12:01:39
41434241,1,41477628,,6,6151,"<p>I am using react-apollo on meteor with mysql and sequelize, I am still a beginner in JS.&#xA;Lets assume I have the following resolver function on my apollo-server:</p>&#xA;&#xA;<pre><code> export default resolvers = {&#xA;     Query: {&#xA;         posts(_, args){&#xA;             return Post.findAndCountAll({ where: args   });&#xA;         },&#xA;         numberOfPosts(){&#xA;             return /// the number of selected posts&#xA;         }&#xA;     }&#xA;</code></pre>&#xA;&#xA;<p>I would like to select some data from the database where some conditions are met and then count the amount of selected rows and return them in the field ""numberOfPosts"".&#xA;<code>findAndCountAll()</code> returns an object, which contains the selected rows and the count. I would like to get my <code>post()</code> to return only the selected rows, and my numberOfPosts() to return only the count of the selected posts. Right now, both is returned by posts().</p>&#xA;&#xA;<p><strong>My schema is:</strong></p>&#xA;&#xA;<pre><code> type Post {&#xA;  id: Int&#xA;  date: Float&#xA;  text: String&#xA;}&#xA;&#xA; type NumberOfPosts{&#xA;  total: Int&#xA;  filtered: Int&#xA;}&#xA;&#xA;type Query {&#xA;  posts(&#xA;   id: Ind,&#xA;   offset: Int,&#xA;   limit: Int,&#xA;   filter: String): [Post]&#xA;  numberOfPosts:[NumberOfPosts] &#xA;}&#xA;&#xA;schema {&#xA;  query: Query&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>The Goal is to receive data in the following format:</strong></p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""numberOfPosts"": [&#xA;      {&#xA;        ""total"": 1000,&#xA;        ""filtered"": 21&#xA;      }&#xA;    ],&#xA;    ""posts"": [&#xA;      {&#xA;        ""id"": 4,&#xA;        ""date"": 5105626122,&#xA;        ""text"": ""jzybiwutudi""&#xA;      },&#xA;      ...&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>My work so far:&#xA;Try 1:</strong></p>&#xA;&#xA;<pre><code>  let selectedCount;&#xA;export default resolvers = {&#xA;    Query: {&#xA;        posts(_, args){&#xA;            return Post.findAndCountAll({where: args}).then(&#xA;                function (results) {&#xA;                    selectedCount = results.count;&#xA;                    return results.rows&#xA;                });&#xA;        },&#xA;        numberOfPosts(){&#xA;            return selectedCount&#xA;        }&#xA;    }}&#xA;</code></pre>&#xA;&#xA;<p>So I am defining a helping variable outside of resolvers, and set it to the number of selected rows, then the count is returned in <code>numberOfPosts()</code>, which works, but the problem with this is, <code>return results.rows</code> causes an error, and I do not understand why.</p>&#xA;&#xA;<p>another issue is, that <code>selectedCount</code> is always the previous number of rows</p>&#xA;&#xA;<p><strong>Try 2</strong></p>&#xA;&#xA;<p>Another solution that seems to work is to Pass the arguments twice into the GraphQL query, like so:</p>&#xA;&#xA;<pre><code>{&#xA;  numberOfPosts(filter: ""example"") {&#xA;    total&#xA;    filtered&#xA;  }&#xA;  posts(filter: ""example"") {&#xA;    id&#xA;    date&#xA;    text&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then both resolver functions know the same arguments, so I can select and count the same posts. But this looks not right to me, since I have to pass the same args twice, they will also be transmitted twice...</p>&#xA;",4316681,,4316681,2017-01-03 12:41:40,2017-01-05 17:14:44,How to design the following resolver for GraphQL server?,<javascript><graphql><graphql-js><apollo-server>,1,5,0,2017-01-02 22:57:05
41453631,1,41455845,,2,268,"<p>I'm working on an application using <strong>React</strong> with <strong>Relay</strong> and <strong>GraphQL</strong>. I've run into an issue where I need to preserve a component's state while changing relay variables.</p>&#xA;&#xA;<p>For example, say I have the component state:</p>&#xA;&#xA;<pre><code>state = {&#xA;  to: '',&#xA;  from: '',&#xA;  body: '',&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And I have a Relay container with the following fragment and variables:</p>&#xA;&#xA;<pre><code>initialVariables: {&#xA;  to: '',&#xA;  from: '',&#xA;},&#xA;fragments: {&#xA;  viewer: () =&gt; Relay.QL`&#xA;    fragment on viewer {&#xA;      ...&#xA;      thread(to: $to, from: $from)&#xA;    }&#xA;  `&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The component has text fields for the <strong>to</strong> and <strong>from</strong> fields, with an <em>onChange</em> handler which also updates the relay variables</p>&#xA;&#xA;<pre><code>onChange = e =&gt; {&#xA;  const to = e.target.value;&#xA;&#xA;  this.setState({ to });&#xA;  this.props.relay.setVariables({ to });&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This causes the query to execute again, the component re-renders, and I lose any changes to my current component state.</p>&#xA;&#xA;<p>The only solution I've found thus far is to keep this state in a parent component, and pass down the values and onChange handlers as props, but it would be nice to keep this all in the same component.</p>&#xA;&#xA;<p><strong>How can I call relay.setVariables without losing state?</strong></p>&#xA;",2855707,,2855707,2017-01-03 23:59:16,2017-01-04 03:42:31,Preserve React component state with Relay.setVariables,<javascript><reactjs><graphql><relay>,1,2,0,2017-01-03 22:53:42
41464960,1,41535379,,0,72,"<p>I'm stuck in wondering if I can filter a list of names which I receive from Relay and graphql-java server without the need of making calls, without making any changes in my GrpahQL schema and only using ReactJS for this purpose.<br>&#xA;---MobX as a state management library can be a decision but I should first store all the Relay result.</p>&#xA;",7041216,,7041216,2017-01-04 14:17:30,2017-01-08 17:09:24,Filtering a list of names with ReactJS using data from RelayJS without calling GrpahQL,<javascript><reactjs><graphql><relayjs><relay>,1,1,0,2017-01-04 13:26:53
41477628,2,,41434241,6,,"<p>You should think more about the design and what each of those queries should do. Those queries should not mutate the database or the global state.</p>&#xA;&#xA;<p>The best thing you can do is to simply define a new type that includes <code>total</code> and <code>filtered</code>, like what you did as <code>NumberOfPosts</code> in your first try, and also the list of posts.</p>&#xA;&#xA;<p>So, your schema would be like:</p>&#xA;&#xA;<pre><code>type Post {&#xA;  id: Int&#xA;  date: Float&#xA;  text: String&#xA;}&#xA;&#xA;type PostList {&#xA;  total: Int&#xA;  filtered: Int&#xA;  posts: [Post]&#xA;}&#xA;&#xA;type Query {&#xA;  posts(&#xA;    id: Ind,&#xA;    offset: Int,&#xA;    limit: Int,&#xA;    filter: String): PostList&#xA;}&#xA;&#xA;schema {&#xA;  query: Query&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And you resolve <code>posts</code> like:</p>&#xA;&#xA;<pre><code>posts(_, args) {&#xA;  return Post.findAndCountAll({ where: args }).then(result =&gt; {&#xA;    return {&#xA;      total: 1000,&#xA;      filtered: result.count,&#xA;      posts: result.rows&#xA;    }&#xA;  })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Notice how I just put 1000 for the total number. You can not get the total number of rows with <code>findAndCountAll</code>. If you that, need you can run two different queries in parallel and use <a href=""https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"" rel=""noreferrer""><code>Promise.all</code></a> to wait for them to be resolved.</p>&#xA;&#xA;<pre><code>posts(_, args) {&#xA;  return Promise.all([&#xA;    Post.count(),&#xA;    Post.findAndCountAll({ where: args })&#xA;  ]).then(data =&gt; {&#xA;    return {&#xA;      total: data[0],&#xA;      filtered: data[1].count,&#xA;      posts: data[1].rows&#xA;    }&#xA;  })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The above code also could benefit from <a href=""https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"" rel=""noreferrer"">ES6's destructuring</a>:</p>&#xA;&#xA;<pre><code>posts(_, args) {&#xA;  return Promise.all([&#xA;    Post.count(),&#xA;    Post.findAndCountAll({ where: args })&#xA;  ]).then(([totalCount, filteredData]) =&gt; {&#xA;    return {&#xA;      total: totalCount,&#xA;      filtered: filteredData.count,&#xA;      posts: filteredData.rows&#xA;    }&#xA;  })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now you can run:</p>&#xA;&#xA;<pre><code>query {&#xA;  posts(filter:""example"") {&#xA;    total&#xA;    filtered&#xA;    posts {&#xA;      id&#xA;      date&#xA;      text&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and get:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""posts"": {&#xA;      ""total"": 1000,&#xA;      ""filtered"": 21,&#xA;      ""posts"": [&#xA;        {&#xA;          ""id"": 4,&#xA;          ""date"": 5105626122,&#xA;          ""text"": ""jzybiwutudi""&#xA;        },&#xA;        ...&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1317053,,1317053,2017-01-05 17:14:44,2017-01-05 17:14:44,"",,0,8,0,2017-01-05 05:05:41
41494305,1,,,1,400,"<p>I have a component wrapped in a Relay container:</p>&#xA;&#xA;<pre><code>const Widget = (props) =&gt; {&#xA;  return (&#xA;   &lt;div&gt; { props.foo.bar } &lt;/div&gt;&#xA;  )&#xA;}&#xA;&#xA;Widget.defaultProps = { foo: {bar: 0} }&#xA;&#xA;export default Relay.createContainer(Widget, {&#xA;  fragments: {&#xA;     store: () =&gt; Relay.QL`&#xA;       fragment on WidgetData {&#xA;          foo {&#xA;             bar&#xA;          }&#xA;        }&#xA;        `&#xA;   }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>I'm using a GraphQL-as-a-service provider for a backend, and when the <code>foo</code> property of <code>WidgetData</code> isn't present, it returns <code>null</code>, which throws when my component attempts to render <code>props.null.bar</code></p>&#xA;&#xA;<p>As far as I know, <code>defaultProps</code> only works when the prop is <code>undefined</code>, not when it's <code>null</code>.</p>&#xA;&#xA;<p>How can I protect against <code>null</code> results with <code>defaultProps</code> in this case? </p>&#xA;&#xA;<p>Hoping to avoid writing a guard statement for each <code>prop</code> I reference, if possible.</p>&#xA;",5456001,,5456001,2017-01-08 02:32:06,2017-01-19 18:12:10,How do I set default props for a component wrapped in a Raley container?,<reactjs><graphql><relayjs><relay>,1,3,0,2017-01-05 20:41:11
41523338,1,,,0,631,"<p>My goal is to combine multiple nested sibling <code>arrays</code> of <code>edges</code> from the same <code>Relay fragment</code> into one <code>render</code> call.</p>&#xA;&#xA;<p>Backend data is delivered via <code>Relay</code> containers (also using <code>react-router-relay</code>).</p>&#xA;&#xA;<p>I have a component hierarchy that displays multiple <code>Tags</code> from several different <code>Users</code>. The top-level query looks something like this:</p>&#xA;&#xA;<pre><code>getUserGroup(id: 'abc') {&#xA;  users {&#xA;    edges { // array of arrays objects with nested arrays&#xA;      node {&#xA;        Tags {&#xA;          edges { // array of objects with target items&#xA;            node {&#xA;              tagName // target item&#xA;              id&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which results in something like this (in fully-flattened form):</p>&#xA;&#xA;<pre><code>  results = [['tagname1', 'tagname2'], [tagname3, tagname4]]&#xA;</code></pre>&#xA;&#xA;<p>Currently I render a hierarchy with each <code>node Type</code> in its own <code>Component</code>, i.e., <code>Tagmenu</code> -> <code>UserTagGroup</code> -> <code>TagItems</code> (code is at the bottom of this post).</p>&#xA;&#xA;<p>This groups all of the tags by <code>User</code>, eventually rendering a list like this:</p>&#xA;&#xA;<pre><code>User 1:&#xA;  - Tag 1&#xA;  - Tag 2&#xA;User 2:&#xA;  - Tag 3&#xA;  - Tag 4&#xA;</code></pre>&#xA;&#xA;<p>What I'd like to achieve is a <code>render</code> where all <code>Users</code>' tags are mixed-in together at the second tier, i.e., a hierarchy like <code>TagMenu</code> -> <code>TagItems</code>, to render:</p>&#xA;&#xA;<pre><code>User Tags&#xA;  - Tag 1&#xA;  ...&#xA;  - Tag 4&#xA;</code></pre>&#xA;&#xA;<p>The only way I can manage so far is to manually extract and combine all of arrays from the top-level <code>Relay</code> container results with something like this (pseudo code):</p>&#xA;&#xA;<pre><code>for each array in users.edges:&#xA;  for each array in node.Tags.edges:&#xA;    return node.tagName&#xA;</code></pre>&#xA;&#xA;<p>This doesn't seem right for 2 reasons:</p>&#xA;&#xA;<ol>&#xA;<li>It's a bit much to pack into a <code>render()</code> function,</li>&#xA;<li>It's not clear if it's possible <a href=""https://stackoverflow.com/questions/41494305/how-do-i-set-default-props-for-a-component-wrapped-in-a-raley-container?noredirect=1#comment70195208_41494305"">to protect against <code>null</code> refs with <code>default props</code> in Relay</a></li>&#xA;</ol>&#xA;&#xA;<p>... but it's obviously doable.</p>&#xA;&#xA;<p>My question is:  what's the <code>Relay</code> way to do this? Given how naturally the library leads to component composition, I can't imagine that pulling deeply nested results at a higher level and manually shuffling them is optimal. Here are my components:</p>&#xA;&#xA;<pre><code>// TagsMenu component, top level&#xA;class TagsMenu extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {&#xA;          this.props.userGroup.users.edges.map(u =&gt; {&#xA;            return &lt;UserTagGroup user={u.node} /&gt;&#xA;          })&#xA;        }&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;fragment on UserGroup {&#xA;  users(first: 1000) {&#xA;    edges {&#xA;      node {&#xA;        ${UserTagGroup.getFragment('user')}&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&#xA;// UserTagGroup, second component&#xA;class UserTagGroup extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;h4&gt;User:  {this.props.user.id}&lt;/h4&gt;&#xA;        {&#xA;          this.props.user.Tags.edges.map(t =&gt; {&#xA;            return &lt;TagMenuItem tag={t.node} /&gt;&#xA;          })&#xA;        }&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;fragment on User {&#xA;  id&#xA;  listingTags(first: 1000) {&#xA;    edges {&#xA;      node {&#xA;        ${TagMenuItem.getFragment('tag')}&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&#xA;// TagMenuItem, bottom level component. Renders 1 Tag.&#xA;class TagMenuItem extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {this.props.tag.tagName}&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;fragment on Tag {&#xA;  tagName&#xA;  id&#xA;}&#xA;</code></pre>&#xA;",5456001,,-1,2017-05-23 12:26:05,2017-05-03 14:04:17,Can I pull deeply-nested nodes from a Relay query result?,<reactjs><graphql><relayjs><relay><react-router-relay>,1,0,0,2017-01-07 15:58:53
41528857,1,,,0,301,"<p>This question is more about a pattern I keep encountering than a specific instance of the problem.</p>&#xA;&#xA;<p>Often I'll have a <code>Relay</code> container that executes a query like this:</p>&#xA;&#xA;<pre><code>getUserGroup(id: $id) {&#xA;    users {&#xA;      edges {&#xA;        node {&#xA;          widgets {&#xA;            edges {&#xA;              node {&#xA;                id&#xA;                widgetTags {&#xA;                  edges {&#xA;                    node {&#xA;                      tagName&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>In other words: I want to render the data in a <code>WidgetList</code> component like so:</p>&#xA;&#xA;<pre><code>// WidgetList.js&#xA;User1:&#xA;  Widget1: &#xA;    TagA&#xA;    TagB&#xA;   Widget2: &#xA;    TagA&#xA;    TagC&#xA;User 2: &#xA;   // ..etc etc&#xA;</code></pre>&#xA;&#xA;<p>My goal is to filter the <code>Widget</code> results based on their <code>WidgetTags</code></p>&#xA;&#xA;<p>My problem is that, in order to filter, I think I need all of the <code>WidgetTag</code> information at the parent level. Because not every <code>Widget</code> has any <code>Tags</code>, I have to enter the query from the <code>User</code> side. </p>&#xA;&#xA;<p>How should one handle a pattern like this with <code>Relay</code>? </p>&#xA;&#xA;<p>The options I've tried so far are:</p>&#xA;&#xA;<ol>&#xA;<li><p>Centralize any data I want to filter-on using a <code>state</code> management app like <code>Mobx</code>.  Each <code>Widget</code> adds its own data to the <code>store</code> upon <code>render</code> and with each <code>update</code>, then the <code>store</code> is used to filter the array of <code>Widgets</code> in the <code>WidgetList render()</code> function.</p></li>&#xA;<li><p>I manually pluck the relevant data from the <code>query</code> results at the <code>WidgetList</code> level, then carry out the same filtration steps as in step 1. </p></li>&#xA;</ol>&#xA;&#xA;<p>Neither of these feel in accordance with <code>Relay</code> best practices, though, so I'm wondering if there isn't a better way.  </p>&#xA;",5456001,,,,2017-01-12 22:35:11,How do I filter Relay results based on values in fields on Connected Types?,<reactjs><graphql><relayjs>,1,0,0,2017-01-08 02:30:22
41528995,1,41529276,,3,186,"<p>Trying to understand the connection between the ""..."" notation in React and GraphQL. Are they</p>&#xA;&#xA;<p>1) Using the same general Javascript syntax? If so, what does it mean - since my understanding was specific to React. (I thought it meant pass the properties inherited from the parent's to a child.""</p>&#xA;&#xA;<p>2) Unrelated syntax that happen to be the same in React and GraphQL.</p>&#xA;&#xA;<p>I saw it used in GraphQL in this <a href=""https://www.learnapollo.com/tutorial-react/react-04"" rel=""nofollow noreferrer"">example from the ApolloClient tutorial</a> </p>&#xA;&#xA;<pre><code>tutorial: const PokemonQuery = gql`   query PokemonQuery($id: ID!) {&#xA;    Pokemon(id: $id) {&#xA;      ... PokemonCardPokemon&#xA;    }   }   ${PokemonCard.fragments.pokemon}&#xA;</code></pre>&#xA;&#xA;<p>In this example, PokemonCardPokemon is a GraphQL fragment. The tutorial says, ""Note that we select the fragment in the query using the ... syntax, and that we additionally include the fragment after the query with ${PokemonCard.fragments.pokemon}.""</p>&#xA;",5715181,,5715181,2017-01-08 05:28:40,2017-01-08 05:28:40,"What is the ""..."" syntax used in both React and GrahpQL? Is it more general Javascript?",<javascript><reactjs><graphql>,1,3,0,2017-01-08 02:56:17
41529276,2,,41528995,4,,"<p>#2</p>&#xA;&#xA;<p>JavaScript/React and GraphQL each use the <code>...</code> operator for their own purposes without knowledge of how the other uses it.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>In JavaScript, <code>...</code> is used with Arrays and array-like objects to either <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"" rel=""nofollow noreferrer"">collect</a> or <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator"" rel=""nofollow noreferrer"">spread</a> their values.</p>&#xA;&#xA;<p>Example, spreading an array's values so they're passed as separate arguments.</p>&#xA;&#xA;<pre><code>var list = [ 5, 3, 10 ];&#xA;console.log(Math.min(...list));           // 3&#xA;&#xA;// shorter and simpler than...&#xA;console.log(Math.min.apply(Math, list));  // 3&#xA;&#xA;// and means the same as...&#xA;console.log(Math.min(5, 3, 10));          // 3&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p>In GraphQL, <code>...</code> is used to apply <a href=""http://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">Fragments</a> or named sets of fields that can be reused throughout the query.</p>&#xA;&#xA;<blockquote>&#xA;<pre><code>{&#xA;  leftComparison: hero(episode: EMPIRE) {&#xA;    ...comparisonFields&#xA;  }&#xA;  rightComparison: hero(episode: JEDI) {&#xA;    ...comparisonFields&#xA;  }&#xA;}&#xA;&#xA;fragment comparisonFields on Character {&#xA;  name&#xA;  appearsIn&#xA;  friends {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;  &#xA;  <p>You can see how the above query would be pretty repetitive if the&#xA;  fields were repeated. The concept of fragments is frequently used to&#xA;  split complicated application data requirements into smaller chunks,&#xA;  especially when you need to combine lots of UI components with&#xA;  different fragments into one initial data fetch.</p>&#xA;</blockquote>&#xA;",15031,,15031,2017-01-08 03:50:56,2017-01-08 03:50:56,"",,0,0,0,2017-01-08 03:44:53
41535379,2,,41464960,1,,"<p><em>Caveat emptor</em>: I'm newish at <code>Relay</code> as well &amp; struggling with these same concepts. But, given the relative dearth of accessible information on <code>Relay</code>, I thought it'd be helpful to try and layout the key concepts here. My understanding could be wrong, so I'd love it if anyone who found a mistake in my code/reasoning would comment/edit. </p>&#xA;&#xA;<p>Filtering took awhile for me to 'click' as well. It depends on where you keep the data you'll use to filter, but let's assume the <code>name</code> field lives on your <code>Users Type</code>, and the query is something like this:</p>&#xA;&#xA;<pre><code>viewer {&#xA;  allUsers {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And let's say your top-level <code>NameList</code> component looked like this:</p>&#xA;&#xA;<pre><code>class NameList extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {this.props.users.edges&#xA;          .map(u =&gt; {&#xA;            &lt;NameItem name={u.node} /&gt;&#xA;           })&#xA;         }&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;Relay.createContainer(NameList, {&#xA;  initialVariables: { first: 10 },&#xA;  fragments: {&#xA;    users: () =&gt; Relay.QL`&#xA;    fragment on Viewer {&#xA;      allUsers(first: $first) {&#xA;         edges {&#xA;           node {&#xA;             ${NameItem.getFragment('user')}&#xA;           }&#xA;          }&#xA;        }&#xA;      }&#xA;    ` &#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>And your <code>NameItem</code> setup was simply:</p>&#xA;&#xA;<pre><code>class NameItem extends Component {&#xA;      render() {&#xA;        return (&#xA;          &lt;div&gt;&#xA;            Name: {this.props.user.name}&#xA;          &lt;/div&gt;&#xA;        )&#xA;      }&#xA;    }&#xA;&#xA;Relay.createContainer(NameItem, {&#xA;  initialVariables: {},&#xA;  fragments: {&#xA;    user: () =&gt; Relay.QL`&#xA;    fragment on User {&#xA;      name&#xA;      }&#xA;    ` &#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Consider the generalizable pattern here:</p>&#xA;&#xA;<p><strong>The List Component</strong></p>&#xA;&#xA;<p>A <code>List</code> component takes a fragment on the top-level <code>Type</code> in the query--in this case, <code>Viewer</code>, from a <code>Relay container</code>.</p>&#xA;&#xA;<p><code>List</code> also inserts a <code>fragment</code> on behalf of its <code>Item</code> child at the level of the <code>User Type</code>. </p>&#xA;&#xA;<p>In other words, it captures an array of <code>User</code> objects it's supposed to pass down to the <code>Item</code> component.  </p>&#xA;&#xA;<p>If this wasn't <code>Relay</code>, and instead was, say, <code>Redux</code>, this component might simply pass <code>state.users</code> to the <code>Item</code> component. You can do that because, at some point, you've manually extracted all your <code>User</code>s from your own back-end and loaded them into <code>Redux</code>. But since <code>Relay</code> does the hard thinking for you, it needs a teensy bit more information than <code>Redux</code>.</p>&#xA;&#xA;<p><strong>The Item Component</strong></p>&#xA;&#xA;<p>This is even more simple. It expects an entity of type <code>User</code> and renders the <code>name</code>. Besides syntax, the functionality here isn't much different from a similar component in a <code>Redux</code> setup.</p>&#xA;&#xA;<p><strong>So really</strong>, without the complexity of <code>Relay</code> on top, all you have is an array of items that you're rendering. In vanilla <code>React</code>, you'd simply filter the array prior to (or during) your call to <code>.map()</code> in <code>render()</code>.</p>&#xA;&#xA;<p>However, with <code>Relay</code>, the <code>fragment</code> handed to the <code>child</code> is opaque to the <code>parent</code>--i.e., the <code>List</code> is handing a blind package to the <code>Item</code>, so it can't make a decision on whether or not to pass it down based on the <code>fragment</code>'s content.</p>&#xA;&#xA;<p>The solution in this contrived example is pretty simple: just peel-off the <code>name</code> field at the <code>parent</code> and <code>child</code> level.  Remember: <code>Relay</code> is about components telling <code>GraphQL</code> what data they need. Your <code>List</code> component needs whatever fields it intends on filtering on--no more, no less. </p>&#xA;&#xA;<p>If we modify the above <code>List</code> container:</p>&#xA;&#xA;<pre><code>...&#xA;users: () =&gt; Relay.QL`&#xA;    fragment on Viewer {&#xA;      allUsers(first: $first) {&#xA;         edges {&#xA;           node {&#xA;             name&#xA;             ${NameItem.getFragment('user')}&#xA;           }&#xA;          }&#xA;        }&#xA;      }&#xA;    ` &#xA;</code></pre>&#xA;&#xA;<p>And then we update our <code>render</code> function:</p>&#xA;&#xA;<pre><code> &lt;div&gt;&#xA;        {this.props.users.edges&#xA;          .map(u =&gt; {&#xA;             if (u.node.name == ""Harvey"") {&#xA;               &lt;NameItem name={u.node} /&gt;&#xA;             }&#xA;           })&#xA;         }&#xA; &lt;/div&gt;&#xA;</code></pre>&#xA;&#xA;<p>Then we've achieved basic filtering without needing <code>mobx</code>, more server trips, etc.</p>&#xA;",5456001,,,,2017-01-08 17:09:24,"",,0,0,0,2017-01-08 17:09:24
41545427,2,,41515226,1,,"<p>If you are interested in using a hosted GraphQL service, <a href=""https://scaphold.io"" rel=""nofollow noreferrer"">scaphold.io</a> has had this feature for a while now. All connection fields in your API come with a <code>WhereArgs</code> argument that exposes filters that let you really dig into your data. When you have a list of scalars like this, the WhereArgs include a <code>contains</code> &amp; <code>notContains</code> field that allow you to filter results based off the values in your list. This allows you to make a query like this.</p>&#xA;&#xA;<pre><code>query MysteriousBooks($where:BookWhereArgs) {&#xA;  viewer {&#xA;    allBooks(where:$where) {&#xA;      edges { node { title, ... } }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# Variables&#xA;{&#xA;  ""where"": {&#xA;    ""categories"": {&#xA;      ""contains"": ""mystery""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Just to be complete, you could also do a slight schema readjustment to make this work without having to filter on a scalar list. For example, you could make <code>Category</code> a node implementing type and then create a connection between <code>Category</code> and <code>Book</code>. Although a <code>Book</code> will likely not have many categories, this would allow you to issue a query like this:</p>&#xA;&#xA;<pre><code>query MysteriousBooks($where: CategoryWhereArgs) {&#xA;  viewer {&#xA;    allCategories(where: $where) {&#xA;      books {&#xA;        edges { node { title, ... } }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# Variables&#xA;{&#xA;  ""where"": { &#xA;    ""name"": { &#xA;      ""eq"": ""mystery"" &#xA;    } &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you structure your schema this way then you would also be able to do more filtering on the books in the category without having to loop through every book in your archive. E.G. you could efficiently ask for ""all the mystery books written in the last year.""</p>&#xA;&#xA;<p>Full disclosure: I work at Scaphold and although I'd love you to try it out no hard feelings if you don't switch over. I'm excited to see people trying and loving GraphQL. If you're curious about how to implement this type of behavior on your own server let me know and I'd be happy to help there as well!</p>&#xA;&#xA;<p>I hope this helps!</p>&#xA;",2088684,,,,2017-01-09 10:05:58,"",,0,0,0,2017-01-09 10:05:58
41572799,2,,41560208,5,,"<p><a href=""http://graphql.org/learn/queries/#fragments"" rel=""noreferrer"">Fragments</a> are used to group the fields and reuse them on the client-side. They are not something you should worry about at the server and while you are creating the schema.</p>&#xA;&#xA;<p>The client-side code should provide the fragments when querying the data from the server. GraphQL itself takes care of adding the fragmented fields on the query. On the server, you need to specify all the fields on all the objects.</p>&#xA;&#xA;<p>Of course you can write your own helpers to reduce the manual work.</p>&#xA;&#xA;<p>Same goes with <a href=""http://graphql.org/learn/queries/#variables"" rel=""noreferrer"">variables</a> too.</p>&#xA;",1317053,,1317053,2017-01-10 16:02:28,2017-01-10 16:02:28,"",,0,2,0,2017-01-10 15:48:40
41623074,1,,,1,522,"<p>In my app, I need to reference the currently signed-in <code>User</code> in numerous components at various places in the component hierarchy.</p>&#xA;&#xA;<p>This means I often use a <code>fragment</code> like this in my <code>Relay</code> containers: </p>&#xA;&#xA;<pre><code>fragments: {&#xA; //...&#xA;&#xA;currentUser: () =&gt; Relay.QL`&#xA;       fragment on User {&#xA;           id&#xA;           userName&#xA;       }&#xA;}`&#xA;</code></pre>&#xA;&#xA;<p>To avoid repeating myself, I'm inclined to just <code>import</code> this fragment into whatever container I need it in (same for other ubiquitous fragments, as well). The Relay docs call this <code>inline fragments</code>:</p>&#xA;&#xA;<pre><code>var userFrag =  () =&gt; Relay.QL`&#xA;       fragment on User {&#xA;           id&#xA;           userName&#xA;       }`&#xA;</code></pre>&#xA;&#xA;<p>However, <a href=""https://facebook.github.io/relay/docs/api-reference-relay-ql.html"" rel=""nofollow noreferrer"">the Relay docs have this warning</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Note that it is highly recommended that Relay.Containers define their&#xA;  own fragments and avoid sharing inline var fragment = Relay.QL...&#xA;  values between containers or files. If you find yourself wanting to&#xA;  share inline fragments, it's likely a sign that it's time to refactor&#xA;  and introduce a new container.</p>&#xA;</blockquote>&#xA;&#xA;<p>This confuses me for a few reasons:</p>&#xA;&#xA;<ol>&#xA;<li>I can't reason why it's ill-advised to share fragments in the fashion I've described above.</li>&#xA;<li>How would I go about 'introducing a new container' to alleviate this repetition? Do they mean wrapping any <code>Component</code> that needs <code>User</code> in another dedicated <code>Relay</code> container?  This seems counterintuitive and like too much boilerplate.</li>&#xA;</ol>&#xA;&#xA;<p>Is there a less frowned-upon way to share fragments, then? Or am I misreading the docs' admonition?</p>&#xA;",5456001,,,,2017-01-12 21:12:39,How should Fragments be shared between Relay containers?,<reactjs><graphql><relayjs><relay>,0,8,0,2017-01-12 21:12:39
41624414,2,,41523338,0,,"<p>What you've been describing - ""manually extract and combine all of arrays from the top-level Relay container"" - do seem like the way to go, though.</p>&#xA;&#xA;<p>If the problem lies in having this function in the <code>render()</code> method, I suggest you to use a combination of state and the method <code>componentWillReceiveProps()</code>. The goal being to recompute the flattened list only when <code>this.props.users</code> has truly changed.</p>&#xA;&#xA;<p>Something along theses line :</p>&#xA;&#xA;<pre><code>class MyRootContainer extends Component {&#xA;&#xA;  constructor(props) {&#xA;    super(props);&#xA;&#xA;    this.state = {&#xA;      flattenedList: this.computeFlattenedListFromProps(this.props),&#xA;    };&#xA;  }&#xA;&#xA;  componentWillReceiveProps(props) {&#xA;    if (this.props.users !== props.users) {&#xA;      this.setState({&#xA;        flattenedList: this.computeFlattenedListFromProps(props),&#xA;      });&#xA;    }&#xA;  }&#xA;&#xA;  computeFlattenedListFromProps(props) {&#xA;    // Compute and return flattened list&#xA;  }&#xA;&#xA;  render() {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3076424,,,,2017-01-12 22:46:53,"",,0,0,0,2017-01-12 22:46:53
41630256,2,,41371233,0,,"<p>The Relay spec and implementation <strong>requires</strong> you to support a <code>node</code> query  in addition you your query root (usually <code>viewer</code>)</p>&#xA;&#xA;<p>Relay will use <code>node</code> internally when it needs to fetch fields for a specific node.&#xA;Regardless of node, if you really want a <code>product</code> query and call it yourself from one of your Relay Containers.</p>&#xA;&#xA;<p>As for global ids, yes - you always need to translate from global id to primary key.&#xA;But to be more exact - you always need to translate from global ID to the internal key representation of whatever DB behind the ObjectType you're querying.&#xA;The global id contains the type information - which ObjectType we're trying to fetch. Without that information the framework wouldn't know what ObjectType to send the id to so it can do the fetching.</p>&#xA;",1228206,,,,2017-01-13 08:27:24,"",,0,0,0,2017-01-13 08:27:24
41645706,1,41645769,,0,46,"<p>I'm looking for advice on how to cleanly format multiple nested connect and graphql statements for readability and ease of typing.  As you can see, wrapping each call gets pretty ungainly to look at.  Is there a suggested shortcut/trick/formatting when you have multiple nested connect/graphql statements?</p>&#xA;&#xA;<pre><code>connect(mapStateToProps, mapDispatchToProps)(graphql(signinUserGql, {name: 'signIn'})(graphql(registerUserGql, {name:'register'})(LoginScreen)));&#xA;</code></pre>&#xA;",611750,,,,2017-01-14 01:13:31,What's a clean formatting for multiple nested connect and graphql calls in javascript?,<javascript><apollo-client>,2,0,0,2017-01-14 01:03:38
41674390,1,41855417,,1,69,"<p>In creating a container using Relay.CreateContainer, I am passing in a Relay.QL fragment that calls for an array of objects.</p>&#xA;&#xA;<p>This array of objects contains some objects by default that I do not want included.</p>&#xA;&#xA;<p>Is it possible to sanitize this response before it is passed as props to the component I am rendering?</p>&#xA;&#xA;<p>I would like to do something like</p>&#xA;&#xA;<pre><code>    export default Relay.createContainer(MyComponent, {&#xA;        fragments: {&#xA;            viewer: () =&gt; Relay.QL`&#xA;               ...&#xA;            `,&#xA;        },&#xA;        sanitizeProps: props =&gt; props.viewer.filter(type =&gt; type.name === 'Pony')&#xA;    });&#xA;</code></pre>&#xA;",1475153,,,,2017-01-25 15:29:39,How to sanitize Relay.createContainer fragment response before it is passed as props,<reactjs><graphql><relayjs><relay>,1,0,0,2017-01-16 10:35:40
41697041,2,,39379943,3,,"<p>I have re-posted <a href=""https://github.com/apollostack/react-apollo/issues/421"" rel=""nofollow noreferrer"">this question on github</a> and the suggested solution was to use something like a react higher order component just as you proposed in your original question. I did a similar thing – without using redux though – <a href=""https://gist.github.com/ctavan/7219a3eca42f96a5c5f755319690bda7"" rel=""nofollow noreferrer"">as outlined in this gist</a>.</p>&#xA;&#xA;<p>To cite <a href=""https://github.com/tmeasday"" rel=""nofollow noreferrer"">Tom Coleman</a>'s response from the github issue:</p>&#xA;&#xA;<blockquote>&#xA;  <p>It doesn't really make sense to include loading state on the mutation&#xA;  container; if you think about it you could call the mutation twice&#xA;  simultaneously -- which loading state should get passed down to the child? My&#xA;  feeling is in general it's not nice to mix imperative (this.mutate(x, y, z))&#xA;  with declarative (props) things; it leads to irresolvable inconsistencies.</p>&#xA;</blockquote>&#xA;",1053532,,,,2017-01-17 12:22:33,"",,0,1,0,2017-01-17 12:22:33
41734312,1,41756589,,0,81,"<p>Some of my Relay edges are being treated as the same despite being different data.</p>&#xA;&#xA;<p>For instance, I want to show a list of recommended movies. These movies are recommended based off the fact that there is an actor the user likes.</p>&#xA;&#xA;<p>I expect my data to be like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""movies"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""name"": ""Cool Movie 1"",&#xA;            ""myActor"": {&#xA;              ""name"": ""John Smith""&#xA;            }&#xA;          },&#xA;          ""node"": {&#xA;            ""name"": ""Cool Movie 1"", &lt;- Same as movie above, different actor&#xA;            ""myActor"": {&#xA;              ""name"": ""Mary Smith""&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Yet it returns the same actor for both node.</p>&#xA;&#xA;<p>In my <strong>resolve()</strong> I return a Relay connection. &#xA;The <strong>edges</strong> are generated like this:</p>&#xA;&#xA;<pre><code>let edges = movieIdAndActorIdPairs.map(({movieId, actorId}) =&gt; ({&#xA;      cursor: //,&#xA;      node: async () =&gt; {&#xA;          const dataRequirements = [getMovie(movieId), getActor(actorId)]&#xA;          let [movie, actor] = await Promise.all(dataRequirements)&#xA;          movie.myActor = actor&#xA;          return movie&#xA;      }&#xA;}))&#xA;</code></pre>&#xA;&#xA;<p>When I log my <code>edges</code> it shows the correct <code>myActor</code> but when I log the <code>myActor</code> field on my <code>Movie</code> type, they both become <em>John Smith</em>.</p>&#xA;",4776002,,4776002,2017-01-20 02:14:11,2017-01-20 05:19:25,Relay edges treated as same,<graphql><relayjs><relay><graphql-js>,2,7,0,2017-01-19 05:22:12
41750606,2,,41741704,3,,"<p>This is a duplicate of <a href=""https://stackoverflow.com/questions/33060182/how-would-you-do-file-uploads-in-a-react-relay-app/35585482#35585482"">How would you do file uploads in a React-Relay app?</a></p>&#xA;&#xA;<p>In short, yes you can do a file upload in graphql with react + relay.&#xA;You need to write the Relay update store action, for example:</p>&#xA;&#xA;<pre><code>onDrop: function(files) {&#xA;  files.forEach((file)=&gt; {&#xA;    Relay.Store.commitUpdate(&#xA;      new AddImageMutation({&#xA;        file,&#xA;        images: this.props.User,&#xA;      }),&#xA;      {onSuccess, onFailure}&#xA;    );&#xA;  });&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>Then implement a mutation for the Relay store</p>&#xA;&#xA;<pre><code>class AddImageMutation extends Relay.Mutation {&#xA;   static fragments = {&#xA;     images: () =&gt; Relay.QL`&#xA;       fragment on User {&#xA;         id,&#xA;       }`,&#xA;     };&#xA;&#xA;   getMutation() {&#xA;     return Relay.QL`mutation{ introduceImage }`;&#xA;   }&#xA;&#xA;   getFiles() {&#xA;     return {&#xA;       file: this.props.file,&#xA;     };&#xA;   }&#xA;&#xA;   getVariables() {&#xA;     return {&#xA;       imageName: this.props.file.name,&#xA;     };&#xA;   }&#xA;&#xA;   getFatQuery() {&#xA;     return Relay.QL`&#xA;       fragment on IntroduceImagePayload {&#xA;         User {&#xA;           images(first: 30) {&#xA;             edges {&#xA;               node {&#xA;                 id,&#xA;               }&#xA;             }&#xA;           }&#xA;         },&#xA;         newImageEdge,&#xA;       }&#xA;     `;&#xA;   }&#xA;&#xA;   getConfigs() {&#xA;     return [{&#xA;       type: 'RANGE_ADD',&#xA;       parentName: 'User',&#xA;       parentID: this.props.images.id,&#xA;       connectionName: 'images',&#xA;       edgeName: 'newImageEdge',&#xA;       rangeBehaviors: {&#xA;         '': 'prepend',&#xA;       },&#xA;     }];&#xA;   }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>In you server-side schema, preform update</p>&#xA;&#xA;<pre><code>const imageMutation = Relay.mutationWithClientMutationId({&#xA;  name: 'IntroduceImage',&#xA;  inputFields: {&#xA;    imageName: {&#xA;      type: new GraphQL.GraphQLNonNull(GraphQL.GraphQLString),&#xA;    },&#xA;  },&#xA;  outputFields: {&#xA;    newImageEdge: {&#xA;      type: ImageEdge,&#xA;      resolve: (payload, args, options) =&gt; {&#xA;        const file = options.rootValue.request.file;&#xA;        //write the image to you disk&#xA;        return uploadFile(file.buffer, filePath, filename)&#xA;        .then(() =&gt; {&#xA;          /* Find the offset for new edge*/&#xA;          return Promise.all(&#xA;            [(new myImages()).getAll(),&#xA;              (new myImages()).getById(payload.insertId)])&#xA;          .spread((allImages, newImage) =&gt; {&#xA;            const newImageStr = JSON.stringify(newImage);&#xA;            /* If edge is in list return index */&#xA;            const offset = allImages.reduce((pre, ele, idx) =&gt; {&#xA;              if (JSON.stringify(ele) === newImageStr) {&#xA;                return idx;&#xA;              }&#xA;              return pre;&#xA;            }, -1);&#xA;&#xA;            return {&#xA;              cursor: offset !== -1 ? Relay.offsetToCursor(offset) : null,&#xA;              node: newImage,&#xA;            };&#xA;          });&#xA;        });&#xA;      },&#xA;    },&#xA;    User: {&#xA;      type: UserType,&#xA;      resolve: () =&gt; (new myImages()).getAll(),&#xA;    },&#xA;  },&#xA;  mutateAndGetPayload: (input) =&gt; {&#xA;    //break the names to array.&#xA;    let imageName = input.imageName.substring(0, input.imageName.lastIndexOf('.'));&#xA;    const mimeType = input.imageName.substring(input.imageName.lastIndexOf('.'));&#xA;    //wirte the image to database&#xA;    return (new myImages())&#xA;    .add(imageName)&#xA;    .then(id =&gt; {&#xA;    //prepare to wirte disk&#xA;      return {&#xA;        insertId: id,&#xA;        imgNmae: imageName,&#xA;      };&#xA;    });&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>All the code above you can find them in this repo <a href=""https://github.com/bfwg/relay-gallery"" rel=""nofollow noreferrer"">https://github.com/bfwg/relay-gallery</a>&#xA;There is also a live demo <a href=""http://fanjin.io"" rel=""nofollow noreferrer"">http://fanjin.io</a></p>&#xA;",5718107,,5718107,2018-01-30 17:56:37,2018-01-30 17:56:37,"",,0,1,0,2017-01-19 19:57:54
41771782,1,,,0,681,"<p>Hi I'm trying to figure out how to handle user errors with graphql and relay when executing mutations.</p>&#xA;&#xA;<p>That's my graphql implementation for a createUser mutation:</p>&#xA;&#xA;<pre><code>mutationWithClientMutationId({&#xA;  name: 'CreateUser',&#xA;  inputFields: {&#xA;    email: { type: new GraphQLNonNull(GraphQLString) },&#xA;  },&#xA;  outputFields: {&#xA;    user: { type: userType },&#xA;    error: {type: errorType},&#xA;  },&#xA;  mutateAndGetPayload: async (attrs, { viewer }) =&gt; {&#xA;    try {&#xA;      // Try to create a user&#xA;    } catch(err) {&#xA;      // err.toObject has the shape required by the error type&#xA;      return { error: err.toObject() };&#xA;    }&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And this is my relay mutation class</p>&#xA;&#xA;<pre><code>class CreateUserMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { createUser }`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      email: this.props.email,&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateUserPayload {&#xA;        error&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: ""FIELDS_CHANGE"",&#xA;      fieldIDs: {&#xA;        error: ????,&#xA;      }&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have tried also another approach which is to not catch the error in graphql, and listen on onFailure when executing a relay mutation but I had to do something like that to get my error <code>return error.getError().source.errors[0]</code> but I think I like the approach of returning an error type better but I cant get it to work, any help please</p>&#xA;",1460518,,,,2017-01-20 21:17:59,"GraphQL, Relay: Handling errors",<graphql><relay>,1,0,0,2017-01-20 20:23:02
41772483,2,,41771782,0,,"<p>I was able to get the error using <code>REQUIRED_CHILDRED</code> instead of <code>FIELDS_CHANGE</code>.</p>&#xA;&#xA;<p>that's what I ended up doing</p>&#xA;&#xA;<pre><code>class CreateUserMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation { createUser }`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      email: this.props.email,&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateUserPayload {&#xA;        error&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: ""REQUIRED_CHILDREN"",&#xA;      children: [&#xA;        Relay.QL`&#xA;          fragment on CreateUserPayload {&#xA;            error {&#xA;              message&#xA;            }&#xA;          }&#xA;        `&#xA;      ]&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1460518,,,,2017-01-20 21:17:59,"",,0,0,0,2017-01-20 21:17:59
41840798,1,41841435,,6,890,"<p>Title mostly says it all: I'm building a react / relay application which will allow the user to dynamically create charts at runtime displaying their various income streams over a specified time range. One feature of this chart is the ability of the user to specify the sampling interval of each income stream (e.g. <code>YEAR</code>, <code>QUARTER</code>, <code>MONTH</code>, <code>WEEK</code>, etc.) as a parameter of each stream. </p>&#xA;&#xA;<p>These values are defined in the schema as a <code>GraphQLInputObjectType</code> instance as follows:</p>&#xA;&#xA;<pre><code>enum timeSeriesIntervalEnum {&#xA;  YEAR&#xA;  QUARTER&#xA;  MONTH&#xA;  WEEK&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>On the client-side, I have <code>react-relay</code> fragments defined of the following form:</p>&#xA;&#xA;<pre><code>fragment on BalanceSheet {&#xA;  income {&#xA;    # some income stream&#xA;    afterTax {  &#xA;      values(interval: $samplingInterval)&#xA;      dates(interval: $samplingInterval)&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This variable value will be populated as part of dropdown menu in a separate component where each value in the dropdown should correspond to a valid <code>timeSeriesIntervalEnum</code> value. </p>&#xA;&#xA;<p>Although it would certainly be possible to simply hardcode these values in, the underlying API is still being changed quite often and <strong>I would like to reduce coupling and instead populate these fields dynamically by specifying the variable type for a given dropdown (e.g. <code>timeSeriesIntervalEnum</code>) and then use the graphql client schema to parse the values and populate either a config json file (pre-runtime) or assign the values dynamically at runtime.</strong></p>&#xA;&#xA;<p><em>NOTE: I already do a bit of query string and fragment transpilation pre-start, so I'm not averse to creating json config files as part of this process if that is required.</em> </p>&#xA;",1139652,,1139652,2017-01-24 23:53:51,2017-01-25 00:30:27,"Given a set of GraphQL variable types, is it possible to use the client schema to create a map of all valid values for each type in the set",<javascript><graphql><relay>,1,0,0,2017-01-24 23:25:36
41862789,1,41864025,,6,970,"<p>Let's assume a type hierarchy of <code>Customer -(hasMany)-&gt; Orders -(hasMany)-&gt; OrderLines</code></p>&#xA;&#xA;<p>Something like this:</p>&#xA;&#xA;<pre><code>Customer {&#xA;    Name&#xA;    Orders [&#xA;        {&#xA;            OrderId&#xA;            Date&#xA;            OrderLines [&#xA;                { &#xA;                    ItemCount&#xA;                    ItemName&#xA;                }&#xA;            ]&#xA;        }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to query for this whole tree, and <em>filter</em> on properties at <em>any level</em> in the tree. </p>&#xA;&#xA;<p>For instance: Get all customers who ordered 'gizmos'.</p>&#xA;&#xA;<p>This is what I tried: at each level of the hierarchy, I specify optional arguments that would filter based on the properties available at that level:</p>&#xA;&#xA;<pre><code>Customer (Name) {&#xA;    Name&#xA;    Orders (OrderId, Date) [&#xA;        {&#xA;            OrderId&#xA;            Date&#xA;            OrderLines (ItemCount, ItemName) [&#xA;                { &#xA;                    ItemCount&#xA;                    ItemName&#xA;                }&#xA;            ]&#xA;        }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>GraphQL needs me to define <em>how to resolve</em> each type in the hierarchy, so when resolving, I filter based on the arguments in the query.</p>&#xA;&#xA;<p><em>But what if I only specify a filter at a deep level?</em> e.g. <code>ItemName : 'gizmo'</code></p>&#xA;&#xA;<p>Assuming there's only one order line in the system containing a gizmo, I would expect to get a response like this:</p>&#xA;&#xA;<pre><code>[{&#xA;    Name: ""cust12"",&#xA;    Orders [{&#xA;        OrderId: ""ade32f"",&#xA;        OrderLines: [{&#xA;            ItemCount: 50000, //customer really likes gizmos&#xA;            ItemName: ""gizmo""&#xA;        }]&#xA;    }]&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>But what I actually get is <strong>all</strong> customers (no filter there), <strong>all</strong> their orders (no filter there) and <strong>all</strong> order items, mostly empty (the items inside are filtered).</p>&#xA;&#xA;<pre><code>[{&#xA;    Name: ""cust12"",&#xA;    Orders [&#xA;    {&#xA;        OrderId: ""aaaaaa"",&#xA;        OrderLines: [ ]&#xA;    },&#xA;    {&#xA;        OrderId: ""ade32f"",&#xA;        OrderLines: [{&#xA;            ItemCount: 50000,&#xA;            ItemName: ""gizmo""&#xA;        }]&#xA;    },&#xA;    {&#xA;        OrderId: ""bbbbbb"",&#xA;        OrderLines: [ ]&#xA;    },&#xA;    {&#xA;        OrderId: ""cccccc"",&#xA;        OrderLines: [ ]&#xA;    }&#xA;    ]&#xA;},&#xA;{&#xA;    Name: ""cust345"",&#xA;    Orders [&#xA;    {&#xA;        OrderId: ""eeeeee"",&#xA;        OrderLines: [ ]&#xA;    },&#xA;    {&#xA;        OrderId: ""ffffff"",&#xA;        OrderLines: [ ]&#xA;    }&#xA;    ]&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>GraphQL calls the resolvers <em>top-down</em>:&#xA;- get all (filtered) clients&#xA;- for each of these get all (filtered) orders&#xA;- for each of those get all (filtered) order lines </p>&#xA;&#xA;<p>Because of the top-down nature of calling the resolvers, I get a lot more data than I bargained for. </p>&#xA;&#xA;<p>How should I approach this?</p>&#xA;",11545,,,,2017-01-26 11:21:05,"GraphQL - how to filter a hierarchy? (""customers who ordered gizmos last month"")",<graphql>,1,0,0,2017-01-25 22:24:47
41864025,2,,41862789,7,,"<h1>Relation filters</h1>&#xA;&#xA;<p>This is actually a more complex topic than it first seems. The problem is that your current filter condition expresses</p>&#xA;&#xA;<blockquote>&#xA;  <p>get all customers, but only include items named 'gizmo'</p>&#xA;</blockquote>&#xA;&#xA;<p>but what you really want is</p>&#xA;&#xA;<blockquote>&#xA;  <p>get all customers that are related to at least one item named 'gizmo'</p>&#xA;</blockquote>&#xA;&#xA;<h2>get all customers that are related to at least one item named 'gizmo'</h2>&#xA;&#xA;<p>An elegant solution for this problem is the addition of <em>relation filters</em> to the schema. In your case, it could look like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  Customer(filter: {&#xA;    orders_some: {&#xA;      orderLines_some: {&#xA;        item: {&#xA;          itemName: ""gizmo""&#xA;        }&#xA;      }&#xA;    }&#xA;  }) {&#xA;    Name&#xA;    Orders {&#xA;      OrderId&#xA;      Date&#xA;      OrderLines { &#xA;        ItemCount&#xA;        ItemName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Using </p>&#xA;&#xA;<pre><code>orders_some: {&#xA;  orderLines_some: {&#xA;    item: {&#xA;      itemName: ""gizmo""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>we only fetch customers that are indirectly related to an item named 'gizmo', exactly what we wanted.</p>&#xA;&#xA;<p>Two more examples:</p>&#xA;&#xA;<h2>get all customers that are not related to any item named 'gizmo'</h2>&#xA;&#xA;<pre><code>query {&#xA;  Customer(filter: {&#xA;    orders_none: {&#xA;      orderLines_some: {&#xA;        item: {&#xA;          itemName: ""gizmo""&#xA;        }&#xA;      }&#xA;    }&#xA;  }) {&#xA;    Name&#xA;    Orders {&#xA;      OrderId&#xA;      Date&#xA;      OrderLines { &#xA;        ItemCount&#xA;        ItemName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>get all customers where all their orders contain some order line with an item named 'gizmo'</h2>&#xA;&#xA;<pre><code>query {&#xA;  Customer(filter: {&#xA;    orders_every: {&#xA;      orderLines_some: {&#xA;        item: {&#xA;          itemName: ""gizmo""&#xA;        }&#xA;      }&#xA;    }&#xA;  }) {&#xA;    Name&#xA;    Orders {&#xA;      OrderId&#xA;      Date&#xA;      OrderLines { &#xA;        ItemCount&#xA;        ItemName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The <code>every</code>, <code>some</code> and <code>none</code> relation filters are an essential part of the Graphcool APIs - you can <a href=""https://www.graph.cool/docs/tutorials/designing-powerful-apis-with-graphql-query-parameters-aing7uech3#expressing-even-complex-data-requirements"" rel=""nofollow noreferrer"">read more here</a>. </p>&#xA;",1176596,,1176596,2017-01-26 11:21:05,2017-01-26 11:21:05,"",,0,1,0,2017-01-26 00:13:31
41897625,1,,,0,462,"<p><strong>Summary:</strong> My problem is that when I create a node using a <code>Relay</code> mutation, the mutation creates the record in my database, but my client-side local data isn't updating, and the query response appears to be missing the new node.</p>&#xA;&#xA;<p><strong>Discussion</strong>: I think the <code>RANGE_ADD</code> should add the new node, <code>ListingRating</code>, to my local collection of <code>ListingRating</code>s, which should automatically update the connected nodes (<code>Listing</code> and <code>User</code>). However, according to the <code>relay</code> panel in <code>react-dev-tools</code>, the mutation doesn't include any of the fields I need updated.</p>&#xA;&#xA;<p><strong>Questions</strong>: </p>&#xA;&#xA;<p><em>Should <code>RANGE_ADD</code> be sufficient here?</em>  If so, what's wrong with my implementation?</p>&#xA;&#xA;<p><em>Do I have to update the <code>Listing</code> and <code>User</code> nodes manually?</em>  If so, how?   Those nodes are only available deeply nested in the mutation <code>payload</code>, and <code>FIELDS_CHANGE</code> requires a <code>fieldId</code> in the top-level of the <code>payload</code>, right? </p>&#xA;&#xA;<p><strong>Schema:</strong> My schema holds <code>Listing</code>s (adverts), <code>User</code>s, and <code>Rating</code>s (users' ratings of those <code>Listings</code>). it looks something like this:</p>&#xA;&#xA;<pre><code>type Listing = {&#xA;  ...&#xA;  ratings: [ListingRating]&#xA;&#xA;}&#xA;&#xA;type User = {&#xA;  ...&#xA;  ratings: [ListingRating]&#xA;}&#xA;&#xA;type ListingRating = {&#xA;  rating: Int&#xA;  user: User&#xA;  listing: Listing&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Mutation</strong>: I'm using scaphold.io as a back end, so don't have control over the mutation structures (though they're to Relay spec). They look like this:</p>&#xA;&#xA;<pre><code>mutation createListingRating(input: CreateListingRatingInput!) { CreateListingRatingPayload }&#xA;&#xA;// CreateListingRatingInput&#xA;{&#xA;  listingId: ID&#xA;  listing: CreateListingInput&#xA;  rating: Int&#xA;  userId: ID&#xA;  user: CreateUserInput&#xA;  clientMutationId: ID&#xA;}&#xA;&#xA;// CreateRatingPayload&#xA;{&#xA;  changedListingRating: ListingRating&#xA;  changedEdge: ListingRatingEdge&#xA;  viewer: Viewer&#xA;  clientMutationId: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Relay mutation</strong>: </p>&#xA;&#xA;<pre><code>export default class CreateListingRating extends Relay.Mutation {&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`&#xA;      mutation {&#xA;        createListingRating&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      userId: this.props.userId,&#xA;      listingId: this.props.listingId,&#xA;      rating: this.props.newRating,&#xA;    }&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on CreateListingRatingPayload @relay(pattern: true){&#xA;        changedEdge&#xA;        changedListingRating {&#xA;          listing&#xA;          user&#xA;          rating&#xA;        }&#xA;        viewer&#xA;      }&#xA;    `&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentID: this.props.viewer.id,&#xA;      parentName: 'viewer',&#xA;      connectionName: 'allListingRatings',&#xA;      edgeName: 'changedEdge',&#xA;      rangeBehaviors: {&#xA;        '': 'append',&#xA;      },&#xA;    }]&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Query</strong>: (not sure this is relevant) In my app, the query I use to display the <code>ListingRating</code>s goes something like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  getUserGroup(id: 'some-group-id') {&#xA;    users {&#xA;      edges {&#xA;        node {&#xA;          listings {&#xA;            edges {&#xA;              node {&#xA;                ratings {&#xA;                  edges {&#xA;                    node {&#xA;                      rating&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Mutation request</strong>: (ie, what displays in the relay panel in react-dev-tools)</p>&#xA;&#xA;<pre><code>mutation CreateListingRating($input_0:CreateListingRatingInput!) {&#xA;&#xA;  createListingRating(input:$input_0) {&#xA;&#xA;    ...F1&#xA;,&#xA;&#xA;    clientMutationId&#xA;  }&#xA;&#xA;}&#xA;fragment F0 on Viewer {&#xA;&#xA;  id,&#xA;&#xA;  user {&#xA;&#xA;    firstName&#xA;,&#xA;&#xA;    id&#xA;  }&#xA;&#xA;}&#xA;fragment F1 on CreateListingRatingPayload {&#xA;&#xA;  viewer {&#xA;&#xA;    ...F0&#xA;&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;",5456001,,,,2017-01-27 17:51:48,How do I update connected Nodes in a RANGE_ADD mutation?,<reactjs><graphql><relayjs><relay>,1,0,0,2017-01-27 15:36:54
41897773,2,,37193982,0,,"<p>In the <code>fatQuery</code>, when you list a <code>non-scalar</code> field, Relay will assume that <em>any</em> connected field may have updated. In certain fields that require arguments (eg, <code>(first: n)</code>), you can use <code>@relay(pattern: true)</code> to bypass this requirement. <a href=""https://stackoverflow.com/questions/34103296/purpose-of-relaypatterntrue"">This SO question</a> discusses the feature.</p>&#xA;",5456001,,-1,2017-05-23 12:17:39,2017-01-27 15:44:38,"",,0,0,0,2017-01-27 15:44:38
41946745,2,,36666622,1,,"<p>I just ran into this. My enum:</p>&#xA;&#xA;<pre><code>const contributorArgs = Object.assign(&#xA;  {},&#xA;  connectionArgs, {&#xA;    sort: {&#xA;      type: new GraphQLEnumType({&#xA;        name: 'ContributorSort',&#xA;        values: {&#xA;          top: { value: 0 },&#xA;        },&#xA;      })&#xA;    },&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>In my queries, I was doing:</p>&#xA;&#xA;<pre><code>... on Topic {&#xA;  id&#xA;  contributors(first: 10, sort: 'top') {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Turns out you just don't quote the value (which after thinking about it makes sense; it's a value in the enum type, not an actual value:</p>&#xA;&#xA;<pre><code>... on Topic {&#xA;  id&#xA;  contributors(first: 10, sort: top) {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2518231,,,,2017-01-30 22:44:28,"",,0,1,0,2017-01-30 22:44:28
41982138,1,,,0,326,"<p>Hey guys I just started learning how to code using react/graphql, and I have a very hard time understanding how parameter passing works. In the code example below taken from <a href=""https://github.com/graphql/swapi-graphql"" rel=""nofollow noreferrer"">https://github.com/graphql/swapi-graphql</a> , I don't know when the resolve function populates the arguments ""edge"" and ""conn"". Could someone give me some insight? </p>&#xA;&#xA;<pre><code>export function connectionFromUrls(&#xA;  name: string,&#xA;  prop: string,&#xA;  type: GraphQLOutputType&#xA;): GraphQLFieldConfig&lt;*, *&gt; {&#xA;  const {connectionType} = connectionDefinitions({&#xA;    name,&#xA;    nodeType: type,&#xA;    resolveNode: edge =&gt; getObjectFromUrl(edge.node),&#xA;    connectionFields: () =&gt; ({&#xA;      totalCount: {&#xA;        type: GraphQLInt,&#xA;        resolve: conn =&gt; conn.totalCount,&#xA;        description:&#xA;`A count of the total number of objects in this connection, ignoring pagination.&#xA;This allows a client to fetch the first five objects by passing ""5"" as the&#xA;argument to ""first"", then fetch the total count so it could display ""5 of 83"",&#xA;for example.`&#xA;      },&#xA;      [prop]: {&#xA;        type: new GraphQLList(type),&#xA;        resolve: conn =&gt; conn.edges.map(edge =&gt; getObjectFromUrl(edge.node)),&#xA;        description:&#xA;`A list of all of the objects returned in the connection. This is a convenience&#xA;field provided for quickly exploring the API; rather than querying for&#xA;""{ edges { node } }"" when no edge data is needed, this field can be be used&#xA;instead. Note that when clients like Relay need to fetch the ""cursor"" field on&#xA;the edge to enable efficient pagination, this shortcut cannot be used, and the&#xA;full ""{ edges { node } }"" version should be used instead.`&#xA;      }&#xA;    })&#xA;  });&#xA;  return {&#xA;    type: connectionType,&#xA;    args: connectionArgs,&#xA;    resolve: (obj, args) =&gt; {&#xA;      const array = obj[prop] || [];&#xA;      return {&#xA;        ...connectionFromArray(array, args),&#xA;        totalCount: array.length&#xA;      };&#xA;    },&#xA;  };&#xA;}&#xA;</code></pre>&#xA;",4311922,,,,2018-01-08 16:23:18,Graphql parameter passing,<javascript><graphql>,1,0,0,2017-02-01 14:25:54
41993034,1,42061088,,3,5143,"<p>I need to change my mutation document dynamically to be able to create multiple items in a single mutation. So I have this function <code>createOrderName</code> that takes an integer and be able to create the correct mutation document. Eg. <code>createOrderName(2)</code> gets</p>&#xA;&#xA;<pre><code>mutation createOrderMut($input0: AddToOrderMenuItemConnectionInput!, $input1: AddToOrderMenuItemConnectionInput!) {&#xA;  input0: addToOrderMenuItemConnection (input:$input0) {&#xA;    changedOrderMenuItem {&#xA;      id&#xA;    }&#xA;  }&#xA;  input1: addToOrderMenuItemConnection (input:$input1) {&#xA;    changedOrderMenuItem {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And my container is as follow.</p>&#xA;&#xA;<pre><code>const CartContainer = compose(&#xA;  graphql(createOrderName(2), {&#xA;    props: ({ mutate }) =&gt; ({&#xA;      addToOrderMenuItem: (menus, orderId) =&gt; mutate({&#xA;        variables: createOrdersInput(menus, orderId)&#xA;      })&#xA;    })&#xA;  })&#xA;)(CartView)&#xA;</code></pre>&#xA;&#xA;<p>Now how can I pass an integer value to this mutation in order for it to create the correct mutation document? Currently it's fix to 2, but I need it to be more flexible so I can create any number of items...</p>&#xA;",9774,,,,2020-11-15 23:56:59,Dynamic mutation document for react-apollo,<graphql><react-apollo><apollo-client>,2,3,0,2017-02-02 01:57:14
42056740,1,42221365,,0,215,"<p>I'm currently in the process of transforming a REST API into GraphQL, but I've hit a bit of a snag in one of the endpoints.</p>&#xA;&#xA;<p>Currently, this endpoint returns an object who's keys can be an unlimited set of strings, and whos values all match a certain shape.</p>&#xA;&#xA;<p>So, as a rudimentary example, I have this situation...</p>&#xA;&#xA;<pre><code>// response&#xA;{&#xA;    foo: { id: 'foo', count: 3 },&#xA;    bar: { id: 'bar', count: 6 },&#xA;    baz: { id: 'baz', count: 1 },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Again, the keys are not known at runtime and can be an unlimited set of strings.</p>&#xA;&#xA;<p>In TypeScript, for example, this sort of situation is handled by creating an interface using an indexable field signature, like so...</p>&#xA;&#xA;<pre><code>interface Data {&#xA;    id: string;&#xA;    count: number;&#xA;}&#xA;&#xA;interface Response {&#xA;    [key: string]: Data;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So, my question is: Is this sort of thing possible with graphql? How would I go about creating a type/schema for this?</p>&#xA;&#xA;<p>Thanks in advance!</p>&#xA;",3990593,,,,2017-02-14 08:40:57,Creating a GraphQLObjectType with an indexable field signature?,<graphql><graphql-js>,1,0,0,2017-02-05 20:10:28
42130437,1,42142682,,0,288,"<p>I was going through the relay docs and came to following code in RANGE_ADD.</p>&#xA;&#xA;<pre><code>class IntroduceShipMutation extends Relay.Mutation {&#xA;  // This mutation declares a dependency on the faction&#xA;  // into which this ship is to be introduced.&#xA;  static fragments = {&#xA;    faction: () =&gt; Relay.QL`fragment on Faction { id }`,&#xA;  };&#xA;  // Introducing a ship will add it to a faction's fleet, so we&#xA;  // specify the faction's ships connection as part of the fat query.&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on IntroduceShipPayload {&#xA;        faction { ships },&#xA;        newShipEdge,&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'faction',&#xA;      parentID: this.props.faction.id,&#xA;      connectionName: 'ships',&#xA;      edgeName: 'newShipEdge',  &#xA;      rangeBehaviors: {&#xA;        // When the ships connection is not under the influence&#xA;        // of any call, append the ship to the end of the connection&#xA;        '': 'append',&#xA;        // Prepend the ship, wherever the connection is sorted by age&#xA;        'orderby(newest)': 'prepend',&#xA;      },&#xA;    }];&#xA;  }&#xA;  /* ... */&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now over here it is mentioned that <code>edgeName</code> is required for adding new node to the connection. Looks well and fine.</p>&#xA;&#xA;<p>Now, I move further down the documentation and reached the <code>GraphQL</code> implementation of this mutation.</p>&#xA;&#xA;<pre><code>mutation AddBWingQuery($input: IntroduceShipInput!) {&#xA;  introduceShip(input: $input) {&#xA;    ship {&#xA;      id&#xA;      name&#xA;    }&#xA;    faction {&#xA;      name&#xA;    }&#xA;    clientMutationId&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now according to docs this mutation gives me output as </p>&#xA;&#xA;<pre><code>{&#xA;  ""introduceShip"": {&#xA;    ""ship"": {&#xA;      ""id"": ""U2hpcDo5"",&#xA;      ""name"": ""B-Wing""&#xA;    },&#xA;    ""faction"": {&#xA;      ""name"": ""Alliance to Restore the Republic""&#xA;    },&#xA;    ""clientMutationId"": ""abcde""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I cannot see <code>edgeName</code> being present here.</p>&#xA;&#xA;<p>I was using graphene for my project. Over there also I saw something similar only </p>&#xA;&#xA;<pre><code>class IntroduceShip(relay.ClientIDMutation):&#xA;  class Input:&#xA;    ship_name = graphene.String(required=True)&#xA;    faction_id = graphene.String(required=True)&#xA;&#xA;ship = graphene.Field(Ship)&#xA;faction = graphene.Field(Faction)&#xA;&#xA;@classmethod&#xA;def mutate_and_get_payload(cls, input, context, info):&#xA;    ship_name = input.get('ship_name')&#xA;    faction_id = input.get('faction_id')&#xA;    ship = create_ship(ship_name, faction_id)&#xA;    faction = get_faction(faction_id)&#xA;    return IntroduceShip(ship=ship, faction=faction)&#xA;</code></pre>&#xA;&#xA;<p>Over here also I cannot see <code>edgeName</code> anywhere. </p>&#xA;&#xA;<p>Any help please?  I am working on mutations for the first so wanted to confirm a m I missing something or is something wrong here? </p>&#xA;",2485624,,,,2020-02-19 23:16:19,Issue with RANGE_ADD in Relay Mutations,<graphql><relayjs><relay>,1,0,0,2017-02-09 07:15:21
42134564,2,,42133424,20,,"<p>You can make use our so called nested mutations to accomplish that.&#xA;First of all, let's see how we can do it from the GraphiQL playground:</p>&#xA;&#xA;<pre><code>mutation createNestedCompany {&#xA;  createCompany(&#xA;    owner: {&#xA;      name: ""Mickey""&#xA;      email: ""mickey@mouse.com""&#xA;    }&#xA;    addresses: [{&#xA;      street: ""A street""&#xA;      city: ""A city""&#xA;      country: ""A country""&#xA;      contacts: [{&#xA;        name: ""Mickey""&#xA;        email: ""mickey@mouse.com""&#xA;        phone: ""+1 23456789""&#xA;      }]&#xA;    }, {&#xA;      street: ""B street""&#xA;      city: ""B city""&#xA;      country: ""B country""&#xA;      contacts: [{&#xA;        name: ""Minney""&#xA;        email: ""minney@mouse.com""&#xA;        phone: ""+9 87654321""&#xA;      }]&#xA;    }]&#xA;  ) {&#xA;    id&#xA;    owner {&#xA;      id&#xA;    }&#xA;    addresses {&#xA;      id&#xA;      contacts {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note that the <code>createCompany</code> mutation has the object argument <code>owner</code> and the list object argument <code>addresses</code>. <code>addresses</code> has a nested <code>contacts</code> list object argument.</p>&#xA;&#xA;<p>Using Apollo Client, we specify input arguments with GraphQL variables, so let's see how it looks in this case:</p>&#xA;&#xA;<pre><code>const createNestedCompany = gql`&#xA;  mutation createNestedCompany(&#xA;    $owner: CompanyownerUser&#xA;    $addresses: [CompanyaddressesAddress!]&#xA;  ) {&#xA;    createCompany(&#xA;      owner: $owner&#xA;      addresses: $addresses&#xA;    ) {&#xA;      id&#xA;      owner {&#xA;        id&#xA;      }&#xA;      addresses {&#xA;        id&#xA;        contacts {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>When calling the mutation with Apollo, we now have to specify the variables as an object:</p>&#xA;&#xA;<pre><code>const variables = {&#xA;  owner: {&#xA;    name: ""Mickey""&#xA;    email: ""mickey@mouse.com""&#xA;  }, &#xA;  addresses: [{&#xA;    street: ""A street""&#xA;    city: ""A city""&#xA;    country: ""A country""&#xA;    contacts: [{&#xA;      name: ""Mickey""&#xA;      email: ""mickey@mouse.com""&#xA;      phone: ""+1 23456789""&#xA;    }]&#xA;  }, {&#xA;    street: ""A street""&#xA;    city: ""A city""&#xA;    country: ""A country""&#xA;    contacts: [{&#xA;      name: ""Minney""&#xA;      email: ""minney@mouse.com""&#xA;      phone: ""+9 87654321""&#xA;    }]&#xA;  }]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and call the mutation with the variables:</p>&#xA;&#xA;<pre><code>this.props.createNestedCompany({ variables })&#xA;  .then((response) =&gt; {&#xA;    console.log('Company, owner and addresses plus contacts created');&#xA;  }).catch((e) =&gt; {&#xA;    console.error(e)&#xA;  })&#xA;</code></pre>&#xA;&#xA;<p>The variable types <code>CompanyownerUser</code> and <code>[CompanyaddressesAddress!]</code> depend on a combination of <strong>the multiplicity</strong> (to-one; to-many), <strong>the related models</strong> (<code>Company</code> and <code>User</code>; <code>Company</code> and <code>Address</code>) and <strong>the related fields</strong> (<code>owner</code>; <code>addresses</code>). You can find all type names in the GraphiQL playground docs when you navigate to the <code>createCompany</code> mutation.</p>&#xA;",1176596,,,,2017-02-09 10:44:48,"",,0,0,0,2017-02-09 10:44:48
42142682,2,,42130437,2,,"<p>This example might be either simplified or a bit obsoloete, because in practice <strong>there is need to return edge</strong> and that's exactly what is fetched by relay (other fields in RANGE_ADD are more a kind of declaration and are not necessarily fetched).</p>&#xA;&#xA;<p>Here is how you can do it in graphene:</p>&#xA;&#xA;<pre><code># Import valid as of graphene==0.10.2 and graphql-relay=0.4.4&#xA;from graphql_relay.connection.arrayconnection import offset_to_cursor&#xA;&#xA;class IntroduceShip(relay.ClientIDMutation):&#xA;    class Input:&#xA;        ship_name = graphene.String(required=True)&#xA;        faction_id = graphene.String(required=True)&#xA;&#xA;    ship = graphene.Field(Ship)&#xA;    faction = graphene.Field(Faction)&#xA;    new_ship_edge = graphene.Field(Ship.get_edge_type().for_node(Ship))&#xA;&#xA;    @classmethod&#xA;    def mutate_and_get_payload(cls, input, context, info):&#xA;        ship_name = input.get('ship_name')&#xA;        faction_id = input.get('faction_id')&#xA;        ship = create_ship(ship_name, faction_id)&#xA;        faction = get_faction(faction_id)&#xA;&#xA;        ship_edge_type = Ship.get_edge_type().for_node(Ship)&#xA;        new_ship_edge = edge_type(&#xA;            # Assuming get_ships_number supplied&#xA;            cursor=offset_to_cursor(get_ships_number())&#xA;            node=ship&#xA;        )&#xA;&#xA;        return cls(ship=ship, faction=faction, new_ship_edge=new_ship_edge)&#xA;</code></pre>&#xA;",2013920,,2013920,2020-02-19 23:16:19,2020-02-19 23:16:19,"",,0,0,0,2017-02-09 17:04:56
42235417,1,,,0,246,"<p>I have a tree structure which I'm trying to query to a specific depth.  I'm new to relay so not sure about if I'm going about this the right way or even if its possible.</p>&#xA;&#xA;<p>My code is currently looking like this:</p>&#xA;&#xA;<pre><code>class TreeRoot extends React.Component {&#xA;  render() {&#xA;    var container = this.props.treeRoot;&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;ViewNode viewNode={container.root} maxDepth={10} expand={true}/&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;} &#xA;&#xA;class ViewNode extends React.Component {&#xA;&#xA;   render() {&#xA;      var vn = this.props.viewNode;&#xA;      return (&#xA;       &lt;div&gt;&#xA;        &lt;div&gt;{vn.type} {vn.widget} {vn.mode}&lt;/div&gt;&#xA;         &lt;ViewNodeList viewNode={vn} maxDepth={this.props.maxDepth-1}/&gt;&#xA;       &lt;/div&gt;&#xA;      );&#xA;  }&#xA;}&#xA;&#xA;ViewNode = Relay.createContainer(ViewNode, {&#xA;    initialVariables:{&#xA;        maxDepth:1,&#xA;        expand:false&#xA;    },&#xA;    fragments: {&#xA;      viewNode: (variables) =&gt; Relay.QL`&#xA;        fragment on ViewNode{&#xA;          id&#xA;          type&#xA;          widget&#xA;          mode&#xA;          viewNodes @include(if: $expand){&#xA;            ${ViewNode.getFragment(""viewNode"", {maxDepth:(variables.maxDepth -1),expand:(variables.maxDepth &gt; 0)}).if(variables.expand)}&#xA;        }&#xA;    }`,&#xA;  }&#xA;});&#xA;&#xA;class ViewNodeList extends React.Component {&#xA;  render() {&#xA;    const vn = this.props.viewNode;&#xA;    if (!vn.viewNodes){&#xA;      return (&lt;div&gt;&lt;/div&gt;);&#xA;    }&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {vn.viewNodes.map((el, i)=&gt; {&#xA;          return &lt;ViewNode key={i} viewNode={el} maxDepth={this.props.maxDepth} expand={this.props.maxDepth &gt; 0}&gt;&lt;/ViewNode&gt;&#xA;        })&#xA;        }&#xA;      &lt;/div&gt;&#xA;    );&#xA;  };&#xA;}&#xA;&#xA;TreeRoot = Relay.createContainer(TreeRoot, {&#xA;    fragments: {&#xA;      root: () =&gt; Relay.QL`&#xA;          fragment on TreeRoot{&#xA;              id&#xA;              name&#xA;              root{&#xA;                  ${ViewNode.getFragment('viewNode',{maxDepth:10,expand:true})}&#xA;              }&#xA;           }&#xA;       `,&#xA;    }&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>The significant bit being the way I'm trying to control the recursion in the ViewNode component's viewNode fragment.  It is attempting to recurse down while decrementing the 'maxDepth' variable and using the 'maxDepth' to calculate the value of the 'expand' variable.  Whether to continue recursing is based on the 'expand' var.</p>&#xA;&#xA;<p>Currently this retrieves the root and the first level of children but doesn't recurse as desired.  Is what I'm trying to do possible?  If it is am I on the right track or going about this in completely the wrong way?</p>&#xA;",2467182,,,,2017-06-21 01:30:24,Recursive query to specific depth,<recursion><graphql><relayjs>,1,0,0,2017-02-14 20:17:32
42238187,2,,41898124,0,,"<blockquote>&#xA;  <p>nodeDefinitions returns the Node interface that objects can implement, and returns the node root field to include on the query type. To implement this, it takes a function to resolve an ID to an object, and to determine the type of a given object.</p>&#xA;</blockquote>&#xA;&#xA;<p>In GraphQL, data are represented by a tree, and the nodes of the tree are different types of data.&#xA;<a href=""https://i.stack.imgur.com/kJBvO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kJBvO.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>nodeInterface, nodeField are used to Serialize and Deserialize nodes. for example: if you want to add a book to the book collection, the new book and its id must be provided. Relay will then convert the book object into a new BookType node and add it into the tree.</p>&#xA;&#xA;<p>I have created a demo on how to upload images using React + Relay + GraphQL. </p>&#xA;&#xA;<p>Github repo: <a href=""https://github.com/bfwg/relay-gallery"" rel=""nofollow noreferrer"">https://github.com/bfwg/relay-gallery</a></p>&#xA;&#xA;<p>Live demo: <a href=""http://fanjin.computer"" rel=""nofollow noreferrer"">http://fanjin.computer</a></p>&#xA;",5718107,,,,2017-02-14 23:35:00,"",,0,0,0,2017-02-14 23:35:00
42276527,1,,,0,77,"<p>Essentially, I have users who can have payments, and theses payments can be filtered with an arg.</p>&#xA;&#xA;<p>Here is my schema, simplified :</p>&#xA;&#xA;<pre><code>type User {&#xA;  payments($filter: PaymentsFilter): PaymentsConnection,&#xA;}&#xA;&#xA;enum PaymentsFilter {&#xA;  MissingDetails,&#xA;}&#xA;&#xA;type PaymentsConnection {&#xA;  edges { ... }&#xA;  pageInfo { ... }&#xA;}&#xA;&#xA;type Payment {&#xA;  id&#xA;  description&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The <code>MissingDetails</code> filter returns only the <code>Payment</code> who are missing a description.&#xA;For example, if I have 2 <code>Payment</code> :</p>&#xA;&#xA;<pre><code>[&#xA;  { id: 1, description: null },&#xA;  { id: 2, description: 'A great payment' },&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>A query as such :</p>&#xA;&#xA;<pre><code>query {&#xA;  loggedUser {&#xA;    payments(filter: MissingDetails) {&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Would return only the first <code>Payment</code>, with <code>id: 1</code>.</p>&#xA;&#xA;<p>I want to achieve an <code>UpdatePaymentMutation</code>, that would update the payment and depending on if the <code>description</code> is set or not in the response, I would <code>RANGE_ADD</code> it to the connection with the filter <code>MissingDetails</code>, or <code>RANGE_DELETE</code> it.<br>&#xA;How can I achieve that ?</p>&#xA;",3076424,,,,2017-02-16 14:19:41,Add or delete from connection depending on response,<graphql><relayjs>,0,5,0,2017-02-16 14:19:41
42356643,2,,42334805,0,,"<p>I could see this being done a couple of ways. You are right that Apollo will strip the isNew value because it is not a part of your schema and is not listed in the queries selection set. I like to separate the concerns of the server data that is managed by apollo and the front-end application state that lends itself to using redux/flux or even more simply by managing it in your component's state.</p>&#xA;&#xA;<p>Apollo gives you the option to supply your own redux store. You can allow apollo to manage its data fetching logic and then manage your own front-end state alongside it. Here is a write up discussing how you can do this: <a href=""http://dev.apollodata.com/react/redux.html"" rel=""nofollow noreferrer"">http://dev.apollodata.com/react/redux.html</a>.</p>&#xA;&#xA;<p>If you are using React, you might be able to use component lifecycle hooks to detect when new comments appear. This might be a bit of a hack but you could use <code>componentWillReceiveProps</code> to compare the new list of comments with the old list of comments, identify which are new, store that in the component state, and then invalidate them after a period of time using <code>setTimeout</code>.</p>&#xA;&#xA;<pre><code>componentWillReceiveProps(newProps) {&#xA;&#xA;  // Compute a diff.&#xA;  const oldCommentIds = new Set(this.props.data.allComments.map(comment =&gt; comment.id));&#xA;  const nextCommentIds = new Set(newProps.data.allComments.map(comment =&gt; comment.id));&#xA;  const newCommentIds = new Set(&#xA;    [...nextCommentIds].filter(commentId =&gt; !oldCommentIds.has(commentId))&#xA;  );&#xA;  this.setState({&#xA;    newCommentIds&#xA;  });&#xA;&#xA;  // invalidate after 1 second&#xA;  const that = this;&#xA;  setTimeout(() =&gt; {&#xA;    that.setState({&#xA;      newCommentIds: new Set()&#xA;    })&#xA;  }, 1000);&#xA;}&#xA;&#xA;// Then somewhere in your render function have something like this.&#xA;render() {&#xA;  ...&#xA;  {&#xA;    this.props.data.allComments.map(comment =&gt; {&#xA;      const isNew = this.state.newCommentIds.has(comment.id);&#xA;      return &lt;CommentComponent isNew={isNew} comment={comment} /&gt;&#xA;    })&#xA;  }&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The code above was right off the cuff so you might need to play around a bit. Hope this helps :)</p>&#xA;",2088684,,,,2017-02-21 00:34:15,"",,0,1,0,2017-02-21 00:34:15
42387786,2,,42374057,4,,"<p>You can pass the parent props to the variables of the initial fetch in the graphql HoC, like this:</p>&#xA;&#xA;<p><code>ParentComponent.jsx</code></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import ChildComponent from './ChildComponent';&#xA;&#xA;const ParentComponent = () =&gt; &lt;ChildComponent filterPropValue=""myDefaultFilterValue"" /&gt;;&#xA;&#xA;export default ParentComponent;&#xA;</code></pre>&#xA;&#xA;<p><code>ChildComponent.jsx</code></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class ChildComponent extends React.Component {&#xA;  refresh() {&#xA;    this.props.refetch({&#xA;      filter: 'mynewFilterValue'&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;I am a child component with {this.props.items.length} items.&lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default graphql(MyQuery, {&#xA;  options: (props) =&gt; ({&#xA;    variables: {&#xA;      filter: props.filterPropValue&#xA;    }&#xA;  }),&#xA;  props: ({ data: { items, error, refetch }) =&gt; ({&#xA;    items,&#xA;    error,&#xA;    refetch&#xA;  })&#xA;})(ChildComponent);&#xA;</code></pre>&#xA;&#xA;<p>Any subsequent refetches with new parameters can then be dealt with via <code>refetch()</code>.</p>&#xA;",416632,,416632,2017-02-22 17:36:38,2017-02-22 17:36:38,"",,0,4,0,2017-02-22 09:38:12
42418328,1,,,2,675,"<p>In GraphQL, I have the following structure</p>&#xA;<pre><code># represents any node with GlobalIdField&#xA;node(id: &quot;uniqueIdOfNode&quot;) {&#xA;   &#xA;}&#xA;&#xA;# represents actually logged user&#xA;viewer {&#xA;&#xA;}&#xA;</code></pre>&#xA;<p>In <a href=""https://github.com/taion/relay-todomvc/blob/master/src/data/schema.js"" rel=""nofollow noreferrer"">sample MVC app schema</a> todos are connected to the viewer so when querying you can get only those todos that belong to logged user.</p>&#xA;<p>However, in my case, I want to display data which is not related to a user. Let's say data is type Country which is NodeInterfaceType and I want to make a query where I ask for the list of countries. So in Relay, I can make fragment on CountryList where I get a country and pass it to React component using Relay.</p>&#xA;<p>If what I've written is not clear enough let me know because I'm confused with it and I'm not sure if I explained it well.</p>&#xA;<p>I've written GraphQL server in PHP but the code or hints can be written in node.js and I'll understand it as well.</p>&#xA;<p>How to do it?</p>&#xA;<h1>Update</h1>&#xA;<p>Some code:</p>&#xA;<p><strong>schema.graphql</strong></p>&#xA;<pre><code># A country&#xA;type Country implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  countryId: Int&#xA;  phonePrefix: String&#xA;  name: String&#xA;  timezone: String&#xA;}&#xA;&#xA;# Representation of date and time in &quot;Y-m-d H:i:s&quot; format&#xA;scalar DateTime&#xA;&#xA;interface NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;}&#xA;&#xA;type Query {&#xA;  # Fetches an object given its ID&#xA;  node(&#xA;    # The ID of an object&#xA;    id: ID!&#xA;  ): NodeInterface&#xA;  viewer: User&#xA;  countries: [Country]&#xA;}&#xA;&#xA;type User implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  username: String&#xA;  userId: Int&#xA;  lastLoginDateTime: DateTime&#xA;}&#xA;</code></pre>&#xA;<p><strong>SampleRoute.js</strong> -used as the first route when someone opens React app</p>&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default class extends Relay.Route {&#xA;    static queries = {&#xA;        countries: () =&gt; Relay.QL`&#xA;            query AppHomeRoute { &#xA;                viewer&#xA;            }&#xA;    `,&#xA;    };&#xA;    static routeName = 'AppHomeRoute';&#xA;}&#xA;</code></pre>&#xA;<p><strong>App.js</strong> I want to have countries list in Index component, Ideally in App js I don't want to event pass countries with props but I want them to be in Index component which will be renamed to CountryList in the future</p>&#xA;<pre><code>import React, { Component } from 'react';&#xA;import Relay from 'react-relay';&#xA;import Index from './page/index';&#xA;&#xA;import './App.css';&#xA;&#xA;class App extends Component {&#xA;  render() {&#xA;    console.log(this.props);&#xA;    return (&#xA;      &lt;Index country={this.props.countries} /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(App, {&#xA;  fragments: {&#xA;    countries: () =&gt; Relay.QL`&#xA;    countries {&#xA;        ${Index.getFragment('country')}&#xA;      }&#xA;    }&#xA;            // fragment F1 on Country {&#xA;            //   ${Index.getFragment('country')}&#xA;            // },&#xA;            &#xA;        `&#xA;  }&#xA;});&#xA;</code></pre>&#xA;<p>Now I get an error:</p>&#xA;<p><strong>SampleRoute.js:5 Uncaught Error: GraphQL validation error ``Cannot query field &quot;viewer&quot; on type &quot;Query&quot;</strong></p>&#xA;<p>which I completely don't understand because when I query the server with graphiql then it works okay.</p>&#xA;<p><strong>Query:</strong></p>&#xA;<pre><code>{&#xA;  viewer {&#xA;    id&#xA;    username&#xA;  }&#xA;  node(id:&quot;dXNlcjo2NjY=&quot;) {&#xA;    id&#xA;    username&#xA;  }&#xA;  countries {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>response:</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;viewer&quot;: {&#xA;      &quot;id&quot;: &quot;dXNlcjo2NjY=&quot;,&#xA;      &quot;username&quot;: &quot;Robert&quot;&#xA;    },&#xA;    &quot;node&quot;: {&#xA;      &quot;id&quot;: &quot;dXNlcjo2NjY=&quot;,&#xA;      &quot;username&quot;: &quot;Robert&quot;&#xA;    },&#xA;    &quot;countries&quot;: [&#xA;      {&#xA;        &quot;name&quot;: &quot;AFGHANISTAN&quot;&#xA;      },&#xA;      {&#xA;        &quot;name&quot;: &quot;ALBANIA&quot;&#xA;      }, (...)&#xA;    ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;",2119757,,-1,2020-06-20 09:12:55,2017-02-23 15:06:31,How to connect list of objects to node in Relay,<node.js><reactjs><graphql><relayjs><relay>,0,8,0,2017-02-23 14:18:44
42427798,1,,,0,563,<p>I am learning <code>graphql</code> and wanted to know if logging solutions exist for the <code>apollo-client</code>.</p>&#xA;&#xA;<p>I find <code>redux-logger</code> to be a tremendous tool to debug an React/Redux app and wanted to know if something of the sort exists for <code>appolo-client</code> ?</p>&#xA;&#xA;<p>I would like to see the state of my <code>store</code> at any given time.</p>&#xA;,2829540,,2829540,2017-02-23 23:39:23,2017-02-24 00:40:38,Apollo GraphQL and React equivalent to redux-logger,<logging><graphql><react-apollo><apollo-client>,1,0,0,2017-02-23 22:59:26
42460337,2,,42457480,10,,<p>Your <code>findConversationsQuery</code> is actually two queries. This one:</p>&#xA;&#xA;<pre><code>query allConversations($customerId: ID!) {&#xA;    allConversations(filter: {&#xA;      customerId: $customerId&#xA;    })&#xA;} &#xA;</code></pre>&#xA;&#xA;<p>And this one:</p>&#xA;&#xA;<pre><code>{&#xA;    id&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The entire query needs to be enclosed between a single pair of opening and closing brackets.</p>&#xA;&#xA;<p>I think what you meant to write is:</p>&#xA;&#xA;<pre><code>query allConversations($customerId: ID!) {&#xA;    allConversations(filter: { customerId: $customerId }){&#xA;        id&#xA;    }&#xA;} &#xA;</code></pre>&#xA;,6268377,,,,2017-02-25 19:01:46,"",,0,0,0,2017-02-25 19:01:46
42485077,2,,36498163,22,,"<p>Use <code>ne</code> :</p>&#xA;&#xA;<pre><code>{&#xA;  items(filter: {status: {ne: ""Unwanted""}}){&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1812870,,2901178,2019-03-10 07:35:38,2019-03-10 07:35:38,"",,0,2,0,2017-02-27 11:50:15
42495598,1,,,1,3160,"<p>In the (untested) example code below, if I want to access an instance of the Apollo GraphQL client inside <code>actions/math.js</code>, I have to pass it from the <code>Calculator</code> component to event handlers, and from the <code>WrappedCalculator</code> event handlers to the action creators.</p>&#xA;&#xA;<p>This results in a lot of code bloat.</p>&#xA;&#xA;<p>What would be a better way for <code>actions/math.js</code> action creators to access the GraphQL client instance?</p>&#xA;&#xA;<p><strong>Example code:</strong></p>&#xA;&#xA;<p><strong>constants/Queries.js</strong>:</p>&#xA;&#xA;<pre><code>const MUTATION_APPEND_TO_AUDIT_TRAIL = gql`&#xA;    mutation MutationAppendToAuditTrail($mathOperation: String!, $operand1: Float!, $operand2: Float!) {&#xA;        appendToAuditTrail(operation: $mathOperation, operand1: $operand1, operand2: $operand2) {&#xA;            id&#xA;            operation&#xA;            operand1&#xA;            operand2&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p><strong>actions/math.js</strong>:</p>&#xA;&#xA;<pre><code>import { INCREMENT_TOTAL_BY, MULTIPLY_TOTAL_BY } from '../constants/ActionTypes';&#xA;import { getTotal } from '../reducers';&#xA;&#xA;incrementResultBy = (operand, graphQlClient) =&gt; (dispatch, getState) {&#xA;    // Use selector to get the total prior to the operation.&#xA;    const total = getTotal(getState());&#xA;&#xA;    // Send action to add a number to the total in the redux store.&#xA;    dispatch({&#xA;        type: types.INCREMENT_TOTAL_BY,&#xA;        operand,&#xA;    });&#xA;&#xA;    // Persist the latest user activity to the server.&#xA;    graphQlClient.mutate({&#xA;        mutation: MUTATION_APPEND_TO_AUDIT_TRAIL,&#xA;        variables: {&#xA;            mathOperation: 'ADDITION',&#xA;            operand1: total,&#xA;            operand2: operand,&#xA;          },&#xA;        });&#xA;};&#xA;&#xA;multiplyResultBy = (operand, graphQlClient) =&gt; (dispatch, getState) {&#xA;    // Use selector to get the total prior to the operation.&#xA;    const total = getTotal(getState());&#xA;&#xA;    // Send action to multiply the total in the redux store by a number.&#xA;    dispatch({&#xA;        type: types.MULTIPLY_TOTAL_BY,&#xA;        operand,&#xA;    });&#xA;&#xA;    // Persist the latest user activity to the server.&#xA;    graphQlClient.mutate({&#xA;        mutation: MUTATION_APPEND_TO_AUDIT_TRAIL,&#xA;        variables: {&#xA;            mathOperation: 'MULTIPLICATION',&#xA;            operand1: total,&#xA;            operand2: operand,&#xA;          },&#xA;        });&#xA;};&#xA;&#xA;export { incrementResultBy, multiplyResultBy };&#xA;</code></pre>&#xA;&#xA;<p><strong>components/Calculator.jsx</strong></p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import ApolloClient from 'apollo-client';&#xA;&#xA;const Calculator = ({&#xA;  total,&#xA;  operand,&#xA;  onPlusButtonClick,&#xA;  onMultiplyButtonClick,&#xA;}) =&gt; (&#xA;  &lt;div&gt;&#xA;    &lt;h2&gt;Perform operation for {total} and {operand}&lt;/h2&gt;&#xA;    &lt;button id=""ADD"" onClick={onPlusButtonClick(() =&gt; this.props.operand, this.props.client)}&gt;ADD&lt;/button&gt;&lt;br /&gt;&#xA;    &lt;button id=""MULTIPLY"" onClick={() =&gt; onMultiplyButtonClick(this.props.operand, this.props.client)}&gt;MULTIPLY&lt;/button&gt;&lt;br /&gt;&#xA;  &lt;/div&gt;&#xA;);&#xA;&#xA;DisplayPanel.propTypes = {&#xA;  // Apollo GraphQL client instance.&#xA;  client: React.PropTypes.instanceOf(ApolloClient),&#xA;&#xA;  // Props from Redux.&#xA;  total: React.PropTypes.number,&#xA;  operand: React.PropTypes.number,&#xA;  onPlusButtonClick: React.PropTypes.func,&#xA;  onMultiplyButtonClick: React.PropTypes.func,&#xA;};&#xA;export default Calculator;&#xA;</code></pre>&#xA;&#xA;<p><strong>containers/WrappedCalculator.js</strong></p>&#xA;&#xA;<pre><code>import { connect } from 'react-redux';&#xA;&#xA;import Calculator from '../components/Calculator';&#xA;&#xA;import { incrementResultBy, multiplyResultBy } from '../actions';&#xA;import { getTotal, getOperand } from '../reducers';&#xA;&#xA;const mapStateToProps = state =&gt; ({&#xA;  total: getTotal(state),&#xA;  operand: getOperand(state),&#xA;});&#xA;&#xA;const mapDispatchToProps = dispatch =&gt; ({&#xA;  onPlusButtonClick: (operand, graphQlClient) =&gt; dispatch(incrementResultBy(operand, graphQlClient)),&#xA;  onMultiplyButtonClick: (operand, graphQlClient) =&gt; dispatch(multiplyResultBy(operand, graphQlClient)),&#xA;});&#xA;&#xA;// Generate Apollo-aware, redux-aware higher-order container.&#xA;const WrappedCalculator = compose(&#xA;  withApollo,&#xA;  connect(mapStateToProps, mapDispatchToProps),&#xA;)(Calculator);&#xA;&#xA;export default WrappedCalculator;&#xA;</code></pre>&#xA;",7607412,,7607412,2017-02-27 21:07:45,2019-03-20 13:56:45,Best way to access Apollo GraphQL client inside redux action creators?,<javascript><react-redux><graphql><apollo>,3,1,0,2017-02-27 20:55:22
42501251,2,,42180756,17,,"<p>I just want to leave here my findings for anyone who gets stuck with this in the future and wants to get pointed to a better direction.</p>&#xA;&#xA;<p>First, the <code>graphql-ruby</code> gem includes everything that is needed to implement a Relay compatible GraphQL API. In includes everything that was before in the <code>graphql-relay</code> gem.</p>&#xA;&#xA;<p>You need to provide 2 things in your Schema in order to make the Relay refetching feature to work well, an <code>id_from_object</code> method that converts an object in your domain, into a global id and also a <code>object_from_id</code> method that will decode the global id into an object in your application:</p>&#xA;&#xA;<pre><code>ApplicationSchema = GraphQL::Schema.define do&#xA;  /* Create IDs by joining the type name &amp; ID, then base64-encoding it */&#xA;  id_from_object -&gt;(object, type_definition, query_ctx) {&#xA;    GraphQL::Schema::UniqueWithinType.encode(type_definition.name, object.id)&#xA;  }&#xA;&#xA;  object_from_id -&gt;(id, query_ctx) {&#xA;    type_name, object_id = GraphQL::Schema::UniqueWithinType.decode(id)&#xA;    # Now, based on `type_name` and `id`&#xA;    # find an object in your application &#xA;    # This will give the user access to all records in your db&#xA;    # so you might want to restrict this properly&#xA;    Object.const_get(type_name).find(object_id)&#xA;  }&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>Also, all your types should implement the <code>NodeInterface</code> provided by the ruby gem, and expose a <code>global_id_field</code> instead of an ID type:</p>&#xA;&#xA;<pre><code>PostType = GraphQL::ObjectType.define do&#xA;  name ""Post""&#xA;  # Implements the ""Node"" interface for Relay&#xA;  interfaces [GraphQL::Relay::Node.interface]&#xA;  # exposes the  global id&#xA;  global_id_field :id&#xA;  field :name, types.String&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>This will allow Relay to refetch data like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  node(id: ""RmFjdGlvbjox"") {&#xA;    id&#xA;    ... on Post {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Relay also uses a <code>babel-relay-plugin</code> which requires a schema.json to be generated and available to the client, if you're building an isolated API with no view rendering, the way to go is to let the clients fetch the schema and not to do that work in the server, something like <a href=""https://github.com/apollographql/apollo-codegen"" rel=""noreferrer"">apollo-codegen</a> can work. However, if you are building a rails app and need the schema in the same app, then you can run an instrospection query and save the result to a json file using a rake task:</p>&#xA;&#xA;<pre><code>Schema.execute GraphQL::Introspection::INTROSPECTION_QUERY&#xA;</code></pre>&#xA;&#xA;<p>Lastly, you'll need to understand that Relay expresses one-to-many relationships with connections:</p>&#xA;&#xA;<pre><code>PostType = GraphQL::ObjectType.define do&#xA;  # default connection&#xA;  # obj.comments by default&#xA;  connection :comments, CommentType.connection_type&#xA;&#xA;  # custom connection&#xA;  connection :featured_comments, CommentType.connection_type do&#xA;    resolve -&gt;(post, args, ctx) {&#xA;      comments = post.comments.featured&#xA;&#xA;      if args[:since]&#xA;        comments = comments.where(""created_at &gt;= ?"", since)&#xA;      end&#xA;&#xA;      comments&#xA;    }&#xA;  end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>Connections support some arguments out of the box, you can use <code>first</code>, <code>last</code>, <code>before</code> and <code>after</code> in your connection queries:</p>&#xA;&#xA;<pre><code>query {&#xA;  posts(first: 5) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>All of this is documented in the <a href=""https://facebook.github.io/relay/docs/graphql-connections.html#content"" rel=""noreferrer"">Relay documentation</a> so make sure you read it as well as the <a href=""https://rmosolgo.github.io/graphql-ruby/"" rel=""noreferrer"">graphql-ruby</a> documentation.</p>&#xA;",2443687,,2443687,2017-05-15 03:03:57,2017-05-15 03:03:57,"",,0,0,0,2017-02-28 05:57:26
42526241,1,,,1,409,"<p>I keep on facing the same error :                                                            </p>&#xA;&#xA;<p>Uncaught Error: Relay transform error. Your schema defines a mutation field <code>addItem</code> that takes 7 arguments, but mutation fields must have exactly one argument named <code>input</code>.`` in file <code>../AddItemMutation.js</code>. Try updating your GraphQL schema if an argument/field/type was recently added.</p>&#xA;&#xA;<p>Where should I declare the input argument in my implementation?&#xA;I have a SimpleForm component which gets the input data and it should use Relay to send GraphQL queries.</p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default class AddItemMutation extends Relay.Mutation {&#xA;&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {addItem}`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;     newName: this.props.name&#xA;    };&#xA;  }&#xA;&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on Item&#xA;      {&#xA;        id,&#xA;        name,&#xA;        owner{&#xA;           name&#xA;        },&#xA;        authorizedBy,&#xA;        authorizedOn,&#xA;        dateFrom,&#xA;        dateTo&#xA;    }`;&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;   return [{&#xA;    type: 'REQUIRED_CHILDREN',&#xA;    children: [Relay.QL`&#xA;      fragment on Item&#xA;      {&#xA;       id,&#xA;       name,&#xA;       owner{&#xA;         name&#xA;       },&#xA;       authorizedBy,&#xA;       authorizedOn,&#xA;       dateFrom,&#xA;       dateTo&#xA;     }`]&#xA;   }];&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The schema is generated with graphql-java library and the field of mutation addItem of type Item takes : newName, newId, newDateFrom, newDateTo, newAuthorizedBy, newAuthorizedOn, newOwner;</p>&#xA;",7041216,,,,2017-03-01 08:02:47,Relay with mutation for a React form,<javascript><reactjs><graphql><relayjs><graphql-java>,0,1,0,2017-03-01 08:02:47
42532111,1,,,0,736,"<p>I've made one query for the main page and it works perfect but when I try to do another relay query to /clients page then relay does not see new type that I've added to the server. This is pretty weird because when I run update-schema the type is present on schema.graphql and when I try to query it with graphiql it works as well. </p>&#xA;&#xA;<p>The error I get:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Uncaught Error: GraphQL validation error <code>Cannot query field&#xA;  ""clientList"" on type ""Query"". Did you mean ""countryList""?</code> in file&#xA;  <code>/home/robert/Sites/relay-test/src/queries/ClientQuery.js</code>. Try&#xA;  updating your GraphQL schema if an argument/field/type was recently&#xA;  added</p>&#xA;</blockquote>&#xA;&#xA;<p><strong>ClientQuery.js</strong></p>&#xA;&#xA;<pre><code>import Relay from 'react-relay';&#xA;&#xA;export default {&#xA;    clientList: () =&gt; Relay.QL`query { clientList }`,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>and <strong>schema.graphql</strong></p>&#xA;&#xA;<pre><code># A list of clients&#xA;type ClientList implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  clientListId: Int&#xA;&#xA;  # List of clients&#xA;  clients(after: String, first: Int, before: String, last: Int): LcoClientConnection&#xA;}&#xA;&#xA;# A country&#xA;type Country implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  countryId: Int&#xA;  phonePrefix: String&#xA;  name: String&#xA;  timezone: String&#xA;}&#xA;&#xA;# A connection to a list of items.&#xA;type CountryConnection {&#xA;  # Information to aid in pagination.&#xA;  pageInfo: PageInfo!&#xA;&#xA;  # A list of edges.&#xA;  edges: [CountryEdge]&#xA;}&#xA;&#xA;# An edge in a connection.&#xA;type CountryEdge {&#xA;  # The item at the end of the edge&#xA;  node: Country&#xA;&#xA;  # A cursor for use in pagination&#xA;  cursor: String&#xA;}&#xA;&#xA;# A list of countries&#xA;type CountryList implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  countryListId: Int&#xA;&#xA;  # Countries list&#xA;  countries(after: String, first: Int, before: String, last: Int): CountryConnection&#xA;}&#xA;&#xA;# Representation of date and time in ""Y-m-d H:i:s"" format&#xA;scalar DateTime&#xA;&#xA;# A client&#xA;type LcoClient implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  name: String&#xA;  country: Country&#xA;  address: String&#xA;  description: String&#xA;}&#xA;&#xA;# A connection to a list of items.&#xA;type LcoClientConnection {&#xA;  # Information to aid in pagination.&#xA;  pageInfo: PageInfo!&#xA;&#xA;  # A list of edges.&#xA;  edges: [LcoClientEdge]&#xA;}&#xA;&#xA;# An edge in a connection.&#xA;type LcoClientEdge {&#xA;  # The item at the end of the edge&#xA;  node: LcoClient&#xA;&#xA;  # A cursor for use in pagination&#xA;  cursor: String&#xA;}&#xA;&#xA;interface NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;}&#xA;&#xA;# Information about pagination in a connection.&#xA;type PageInfo {&#xA;  # When paginating forwards, are there more items?&#xA;  hasNextPage: Boolean!&#xA;&#xA;  # When paginating backwards, are there more items?&#xA;  hasPreviousPage: Boolean!&#xA;&#xA;  # When paginating backwards, the cursor to continue.&#xA;  startCursor: String&#xA;&#xA;  # When paginating forwards, the cursor to continue.&#xA;  endCursor: String&#xA;}&#xA;&#xA;type Query {&#xA;  # Fetches an object given its ID&#xA;  node(&#xA;    # The ID of an object&#xA;    id: ID!&#xA;  ): NodeInterface&#xA;  viewer: User&#xA;  countryList: CountryList&#xA;  clientList: ClientList&#xA;}&#xA;&#xA;type User implements NodeInterface {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  username: String&#xA;  userId: Int&#xA;  lastLoginDateTime: DateTime&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>querying for ""viewer"" and ""countryList"" types works. </p>&#xA;&#xA;<p>I've looked on similar threads on SO but they don't solve the problem. </p>&#xA;&#xA;<p>What am I missing? </p>&#xA;",2119757,,,,2017-03-01 12:45:20,"React Relay Uncaught Error: GraphQL validation error ``Cannot query field ""clientList"" on type ""Query"".",<javascript><graphql><relayjs><relay><graphql-js>,0,2,0,2017-03-01 12:45:20
42549684,1,42567639,,5,6635,"<p>I'm building a React front end which allows users to select an ""active"" query from a list of static queries and flattens to the result to be displayed in a table. What is the best way to pass the GraphQL query from a higher-order component into a nested child component? </p>&#xA;&#xA;<p>Most of the documentation/solutions that I've seen focus on binding a static query with dynamical conditions from component states to a component, which would not work for my purpose as the different static queries have varying fields and query different node types. </p>&#xA;&#xA;<p>What is the best-practice/recommended approach here? I feel like this is not a very unique use case, but I can't seem to find any examples that would do something similar. </p>&#xA;&#xA;<p>I'm using Apollo-Client/Redux as my client-side store.</p>&#xA;&#xA;<p>Below is the rough outline of the component:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>class GridViewPage extends React.Component{&#xD;&#xA;  constructor(props, context) {&#xD;&#xA;    super(props, context);&#xD;&#xA;    this.state = {&#xD;&#xA;      activeQuery = ... Stores the selected query ...&#xD;&#xA;    };&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  render() {&#xD;&#xA;    return (&#xD;&#xA;      &lt;div className=""gridContainer""&gt;&#xD;&#xA;        ...Component here allows users to select a query from the active list and saves it/it's ID/Index to the state...&#xD;&#xA;&#xD;&#xA;        &lt;Panel collapsible&gt;&#xD;&#xA;        ...Some toolbar components...&#xD;&#xA;        &lt;/Panel&gt;&#xD;&#xA;        ...Component here displays the result of the query (Ideally by receiving the query or the result of as a prop?)...&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;GridViewPage.propTypes = {&#xD;&#xA;  grids: PropTypes.array.isRequired,&#xD;&#xA;  actions: PropTypes.object.isRequired&#xD;&#xA;};&#xD;&#xA;&#xD;&#xA;function mapStateToProps(state, ownProps) {&#xD;&#xA;  return {&#xD;&#xA;      // Receives list of available queries as a prop&#xD;&#xA;      grids: state.grids&#xD;&#xA;  };&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",4125867,,8333984,2020-02-25 14:19:27,2020-02-25 14:19:27,Dynamically set GraphQL queries for React components with Apollo Client,<reactjs><react-redux><graphql><react-apollo>,1,0,0,2017-03-02 07:56:57
42552256,1,,,0,1554,"<p>I have written below code :</p>&#xA;&#xA;<p>On Certain User Action below method is called :</p>&#xA;&#xA;<pre><code>handleFolderClicked = (topic, parent) =&gt; {&#xA;    console.log('Main : handleFolderClicked called : ', parent);&#xA;    this.props.relay.setVariables({&#xA;      parentFolder: parent,&#xA;      email: loginEmail&#xA;    });&#xA;  }&#xA;&#xA;Main = Relay.createContainer(Main, {&#xA;  initialVariables: {&#xA;    pageSize: pageSize,&#xA;    email: loginEmail,&#xA;    parentFolder: parentFolder,&#xA;  },&#xA;  fragments: {&#xA;    store: () =&gt; Relay.QL`&#xA;      fragment on Store {&#xA;        id,&#xA;        fileConnection(first:999, email:$email, parentFolder:$parentFolder) {&#xA;          ${DirectoryListing.getFragment('files')},&#xA;        }&#xA;        users {&#xA;          email,&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;});&#xA;export default Main;&#xA;</code></pre>&#xA;&#xA;<p>On the time of page load its working fine and fetching results but when value of parentFolder is changed using setVariables, it throws above error.</p>&#xA;&#xA;<p>An insight might be useful and appreciated. Thanks</p>&#xA;",2752896,,,,2017-03-07 21:27:56,"Fragment ""F1"" cannot be spread here as objects of type ""Node"" can never be of type ""Store""",<reactjs><graphql><relay>,1,0,0,2017-03-02 10:01:54
42623708,2,,42622912,100,,"<p><strong><em>Let's begin with a short introduction in simple words</em></strong></p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>GraphQl Relay specifications</strong></p>&#xA;&#xA;<ul>&#xA;<li>mechanism for refetching an object</li>&#xA;<li>description of how to page through connections</li>&#xA;<li>structure around mutations to make them predictable</li>&#xA;</ul>&#xA;&#xA;<p><strong>Connections:</strong></p>&#xA;&#xA;<ul>&#xA;<li>a connection is a collection of objects with metadata&#xA;such as <code>edges</code>, <code>pageInfo</code>...</li>&#xA;<li><p>pageInfo will contain <code>hasNextPage</code>, <code>hasPreviousPage</code>, <code>startCursor</code>, <code>endCursor</code></p>&#xA;&#xA;<ul>&#xA;<li><code>hasNextPage</code> will tell us if there are more edges available, or if we’ve reached the end of this connection.</li>&#xA;</ul></li>&#xA;<li><p>The array of records: edges</p>&#xA;&#xA;<ul>&#xA;<li>edges will provide you flexibility to use your data(node) </li>&#xA;<li>edges will help you for the pagination, There is graphql <code>GraphQLList</code> but with no functionality such as pagination, only with array of objects (data)</li>&#xA;</ul></li>&#xA;<li><p>Each edge has</p>&#xA;&#xA;<ul>&#xA;<li>a <code>node</code>: a record or a data</li>&#xA;<li>a <code>cursor</code>: base64 encoded string to help relay with pagination</li>&#xA;</ul></li>&#xA;</ul>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""noreferrer"">https://facebook.github.io/relay/graphql/connections.htm</a></p>&#xA;&#xA;<p><strong>Node:</strong></p>&#xA;&#xA;<ul>&#xA;<li>you can set the number of nodes you need to show using the relay <code>connectionArgs(first, last, after, before)</code></li>&#xA;</ul>&#xA;&#xA;<p><strong>Relay Pagination works as</strong></p>&#xA;&#xA;<ul>&#xA;<li><p>Fetches all objects in the collection and return a slice based on the <code>first/last</code> x records, used thru connectionArgs</p></li>&#xA;<li><p><code>after/before</code> are used to indicate to the GraphQL server the number of required slice (data) using cursor from the node</p></li>&#xA;</ul>&#xA;&#xA;<p>There are many more things to consider like <code>nodeDefinitions</code>, <code>globalFieldId</code>, <code>nodeInterfaces</code></p>&#xA;&#xA;<p><a href=""https://github.com/graphql/graphql-relay-js#object-identification"" rel=""noreferrer"">https://github.com/graphql/graphql-relay-js#object-identification</a></p>&#xA;",5127888,,5127888,2020-05-06 16:07:30,2020-05-06 16:07:30,"",,0,6,0,2017-03-06 10:53:08
42632389,2,,42631523,10,,"<p>You can use a fragment for the query, which includes all mutable fields of the data. That fragment can be used by a <a href=""https://www.npmjs.com/package/graphql-filter-fragment"" rel=""nofollow noreferrer"">filter utility</a> to remove all unwanted data before the mutation happens.</p>&#xA;<p>The gist is:</p>&#xA;<pre><code>const ArticleMutableFragment = gql`&#xA;fragment ArticleMutable on Article {&#xA;  headline&#xA;  subline&#xA;  publishing {&#xA;    published&#xA;    time&#xA;  }&#xA;}&#xA;`&#xA;&#xA;const ArticleFragment = gql`&#xA;fragment Article on Article {&#xA;  ...ArticleMutable&#xA;  id&#xA;  created&#xA;  updated&#xA;}&#xA;${ArticleMutableFragment}&#xA;`;&#xA;&#xA;const query = gql`&#xA;query Article($id: ID!) {&#xA;  article(id: $id) {&#xA;    ...Article&#xA;  }&#xA;}&#xA;${ArticleFragment}&#xA;`;&#xA;&#xA;const articleUpdateMutation = gql`&#xA;mutation updateArticle($id: ID!, $article: ArticleInput!) {&#xA;  updateArticle(id: $id, article: $article) {&#xA;    ...Article&#xA;  }&#xA;}&#xA;${ArticleFragment}&#xA;`;&#xA;&#xA;...&#xA;&#xA;import filterGraphQlFragment from 'graphql-filter-fragment';&#xA;&#xA;...&#xA;&#xA;graphql(articleUpdateMutation, {&#xA;  props: ({mutate}) =&gt; ({&#xA;    onArticleUpdate: (id, article) =&gt;&#xA;      // Filter for properties the input type knows about&#xA;      mutate({variables: {id, article: filterGraphQlFragment(ArticleMutableFragment, article)}})&#xA;  })&#xA;})&#xA;&#xA;...&#xA;</code></pre>&#xA;<p>The <code>ArticleMutable</code> fragment can now also be reused for creating new articles.</p>&#xA;",343045,,343045,2022-01-04 15:50:35,2022-01-04 15:50:35,"",,0,5,0,2017-03-06 17:54:51
42633446,1,,,0,129,"<p>I have the following components:</p>&#xA;&#xA;<p><strong>Position</strong></p>&#xA;&#xA;<pre><code>const Position = React.createClass({&#xA;  render() {&#xA;    return (&#xA;      &lt;LinkSummary linkSummary={this.props.position.linkSummary} /&gt;&#xA;    );&#xA;  }&#xA;});&#xA;&#xA;const PositionContainer = Relay.createContainer(Position, {&#xA;  fragments: {&#xA;    position: Relay.QL`&#xA;      fragment on Position {&#xA;        text&#xA;        linkSummary {&#xA;          ${LinkSummary.getFragment('linkSummary')}&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>LinkSummary</strong></p>&#xA;&#xA;<pre><code>const LinkSummary = React.createClass({ ... });&#xA;&#xA;const LinkSummaryContainer = Relay.createContainer(LinkSummary, {&#xA;  fragments: {&#xA;    linkSummary: Relay.QL`&#xA;      fragment on LinkSummary {&#xA;        url&#xA;      }&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The above throws an error in <code>Position</code>, where it claims that I can't:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Uncaught Error: GraphQL validation error ``Cannot query field ""linkSummary"" on type ""Position"".``</p>&#xA;</blockquote>&#xA;&#xA;<p>If I change the fragment on <code>Position</code> to include any field from <code>LinkSummary</code>, it works. I.E.</p>&#xA;&#xA;<pre><code>fragment on Position {&#xA;  text&#xA;  linkSummary {&#xA;    description&#xA;    ${LinkSummary.getFragment('linkSummary')}&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it not possible to just want to include the child fragment, but not use any part of that field for the current container? How else should I specify the child fragment? Worst case scenario, I could change the <code>LinkSummary</code> container to accept the entire Position and then just include its fragment in <code>PositionContainer</code> at the same level as every other field, but that seems wrong since <code>LinkSummary</code> is its own type in my schema.</p>&#xA;",2518231,,2518231,2017-03-06 19:17:43,2017-03-06 19:17:43,Including Relay child fragments with no fields for current component,<graphql><relayjs><relay>,0,6,0,2017-03-06 18:57:51
42638030,1,,,6,2166,"<p>Based on this talk: <a href=""https://www.youtube.com/watch?v=srfaKA2wJ0s"" rel=""noreferrer"">https://www.youtube.com/watch?v=srfaKA2wJ0s</a></p>&#xA;&#xA;<p>I would like to implement an analytics/time series query in GraphQL like</p>&#xA;&#xA;<pre><code>query {&#xA;   sales(date: { start: ‘2017-01-01’, end: ‘2018-01-01’ }) {&#xA;       revenue(stat: mean)&#xA;       daily: interval(by: day) {&#xA;          date&#xA;          revenue&#xA;       }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>revenue(stat: mean) is an aggregation based on one statistic (mean in this case)&#xA;daily is a list of data points by hour/day/month</p>&#xA;&#xA;<p>How to implement this using mongodb, or postgresql/mysql databases in a performant way?</p>&#xA;",2628278,,15687,2017-03-07 00:41:52,2017-03-07 00:50:23,GraphQL for Time Series,<time-series><analytics><graphql>,1,0,0,2017-03-07 00:23:03
42641424,1,42642081,,0,136,<p>I need the edge type to add additional fields between two nodes. But I don't need connections for pagination. </p>&#xA;&#xA;<p>Can I use edge without connections in GraphQL? What is the best practice of doing so? </p>&#xA;,4056509,,4056509,2017-03-07 06:21:04,2017-03-07 06:57:00,Can I use edge type without connection types in GraphQL?,<facebook-graph-api><graphql><graphql-js>,1,0,0,2017-03-07 06:13:58
42652411,1,,,13,267,"<p>I have a route like this</p>&#xA;&#xA;<pre><code>&lt;Route path=""/search"" component={Search}&gt;&#xA;</code></pre>&#xA;&#xA;<p>The basic <code>Search</code> component looks likes this</p>&#xA;&#xA;<pre><code>class Search extends React.Component {&#xA;  constructor (props) {&#xA;    super(props)&#xA;    this.state = {query: ''}&#xA;  }&#xA;  handleSubmit (event) {&#xA;    event.preventDefault()&#xA;    this.setState({query: this.refs.queryInput.value})&#xA;  }&#xA;  renderSearchResult() {&#xA;    if (this.state.query === '')&#xA;      return &lt;EmptySearchResult /&gt;&#xA;    else&#xA;      return &lt;SearchResult query={this.state.query}/&gt;&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div className=""searchContainer""&gt;&#xA;        &lt;div className=""row""&gt;&#xA;          &lt;div className=""search""&gt;&#xA;            &lt;form onSubmit={event =&gt; this.handleSubmit(event)}&gt;&#xA;              &lt;input className=""searchInput"" placeholder=""robocop"" ref=""queryInput"" /&gt;&#xA;            &lt;/form&gt;&#xA;          &lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;        &lt;div className=""row""&gt;&#xA;          {this.renderSearchResult()}&#xA;        &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>SearchResult</code> relay container looks like this</p>&#xA;&#xA;<pre><code>class SearchResult extends React.Component {&#xA;  render() {&#xA;    var {viewer: {moviesByTitle: movies}} = this.props;&#xA;    return (&#xA;      &lt;div className=""searchResult""&gt;&#xA;        {movies.edges.map((edge,i) =&gt;&#xA;          &lt;div key={i} className=""rowItem scrollRowItem""&gt;&#xA;            &lt;Movie movie={edge.node} /&gt;&#xA;          &lt;/div&gt;)}&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(SearchResult, {&#xA;  initialVariables: {&#xA;    query: '???'&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        moviesByTitle(title: $query, first: 10) {&#xA;          edges {&#xA;            node {&#xA;              ${Movie.getFragment('movie')}&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Error:</strong></p>&#xA;&#xA;<pre><code>Warning: RelayContainer: Expected prop `viewer` to be supplied to `SearchResult`, but got `undefined`. Pass an explicit `null` if this is intentional.&#xA;</code></pre>&#xA;&#xA;<p>What I was trying to do inside my Search component (changes in bold)</p>&#xA;&#xA;<pre><code><b>const ViewerQueries = {&#xA;  viewer: () => Relay.QL`query { viewer }`&#xA;}</b>&#xA;&#xA;...&#xA;&#xA;renderSearchResult() {&#xA;  if (this.state.query === '')&#xA;    return &lt;EmptySearchResult /&gt;&#xA;  else&#xA;    return &lt;SearchResult query={this.state.query} <b>queries={ViewerQueries}</b> /&gt;&#xA;}</code></pre>&#xA;&#xA;<p>But of course that doesn't work because the queries need to somehow be attached to the <code>Route</code></p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Questions</strong></p>&#xA;&#xA;<ol>&#xA;<li><p>My <code>Search</code> Component is just a presentational component that does not need data of its own. Instead, it just feeds a <code>query</code> prop to the <code>SearchResult</code> relay container. How should I structure the Components and Relay containers to attach them to the Route properly?</p></li>&#xA;<li><p>How can I use the <code>SearchResult</code> <code>query</code> prop to set a variable in the relay query fragment?</p></li>&#xA;<li><p>I don't understand the ""viewer"" abstraction in general – most examples I've seen are very contrived and don't show how they'd work in a more realistic setting; eg users with different access to different resources, or different parts of your program that are intended to view different slices of data</p></li>&#xA;</ol>&#xA;",633183,,633183,2017-10-05 04:56:10,2017-10-11 09:44:38,How to wire data to a deep component in react-router-relay?,<functional-programming><react-router><graphql><relay><react-router-relay>,1,2,0,2017-03-07 15:41:32
42655080,1,,,1,1204,"<p>imagine I have this as my schema, where people query with a bird Id and if they ask for the location they get everything about the location. Do I still have to define Location in ""schema"" format? or is there any way to use the case class immediately here?</p>&#xA;&#xA;<p>If you want a bit of background about why I want to this:&#xA;I got a JSon-schema that is massively nested and it will be very close to impossible to manage every level of it. I am happy with the user requesting a top layer element which will return what ever case class is defined at that stage.</p>&#xA;&#xA;<pre><code>import sangria.schema._&#xA;&#xA;case class Location( lat: String, long: String )&#xA;case class Bird( name: String, location: List[Location] )&#xA;&#xA;class BirdRepo {&#xA;  def get(id: Int ) = {&#xA;    if( id &lt; 10 ) {&#xA;      Bird( ""Small"",&#xA;        List( Location(""1"", ""2""), Location(""3"", ""4"")&#xA;      ))&#xA;    } else {&#xA;      Bird( ""Big"",&#xA;        List( Location(""5"", ""6""), Location(""7"", ""8"")&#xA;        ))&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;object SchemaDefinition {&#xA;  val Bird = ObjectType(&#xA;    ""Bird"",&#xA;    ""Some Bird"",&#xA;    fields[BirdRepo, Bird] (&#xA;      Field( ""name"", StringType, resolve = _.value.name ),&#xA;      Field( ""location"", List[Location], resolve = _.value.location)&#xA;//                       ^^ I know this is not possible&#xA;    )&#xA;  )&#xA;}&#xA;</code></pre>&#xA;",430522,,,,2017-03-10 22:26:59,Do I have to rewrite every case class in Sangria schema to expose in graphQL?,<scala><graphql><sangria>,2,0,0,2017-03-07 17:57:29
42658680,2,,42552256,0,,"<p>I had this error and I solved with something like this:</p>&#xA;&#xA;<p><code>Store</code> has to implement Relay's <code>Node</code> interface, meaning that it has to provide an <code>id: ID!</code> field, and if you do a node query using the returned ID, your <code>Store</code> has to be returned.</p>&#xA;&#xA;<p>In my case I named my root object <code>viewer</code> of type <code>Viewer</code>; so after implementing the <code>Node</code> interface, this query has to work:</p>&#xA;&#xA;<pre><code>{&#xA;  viewer {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which returns:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""id"": ""Vmlld2VyOk5vbmU=""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now if I use that ID to run a node Query, the viewer has to be returned. So for the query:</p>&#xA;&#xA;<pre><code>{&#xA;  node(id: ""Vmlld2VyOk5vbmU="") {&#xA;    id,&#xA;    __typename&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This should be the result:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""node"": {&#xA;      ""id"": ""Vmlld2VyOk5vbmU="",&#xA;      ""__typename"": ""Viewer""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Replace all occurrences of <code>viewer</code>/<code>Viewer</code> with <code>store</code>/<code>Store</code> and it should work.</p>&#xA;",288457,,,,2017-03-07 21:27:56,"",,0,0,0,2017-03-07 21:27:56
42671220,2,,42670733,8,,"<p>If you want to add a whole object to the mutation you have to define a graphql element of the type input. Here is a link to a small <a href=""https://github.com/sogko/graphql-schema-language-cheat-sheet"" rel=""nofollow noreferrer"">cheatsheet</a>.</p>&#xA;<p>In your case it could look like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>    type Location {&#xA;        city: String&#xA;        country: String&#xA;        zip: String&#xA;    }&#xA;&#xA;    type Place {&#xA;        id: String&#xA;        name: String&#xA;        location: Location&#xA;    }&#xA;&#xA;    type Event {&#xA;        id: String&#xA;        name: String&#xA;        description: String&#xA;        place: Place&#xA;    }&#xA;&#xA;    input LocationInput {&#xA;       city: String&#xA;       country: String&#xA;       zip: String&#xA;    }&#xA;&#xA;    input PlaceInput {&#xA;        id: ID!&#xA;        name: String!&#xA;        location: LocationInput!&#xA;    }&#xA;&#xA;    type Query {&#xA;        events: [Event]&#xA;    }&#xA;&#xA;    type Mutation {&#xA;        updateEvent(id: String, name: String, description: String, place: PlaceInput!): Event&#xA;    }&#xA;&#xA;    schema {&#xA;        query: Query&#xA;        mutation: Mutation&#xA;    }&#xA;</code></pre>&#xA;",4500001,,308731,2021-09-05 08:21:57,2021-09-05 08:21:57,"",,0,3,0,2017-03-08 12:19:02
42782604,1,42829613,,2,2145,"<p>Relay cursor connection specification <a href=""https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.Fields"" rel=""nofollow noreferrer"">says</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p><code>hasNextPage</code> will be false if the client is not paginating with <code>first</code>,&#xA;  or if the client is paginating with <code>first</code>, and the server has&#xA;  determined that the client has reached the end of the set of edges&#xA;  defined by their cursors.</p>&#xA;</blockquote>&#xA;&#xA;<p>What I understand from that spec is that Relay can only paginate in one&#xA;direction; forwards or backwards. That seems reasonable for an <em>infinite&#xA;scroll</em> pagination implementation.</p>&#xA;&#xA;<p>But how would one implement a <em>sequential pages</em> navigation similar to the stackoverflow questions page which&#xA;can navigate both ways? </p>&#xA;&#xA;<p>Is Relay.js suitable for this kind pagination? I can't rely on <code>hasNextPage</code> and <code>hasPreviousPage</code> field which never has true value unless I paginate with <code>first</code> and <code>last</code> which is also very discouraged.</p>&#xA;",4019871,,2030321,2017-03-16 15:09:36,2020-09-06 20:46:22,Forward and backward pagination with relay js,<javascript><reactjs><graphql><relayjs>,2,0,0,2017-03-14 09:50:23
42789001,1,43059542,,0,123,<p>I'm trying to understand what config should be used for <code>RANGE_ADD</code> mutation if <code>parent</code> of the new item is something like <code>SearchType</code> which doesn't have an ID attribute.&#xA;What should be used as <code>parentId</code> in this case or how this mutation should be configured? If I don't specify <code>parentID</code> then newly created item won't be added to the Relay store.</p>&#xA;&#xA;<p>I've read lots of issue in Relay repo but it's still unclear to me how to handle this mutation properly.</p>&#xA;,3066813,,,,2017-03-28 02:17:49,Relay RANGE_ADD queryConfig on SearchType,<javascript><graphql><relayjs>,1,0,0,2017-03-14 14:41:15
42829613,2,,42782604,4,,"<blockquote>&#xA;<p>What I understand from that spec is that relay can only paginate with single direction, forwards or backwards.</p>&#xA;</blockquote>&#xA;<p>Correct. The original design was exactly that, an infinite scroll pagination. It was never intended to be used for bi-directional pagination.</p>&#xA;<blockquote>&#xA;<p>But how about sequential pages like stackoverflow questions page?</p>&#xA;</blockquote>&#xA;<p>This is quite tricky do to with the default implementation of Relay as it stands today because, as stated above, it was't designed for bi-directional navigation.</p>&#xA;<p>That said, you <em>can</em> still achieve this, though not through optimal means.</p>&#xA;<hr />&#xA;<h3>Method 1 - Passing page info through Relay</h3>&#xA;<p>This is probably the easiest method to implement, though the less optimal one. It involves passing the page info to Relay as a GraphQL argument. This requires a new Relay query each time you navigate to a new page.</p>&#xA;<p><strong>Example</strong></p>&#xA;<p>Assume you have a view displaying a list of members. You fetch a list of <code>member</code> nodes with <code>memberList</code>. If you only want to display 10 members per &quot;page&quot; and we're on page 3, you could do:</p>&#xA;<pre><code>app: () =&gt; Relay.QL`&#xA;  fragment on App {&#xA;    memberList(page: 3, limit: 10) {&#xA;      ...&#xA;    }&#xA;  }`&#xA;}&#xA;</code></pre>&#xA;<p>In your backend your SQL query would now look something like:</p>&#xA;<pre><code>SELECT id, username, email FROM members LIMIT 20, 10;&#xA;</code></pre>&#xA;<p>Where <code>20</code> is the starting record: <code>(page-1)*10</code> and <code>10</code> is the limit (how many items after the start). So the above will fetch the records 21-30.</p>&#xA;<p>Note that you would need initial values for <code>page</code> and <code>limit</code>. So your final query would be:</p>&#xA;<pre><code>prepareVariables() {&#xA;  return {&#xA;    page: 1,&#xA;    limit: 10,&#xA;  };&#xA;},&#xA;fragments: {&#xA;  app: () =&gt; Relay.QL`&#xA;    fragment on App {&#xA;      memberList(page: $page, limit: $limit) {&#xA;        ...&#xA;      }&#xA;    }`&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And when navigating to a new page we need to update the values:</p>&#xA;<pre><code>_goToPage = (pg) =&gt; {&#xA;  this.props.relay.setVariables({&#xA;    page: pg,&#xA;  });&#xA;}&#xA;</code></pre>&#xA;<hr />&#xA;<h3>Method 2 - Manually managing cursors</h3>&#xA;<p>This is a slightly hacky implementation in that it essentially gives you a bi-directional navigation, even though is not natively supported. This approach is slightly more optimal to the first one, but sacrifices the ability to jump to a page directly.</p>&#xA;<p>Note that we cannot use both <code>first</code> and <code>last</code>:</p>&#xA;<blockquote>&#xA;<p>Including a value for both first and last is strongly discouraged, as it is likely to lead to confusing queries and results.</p>&#xA;</blockquote>&#xA;<p>Hence we would construct our query normally. Something like:</p>&#xA;<pre><code>app: () =&gt; Relay.QL`&#xA;  fragment on App {&#xA;    memberList(first: 10, after: $cursor) {&#xA;      ...&#xA;    }&#xA;  }`&#xA;}&#xA;</code></pre>&#xA;<p>where the initial value for <code>$cursor</code> is <code>null</code>.</p>&#xA;<p>As you navigate to the next page and set the value for <code>$cursor</code> to be the cursor of the last member node, you also save the value in a local stack variable.</p>&#xA;<p>This way, whenever you navigate back you would simply pop the last cursor from the stack and use that for your <code>after</code> argument. It requires some extra logic in your application, but this is definitely doable.</p>&#xA;",2030321,,-1,2020-06-20 09:12:55,2017-03-16 15:24:52,"",,0,1,0,2017-03-16 09:10:47
42881377,1,42943440,,3,266,"<p>Suppose I have a react application with these features on a single page:&#xA;New books,&#xA;Books by author xyz,&#xA;Create new book</p>&#xA;&#xA;<p>Now suppose I create a new book by author xyz. The page is updated in two places, there is one more new book, and there is one more book by author xyz.</p>&#xA;&#xA;<p>How do apollo-react and relay differ in their approach to solving this issue? How do they solve this issue? Most of the examples I have seen only show rudimentary mutations</p>&#xA;",3155734,,110274,2019-07-27 17:07:09,2019-07-27 17:07:09,How does relay or Apollo-react solve mutations that involve multiple relationships,<reactjs><graphql><graphql-js><apollo>,1,0,0,2017-03-19 00:06:33
42938472,1,42943108,,13,7298,"<p>I am trying to understand more complex graphql apis that implement the <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""noreferrer"">Relay Cursor Connections Specification</a></p>&#xA;&#xA;<p>If you look at the query below that I run on the <a href=""https://developer.github.com/early-access/graphql/explorer/"" rel=""noreferrer"">github graphql api explorer</a></p>&#xA;&#xA;<pre><code>{&#xA;  repository(owner: ""getsmarter"", name: ""moodle-api"") {&#xA;    id&#xA;    issues(first:2 ) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          body&#xA;        }&#xA;      }&#xA;      nodes {&#xA;        body&#xA;      }&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;        startCursor&#xA;      }&#xA;      totalCount&#xA;    } &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Notice it has the fields <strong>edges</strong> and <strong>nodes</strong>.</p>&#xA;&#xA;<p>Why does github have an additional field called nodes in their api? Why don’t they just use the edges field since you can get the same data from edges? Is this just for convenience? </p>&#xA;",799618,,,,2017-03-22 23:58:23,What is the reason for having edges and nodes in a connection in your graphql schema?,<facebook><graphql><relay>,3,2,0,2017-03-21 21:31:17
42940307,2,,42938472,14,,"<p>A node is always the same, regardless of how you get to it. The edge is metadata about that node in the context of the connection, usually just the cursor, but you could also add things like a relevancy score if your connection represented a search query. This data shouldn't exist on the node itself, because it makes no sense in a different context.</p>&#xA;&#xA;<p><strong>Terminology</strong>:</p>&#xA;&#xA;<ol>&#xA;<li><strong>Node</strong>, represents an entity. In a diagram of circles connected by lines, these would be the circles.</li>&#xA;<li><strong>Edge</strong>, connects two nodes together, may include metadata. In the diagram, these would be the lines.</li>&#xA;<li><strong>Connection</strong>, a paginated list of nodes. In the diagram, this would be a collection of lines.</li>&#xA;</ol>&#xA;",15687,,,,2017-03-21 23:50:45,"",,0,0,0,2017-03-21 23:50:45
42943108,2,,42938472,16,,"<p>If we look at the general structure of the common connection implementation you typically have the following:&#xA;TypeA -> TypeAToTypeBConnection (usually a field on TypeA with a name like <code>typeBConnection</code>) -> TypeAToTypeBEdge (usually field of name on connection with name <code>edges</code>) -> TypeB (usually field name on an edge with name <code>node</code>)</p>&#xA;&#xA;<pre><code>A -&gt; connection -&gt; edges -&gt; B&#xA;</code></pre>&#xA;&#xA;<p><strong>Connection types</strong> will normally have fields containing information which is specific to the entire connection which is typically paging information, total counts, etc.</p>&#xA;&#xA;<p><strong>Edge types</strong> normally have fields which have information which is specific to that connection but not common to all nodes.  The most common field in this case is <code>cursor</code> which represents the nodes ‘location’ in the connection which is not a globally unique ID but a way to return to that location in the connection.</p>&#xA;&#xA;<p><strong>Node type</strong> is normally just the type which the connection goes too which contains no connection specific information</p>&#xA;&#xA;<p>In the case of github’s API the Edge type has the commonly implemented <code>cursor</code> field which can be used as a reference within that connection later.  They also have a field which bypasses the <code>edge</code> type in the case you don't need the cursors.  This is why you see both <code>edges</code> and <code>nodes</code> fields directly off the connection type.</p>&#xA;&#xA;<p>To see these cursor fields you can send the following query to see what I am talking about:</p>&#xA;&#xA;<pre><code>{&#xA;  repository(owner: ""getsmarter"", name: ""moodle-api"") {&#xA;    issues(first:2 ) {&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For more detail on this style of connection take a look here: <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""noreferrer"">https://facebook.github.io/relay/graphql/connections.htm</a></p>&#xA;&#xA;<p><strong>EDIT - Additional response:</strong>&#xA;The purpose of allowing access to both an edge type and a node type right at the connection could be for, at least, 2 reasons which I can think of.  Firstly, for the convenience of those using the API when their use case does not require cursors.  Second, there might be a case in which, depending on the query sent, they may not need to ever even generate cursors.  The second would likely be minimal savings in CPU time and would probably be more trouble than it is worth.</p>&#xA;&#xA;<p>Having implemented cursors in a GraphQL endpoint myself in the past, once you get over the how, the actual generation of them is not really all that difficult.  It is simply a matter of serializing a few key pieces of information.  It also might be worth noting, it is pretty trivial to provide both (<code>A-&gt;conn-&gt;edge-&gt;B</code> and <code>A-&gt;conn-&gt;B</code>) once you have already created the Edge type.</p>&#xA;&#xA;<p>As I do not work for Github, I can’t tell you what exact intention was.  However, I would most definitely think it is the first reason… simply developer convenience.</p>&#xA;",1090576,,1090576,2017-03-22 23:58:23,2017-03-22 23:58:23,"",,0,3,0,2017-03-22 05:01:16
43037928,2,,42694039,1,,"<p>I would do something similar to <strong>Option 2</strong>, but put the life cycle methods into the actual Component. This way the business logic in the life cycle will be separated from the props inherited from Container. </p>&#xA;&#xA;<p>So something like this:</p>&#xA;&#xA;<pre><code>class yourComponent extends Component{&#xA;    componentWillReceiveProps(nextProps) {&#xA;      const {&#xA;        loading,&#xA;        items,&#xA;        selectedItem,&#xA;        selectItem,&#xA;      } = nextProps;&#xA;      if (!selectedItem &amp;&amp; !loading &amp;&amp; items &amp;&amp; items.length) {&#xA;        selectItem(items[items.length - 1].id);&#xA;      }&#xA;    }&#xA;  render(){...}&#xA;}&#xA;&#xA;// Connect redux and graphQL to the Component&#xA;const yourComponentWithGraphQL = graphql(...)(yourComponent);&#xA;export default connect(mapStateToProps, mapDispatchToProps)(yourComponentWithGraphQL)&#xA;</code></pre>&#xA;",4056509,,,,2017-03-27 04:24:56,"",,0,2,0,2017-03-27 04:24:56
43045639,1,43065727,,3,2595,"<p>I have a graphql query which gets a <code>Meeting</code> object with <code>Client</code> object:</p>&#xA;&#xA;<pre><code>type Meeting {&#xA;  address: String!&#xA;  client: Client&#xA;}&#xA;type Client {&#xA;  displayName: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The <code>displayName</code> is required, but <code>client</code> isn't.&#xA;If I'm querying it as</p>&#xA;&#xA;<pre><code>{&#xA;  getMeeting(meetingId: ""43bbea6ea0c6112b0abcf11d"") {&#xA;    address&#xA;    client {&#xA;      displayName&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And this meeting doesn't have a client, then I'm getting an error:</p>&#xA;&#xA;<pre><code>Error: Cannot return null for non-nullable field Client.displayName.&#xA;</code></pre>&#xA;&#xA;<p>I just want that if there is a client, I will get its full details. And if there isn't, I will get <code>client: null</code>.</p>&#xA;&#xA;<p>If I will remove the required from the <code>displayName</code>, it will work also when client is null and I will get </p>&#xA;&#xA;<p><code>""client"": {&#xA;   ""displayName"": null&#xA; }</code></p>&#xA;&#xA;<p>as I've expected. But I'm still looking for a way to enforce the required on the <code>displayName</code> - only if there is a client.</p>&#xA;&#xA;<p>Is there any way to do that in graphql?</p>&#xA;",3883957,,3883957,2017-03-28 09:29:36,2017-03-28 09:29:36,"Graphql - get full sub-object, or null if doesn't exist",<mongoose><graphql>,1,2,0,2017-03-27 11:51:17
43059542,2,,42789001,0,,"<p>In your case creating <code>SearchType</code> object with an static id would work. This is an example using graphql-ruby but the concept should work in any implementations:</p>&#xA;&#xA;<p><a href=""https://github.com/gauravtiwari/relay-rails-blog/blob/8b257c3d32b7ef9d1aab4420257d8b6471006d0a/app/models/viewer.rb"" rel=""nofollow noreferrer"">https://github.com/gauravtiwari/relay-rails-blog/blob/8b257c3d32b7ef9d1aab4420257d8b6471006d0a/app/models/viewer.rb</a></p>&#xA;&#xA;<p>And client side implementation would look like:</p>&#xA;&#xA;<pre><code>class SearchPostMutation extends Relay.Mutation {&#xA;  getMutation() {&#xA;    return Relay.QL`mutation {searchPosts}`;&#xA;  }&#xA;&#xA;  getVariables() {&#xA;    return {&#xA;      // For debug, you can hard code your SearchType object's id here. &#xA;      id: 'SA9bdDbpc4QtwzppZD0+IbJsE4QgzQ==',&#xA;    };&#xA;  }&#xA;&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'searchPost',&#xA;      // For debug, you can hard code your SearchType object's id here. &#xA;      parentID: 'SA9bdDbpc4QtwzppZD0+IbJsE4QgzQ==',&#xA;      connectionName: 'posts',&#xA;      edgeName: 'newPostEdge',&#xA;      rangeBehaviors: {&#xA;        '': 'prepend',&#xA;      },&#xA;    }];&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2930161,,,,2017-03-28 02:17:49,"",,0,0,0,2017-03-28 02:17:49
43089129,1,43095273,,1,441,"<p>I'm trying to setup my app with Relay and <code>react-navigation</code>, following the hints that were discussed in <a href=""https://github.com/react-community/react-navigation/issues/588#issuecomment-287499493"" rel=""nofollow noreferrer"">this GitHub issue</a>. Also note that I used <code>create-react-native-app</code> to create the project.</p>&#xA;&#xA;<p>This is what my setup looks like:</p>&#xA;&#xA;<p><strong>App.js</strong></p>&#xA;&#xA;<pre><code>Relay.injectNetworkLayer(&#xA;  new Relay.DefaultNetworkLayer('https://api.graph.cool/relay/v1/ciyeih9590fhl0162e5zh1z4h', {&#xA;    headers: {&#xA;    },&#xA;  })&#xA;)&#xA;&#xA;const RootNavigationStack = StackNavigator({&#xA;  PokemonList: {&#xA;    screen: PokemonList&#xA;  }&#xA;})&#xA;&#xA;export default class App extends React.Component {&#xA;  render() {&#xA;    return &lt;RootNavigationStack /&gt;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>PokemonList.js</strong></p>&#xA;&#xA;<pre><code>class IndexRoute extends Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`query { viewer }`&#xA;  }&#xA;  static routeName = 'IndexRoute'&#xA;}&#xA;&#xA;export default class PokemonList extends React.Component {&#xA;&#xA;  render() {    &#xA;    return (&#xA;      &lt;Relay.RootContainer&#xA;        Component={PokemonListRelayContainer}&#xA;        route={new IndexRoute()}&#xA;        renderFetched={(data) =&gt; {&#xA;          console.log('PokemonList - renderFetched', data)&#xA;          return &lt;Text&gt;Test&lt;/Text&gt;&#xA;        }}&#xA;      /&gt;&#xA;    )&#xA;  }&#xA;&#xA;}&#xA;&#xA;const PokemonListRelayContainer = Relay.createContainer(PokemonList, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        id&#xA;        allPokemons(first: 10) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>The logging statement in <code>renderFetched</code> is being executed, but for some reason the <code>data</code>is empty:</p>&#xA;&#xA;<pre><code>PokemonList - renderFetched {""viewer"":{""__dataID__"":""viewer-fixed"",""__fragments__"":{""0::client"":[{}]}}}&#xA;</code></pre>&#xA;&#xA;<p>Any idea what I'm missing in this setup?</p>&#xA;",1779113,,1779113,2017-03-29 11:46:29,2017-03-29 13:42:34,Data in Relay not fetched when using it with react-navigation in React Native,<javascript><react-native><graphql><relay><react-navigation>,1,1,0,2017-03-29 09:09:28
43095273,2,,43089129,1,,"<p>I solved the issue myself, so apparently the <code>PokemonList</code>, being my root component, didn't get access to the data that was requested - though I assume it actually was loaded, but due to Relay's data masking wasn't visible to the component.</p>&#xA;&#xA;<p>The solution I came up with to wrap <code>PokemonList</code> in another component that would render the <code>Relay.RootContainer</code> and then go from there with my conventional Relay setup. </p>&#xA;&#xA;<p>This is what it now looks likes:</p>&#xA;&#xA;<p><strong>PokemonListWrapper.js</strong></p>&#xA;&#xA;<pre><code>class PokemonListWrapper extends React.Component {    &#xA;  render() {&#xA;    return (&#xA;      &lt;Relay.RootContainer&#xA;        Component={PokemonList}&#xA;        route={new IndexRoute()}&#xA;        renderFetched={data =&gt; &lt;PokemonList {...this.props} {...data}/&gt;}        &#xA;      /&gt;&#xA;    )&#xA;  }    &#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>PokemonList.js</strong></p>&#xA;&#xA;<pre><code>class PokemonList extends React.Component {&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;ScrollView&gt;&#xA;        {this.props.viewer.allPokemons.edges.map(pokemonEdge =&gt; (&#xA;          &lt;Text key={pokemonEdge.node.id}&gt;{pokemonEdge.node.name}&lt;/Text&gt;&#xA;        ))}&#xA;      &lt;/ScrollView&gt;&#xA;    )&#xA;  }&#xA;&#xA;}&#xA;&#xA;export default Relay.createContainer(PokemonList, {&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        id&#xA;        allPokemons(first: 10) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p><strong>App.js</strong></p>&#xA;&#xA;<pre><code>Relay.injectNetworkLayer(&#xA;  new Relay.DefaultNetworkLayer('https://api.graph.cool/relay/v1/ciyeih9590fhl0162e5zh1z4h')&#xA;)&#xA;&#xA;export class IndexRoute extends Route {&#xA;  static queries = {&#xA;    viewer: () =&gt; Relay.QL`query { viewer }`&#xA;  }&#xA;  static routeName = 'IndexRoute'&#xA;}&#xA;&#xA;const RootNavigationStack = StackNavigator({&#xA;  PokemonList: {&#xA;    screen: PokemonListWrapper&#xA;  }&#xA;})&#xA;&#xA;export default class App extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;RootNavigationStack /&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p></p>&#xA;",1779113,,,,2017-03-29 13:42:34,"",,0,0,0,2017-03-29 13:42:34
43189071,1,,,1,143,"<p>In my schema, I have a type (ContentBlock) that contains an array of nested entities (Variations) using the Relay standard connection (edges, node, etc.). I've got a view that allows the user to specify some filter criteria, which then gets passes as an argument to the ContentBlock type, and returns a filtered set of Variations (the filtering is complex and must be done on the server). I've also got a view with a different query that passes no argument to ContentBlock, and so gets back ALL of the nested Variations.</p>&#xA;&#xA;<p>When toggling from the ""show all"" view to the ""filtered"" view, Apollo performs the filtered query, and the store gets updated such that each ContentBlock entity's list of Variations now only contains the filtered result. But, if I now return to the ""show all"" view, I still only have the filtered result.</p>&#xA;&#xA;<p>I know I could always do a <code>.refetch()</code> on the ""show all"" query when I hit that view, but I'm wondering if anyone has a suggestion of a way I could change my schema, query, or store so that I can maintain both the filtered result alongside the full result and not have to go back to the server for data when toggling between views.</p>&#xA;&#xA;<p>Even as I write this, I'm contemplating adding a field to the schema that contains the filtered list of Variation ids - that way I could still return all Variations but only show the filtered ones? But, there are other cases in my app where I really <em>don't</em> need to fetch all of them (the ""show all"" is an admin view, most users will only ever get the filtered set).</p>&#xA;&#xA;<p>Any thoughts or suggestions would be much appreciated!</p>&#xA;",1623146,,,,2017-04-03 15:52:30,Toggling between filtered GraphQL query results using Apollo,<graphql><apollo><react-apollo>,0,2,0,2017-04-03 15:52:30
43195283,1,43195913,,0,123,"<p>I have a Create-React-App server that proxies all API requests to my back-end Express-GraphQL server, located at localhost:3001</p>&#xA;&#xA;<p>Whenever I make a request on the homepage component '/' it sends the request to ""localhost:3000/graphql' which works just fine. But if I make a request on a nested child component that sends the request to something like</p>&#xA;&#xA;<pre><code>""localhost:3000/topic/:id""&#xA;</code></pre>&#xA;&#xA;<p>it sends back a 404 because it can't find ""<a href=""http://localhost:3000/topic/graphql"" rel=""nofollow noreferrer"">http://localhost:3000/topic/graphql</a>""</p>&#xA;&#xA;<p>So my question is, how do I tell React to still make those requests to localhost:3000/graphql for nested child components?</p>&#xA;",0,user7594529,,,2017-04-03 23:25:39,GraphQL Queries using different server on client side,<reactjs><express><graphql><create-react-app><react-apollo>,1,1,0,2017-04-03 22:20:33
43231665,2,,43230615,3,,"<p>I don't know about Scaphold, but you can either keep all items in a single array that you always update in one mutation, or you can update the list items one by one.</p>&#xA;&#xA;<p>The easiest way to have a decoupled manual sorting, is to have an <code>order: Float</code> field, which you set to <code>(prev.order + next.order)/2</code> every time you want to move a card between two other cards, or <code>1</code> more/less than the last/first one if you move to back/front.</p>&#xA;&#xA;<p>Given floating point precision, you can do this between the same two cards  53 times before the precision suffers, at which point you can re-distribute the <code>order</code> fields or manually move the offending cards up and then back down.</p>&#xA;",124416,,,,2017-04-05 12:47:41,"",,0,2,0,2017-04-05 12:47:41
43433843,1,43435112,,1,537,"<p>This is the code from official docs of relay, This is for GraphQLAddTodoMutation</p>&#xA;&#xA;<pre><code>const GraphQLAddTodoMutation = mutationWithClientMutationId({&#xA;  name: 'AddTodo',&#xA;  inputFields: {&#xA;    text: { type: new GraphQLNonNull(GraphQLString) },&#xA;  },&#xA;  outputFields: {&#xA;    todoEdge: {&#xA;      type: GraphQLTodoEdge,&#xA;      resolve: ({localTodoId}) =&gt; {&#xA;        const todo = getTodo(localTodoId);&#xA;        return {&#xA;          cursor: cursorForObjectInConnection(getTodos(), todo),&#xA;          node: todo,&#xA;        };&#xA;      },&#xA;    },&#xA;    viewer: {&#xA;      type: GraphQLUser,&#xA;      resolve: () =&gt; getViewer(),&#xA;    },&#xA;  },&#xA;  mutateAndGetPayload: ({text}) =&gt; {&#xA;    const localTodoId = addTodo(text);&#xA;    return {localTodoId};&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>I think mutateAndGetPayload executes first then outputFields? since it used localTodoId object as parameter, I see localTodoId object returned from mutateAndGetPayload. </p>&#xA;&#xA;<p>and this is the code for relay mutation.please look at the getFatQuery</p>&#xA;&#xA;<pre><code>export default class AddTodoMutation extends Relay.Mutation {&#xA;  static fragments = {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on User {&#xA;        id,&#xA;        totalCount,&#xA;      }&#xA;    `,&#xA;  };&#xA;  getMutation() {&#xA;    return Relay.QL`mutation{addTodo}`;&#xA;  }&#xA;  getFatQuery() {&#xA;    return Relay.QL`&#xA;      fragment on AddTodoPayload @relay(pattern: true) {&#xA;        todoEdge,&#xA;        viewer {&#xA;          todos,&#xA;          totalCount,&#xA;        },&#xA;      }&#xA;    `;&#xA;  }&#xA;  getConfigs() {&#xA;    return [{&#xA;      type: 'RANGE_ADD',&#xA;      parentName: 'viewer',&#xA;      parentID: this.props.viewer.id,&#xA;      connectionName: 'todos',&#xA;      edgeName: 'todoEdge',&#xA;      rangeBehaviors: ({status}) =&gt; {&#xA;        if (status === 'completed') {&#xA;          return 'ignore';&#xA;        } else {&#xA;          return 'append';&#xA;        }&#xA;      },&#xA;    }];&#xA;  }&#xA;  getVariables() {&#xA;    return {&#xA;      text: this.props.text,&#xA;    };&#xA;  }&#xA;  getOptimisticResponse() {&#xA;    return {&#xA;      // FIXME: totalCount gets updated optimistically, but this edge does not&#xA;      // get added until the server responds&#xA;      todoEdge: {&#xA;        node: {&#xA;          complete: false,&#xA;          text: this.props.text,&#xA;        },&#xA;      },&#xA;      viewer: {&#xA;        id: this.props.viewer.id,&#xA;        totalCount: this.props.viewer.totalCount + 1,&#xA;      },&#xA;    };&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think the todoEdge is from the outputFields from GraphQL? I see a viewer query on it, why does it need to query the viewer? How do I create a getFatQuery? I would really appreciate if someone help me understand this more and about Relay mutation. </p>&#xA;",5288560,,,,2017-04-16 15:09:09,"I need help understanding Relay OutputFields, getFatQuery",<graphql><relayjs><relay><graphql-js>,1,0,0,2017-04-16 04:54:11
43470893,2,,43468389,0,,<p>try to separate the nested objects:</p>&#xA;&#xA;<pre><code>type Year {&#xA;    month: [Event]&#xA;}    &#xA;&#xA;type Calendar {&#xA;    year: Year&#xA;}&#xA;</code></pre>&#xA;,3883957,,,,2017-04-18 11:27:29,"",,0,4,0,2017-04-18 11:27:29
43476153,2,,40954715,0,,"<p>Maybe, it depends on where you want the conversion to happen.</p>&#xA;&#xA;<p>If it's a variable, <code>Relay</code> containers have a <code>prepareVariables</code> prop that takes a function. I doubt this is what you're after, though, because you can't (afaik) pass a <code>Date</code> object as a var. If it's something like that,&#xA; though, here's an example <a href=""https://facebook.github.io/relay/docs/api-reference-relay-container.html#preparevariables"" rel=""nofollow noreferrer"">adapted from the docs:</a> </p>&#xA;&#xA;<pre><code>module.exports = Relay.createContainer(ProfilePicture, {&#xA;  initialVariables: {size: 5},&#xA;  prepareVariables: prevVariables =&gt; {&#xA;    return {&#xA;      ...prevVariables,&#xA;      size: typeof prevVariables.size === 'number'? * prevVariables.size : Number(prevVariables.size),&#xA;    };&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>If you're hoping to coerce the output of a Relay container, you'll have to either do it in the component that's consuming the props, or in a Higher Order Component. Here's the same example using the superlative <a href=""https://github.com/acdlite/recompose"" rel=""nofollow noreferrer"">recompose</a> (and the <a href=""https://github.com/acdlite/recompose/tree/master/src/packages/recompose-relay"" rel=""nofollow noreferrer"">recompose relay-container</a>, by the same author):</p>&#xA;&#xA;<pre><code>export default compose(&#xA;  createContainer({&#xA;      fragments: {&#xA;        widget: () =&gt; Relay.QL`&#xA;          fragment on Widget {&#xA;            myDate&#xA;          }`&#xA;      }&#xA;  }),&#xA;  withProps(props =&gt; ({myDate: props.widget.myDate instanceof myDate ? props.widget.myDate : new Date(props.widget.myDate)}))&#xA;)(ProfilePicture)&#xA;</code></pre>&#xA;",5456001,,5456001,2017-04-18 15:48:17,2017-04-18 15:48:17,"",,0,0,0,2017-04-18 15:21:24
43532100,1,44316573,,0,184,"<p>Consider <a href=""https://github.com/apollographql/react-apollo/pull/136/files#diff-5a60ee56da2bb34d287b107dc03083edR187"" rel=""nofollow noreferrer"">this example</a> using version <code>5.3.2</code>:  </p>&#xA;&#xA;<pre><code>@reduxForm({&#xA;   form: 'contact',&#xA; }, (state, ownProps) =&gt; ({ // check the current component's props&#xA;   initialValues: ownProps.data.loading &#xA;     ? '' // nothing if still loading&#xA;     : ownProps.data.allPeople.people[0].name, // data if done fetching&#xA; }))&#xA;</code></pre>&#xA;&#xA;<p><a href=""http://redux-form.com/6.6.3/examples/initializeFromState/"" rel=""nofollow noreferrer"">The documented demo code for version <code>&gt;6</code></a> doesn't show this function callback pattern as a possibility:</p>&#xA;&#xA;<pre><code>// Decorate with reduxForm(). It will read the initialValues prop provided by connect()&#xA;InitializeFromStateForm = reduxForm({&#xA;  form: 'initializeFromState'  // a unique identifier for this form&#xA;})(InitializeFromStateForm)&#xA;&#xA;// You have to connect() to any reducers that you wish to connect to yourself&#xA;InitializeFromStateForm = connect(&#xA;  state =&gt; ({&#xA;    initialValues: state.account.data // pull initial values from account reducer&#xA;  }),&#xA;  { load: loadAccount }               // bind account loading action creator&#xA;)(InitializeFromStateForm)&#xA;</code></pre>&#xA;&#xA;<p>Is the first pattern still possible? If so, how does it work? Is it documented anywhere? I see that <a href=""http://redux-form.com/6.6.3/docs/api/ActionCreators.md/#-initialize-form-string-data-object-keepdirty-boolean-options-keepdirty-boolean-keepsubmitsucceeded-boolean-"" rel=""nofollow noreferrer"">I'm given an <code>initialize</code> dispatcher</a> in my component props. Is that the way? </p>&#xA;",5563098,,,,2017-06-01 20:29:30,What's the API for declaring initialValues asyncronously in redux-form?,<redux-form><react-apollo><apollo-client>,1,0,0,2017-04-21 00:44:21
43543845,1,43544238,,1,1162,"<p>Please find a basic simplified problem and a question below:</p>&#xA;&#xA;<h2>Monopoly Example</h2>&#xA;&#xA;<p><strong>Data Types:</strong></p>&#xA;&#xA;<p>USER</p>&#xA;&#xA;<ul>&#xA;<li><p>name</p></li>&#xA;<li><p>houses (one-to-many)</p></li>&#xA;</ul>&#xA;&#xA;<p>STREET</p>&#xA;&#xA;<ul>&#xA;<li>name</li>&#xA;</ul>&#xA;&#xA;<p>HOUSE</p>&#xA;&#xA;<ul>&#xA;<li>street (one-to-one)</li>&#xA;</ul>&#xA;&#xA;<p>Note that in my data model there is no reference between user and streets (maybe monopoly wasn't the best example -.-)</p>&#xA;&#xA;<p><strong>Question:</strong></p>&#xA;&#xA;<p>A user can have several houses on different streets. How can I query a list of streets that a specific user has houses on?</p>&#xA;&#xA;<p>Wanted Result:</p>&#xA;&#xA;<pre><code>{&#xA;    ""data"": {&#xA;        ""User"": {&#xA;            ""name"": ""The Hat"",&#xA;            ""streets"": [&#xA;            {&#xA;                name: ""Bow Street""&#xA;            },&#xA;            {&#xA;                name: ""Oxford Street""&#xA;            },&#xA;            {&#xA;                name: ""Park Lane""&#xA;            },&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is that possible?</p>&#xA;",389430,,389430,2017-04-21 13:48:37,2017-04-21 13:57:33,GraphQL query to cross reference data,<graphql>,1,0,0,2017-04-21 13:19:57
43544238,2,,43543845,1,,"<p>Fetching relational data like that is typically handled by having nested fields in your query. The ability to traverse the data graph in a query is one of GraphQL's biggest benefits.</p>&#xA;&#xA;<p>In general, <a href=""https://www.graph.cool/docs/tutorials/designing-powerful-apis-with-graphql-query-parameters-aing7uech3"" rel=""nofollow noreferrer"">this article about GraphQL APIs</a> is a helpful resource to understand how it works.</p>&#xA;&#xA;<p>Let's look at some different possible queries.</p>&#xA;&#xA;<h1>Query a list of streets that a specific user has houses on</h1>&#xA;&#xA;<pre><code>query {&#xA;  allStreets(filter: {&#xA;    house: {&#xA;      user: {&#xA;        id: ""user-id""&#xA;      }&#xA;    }&#xA;  }) {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here we make use of <a href=""https://www.graph.cool/docs/reference/simple-api/filtering-by-field-xookaexai0/#relation-filters"" rel=""nofollow noreferrer"">a relational filter</a> passed in as an argument to query the streets that are related to a hours that is related to a specific user, which results in:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""allStreets"": [&#xA;      {&#xA;        ""name"": ""Bow Street""&#xA;      },&#xA;      {&#xA;        ""name"": ""Oxford Street""&#xA;      },&#xA;      {&#xA;        ""name"": ""Park Lane""&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>We can see that we get back a list of streets. We could also include the house field in the <code>allStreets</code> query to obtain that information as well.</p>&#xA;&#xA;<h1>Query a specific user object and a list of streets that it has houses on</h1>&#xA;&#xA;<pre><code>query {&#xA;  User(id: ""user-id"") {&#xA;    name&#xA;    houses {&#xA;      street {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here we specify a user by id, so the top-level object of the result is a single user object. Additionally, we are getting back a list of streets that user has houses on:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""User"": {&#xA;      ""name"": ""The Hat"",&#xA;      ""houses"": [&#xA;        {&#xA;          ""street"": {&#xA;            ""name"": ""Bow Street""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""street"": {&#xA;            ""name"": ""Oxford Street""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""street"": {&#xA;            ""name"": ""Park Lane""&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What's notable is that the structure of the response follows the structure of the query precisely.</p>&#xA;",1176596,,1176596,2017-04-21 13:57:33,2017-04-21 13:57:33,"",,0,2,0,2017-04-21 13:39:05
43603086,1,,,1,151,"<p><strong>Hello all,</strong></p>&#xA;&#xA;<p>I'm building a 'complex' social english vocabulary 'game' in React/Redux and GraphQL/<a href=""http://graph.cool"" rel=""nofollow noreferrer"">GraphCool</a></p>&#xA;&#xA;<p>Is it a best practice to save all the state only to redux while the app is active, and only dispatch the user/game state to the backend in like 5 / 10 minute intervals, and / or when the user quits the app ? </p>&#xA;&#xA;<p>It feels like mutating every state change might be spawning to many requests unnecessarily ?</p>&#xA;&#xA;<p>Am I thinking in the right direction here ?</p>&#xA;&#xA;<p><strong>Thanks!</strong></p>&#xA;",7737961,,,,2017-04-25 08:27:52,"GraphQL, Redux, React. Saving state on intervals",<reactjs><redux><graphql><apollo><graphcool>,2,0,0,2017-04-25 06:22:49
43607507,2,,43607279,3,,"<p>What you are overlooking here is the fact that you are mixing the es6 and es5 syntax of using react.</p>&#xA;&#xA;<p>In the ES5 syntax this is how you create components -> <code>const Comments = React.createClass</code>&#xA;Here you do not need to define a constructor. <code>createClass</code> does that for you.</p>&#xA;&#xA;<p>In the ES6 syntax, this is how you create components -> <code>class Comments extends React.Component</code>&#xA;And here you have to define your own constructor.</p>&#xA;&#xA;<p>What you can do is either switch to the new syntax completely or do <code>this.subscription = this.subscribe();</code> in a lifecycle method like <code>componentWillMount</code> or <code>componentDidMount</code>.</p>&#xA;",3489228,,,,2017-04-25 10:00:25,"",,0,1,0,2017-04-25 10:00:25
43624620,1,,,5,3114,"<p>In my graphQL schema, I have a relationship between two objects. Say Humans and Cats.</p>&#xA;&#xA;<p>Humans have many Cats and Cats have one human.</p>&#xA;&#xA;<p>If I want to create a new Cat belonging to a human, I need to query for the human by ID and then I need to use that ID to do a mutation to create the cat.</p>&#xA;&#xA;<p>How can I chain these together? It seems simple but can't find an appropriate example. It is also very likely that I'm thinking about this in the wrong way.</p>&#xA;",754803,,,,2017-04-29 20:18:11,GraphQL - How to chain queries and mutations?,<graphql><apollo>,1,0,0,2017-04-26 03:42:45
43638901,2,,40914883,2,,"<p>I have a very similar setup. One user sees cases in the <code>IN_PROGRESS</code> state until he submits. When he does, I want it to move from <code>IN_PROGRESS</code> to <code>WAITING</code>. I've just got it to work by having the following configs :</p>&#xA;&#xA;<pre><code>return [&#xA;  {&#xA;    type: ""FIELDS_CHANGE"",&#xA;    fieldIDs: {&#xA;      case: this.props.caseId&#xA;    }&#xA;  },&#xA;  {&#xA;    type: ""RANGE_ADD"",&#xA;    parentName: ""viewer"",&#xA;    parentID: this.props.viewer.__dataID__, // eslint-disable-line&#xA;    connectionName: ""cases"",&#xA;    edgeName: ""case"",&#xA;    rangeBehaviors: {&#xA;      """": ""refetch"",&#xA;      ""type(IN_PROGRESS)"": ""remove"",&#xA;      ""type(WAITING)"": ""prepend""&#xA;    }&#xA;  }&#xA;];&#xA;</code></pre>&#xA;&#xA;<p>I'm guessing replacing <code>type(IN_PROGRESS)</code> by your <code>state(pending)</code> should work!</p>&#xA;",229726,,,,2017-04-26 15:45:24,"",,0,1,0,2017-04-26 15:45:24
43673134,2,,43624620,-2,,"<p>I don't think it makes sense to chain them. If you want to create a new cat you need a list where you select the humans you want to add the cat to. So you already have to query for the humans, before you send the mutation.</p>&#xA;&#xA;<p>The mutation for the cat would contain the selected human ids, the process could look like this:</p>&#xA;&#xA;<ol>&#xA;<li>query for humans</li>&#xA;</ol>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const getAllHumansQuery = gql`&#xD;&#xA;query getAllHumans {&#xD;&#xA;   getAllHumans {&#xD;&#xA;      id&#xD;&#xA;      name&#xD;&#xA;   }&#xD;&#xA;}&#xD;&#xA;`;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<ol start=""2"">&#xA;<li><p>Build form with selection of humans on the client</p></li>&#xA;<li><p>Send create new cat mutation</p></li>&#xA;</ol>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>// server&#xD;&#xA;`&#xD;&#xA;input CatInput {&#xD;&#xA;  name: String!&#xD;&#xA;  humanIds: [ID!]&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;createCat(newCat: CatInput!) : String&#xD;&#xA;`&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// client&#xD;&#xA;&#xD;&#xA;const createCatMutation = gql `&#xD;&#xA;  mutation createCat($newCat: CatInput!) {&#xD;&#xA;    createCat(newCat: $newCat) {&#xD;&#xA;      name&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;`;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",4500001,,4500001,2017-04-29 20:18:11,2017-04-29 20:18:11,"",,0,0,0,2017-04-28 06:09:30
43684386,1,43732548,,12,719,"<p>I cannot navigate to <code>/users</code> in my app, because it doesn`t trigger fetching of all queries that I would expect it should. </p>&#xA;&#xA;<p>My app consists of an <code>App</code> component and some components that contain actual content like <code>Dashboard</code> or <code>UserList</code>. There is also an <code>EnsureAuthenticationContainer</code> but this is just a component that, when a user is authenticated, simply renders it's children. This is my route setup:</p>&#xA;&#xA;<pre><code>const ViewerQueries = {&#xA;    viewer: () =&gt; Relay.QL`query { viewer }`&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>[...]</p>&#xA;&#xA;<pre><code>&lt;Router history={browserHistory} render={applyRouterMiddleware(useRelay.default)} environment={Relay.Store}&gt;&#xA;    &lt;Route path=""/"" component={App} queries={ViewerQueries}&gt;&#xA;        &lt;Route path=""login"" component={Login} /&gt;&#xA;        &lt;Route component={EnsureAuthenticationContainer}&gt;&#xA;            &lt;IndexRoute component={Dashboard} /&gt;&#xA;            &lt;Route path=""users"" component={UserList} queries={ViewerQueries} /&gt;&#xA;            &lt;many more routes /&gt;&#xA;        &lt;/Route&gt;&#xA;    &lt;/Route&gt;&#xA;&lt;/Router&gt;&#xA;</code></pre>&#xA;&#xA;<p>The problem is, that both <code>App</code> and <code>UserList</code> have defined fragements and it seems that only the query of <code>UserList</code> is send.</p>&#xA;&#xA;<p>Fragment of <code>App</code>:</p>&#xA;&#xA;<pre><code>fragments: {&#xA;    viewer: () =&gt; {&#xA;        return Relay.QL`&#xA;            fragment on ViewerType {&#xA;                loggedInUser {&#xA;                    id&#xA;                }&#xA;            }&#xA;       `;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Fragment of <code>UserList</code>:</p>&#xA;&#xA;<pre><code>fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;        fragment on ViewerType {&#xA;            id,&#xA;            users(first: $limit) {&#xA;                edges {&#xA;                    node {&#xA;                        id,&#xA;                        userName,&#xA;                        firstName,&#xA;                        lastName,&#xA;                        eMail&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    `,&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I setup React/Relay/Router to query both <code>users</code> and <code>loggedInUser</code>?</p>&#xA;&#xA;<p><strong>Update</strong></p>&#xA;&#xA;<p>I use react-router@3.0.5 and react-router-relay@0.13.7</p>&#xA;&#xA;<p><strong>Update #2</strong></p>&#xA;&#xA;<p>This is the only query Relay generates when I visit ""/users"" and which is send to the server:</p>&#xA;&#xA;<pre><code>query Index {&#xA;  viewer {&#xA;    id,&#xA;    ...F0&#xA;  }&#xA;}&#xA;fragment F0 on ViewerType {&#xA;  _users2quBPZ:users(first:100) {&#xA;    edges {&#xA;      node {&#xA;        id,&#xA;        userName,&#xA;        firstName,&#xA;        lastName,&#xA;        eMail&#xA;      },&#xA;      cursor&#xA;    },&#xA;    pageInfo {&#xA;      hasNextPage,&#xA;      hasPreviousPage&#xA;    }&#xA;  },&#xA;  id&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The response matches the query:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/2eZaU.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/2eZaU.png"" alt=""The response from the server""></a></p>&#xA;",529359,,529359,2021-02-19 14:54:00,2021-02-19 14:54:00,Relay: How to merge instead of override queries in nested routes?,<javascript><reactjs><graphql-js><relayjs><react-router-relay>,1,4,0,2017-04-28 15:58:49
43732548,2,,43684386,3,,"<p>I'm totally not sure but I would have done like this : </p>&#xA;&#xA;<p>fragment of App : </p>&#xA;&#xA;<pre><code>fragments: {&#xA;  viewer: () =&gt; {&#xA;    return Relay.QL`&#xA;      fragment on ViewerType {&#xA;        loggedInUser {&#xA;          id&#xA;        }&#xA;        ${UserList.getFragment(""viewer"")}&#xA;      }&#xA;    `;&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think this example repo is going to be helpful to you : <a href=""https://github.com/taion/relay-todomvc/blob/master/src/components/TodoApp.js#L60-69"" rel=""nofollow noreferrer"">https://github.com/taion/relay-todomvc/blob/master/src/components/TodoApp.js#L60-69</a></p>&#xA;",2871398,,,,2017-05-02 07:36:44,"",,0,6,0,2017-05-02 07:36:44
43838106,1,43838229,,8,1140,"<p>I am puzzled by this.</p>&#xA;&#xA;<p>Suppose I currently have a the following query:</p>&#xA;&#xA;<pre><code>export const getPokemon = gql`&#xA;  query getPokemon($filters: AssetFilters) {&#xA;    pokemon(filters: $filters) {&#xA;      name,&#xA;      generation,&#xA;      exp&#xA;    }&#xA;  }`;&#xA;</code></pre>&#xA;&#xA;<p>By default no filters are passed in so everything is returned.</p>&#xA;&#xA;<p>Now, I would like to refetch with a filter as such:</p>&#xA;&#xA;<pre><code>this.props.refetch({&#xA;  filters: {&#xA;    generation: '3rd'&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The above seems to <strong>override the local cache of the original query</strong>!</p>&#xA;&#xA;<p>I am writing an offline-first app and I would like these different filtering permutations to be cached separately rather than override the original cache. </p>&#xA;&#xA;<p>How can I overcome this caching difficulty and have Apollo cache these queries with different arguments separately?</p>&#xA;",1869326,,,,2017-05-08 00:45:39,"React Apollo: One query, multiple arguments - How to cache?",<reactjs><apollo><react-apollo><apollo-client>,1,3,0,2017-05-08 00:22:23
43846889,1,43903642,,5,1957,"<p>I'm trying to perform 3 unique searches inside one query. The problem is that my search ""filter"" type is mandatory in the schema but in the front-end it's optional. If a null value is provided inside my filter then I'll get a graphql error.</p>&#xA;&#xA;<p>I want to skip searching for mainSearchData, firstComparisonSearchData or secondComparisonSearchData depending on whether the search filters contain data.</p>&#xA;&#xA;<p>I know that I can use the <code>skip</code> function to ignore the <em>whole</em> query but how can I achieve the same for part of the query? Or alternatively, how can I compose these as separate queries but perform just <em>one</em> request?</p>&#xA;&#xA;<pre><code>const GROWTH_QUERY = gql`query aggregateQuery($mainFilter: filter!, $firstComparisonFilter: filter!, $secondComparisonFilter: filter! $interval: interval!) {&#xA;  mainSearchData: groupBy(filter: $mainFilter, first: 20, after: 0) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;  firstComparisonSearchData: groupBy(filter: $firstComparisonFilter, first: 20, after: 0) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;  secondComparisonSearchData: groupBy(filter: $secondComparisonFilter, first: 20, after: 0) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;}`;&#xA;</code></pre>&#xA;",2872979,,,,2017-05-10 22:25:18,Is is possible to skip part of a query with apollo-client,<graphql><react-apollo><apollo-client>,1,0,0,2017-05-08 11:48:50
43900233,2,,43689284,0,,"<p>If using Sequelize as an underlying ORM, this functionality can be supported through Sequelize range operators. From <a href=""http://docs.sequelizejs.com/en/latest/docs/querying/#range-operators"" rel=""nofollow noreferrer"">http://docs.sequelizejs.com/en/latest/docs/querying/#range-operators</a>:</p>&#xA;&#xA;<pre><code>{&#xA;  createdAt: {&#xA;    $lt: new Date(),&#xA;    $gt: new Date(new Date() - 24 * 60 * 60 * 1000)&#xA;  }&#xA;}&#xA;// createdAt &lt; [timestamp] AND createdAt &gt; [timestamp]&#xA;</code></pre>&#xA;",2816343,,2816343,2018-01-24 20:34:13,2018-01-24 20:34:13,"",,0,4,0,2017-05-10 18:32:20
43903642,2,,43846889,10,,"<p>You can use the <code>skip</code> function on the fields themselves.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>const GROWTH_QUERY = gql`query aggregateQuery($mainFilter: filter!, $firstComparisonFilter: filter!, $secondComparisonFilter: filter! $interval: interval!) @skip(if: ...) {&#xA;  mainSearchData: groupBy(filter: $mainFilter, first: 20, after: 0) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;  firstComparisonSearchData: groupBy(filter: $firstComparisonFilter, first: 20, after: 0) @skip(if: ...) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;  secondComparisonSearchData: groupBy(filter: $secondComparisonFilter, first: 20, after: 0) @skip(if: ...) {&#xA;    items: publicationDate(interval: $interval, minDocCount: 1, sort: DESC) {&#xA;      date&#xA;      count&#xA;    }&#xA;  }&#xA;}`;&#xA;</code></pre>&#xA;&#xA;<p>Notice the <code>@skip(if: ...)</code> statements after the alias calls on <code>mainSearchData</code>, <code>firstComparisonSearchData</code>, and <code>secondComparisonSearchData</code>.</p>&#xA;",6452097,,,,2017-05-10 22:25:18,"",,0,0,0,2017-05-10 22:25:18
43920259,1,,,1,840,"<p>I'm trying to implement cursor pagination and followed the examples in the doc but I keep getting an error saying <strong>'Cannot query field ""cursor"" on type ""Query""'</strong>. </p>&#xA;&#xA;<p>I'm aware that the ""cursor"" field doesn't actually exist on the Accounts schema...but from what I'm reading from the docs.. you have to include it somewhere in the gql`` query. Furthermore, not sure if I'm missing anything but I'm a bit confused of how to structure my query to allow cursor pagination.</p>&#xA;&#xA;<p><strong>Original Query: (running this gives me no error)</strong></p>&#xA;&#xA;<pre><code>const AccountsQuery = gql`&#xA;  query {&#xA;    accounts {&#xA;      accountName&#xA;      accountId&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p><strong>New Query: (this gives ""cannot find cursor field on accounts"" error)</strong></p>&#xA;&#xA;<pre><code>const AccountsQuery = gql`&#xA;  query Accounts($cursor: String){&#xA;    accounts(cursor: $cursor) {&#xA;      cursor&#xA;      accountName&#xA;      accountId&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p><strong>GraphQL wrapper:</strong></p>&#xA;&#xA;<pre><code>export default graphql(AccountsQuery, {&#xA;  props: ({ data: { loading, cursor, accounts, fetchmore } }) =&gt; ({&#xA;    loading,&#xA;    accounts,&#xA;    loadMoreEntries() {&#xA;      return fetchmore({&#xA;        query: AccountsQuery,&#xA;        variables: {&#xA;          cursor: cursor,&#xA;        },&#xA;        updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;          const previousEntry = previousResult.entry;&#xA;          const newAccounts = fetchMoreResult.accounts;&#xA;&#xA;          return {&#xA;            cursor: fetchMoreResult.cursor,&#xA;            entry: {&#xA;              accounts: [...newAccounts, ...previousEntry]&#xA;            },&#xA;          };&#xA;        },&#xA;      })&#xA;    }&#xA;  })&#xA;})(QuickViewContainer);&#xA;</code></pre>&#xA;&#xA;<p>Any help would be appreciated to getting cursor pagination working!</p>&#xA;",3295436,,,,2021-08-20 12:51:17,Cursor Pagination with Apollo/GraphQL keeps giving me error,<pagination><graphql><apollo><react-apollo>,1,1,0,2017-05-11 15:50:42
43943976,2,,43920259,3,,"<p>Sounds like the <code>cursor</code> field isn't getting implemented on the server. Your <code>Account</code> type needs to have that field like so:</p>&#xA;<pre><code>Account {&#xA;  cursor&#xA;  accountName&#xA;  accountId&#xA;}&#xA;</code></pre>&#xA;<p>For a convention on how to do cursor pagination, you should follow the standard Relay spec. You can <a href=""https://www.apollographql.com/docs/react/pagination/cursor-based/#relay-style-cursor-pagination"" rel=""nofollow noreferrer"">read more about how it's implemented here</a> in a Relay-compliant GraphQL API.</p>&#xA;<p>This would make your query look like this:</p>&#xA;<pre><code>query {&#xA;  viewer {&#xA;    allAccounts {&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          accountName&#xA;          accountId&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Each edge account has a cursor that corresponds to a node and will be auto-populated with globally-unique opaque cursor IDs from the server.</p>&#xA;<p>Hope this helps!</p>&#xA;",6452097,,5057920,2021-08-20 12:51:17,2021-08-20 12:51:17,"",,0,0,0,2017-05-12 18:05:18
43981052,1,44057021,,1,2631,"<p>I'm using relay-modern. The following is getting me an error saying that $limit is not defined. How would I define the limit in the QueryRenderer?&#xA; My thinking is that the limit was defined in Main.js but it looks like I need to somehow reference it in the QueryRenderer. I have a QueryRenderer in my app.js file that calls a fragment on another component, Main.js. app.js looks like this, Main.js follows:</p>&#xA;&#xA;<p>```js</p>&#xA;&#xA;<pre><code>import '../style/style.css'&#xA;import React from 'react'&#xA;import ReactDOM from 'react-dom'&#xA;import { QueryRenderer, graphql } from 'react-relay'&#xA;import environment from './createRelayEnvironment'&#xA;import Main from './components/Main'&#xA;&#xA;// change rootContainer to QueryRenderer&#xA;ReactDOM.render(&#xA;  &lt;QueryRenderer&#xA;    environment={environment}&#xA;    query={graphql`&#xA;      query appQuery {&#xA;        store {&#xA;          ...Main_store&#xA;          }&#xA;      }&#xA;    `}&#xA;    // variables={{limit: 100, query: ''}}&#xA;    render={({ error, props}) =&gt; {&#xA;      if (props) {&#xA;        return &lt;Main store={props.store} /&gt;&#xA;      } else {&#xA;        return &lt;div&gt;Loading&lt;/div&gt;&#xA;      }&#xA;    }}&#xA;  /&gt;,&#xA;  document.getElementById('react')&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>```</p>&#xA;&#xA;<p>The ...Main_store fragment being called there is coming from this component, Main.js</p>&#xA;&#xA;<p>```js</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import {&#xA;  createFragmentContainer,&#xA;  createRefetchContainer,&#xA;  graphql&#xA;} from 'react-relay'&#xA;import { debounce } from 'lodash'&#xA;&#xA;import Business from './Business'&#xA;import CreateBusinessMutation from '../mutations/CreateBusinessMutation'&#xA;&#xA;class Main extends React.Component {&#xA;  constructor (props) {&#xA;    super(props)&#xA;// TODO props.relay.* APIs do not exist on compat containers&#xA;// TODO needs manual handling&#xA;    this._loadMore = debounce(this._loadMore, 300)&#xA;    this.props.relay.Variables = { limit: 100, query: '' }&#xA;  }&#xA;&#xA;  search = (e) =&gt; {&#xA;// TODO needs manual handling&#xA;    this._loadMore({ query: e.target.value })&#xA;  };&#xA;&#xA;  setLimit = (e) =&gt; {&#xA;// TODO needs manual handling&#xA;    this._loadMore({ limit: Number(e.target.value) })&#xA;  };&#xA;&#xA;  handleSubmit = (e) =&gt; {&#xA;    e.preventDefault()&#xA;    let onSuccess = () =&gt; {&#xA;      $('#modal').closeModal()&#xA;    }&#xA;&#xA;    let onFailure = (transaction) =&gt; {&#xA;      const error = transaction.getError() || new Error('Mutation failed.')&#xA;      console.error(error)&#xA;    }&#xA;&#xA;    let name = this.refs.newName.value = ''&#xA;    let url = this.refs.newUrl.value = ''&#xA;&#xA;    CreateBusinessMutation.commit(&#xA;      this.props.relay.environment,&#xA;      name,&#xA;      url,&#xA;      this.props.store&#xA;    ),&#xA;    {onFailure, onSuccess}&#xA;  }&#xA;&#xA;  componentDidMount () {&#xA;    $('.modal-trigger').leanModal()&#xA;  }&#xA;&#xA;  render () {&#xA;    let content = this.props.store.businessConnection.edges.map(edge =&gt; {&#xA;      return &lt;Business key={edge.node.id} business={edge.node} /&gt;&#xA;    })&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;div className=""input-field""&gt;&#xA;          &lt;input id=""search"" type=""text"" onChange={this.search} /&gt;&#xA;          &lt;label htmlFor=""search""&gt;Search All Businesses&lt;/label&gt;&#xA;        &lt;/div&gt;&#xA;&#xA;        &lt;div className=""row""&gt;&#xA;          &lt;a className=""waves-effect waves-light btn modal-trigger right light-blue white-text"" href=""#modal""&gt;Add New Business&lt;/a&gt;&#xA;        &lt;/div&gt;&#xA;&#xA;        &lt;ul&gt;&#xA;          {content}&#xA;        &lt;/ul&gt;&#xA;&#xA;        &lt;div className=""row""&gt;&#xA;          &lt;div className=""col m3 hide-on-small-only""&gt;&#xA;            &lt;div className=""input-field""&gt;&#xA;              &lt;select id=""showing"" className=""browser-default""&#xA;// TODO props.relay.* APIs do not exist on compat containers&#xA;                onChange={this.setLimit} defaultValue={this.props.relay.variables.limit}&gt;&#xA;                &lt;option value=""100""&gt;Show 100&lt;/option&gt;&#xA;                &lt;option value=""200""&gt;Show 200&lt;/option&gt;&#xA;              &lt;/select&gt;&#xA;            &lt;/div&gt;&#xA;          &lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;&#xA;        &lt;div id=""modal"" className=""modal modal-fixed-footer""&gt;&#xA;          &lt;form onSubmit={this.handleSubmit}&gt;&#xA;            &lt;div className=""modal-content""&gt;&#xA;              &lt;h5&gt;Add New Business&lt;/h5&gt;&#xA;              &lt;div className=""input-field""&gt;&#xA;                &lt;input type=""text"" id=""newName"" ref=""newName"" required className=""validate"" /&gt;&#xA;                &lt;label htmlFor=""newName""&gt;Name&lt;/label&gt;&#xA;              &lt;/div&gt;&#xA;              &lt;div className=""input-field""&gt;&#xA;                &lt;input type=""url"" id=""newUrl"" ref=""newUrl"" required className=""validate"" /&gt;&#xA;                &lt;label htmlFor=""newUrl""&gt;Url&lt;/label&gt;&#xA;              &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;            &lt;div className=""modal-footer""&gt;&#xA;              &lt;button type=""submit"" className=""waves-effect waves-green btn-flat green darken-3 white-text""&gt;&#xA;                &lt;strong&gt;Add&lt;/strong&gt;&#xA;              &lt;/button&gt;&#xA;              &lt;a href=""#!"" className=""modal-action modal-close waves-effect waves-red btn-flat""&gt;Cancel&lt;/a&gt;&#xA;            &lt;/div&gt;&#xA;          &lt;/form&gt;&#xA;        &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;  _loadMore () {&#xA;    // Increments the number of stories being rendered by 10.&#xA;    const refetchVariables = fragmentVariables =&gt; ({&#xA;      query: fragmentVariables.query,&#xA;      limit: fragmentVariables.limit&#xA;    })&#xA;    this.props.relay.refetch(refetchVariables, null);&#xA;  }&#xA;}&#xA;&#xA;Main = createRefetchContainer(Main, {&#xA;  /* TODO manually deal with:&#xA;  initialVariables: {&#xA;    limit: 100,&#xA;    query: ''&#xA;  }&#xA;  */&#xA;  store: graphql`&#xA;    fragment Main_store on Store {&#xA;      id,&#xA;      businessConnection(first: $limit, query: $query) {&#xA;        edges {&#xA;          node {&#xA;            id,&#xA;            ...Business_business&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;},&#xA;  graphql`&#xA;    query MainRefetchQuery($limit: Int, $query: String) {&#xA;        store {&#xA;          ...Main_store&#xA;        }&#xA;      }&#xA;  `,&#xA;)&#xA;&#xA;export default Main&#xA;</code></pre>&#xA;&#xA;<p>```</p>&#xA;&#xA;<p>This is the error in Chrome DevTools Network Tab on the query.</p>&#xA;&#xA;<pre><code>{&#xA;    ""errors"": [&#xA;        {&#xA;            ""message"": ""Variable \""$limit\"" is not defined by operation \""appQuery\""."",&#xA;            ""locations"": [&#xA;                {&#xA;                    ""line"": 10,&#xA;                    ""column"": 29&#xA;                },&#xA;                {&#xA;                    ""line"": 1,&#xA;                    ""column"": 1&#xA;                }&#xA;            ]&#xA;        },&#xA;        {&#xA;            ""message"": ""Variable \""$query\"" is not defined by operation \""appQuery\""."",&#xA;            ""locations"": [&#xA;                {&#xA;                    ""line"": 10,&#xA;                    ""column"": 44&#xA;                },&#xA;                {&#xA;                    ""line"": 1,&#xA;                    ""column"": 1&#xA;                }&#xA;            ]&#xA;        },&#xA;        {&#xA;            ""message"": ""Variable \""$showLikes\"" is not defined by operation \""appQuery\""."",&#xA;            ""locations"": [&#xA;                {&#xA;                    ""line"": 24,&#xA;                    ""column"": 27&#xA;                },&#xA;                {&#xA;                    ""line"": 1,&#xA;                    ""column"": 1&#xA;                }&#xA;            ]&#xA;        }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any ideas would be greatly appreciated.(This mostly generated using the <a href=""https://facebook.github.io/relay/docs/conversion-playbook.html"" rel=""nofollow noreferrer"">Relay Conversion Playbook</a>) Thank you.</p>&#xA;&#xA;<p>Updating - Adding schema in case that helps get answer:</p>&#xA;&#xA;<p>```</p>&#xA;&#xA;<p>type Business implements Node {&#xA;      # The ID of an object&#xA;      id: ID!&#xA;      name: String&#xA;      url: String&#xA;      state: String&#xA;      likesCount: Int&#xA;      createdAt: String&#xA;    }</p>&#xA;&#xA;<pre><code># A connection to a list of items.&#xA;type BusinessConnection {&#xA;  # Information to aid in pagination.&#xA;  pageInfo: PageInfo!&#xA;&#xA;  # A list of edges.&#xA;  edges: [BusinessEdge]&#xA;}&#xA;&#xA;# An edge in a connection.&#xA;type BusinessEdge {&#xA;  # The item at the end of the edge&#xA;  node: Business&#xA;&#xA;  # A cursor for use in pagination&#xA;  cursor: String!&#xA;}&#xA;&#xA;input CreateBusinessInput {&#xA;  name: String!&#xA;  url: String!&#xA;  clientMutationId: String&#xA;}&#xA;&#xA;type CreateBusinessPayload {&#xA;  businessEdge: BusinessEdge&#xA;  store: Store&#xA;  clientMutationId: String&#xA;}&#xA;&#xA;type Mutation {&#xA;  createBusiness(input: CreateBusinessInput!): CreateBusinessPayload&#xA;  thumbsUp(input: ThumbsUpInput!): ThumbsUpPayload&#xA;}&#xA;&#xA;# An object with an ID&#xA;interface Node {&#xA;  # The id of the object.&#xA;  id: ID!&#xA;}&#xA;&#xA;# Information about pagination in a connection.&#xA;type PageInfo {&#xA;  # When paginating forwards, are there more items?&#xA;  hasNextPage: Boolean!&#xA;&#xA;  # When paginating backwards, are there more items?&#xA;  hasPreviousPage: Boolean!&#xA;&#xA;  # When paginating backwards, the cursor to continue.&#xA;  startCursor: String&#xA;&#xA;  # When paginating forwards, the cursor to continue.&#xA;  endCursor: String&#xA;}&#xA;&#xA;type Query {&#xA;  # Fetches an object given its ID&#xA;  node(&#xA;    # The ID of an object&#xA;    id: ID!&#xA;  ): Node&#xA;  store: Store&#xA;}&#xA;&#xA;type Store implements Node {&#xA;  # The ID of an object&#xA;  id: ID!&#xA;  businessConnection(after: String, first: Int, before: String, last: Int, query: String): BusinessConnection&#xA;}&#xA;&#xA;input ThumbsUpInput {&#xA;  businessId: String&#xA;  clientMutationId: String&#xA;}&#xA;&#xA;type ThumbsUpPayload {&#xA;  business: Business&#xA;  clientMutationId: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>```</p>&#xA;",2336356,,2336356,2017-05-17 15:18:50,2017-08-10 16:39:47,Passing relay modern variable in QueryRenderer,<javascript><graphql><relayjs>,1,0,0,2017-05-15 13:39:01
43983236,1,,,0,930,"<p>started relay at learnrelay.org, from the tutorial the code to set initial variables <a href=""https://www.learnrelay.org/queries/variables/"" rel=""nofollow noreferrer"">https://www.learnrelay.org/queries/variables/</a> is like this: </p>&#xA;&#xA;<pre><code>export default Relay.createContainer(&#xA;  ListPage,&#xA;  {&#xA;    initialVariables: {&#xA;      sortOrder: 'id_DESC'&#xA;    },&#xA;    fragments: {&#xA;      viewer: () =&gt; Relay.QL`&#xA;        fragment on Viewer {&#xA;          allPokemons (first: 1000, orderBy: $sortOrder) {&#xA;</code></pre>&#xA;&#xA;<p>we usually assign variables in relay classic like this, but this code throws an error in relay modern and I don't know why?</p>&#xA;&#xA;<pre><code>export default createPaginationContainer(TodoList,&#xA;  initialVariables: {&#xA;    first: 10,&#xA;  }, &#xA;  fragments: {&#xA;  viewer: graphql`&#xA;    fragment TodoList_viewer on User {&#xA;      todos( # we need to expose todos on user so we can check if todo text already exist and sync in database &#xA;        first: $first &#xA;      ) @connection(key: ""TodoList_todos"") { #assign a key of connection that can be used shared updater&#xA;</code></pre>&#xA;",5288560,,5288560,2017-05-15 15:28:01,2017-06-04 00:10:05,How to set initial variables in relay modern?,<javascript><graphql><relayjs>,1,7,0,2017-05-15 15:24:21
44046754,1,44238066,,19,2367,"<p>So, first <strong>a bit of background</strong>. &#xA;I'm a native iOS/Android developer who is now starting my first ever React Native project. It comes with all the benefits and pains of Javascript, but I like it a lot so far :-) I decided to also try my hand at GraphQL for the first time as well.</p>&#xA;&#xA;<p>Being new to the React milieu in general, I also don’t have any prior knowledge of Relay, but chose it on recommendation from friends in my startup community and my web-dev colleagues. I was also warned about a somewhat steep learning curve, but decided to go ahead anyway - I am already fighting an uphill battle with JS and a 0.xx version of a new mobile platform, so what the hell, right? :-) I managed to set up my project correctly and punch a whole through to my GQL server with a <code>QueryRenderer</code>, which was a great relief :-)</p>&#xA;&#xA;<p><strong>So, on to the questions</strong></p>&#xA;&#xA;<p>I'm having a hard time figuring out the container/component relationship, and container composition in general. Reading <a href=""https://facebook.github.io/relay/docs/fragment-container.html#container-composition"" rel=""noreferrer"">the docs on composition</a> helped, but I'm still in doubt over the role of the <code>QueryRenderer</code></p>&#xA;&#xA;<ul>&#xA;<li><code>QueryRenderer</code> is said by the docs to be the root container for every Relay tree. Does that mean that one should have a <code>QueryRenderer</code> for the root in our app? Or at the root of each navigation path (i.e. tabs in our app)? Or just for each container component (as opposed to presentational/dumb/pure components, React wise)? Note that I'm not looking for opinions, but arguments for best practice :-)</li>&#xA;<li>Can a <code>FragmentContainer</code> (or any other container, for that matter) work without a <code>QueryRenderer</code> in the ‘parent’ component?</li>&#xA;<li>How is the <code>QueryRenderer</code> linked to child containers? Does it fetch the sum of all the data that child containers want, and then the child containers read from the cache, or? If so, I’ve misunderstood the pros of Relay - we are under the impression that each component can retrieve data independently from every other components, and that each component does not know anything about the data requirements of other components (including parent/child components). I think this assumption is also what confuses me about the <code>QueryRenderer</code>, and the need for a “Root” container.</li>&#xA;<li>If <code>QueryRenderer</code> is a ‘parent’/‘root’ Relay container to a Relay tree, how come it has to render view components based on it’s request? And why does it have to have a request? When and for what should we use a <code>QueryRenderer</code>?</li>&#xA;</ul>&#xA;&#xA;<p>Any help is much appreciated :-)</p>&#xA;",1409779,,1409779,2017-05-18 17:34:46,2017-05-29 08:38:28,Role of QueryRenderer in Relay Modern?,<reactjs><graphql><relay>,2,0,0,2017-05-18 11:40:15
44049658,1,,,1,528,"<p>The requirement is:</p>&#xA;&#xA;<ol>&#xA;<li>Get a list of movies that are playing on a specific date within X radius</li>&#xA;<li>For each movie get venues that are playing that movie (in order of a distance)</li>&#xA;<li>For each venue, get events that are playing movie on that date</li>&#xA;</ol>&#xA;&#xA;<p>The current schema is:</p>&#xA;&#xA;<pre><code>type Query {&#xA;  movies (&#xA;    first: Int&#xA;    after: String&#xA;    coordinates: CoordinatesInput!&#xA;    date: String&#xA;  ): MovieConnection!  &#xA;}&#xA;&#xA;type Movie implements Node {&#xA;  id: ID!&#xA;  name: String!&#xA;  venues (&#xA;    first: Int&#xA;    after: String&#xA;    movieId: ID!&#xA;    coordinates: CoordinatesInput!&#xA;    date: String!&#xA;  ): VenueConnection!&#xA;}&#xA;&#xA;type Venue {&#xA;  id: ID!&#xA;  name: String!&#xA;  events (&#xA;    date: String!&#xA;    venueId: ID!&#xA;    movieId: ID!&#xA;  ): EventConnection!&#xA;}&#xA;&#xA;type Event implements Node {&#xA;  id: ID!&#xA;  venue: Venue!&#xA;  movie: Movie!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Where <code>*Connection</code> is a <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">cursor pagination</a> implementation detail.</p>&#xA;&#xA;<p>In effect, I need to be able to write a query equivalent to:</p>&#xA;&#xA;<pre><code>query (&#xA;  $date: String!&#xA;  $coordinates: CoordinatesInput!&#xA;) {&#xA;  movies(&#xA;    date: $date&#xA;    coordinates: $coordinates&#xA;  ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        venues(&#xA;          date: $date&#xA;          coordinates: $coordinates&#xA;          # WARNING! made up syntax&#xA;          movieId: $parent.parent.movieId&#xA;        ) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;              events (&#xA;                date: $date&#xA;                # WARNING! made up syntax&#xA;                movieId: $parent.parent.parent.parent.movieId&#xA;                venueId: $parent.parent.venueId&#xA;              ) {&#xA;                edges {&#xA;                  node {&#xA;                    id&#xA;                    date&#xA;                    time&#xA;                    timestamp&#xA;                    url&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>As far as I can tell, the spec of <a href=""/questions/tagged/graphql"" class=""post-tag"" title=""show questions tagged &#39;graphql&#39;"" rel=""tag"">graphql</a> does not describe a way to reference a parent node in parameters.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>What works...</strong> inverting the issue.</p>&#xA;&#xA;<p>The inverse of the issue is simple. All I need is to get events defined by date and location and then retrieve the venue and movie associated with that event, e.g.</p>&#xA;&#xA;<pre><code>getEventsByDateAndLocation(date: ""2017-05-18"", location: [..]) {&#xA;  id&#xA;  venue {}&#xA;  movie {}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem with this approach is that it will increase the server response drastically, e.g. if we are display the 200~ events per page and <code>Movie</code>/ <code>Venue</code> size is 1kb, the response suddenly becomes 400kb (un-gziped). If the records were normalized, the response would be ~20kb. Thats a big difference.</p>&#xA;&#xA;<p>A possible solution is to make two requests: one to retrieve list of events (along with the required identifiers) and one to retrieve the actual resources, e.g.</p>&#xA;&#xA;<pre><code>getEventsByDateAndLocation(date: ""2017-05-18"", location: [..]) {&#xA;  id&#xA;  venue {&#xA;    id&#xA;  }&#xA;  movie {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(followed by a batched-query to retrieve <code>Venue</code> and <code>Movie</code> by their ID).</p>&#xA;&#xA;<p>This has the drawback of data composition complexity.</p>&#xA;",368691,,,,2017-05-18 13:51:20,How to get parent node's ID as a parameter?,<graphql>,0,1,0,2017-05-18 13:51:20
44057021,2,,43981052,4,,"<p>QueryRenderer can take a <code>variables</code> prop.  Try this:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  // ...&#xA;  variables={{&#xA;    limit: 10,&#xA;  }}&#xA;  // ...&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p>Now you can reference <code>$limit</code> in any fragment children of the <code>QueryRenderer</code> query.</p>&#xA;&#xA;<p>If you need to change the value of <code>$limit</code> and refetch, use <code>createRefetchContainer</code> and call the <code>refetch</code> method.</p>&#xA;&#xA;<p><a href=""https://github.com/facebook/relay/issues/1770#issuecomment-302175983"" rel=""nofollow noreferrer"">This GitHub comment</a> addresses the issue, and will be incorporated into the Relay Modern documentation.</p>&#xA;&#xA;<p>Example available <a href=""https://facebook.github.io/relay/docs/query-renderer.html"" rel=""nofollow noreferrer"">here</a></p>&#xA;",152711,,5343736,2017-08-10 16:39:47,2017-08-10 16:39:47,"",,0,2,0,2017-05-18 20:14:13
44071177,2,,44070485,4,,"<p>Make your mutation input a list and return a list of created people. Something like this:</p>&#xA;&#xA;<pre><code>class CreatePerson(graphene.Mutation):&#xA;    class Input:&#xA;        name = graphene.List(graphene.String)&#xA;&#xA;    ok = graphene.Boolean()&#xA;    people = graphene.List(Person)&#xA;&#xA;    @staticmethod&#xA;    def mutate(root, args, context, info):&#xA;        people = [Person(name=name) for name in args.get('name)]&#xA;        ok = True&#xA;        return CreatePerson(people=people, ok=ok)&#xA;</code></pre>&#xA;",185527,,,,2017-05-19 13:17:37,"",,0,3,0,2017-05-19 13:17:37
44075735,1,44222269,,0,2331,"<p>I would like to know if graphql can be used to construct queries that use aggregate filters. Something like <code>having max(customers) &lt; 10</code></p>&#xA;&#xA;<p>As an example (please the filter criteria where I would like to specify count as one of the criteria) :</p>&#xA;&#xA;<pre><code>query {&#xA;  allMovies {&#xA;    title&#xA;    _actorsMeta {&#xA;      count&#xA;    }&#xA;  }&#xA;  _allMoviesMeta(filter: {&#xA;    title_starts_with: ""Inception""&#xA;    ***count : &gt; 5***&#xA;  }) {&#xA;    count&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8038002,,1402846,2017-05-20 02:06:02,2018-11-27 15:55:47,Does graphql support filters on aggregates?,<reactjs><graphql><react-apollo><apollo-client>,1,2,0,2017-05-19 17:23:21
44079618,1,,,32,23923,"<p>I am using apollo graphql in my react application.&#xA;Say I have the following query:</p>&#xA;&#xA;<pre><code>query ListQuery($filter: String!) {&#xA;   items(filter: $filter) {&#xA;     id&#xA;     name&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This query lets me query a list of items using a filter. Say I used filter string A, and then used filter string B. The cache would now contain two entries: ListQuery(A) and ListQuery(B).</p>&#xA;&#xA;<p>Now let's say I use a mutation to add a new item. How can I remove all the cached queries from the cache? So in this case, I want to remove both ListQuery(A) and ListQuery(B) from the cache.</p>&#xA;&#xA;<p>How can I accomplish this?</p>&#xA;",7253975,,,,2022-10-02 03:22:51,Apollo GraphQl react. How to clear query cache for all variable combinations?,<caching><react-apollo>,5,2,0,2017-05-19 22:00:57
44085966,2,,44070485,8,,"<p>Instead of using a mutation that creates a list of objects, you can also call a mutation that creates one objects <em>multiple times in one GraphQL request</em>. This is accomplished using <a href=""http://graphql.org/learn/queries/#aliases"" rel=""noreferrer""><em>GraphQL Aliases</em></a>:</p>&#xA;&#xA;<pre><code>mutation {&#xA;  c001: createPerson(&#xA;    name: ""Donald Duck""&#xA;    age: 42&#xA;  ) {&#xA;    id&#xA;  }&#xA;&#xA;  c002: createPerson(&#xA;    name: ""Daisy Duck""&#xA;    age: 43&#xA;  ) {&#xA;    id&#xA;  }&#xA;&#xA;  c003: createPerson(&#xA;    name: ""Mickey Mouse""&#xA;    age: 44&#xA;  ) {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1176596,,1176596,2018-08-30 13:00:02,2018-08-30 13:00:02,"",,0,2,0,2017-05-20 12:38:12
44135234,1,44138732,,1,1171,"<p>My problem is quite simple, I need to get different menu functions depending on which type of user is logged in on my app (using react/redux/graphql/apollo).</p>&#xA;&#xA;<p>I have it all working fine, but my graphql query to get the info I need currently looks like this:</p>&#xA;&#xA;<pre><code>const currentUsr = gql`&#xA;query getCurrentUser {&#xA;    getCurrentUser{&#xA;        firstname,&#xA;        id_users,&#xA;        menuItem {&#xA;            title,&#xA;            url,&#xA;            id_parent,&#xA;            is_parent,&#xA;            icon,&#xA;            id_menu_item,&#xA;            childs {&#xA;                title,&#xA;                url,&#xA;                id_parent,&#xA;                is_parent,&#xA;                icon,&#xA;                id_menu_item,            &#xA;                childs {&#xA;                    title,&#xA;                    url,&#xA;                    id_parent,&#xA;                    is_parent,&#xA;                    icon,&#xA;                    id_menu_item&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>It's fairly obvious that I want to use fragments here, to make it look more like this: </p>&#xA;&#xA;<p>my <code>fragment</code> would be something like </p>&#xA;&#xA;<pre><code>fragment itemInfo{&#xA;    title,&#xA;    title,&#xA;    url,&#xA;    id_parent,&#xA;    is_parent,&#xA;    icon,&#xA;    id_menu_item&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and the result I want: </p>&#xA;&#xA;<pre><code>const currentUsr = gql`&#xA;query getCurrentUser {&#xA;    getCurrentUser{&#xA;        firstname,&#xA;        id_users,&#xA;        menuItem {&#xA;            ...itemInfo&#xA;            childs {&#xA;                ...itemInfo&#xA;                childs {&#xA;                    ...itemInfo&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I can't find a simple explanation on the doc, at least I don't get it right. I don't know if I need to create fragments server or client side, and how to properly do it. Can someone comfortable with graphql/apollo help me out on what to do here? Much appreciated!</p>&#xA;",6826071,,,,2017-05-23 15:12:25,Having trouble using graphql's fragments with Apollo,<javascript><reactjs><graphql><apollo><apollostack>,1,0,0,2017-05-23 12:44:51
44179252,2,,44159753,21,,"<p>There's exactly 5 possibilities (as of graphql-java v12) to provide info to a resolver (<code>DataFetcher</code>) at any level:</p>&#xA;<p><strong>1) Directly pass them in the query (possibly on multiple levels):</strong></p>&#xA;<pre><code>{customer(id: 3) {&#xA;      user {&#xA;         profile(id: 3) {&#xA;             name&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p><strong>2) Get values from the <em>source</em> object</strong></p>&#xA;<p>The <em>source</em> is the result of the enclosing query.&#xA;In your case, the source for the <code>customer</code> query is the root (whatever you provided at the query execution time, e.g.</p>&#xA;<pre><code>graphQL.execute(ExecutionInput.newExecutionInput()&#xA;    .query(query)&#xA;    .root(root)&#xA;    .build())&#xA;</code></pre>&#xA;<p>The source for the <code>user</code> query is whatever <code>customer</code> query returned, presumably some <code>Customer</code> instance.<br />&#xA;The source for the <code>profile</code> query is whatever the <code>user</code> query returned, presumably a <code>User</code> instance.&#xA;You can get a hold of the source via <code>DataFetchingEnvironment#getSource()</code>. So, if <code>User</code> contains the <code>CustomerID</code> you're after, just get it via <code>((User) env.getSource()).getCustomerId()</code>. If not, consider wrapping the result into an object that would contain all you need in the sub-queries.</p>&#xA;<p><strong>3) Pass the values around using the shared context</strong></p>&#xA;<p>graphql-java passes around an instance of <code>GraphQLContext</code> available to all resolvers. So, inside the <code>DataFetcher</code> for <code>customer</code>, you can store the <code>CustomerID</code> into it:</p>&#xA;<pre><code>Customer customer = getCustomer();&#xA;GraphQLContext context = env.getContext();&#xA;context.put(&quot;CustomerID&quot;, customer.getId());&#xA;</code></pre>&#xA;<p>Later on, inside the <code>DataFetcher</code> for <code>profile</code>, you can get it from the context:</p>&#xA;<pre><code>String customerId = env.getContext().get(&quot;CustomerID&quot;);&#xA;</code></pre>&#xA;<p>To initialize a context, pass it when executing the query:</p>&#xA;<pre><code>ExecutionInput input = ExecutionInput.newExecutionInput()&#xA;  .query(operation)&#xA;  .graphQLContext(new HashMap&lt;&gt;())&#xA;  .build()&#xA;graphQL.execute(query, input);&#xA;</code></pre>&#xA;<p>This way is stateful, thus the hardest to manage, so use it only if all else fails.</p>&#xA;<p><strong>4) Directly get the arguments passed to a parent field</strong></p>&#xA;<pre><code>ExecutionStepInfo stepInfo = dataFetchingEnvironment.getExecutionStepInfo();&#xA;stepInfo.getParent().getArguments(); // get the parent arguments&#xA;</code></pre>&#xA;<p><strong>5) Pass the values around using the <em>local</em> context</strong></p>&#xA;<p>Instead of returning the result directly, wrap it into a <code>DataFetcherResult</code>. That way you can also attach any object as a <code>localContext</code> that will be available to all child <code>DataFetcher</code>s via <code>DataFetchingEnvironment#getLocalContext()</code></p>&#xA;",294657,,294657,2022-11-28 01:03:40,2022-11-28 01:03:40,"",,0,2,0,2017-05-25 11:17:31
44217880,1,44280876,,0,512,"<p>I'm building a graphql application  where a <code>User</code> can have a bunch of <code>Entries</code>. It is an n to m relationship, with the intermediary table/edge holding additional information about the relationship.&#xA;My graphql schema looks something like this : </p>&#xA;&#xA;<pre><code>type User {&#xA;    id: ID!,&#xA;    entries(…): [UserEntry]&#xA;}&#xA;&#xA;type UserEntry {&#xA;    id: ID!,&#xA;    user: User,&#xA;    entry: Entry,&#xA;    someOtherAttribute: String,&#xA;    yetAnotherAttribute: String&#xA;}&#xA;&#xA;type Entry {...}&#xA;&#xA;type Query {&#xA;  me: User!&#xA;  userEntry(userEntryId: ID!): UserEntry!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to add cursor style pagination to that <code>entries</code> field, following the <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay Cursor Connections Specification</a>.&#xA;So I guess <code>UserEntry</code> would become something like this : </p>&#xA;&#xA;<pre><code>type UserEntryEdge {&#xA;    node: Entry,&#xA;    cursor: String,&#xA;    someOtherAttribute: String,&#xA;    yetAnotherEdgeAttribute: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I want to still be able to query the <code>UserEntry</code>/<code>UserEntryEdge</code> directly, and in that context the <code>cursor</code> field for example would be irrelevant.</p>&#xA;&#xA;<p><strong>What's the best way to design my graphql schema to be able to query edges data directly ?</strong></p>&#xA;&#xA;<p><em>(FYI: I'm using nodejs and the apollo framework suite both on server and client)</em></p>&#xA;",618807,,618807,2017-05-27 18:00:58,2017-05-31 09:28:15,Modeling Relay Cursor Connections,<graphql><relay>,2,2,0,2017-05-27 14:13:15
44218491,2,,44217880,0,,"<p>If you still need to query <code>UserEntry</code> directly then I guess you should keep it as a separate type in your schema and not transform it into <code>Edge</code> type.</p>&#xA;&#xA;<p>So just keep both <code>UserEntry</code> and <code>UserEntryEdge</code>.</p>&#xA;&#xA;<p>The resulting schema may look like:</p>&#xA;&#xA;<pre><code>type User {&#xA;    id: ID!,&#xA;    entries(…): [UserEntryConnection]&#xA;}&#xA;&#xA;type UserEntryConnection {&#xA;  edges: [UserEntryEdge]&#xA;  nodes: [Entry] # shortcut (GitHub does like that)&#xA;  pageInfo: PageInfo!&#xA;}&#xA;&#xA;type UserEntryEdge {&#xA;    node: Entry,&#xA;    cursor: String,&#xA;    info: UserEntry # To not duplicate attributes, you can use UserEntry type here&#xA;}&#xA;&#xA;type UserEntry {&#xA;    id: ID!,&#xA;    user: User,&#xA;    entry: Foo,&#xA;    someOtherAttribute: String,&#xA;    yetAnotherAttribute: String&#xA;}&#xA;&#xA;type Entry {...}&#xA;&#xA;type Query {&#xA;  me: User!&#xA;  userEntry(userEntryId: ID!): UserEntry! # keep userEntry field as is&#xA;}&#xA;</code></pre>&#xA;",1749888,,,,2017-05-27 15:15:50,"",,0,1,0,2017-05-27 15:15:50
44223592,1,46745547,,4,3570,"<p>Module not found: Error: Can't resolve './<strong>generated</strong>/GetAllCities.graphql'</p>&#xA;&#xA;<p>the component:</p>&#xA;&#xA;<pre><code>export class Map extends React.Component {&#xA;21   constructor(props){&#xA;22     super(props);&#xA;23   };&#xA;&#xA;&#xA; 24   render(){&#xA; 25     return(&#xA; 26      &lt;div id='map'&gt;&#xA; 27        &lt;GoogleMapReact&#xA; 28        bootstrapURLKeys={{key: ''}}&#xA; 29        defaultCenter={this.props.center}&#xA; 30        defaultZoom={this.props.zoom}&#xA; 31        &gt;&#xA; 32          &lt;QueryRenderer&#xA; 33            environment={environment}&#xA; 34            query={graphql`&#xA; 35              query GetAllCities {&#xA; 36                cities {&#xA; 37                  id&#xA; 38                  lat&#xA; 39                }&#xA; 40              }&#xA; 41           `}&#xA; 42            render={&#xA; 43              ({error, props}) =&gt; {&#xA; 44                if (error) {&#xA; 45                  return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA; 46                } else if (props) {&#xA; 47                  console.log(props);&#xA; 48                  return &lt;div&gt;{props.data.id}&lt;/div&gt;;&#xA; 49                }&#xA; 50                  return &lt;div&gt;Loading&lt;/div&gt;;&#xA; 51              }&#xA; 52            }&#xA; 53          /&gt;&#xA; 54        &lt;/GoogleMapReact&gt;&#xA;</code></pre>&#xA;&#xA;<p>the relay-compiler command:</p>&#xA;&#xA;<pre><code> 11     ""relay"": ""relay-compiler --src ./src --schema ./data/schema.graphql --extensions=js,jsx"",&#xA;</code></pre>&#xA;&#xA;<p>the schema:</p>&#xA;&#xA;<pre><code>  1 # A city to be used on the map&#xA;  2 type City {&#xA;  3   id: Int!&#xA;  4   lat: Float&#xA;  5   lng: Float&#xA;  6   todo: [ToDo]&#xA;  7 }&#xA;  8 &#xA;  9 # Mutations for the To Do List&#xA; 10 type Mutation {&#xA; 11   createToDo(city_id: Int!, text: String!): ToDo&#xA; 12 }&#xA; 13 &#xA; 14 # An array of Cities&#xA; 15 type Query {&#xA; 16   cities: [City]&#xA; 17   city(id: Int): City&#xA; 18 }&#xA; 19 &#xA; 20 # A To Do for a city&#xA; 21 type ToDo {&#xA; 22   city_id: Int!&#xA; 23   text: String&#xA; 24   likes: Int&#xA; 25   id: Int!&#xA; 26 }&#xA;</code></pre>&#xA;&#xA;<p>the babelrc file:</p>&#xA;&#xA;<pre><code>  1 {&#xA;  2   ""plugins"": [&#xA;  3      [""relay"", {&#xA;  4        ""compat"": true,&#xA;  5        ""schema"": ""./data/schema.graphql"",&#xA;  6        ""enforceSchema"": true,&#xA;  7        ""suppressWarnings"": false,&#xA;  8        ""debug"": false,&#xA;  9      }]&#xA; 10    ],&#xA; 11   ""presets"": [""react"", ""es2015"", ""es2016"", ""es2017""]&#xA; 12 }~   &#xA;</code></pre>&#xA;&#xA;<p>the major issue is yarn run relay or npm run relay does not generate the <strong>generated</strong> GetAllCities.graphql</p>&#xA;&#xA;<p>also get no error. it worked before with a fragment container. renaming the file to .js also doesn't work.</p>&#xA;",561236,,,,2017-10-14 14:16:11,Relay Compiler not generating .graphql files,<graphql><relayjs><relay>,2,0,0,2017-05-28 03:37:49
44224104,2,,44124284,0,,"<p>As of now, I'm not certain there is a proper way, but these are the options I think are reasonable</p>&#xA;&#xA;<ol>&#xA;<li>Manually pass down data via props</li>&#xA;<li>Wrap your deeply nested component with the same query</li>&#xA;</ol>&#xA;&#xA;<p>Manual pass down ensures your components rerender correctly, but it can be a pain to refactor. Wrapping your nested component would just hit the cache. Yes, you probably need to redo the loading logic, but that's not a show stopper.</p>&#xA;&#xA;<p>My advice is to manually pass down props for shallow nested components and rewrap deeply nested components. Unfortunately, react-apollo doesn't provide a convenient way to access the apollo-store for nested components the same way that redux's <code>connect</code> container does.</p>&#xA;",3574317,,,,2017-05-28 05:25:09,"",,0,0,0,2017-05-28 05:25:09
44280876,2,,44217880,1,,"<p>You are actually modelling your schema like this</p>&#xA;&#xA;<pre><code>[User] hasAndBelongsToMany [Entry]&#xA;</code></pre>&#xA;&#xA;<p>But you could think about it like</p>&#xA;&#xA;<pre><code>[User] hasMany [UserEntry] hasOne [Entry]&#xA;    and&#xA;[Entry] hasMany [UserEntry] hasOne [User]&#xA;</code></pre>&#xA;&#xA;<p>So, going back to your GraphQL Schema:</p>&#xA;&#xA;<pre><code>type User {&#xA;    id: ID!,&#xA;    userEntriesConnection(…): UserEntriesConnection!&#xA;}&#xA;&#xA;type UserEntriesConnection {&#xA;    edges: [UserEntryEdge]!,&#xA;    pageInfo: ...&#xA;}&#xA;&#xA;type UserEntryEdge {&#xA;    cursor: String!,&#xA;    node: UserEntry,&#xA;}&#xA;&#xA;type UserEntry {&#xA;    id: ID!,&#xA;    user: User,&#xA;    entry: Entry,&#xA;    someOtherAttribute: String,&#xA;    yetAnotherAttribute: String&#xA;}&#xA;&#xA;type Entry { ... }&#xA;&#xA;type Query {&#xA;  me: User!&#xA;  userEntry(userEntryId: ID!): UserEntry!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Would that fit your need ? The queries would be more verbose, because there is more depth, but it is more complete.</p>&#xA;",3076424,,,,2017-05-31 09:28:15,"",,0,0,0,2017-05-31 09:28:15
44321127,1,,,0,593,"<p>I have read from <a href=""https://github.com/facebook/relay/blob/master/packages/react-relay/modern/ReactRelayPaginationContainer.js"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/blob/master/packages/react-relay/modern/ReactRelayPaginationContainer.js</a> and <a href=""https://facebook.github.io/relay/docs/pagination-container.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/pagination-container.html</a></p>&#xA;&#xA;<p>My count variable is working and I think I have set it up correctly but I cannot loadMore items and my hasMore is false which means I have no more todos to display.This is my code: </p>&#xA;&#xA;<pre><code>export default createPaginationContainer(TodoList,&#xA;  {&#xA;    viewer: graphql`&#xA;            fragment TodoList_viewer on User {&#xA;              todos(&#xA;                first: $count  # &#xA;              ) @connection(key: ""TodoList_todos"") {&#xA;                edges {&#xA;                  node {&#xA;                    id,&#xA;                    complete,&#xA;                    ...Todo_todo,&#xA;                  },&#xA;                },&#xA;              },&#xA;              id,&#xA;              totalCount,&#xA;              completedCount,&#xA;              ...Todo_viewer,&#xA;            }&#xA;        `,&#xA;  },&#xA;  {&#xA;    direction: 'forward',&#xA;    getConnectionFromProps(props) {&#xA;      console.log(""getConnectionFromProps props "",props)&#xA;      return props.viewer &amp;&amp; props.viewer.todos;&#xA;    },&#xA;    getFragmentVariables(prevVars, totalCount) {&#xA;      console.log(""getFragmentVariables total count "",totalCount )&#xA;      return {&#xA;        ...prevVars,&#xA;        count: totalCount, // the total of displayed todos on the fragment&#xA;      };&#xA;    },&#xA;    getVariables(props, {count}, fragmentVariables) {&#xA;      console.log(""getVariables count "",count)&#xA;      return {&#xA;        count,&#xA;        // cursor,&#xA;        // in most cases, for variables other than connection filters like&#xA;        // `first`, `after`, etc. you may want to use the previous values.&#xA;        // orderBy: fragmentVariables.orderBy,&#xA;      };&#xA;    },&#xA;    query: graphql`&#xA;      query TodoListPaginationQuery( # assign component name + Pagination + Query&#xA;        $count: Int!&#xA;      ) {&#xA;        viewer {&#xA;          # You could reference the fragment defined previously.&#xA;          ...TodoList_viewer&#xA;        }&#xA;      }&#xA;    `&#xA;  });&#xA;</code></pre>&#xA;&#xA;<p>I don't know what I am doing wrong here. Maybe if you know a working sample for this(which I cannot find in github) I would really appreciate</p>&#xA;",5288560,,,,2018-02-24 21:34:11,I cannot do loadMore in relay even there are more items?,<reactjs><relayjs><graphql-js>,2,0,0,2017-06-02 05:01:13
44334964,1,46293036,,0,257,<p>I am trying to make a multilingual single page application using react-apollo. The сurrent locale is stored in redux store. The problem is that I have to connect every component to redux just to pass locale variable to the query. Such repetition of code looks redundant. I cannot hardcode locale to the query because it can be different for different users. I need to pass default value dynamically. Any ideas?</p>&#xA;,2322869,,,,2017-09-19 06:08:59,React apollo default query variable from redux store,<reactjs><graphql><apollo><react-apollo>,1,0,0,2017-06-02 18:04:45
44336300,1,44416986,,1,150,"<p>My backend schema has a model, <code>Request</code>, that uses a polymorphic association such that several different models all have-many Requests and a <code>Request</code> can belong to any one of those different models.</p>&#xA;&#xA;<p>I've got a React Component, <code>RequestList</code>, that I want to be able to use in any of it's potential parent models.</p>&#xA;&#xA;<p>Here's some sample code:</p>&#xA;&#xA;<p>FooShowView.js</p>&#xA;&#xA;<pre><code>class FooShowView extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;RequestList router={this.props.router} /&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(ShowView, {&#xA;  initialVariables: {&#xA;    FooId: null&#xA;  },&#xA;  fragments: {&#xA;    viewer: (variables) =&gt; {&#xA;      return Relay.QL`&#xA;        fragment on Viewer {&#xA;          Foo(id: $FooId) {&#xA;            id${ RequestList.getFragment('Foo') }&#xA;          }&#xA;        }`&#xA;      `&#xA;    }&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>RequestList.js</p>&#xA;&#xA;<pre><code>class RequestList extends Component {&#xA;&#xA;  renderRows = () =&gt; {&#xA;    return this.props.requests.edges.map(edge =&gt; edge.node).map((intReq, i) =&gt; {&#xA;      return (&#xA;        &lt;RequestRow&#xA;          request={ intReq }&#xA;          key={ i }&#xA;        /&gt;&#xA;      );&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;Table&gt;&#xA;        { this.renderRows() }&#xA;      &lt;/Table&gt;&#xA;    );&#xA;  }&#xA;};&#xA;&#xA;export default Relay.createContainer(RequestList, {&#xA;  fragments: {&#xA;    foo: () =&gt; Relay.QL`&#xA;      fragment on Foo {&#xA;        requests(first: 10) {&#xA;          edges {&#xA;            node {&#xA;              ${ RequestRow.getFragment('request') }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>The problem is that now to render the RequestTable for another one of <code>Request</code>'s parents, say in the <code>BarShowView</code>, I'd need to add a new fragment to <code>RequestList</code>:</p>&#xA;&#xA;<pre><code>bar: () =&gt; Relay.QL`&#xA;  fragment on Bar {&#xA;    requests(first: 10) {&#xA;      edges {&#xA;        node {&#xA;          ${ RequestRow.getFragment('request') }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`,&#xA;</code></pre>&#xA;&#xA;<p>And then Relay will spit out warnings that I need to provide both bar and foo as props to my List, even if it's not relevant to the current view.</p>&#xA;&#xA;<p>Since <code>Request</code> is associated with roughly 8 different models in my schema, this will quickly become unreasonable.</p>&#xA;&#xA;<p>What is the correct way to create a reusable react component that will render the polymorphic children of whatever record I'm looking at?</p>&#xA;",5062425,,,,2017-06-07 15:31:16,Writing Fragments for Polymorphic Associations in RelayJS and GraphQL,<reactjs><relayjs><graphql-js>,1,0,0,2017-06-02 19:39:50
44382147,1,44391602,,6,691,"<p>I'm looking up organization members based on a list of organization ids.  Each org has a paged list of members with an <code>endCursor</code>.  Since each <code>endCursor</code> will be different and each org has different numbers of members (and different number of pages), how can I pass in different cursors back as variables?  If so, how would each cursor be associated to the org ID from the previous query?</p>&#xA;&#xA;<pre><code>query($orgIds:[ID!]!, $page_cursor:String) { // not sure how to pass in the cursor when different length lists are returned&#xA;    nodes(ids:$orgIds) {&#xA;        ... on Organization {&#xA;            id&#xA;            members(first: 100, after: $page_cursor) {&#xA;            edges {&#xA;                node {&#xA;                    id&#xA;                }&#xA;            }&#xA;            pageInfo {&#xA;                endCursor&#xA;                hasNextPage&#xA;            }&#xA;        }    &#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've read <a href=""http://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">http://graphql.org/learn/pagination/</a> but I'm not seeing anything related to passing in multiple cursors for the same edge list.</p>&#xA;",2517012,,1749888,2017-06-06 18:35:12,2017-06-06 18:35:12,Pass in multiple cursors as variables to GitHub GraphQL API?,<github-api><graphql>,1,0,0,2017-06-06 05:44:01
44383522,1,,,6,1760,"<p>I want to implement cursor based pagination in Apollo graphql server. I have prepared schema with pagination requirement. But i am stuck at resolver side.&#xA;Here is my schema</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const typeDefinitions = `&#xD;&#xA;input CreateDeveloperInput {&#xD;&#xA;  # An arbitrary string value with no semantic meaning. Will be included in the&#xD;&#xA;  # payload verbatim. May be used to track mutations by the client.&#xD;&#xA;  clientMutationId: String&#xD;&#xA;  developer: DeveloperInput!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type CreateDeveloperPayload {&#xD;&#xA;  clientMutationId: String&#xD;&#xA;  developerEdge(orderBy: DevelopersOrderBy = PRIMARY_KEY_ASC): DevelopersEdge&#xD;&#xA;  query: Query&#xD;&#xA;}&#xD;&#xA;input DeleteDeveloperByIdInput {&#xD;&#xA;  # An arbitrary string value with no semantic meaning. Will be included in the&#xD;&#xA;  # payload verbatim. May be used to track mutations by the client.&#xD;&#xA;  clientMutationId: String&#xD;&#xA;  id: Int!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;input DeleteDeveloperInput {&#xD;&#xA;  clientMutationId: String&#xD;&#xA;  nodeId: ID!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type DeleteDeveloperPayload {&#xD;&#xA;  clientMutationId: String&#xD;&#xA;  developer: Developer&#xD;&#xA;  deletedDeveloperId: ID&#xD;&#xA;&#xD;&#xA;  # Our root query field type. Allows us to run any query from our mutation payload.&#xD;&#xA;  query: Query&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type Developer implements Node {&#xD;&#xA;  nodeId: ID!&#xD;&#xA;  id: Int!&#xD;&#xA;  name: String!&#xD;&#xA;  place: String&#xD;&#xA;  salary: Int&#xD;&#xA;  joiningDate: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;input DeveloperCondition {&#xD;&#xA;  id: Int&#xD;&#xA;  name: String&#xD;&#xA;  place: String&#xD;&#xA;  salary: Int&#xD;&#xA;  joiningDate: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;input DeveloperInput {&#xD;&#xA;  id: Int&#xD;&#xA;  name: String!&#xD;&#xA;  place: String&#xD;&#xA;  salary: Int&#xD;&#xA;  joiningDate: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;input DeveloperPatch {&#xD;&#xA;  id: Int&#xD;&#xA;  name: String&#xD;&#xA;  place: String&#xD;&#xA;  salary: Int&#xD;&#xA;  joiningDate: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type DevelopersConnection {&#xD;&#xA;  # Information to aid in pagination.&#xD;&#xA;  pageInfo: PageInfo!&#xD;&#xA;  totalCount: Int&#xD;&#xA;  edges: [DevelopersEdge]&#xD;&#xA;  nodes: [Developer!]&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type DevelopersEdge {&#xD;&#xA;  # A cursor for use in pagination.&#xD;&#xA;  cursor: String&#xD;&#xA;  node: Developer!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;enum DevelopersOrderBy {&#xD;&#xA;  PRIMARY_KEY_ASC&#xD;&#xA;  PRIMARY_KEY_DESC&#xD;&#xA;  NATURAL&#xD;&#xA;  ID_ASC&#xD;&#xA;  ID_DESC&#xD;&#xA;  NAME_ASC&#xD;&#xA;  NAME_DESC&#xD;&#xA;  PLACE_ASC&#xD;&#xA;  PLACE_DESC&#xD;&#xA;  SALARY_ASC&#xD;&#xA;  SALARY_DESC&#xD;&#xA;  JOINING_DATE_ASC&#xD;&#xA;  JOINING_DATE_DESC&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# The root mutation type which contains root level fields which mutate data.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;interface Node {&#xD;&#xA;  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.&#xD;&#xA;  nodeId: ID!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# Information about pagination in a connection.&#xD;&#xA;type PageInfo {&#xD;&#xA;  # When paginating forwards, are there more items?&#xD;&#xA;  hasNextPage: Boolean!&#xD;&#xA;&#xD;&#xA;  # When paginating backwards, are there more items?&#xD;&#xA;  hasPreviousPage: Boolean!&#xD;&#xA;&#xD;&#xA;  # When paginating backwards, the cursor to continue.&#xD;&#xA;  startCursor: String&#xD;&#xA;&#xD;&#xA;  # When paginating forwards, the cursor to continue.&#xD;&#xA;  endCursor: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# The root query type which gives access points into the data universe.&#xD;&#xA;type Query implements Node {&#xD;&#xA;   allDevelopers(&#xD;&#xA;&#xD;&#xA;    # Read all values in the set before (above) this cursor.&#xD;&#xA;    before: String,&#xD;&#xA;&#xD;&#xA;    # Read all values in the set after (below) this cursor.&#xD;&#xA;    after: String, first: Int, last: Int, offset: Int,&#xD;&#xA;&#xD;&#xA;    # A condition to be used in determining which values should be returned by the collection.&#xD;&#xA;    condition: DeveloperCondition): DevelopersConnection&#xD;&#xA;&#xD;&#xA;  # Exposes the root query type nested one level down. This is helpful for Relay 1&#xD;&#xA;  # which can only query top level fields if they are in a particular form.&#xD;&#xA;  &#xD;&#xA;  nodeId: ID!&#xD;&#xA;}&#xD;&#xA;schema {&#xD;&#xA;query: Query&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;`;&#xD;&#xA;&#xD;&#xA;export default [typeDefinitions];</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>Is it possible to resolve in resolvers? If yes, can any one please tell me how to implement it</p>&#xA;",6414472,,6414472,2017-06-12 05:40:43,2020-04-16 18:47:37,Pagination in apollo-graphql server,<graphql><graphql-js><apollo-server>,1,1,0,2017-06-06 07:11:24
44391602,2,,44382147,4,,"<p>I haven't found any details in the graphql specs on how supply an array of cursors for the same edge list. GitHub would have to come up with a custom feature for that. Though I have a feeling it is not quite what you are looking for.</p>&#xA;&#xA;<p>A cursor exist per node, so if you add cursor field to your edges request, you will get the cursors for all nodes within your request.</p>&#xA;&#xA;<pre><code>edges {&#xA;    cursor&#xA;    node {&#xA;        id&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Response would become something like this:</p>&#xA;&#xA;<pre><code>""edges"": [&#xA;    {&#xA;      ""cursor"": ""Y3Vyc29yOnYyOpLOAANaVM4AA1pU"",&#xA;      ""node"": {&#xA;        ""id"": ""MDQ6VXNlcjIxOTczMg==""&#xA;      }&#xA;    },&#xA;</code></pre>&#xA;&#xA;<p>Please note that endCursor is not the same if you  change the ""first:100"" parameter to let's say ""first:5"", because endCursor would be the last cursor of the last node of the 5 first results.</p>&#xA;&#xA;<p>The only reference you will have from your cursor ID to your orginazation ID, would be that the structure of the object being returned from GitHub's graphql API. Any cursor in your example is a child of a specific organisation.</p>&#xA;&#xA;<p>From my point of view, It would be up to your client to remember that reference if needed afterwards. With that in mind, you might want to simply iterate through the pages of a single organisation, before you go to the next. (supplying only 1 organisation pr request, and not an array).</p>&#xA;",7544237,,7544237,2017-06-06 14:32:59,2017-06-06 14:32:59,"",,0,0,0,2017-06-06 13:38:43
44400020,1,44408612,,1,5756,"<p>In this case, type ""X"" is <code>Application</code> and type ""Y"" is type ""Node"" - I can see <em>why this is happening</em>, but my understanding of Relay isn't enough to understand how to fix it. The query generated by Relay is</p>&#xA;&#xA;<pre><code>query {&#xA;    node(id: $some_id) {&#xA;        ...F0&#xA;    }&#xA;}&#xA;&#xA;fragment F0 on Application {&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have a schema that looks like </p>&#xA;&#xA;<pre><code>query {&#xA;    application { &#xA;        /* kind of a generic endpoint for fetching lists, etc */&#xA;        invites(token: $token) {&#xA;            name&#xA;        }&#xA;    }&#xA;    viewer { /* the current user */ }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm trying to fetch a specific invite from outside a session (<code>viewer</code> is <code>null</code>).</p>&#xA;&#xA;<p>I've tried </p>&#xA;&#xA;<pre><code>const application = Relay.QL`query { application }`&#xA;...&#xA;&lt;Route ... queries={{ application }}/&gt;&#xA;...&#xA;Relay.createContainer(Component, {&#xA;    initialValues: { token: null },&#xA;    fragments: {&#xA;        application: () =&gt; {&#xA;            fragment on Application {&#xA;                invites(token: $token) {&#xA;                    ...&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>which gives me the error </p>&#xA;&#xA;<p>fragment ""F0"" cannot be spread here as objects of type ""Node"" can never be of type ""Application"" - or something to that effect.</p>&#xA;&#xA;<p>I'm a little confused, because if I were to write a raw query and run it through GraphQL directly</p>&#xA;&#xA;<pre><code>query {&#xA;    application {&#xA;        invites(token: ""asdasdasd"") {&#xA;            edges {&#xA;                node {&#xA;                    name&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>it gives me what I'm looking for...</p>&#xA;&#xA;<p>In the backend, my graph is defined like</p>&#xA;&#xA;<pre><code>export const Application = new GraphQLObjectType({&#xA;  name: 'Application',&#xA;  fields: () =&gt; ({&#xA;    id: {&#xA;      type: GraphQLString,&#xA;      resolve: () =&gt; 'APPLICATION_ID'&#xA;    },&#xA;    invites: {&#xA;        type: InviteConnectionType,&#xA;        args: connectionArgs,&#xA;        resolve: (application, args) =&gt; {&#xA;            ...&#xA;        } &#xA;    }&#xA;  })&#xA;})&#xA;&#xA;export default new GraphQLSchema({&#xA;  query: new GraphQLObjectType({&#xA;  name: 'query',&#xA;  fields: {&#xA;    node: nodeField,&#xA;    application: {&#xA;      type: Application,&#xA;      resolve: (root, args, ctx) =&gt; {&#xA;        return Promise.resolve({})&#xA;      }&#xA;    }&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>I've been looking at questions like <a href=""https://stackoverflow.com/questions/42552256/fragment-f1-cannot-be-spread-here-as-objects-of-type-node-can-never-be-of-ty"">this</a> and some <a href=""https://github.com/facebook/relay/issues/1409"" rel=""nofollow noreferrer"">issues on the Relay github</a>, but it's not clear to me how I should implement <code>nodeInterface</code>.</p>&#xA;&#xA;<p>edit: the short-long of the current <code>nodeInterface</code> code is </p>&#xA;&#xA;<pre><code>export const {&#xA;  nodeInterface,&#xA;  nodeField&#xA;} = nodeDefinitions(&#xA;  (globalId) =&gt; {&#xA;    const { type, id } = fromGlobalId(globalId)&#xA;    return db[type].findById(id)&#xA;  },&#xA;  (obj) =&gt; {&#xA;    const name = obj.$modelOptions.name.singular&#xA;    return types[name]&#xA;  }&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>Application is not a db model, however, just a generic interface to fetch data through. I've tried checking to see if <code>type === 'Application'</code>, and returning null (although I see why that doesn't work), returning <code>Application</code> (the GraphQLObject), but that doesn't work... not really sure where to go from there.</p>&#xA;",877279,,877279,2017-06-07 16:02:40,2017-06-19 23:08:04,"Fragment cannot be spread here as objects of type ""X"" can never be of type ""Y""",<reactjs><graphql><relay>,2,0,0,2017-06-06 21:20:25
44416986,2,,44336300,0,,"<p>What I ended up doing (in case someone runs into this) is just putting the <code>RequestList</code> fragment on the root and just passing in variables so it only queries for the appropriate associated records. Much simpler than having to write a half dozen fragments. So my createContainer call now looks like:</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(RequestList, {&#xA;  initialVariables: {&#xA;    fooId: null,&#xA;    barId: null&#xA;  }&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on Viewer {&#xA;        requests(&#xA;          first: 10,&#xA;          fooId: $fooId,&#xA;          barId: $barId&#xA;        ) {&#xA;          edges {&#xA;            node {&#xA;              ${ RequestRow.getFragment('request') }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Note: if you're wondering why I'm passing up both fooID and barId instead of ""requestableType"" and ""requestableID"" it's because I'm using Elixir which doesn't support that type of polymorphism.</p>&#xA;",5062425,,,,2017-06-07 15:31:16,"",,0,0,0,2017-06-07 15:31:16
44436595,2,,44436233,5,,"<p>it must be like this;</p>&#xA;&#xA;<pre><code>...&#xA;return Db.models.elements.findAll({ &#xA;  limit: 3, &#xA;  where: args, &#xA;  order: [['created_at', 'DESC']] &#xA;});&#xA;</code></pre>&#xA;&#xA;<p><a href=""http://docs.sequelizejs.com/manual/tutorial/querying.html#pagination-limiting"" rel=""noreferrer"">http://docs.sequelizejs.com/manual/tutorial/querying.html#pagination-limiting</a>&#xA;<a href=""http://docs.sequelizejs.com/manual/tutorial/querying.html#ordering"" rel=""noreferrer"">http://docs.sequelizejs.com/manual/tutorial/querying.html#ordering</a></p>&#xA;",6260863,,6260863,2017-06-08 13:35:27,2017-06-08 13:35:27,"",,0,1,0,2017-06-08 13:05:15
44468315,1,,,0,102,"<p>In the Relay Modern example app <code>todo-modern</code> there is a file called database.js. Is this file necessary in all Relay Modern apps? If not, how do you define <code>{nodeInterface, nodeField}</code> without it? It seems to have all of these getter functions that I don't understand the point of.</p>&#xA;&#xA;<p>I'm finding that there is not enough documentation or examples of Relay Modern. It is quite frustrating.</p>&#xA;",437270,,,,2017-06-20 21:34:10,Relay Modern- what is database.js and is it necessary?,<react-native><graphql><relayjs><relay>,1,1,0,2017-06-10 00:26:28
44534644,1,44539223,,22,8384,"<p>With a sample make it easy understand, with <a href=""https://developer.github.com/v4/explorer/"" rel=""noreferrer"">https://developer.github.com/v4/explorer/</a> </p>&#xA;&#xA;<p>query the viewer info:</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    followers {&#xA;      totalCount&#xA;    }&#xA;    following {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>the result is:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""followers"": {&#xA;        ""totalCount"": 131&#xA;      },&#xA;      ""following"": {&#xA;        ""totalCount"": 28&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>what I want is:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""followersCount"" 131,&#xA;      ""followingCount"": 28&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>so does GraphQL support this ? and how to do it?</p>&#xA;",1525377,,,,2017-06-14 08:16:56,How to flat query result?,<graphql>,1,0,0,2017-06-14 02:54:37
44546216,2,,44507631,0,,"<p>Make sure that you have your resolver for <em>cars</em> set up as a sub query of <em>houses</em>. The result from the <em>houses</em> query should be passed as the <em>root</em> argument to the <em>cars</em> sub query.</p>&#xA;&#xA;<pre><code>type House {&#xA;  id&#xA;  color&#xA;  cars( type: String! ): [ Car ]&#xA;}&#xA;&#xA;type Car {&#xA;  name&#xA;  year&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Your resolver might look like:</p>&#xA;&#xA;<pre><code>Query: {&#xA;  async houses( root, args, context ) {&#xA;    return { ... houses ... }&#xA;  }&#xA;},&#xA;houses: {&#xA;  async cars( root, args, context ) {&#xA;    return { ... cars ... }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then create a resolver for <em>cars</em> that is nested underneath the <em>houses</em> query. Here's an article on it if you are using graphql-tools from Apollo: <a href=""http://dev.apollodata.com/tools/graphql-tools/resolvers.html"" rel=""nofollow noreferrer"">Writing resolvers with graphql-tools</a></p>&#xA;&#xA;<p>Hope this helps!</p>&#xA;",7993814,,,,2017-06-14 13:27:58,"",,0,0,0,2017-06-14 13:27:58
44547738,2,,44321127,0,,"<p>Is your server exposing the pageInfo of the connection correctly?. The <code>TodoConnection</code> type should have the following fields</p>&#xA;&#xA;<ol>&#xA;<li><code>edges: [TodoEdge]</code></li>&#xA;<li><code>pageInfo: PageInfo!</code></li>&#xA;</ol>&#xA;&#xA;<p>The <code>PageInfo</code> type should have the following fields:</p>&#xA;&#xA;<pre><code>endCursor: String&#xA;When paginating forwards, the cursor to continue.&#xA;&#xA;hasNextPage: Boolean!&#xA;When paginating forwards, are there more items?&#xA;&#xA;hasPreviousPage: Boolean!&#xA;When paginating backwards, are there more items?&#xA;&#xA;startCursor: String&#xA;When paginating backwards, the cursor to continue.&#xA;</code></pre>&#xA;&#xA;<p>I couldn't find an example either but I suggest you take a look at those types/fields. If you have GraphiQL installed in your stack then you could also try querying manually to discard any server related problems.</p>&#xA;",667598,,,,2017-06-14 14:34:10,"",,0,1,0,2017-06-14 14:34:10
44587362,1,44588834,,0,3268,"<p>I’ve got a question I can’t seemingly resolve on my own.</p>&#xA;&#xA;<p>Together with basic Query, Mutation and so on types I’ve made the following type definition:</p>&#xA;&#xA;<pre><code>module Types&#xA;  UserType = GraphQL::ObjectType.define do&#xA;    name 'User'&#xA;    description 'A user'&#xA;&#xA;    implements GraphQL::Relay::Node.interface&#xA;    global_id_field :id&#xA;&#xA;    field :email, !types.String, 'Email address'&#xA;&#xA;    connection :docs, DocType.connection_type, 'Available docs'&#xA;  end  &#xA;end&#xA;</code></pre>&#xA;&#xA;<p>And I then try to query it with:</p>&#xA;&#xA;<pre><code>query FileListQuery(&#xA;  $after: String&#xA;  $first: Int&#xA;) {&#xA;  viewer {&#xA;    currentUser {&#xA;      docs(first: $first, after: $after) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            name&#xA;            __typename&#xA;          }&#xA;          cursor&#xA;        }&#xA;        pageInfo {&#xA;          endCursor&#xA;          hasNextPage&#xA;          hasPreviousPage&#xA;          startCursor&#xA;        }&#xA;      }&#xA;      id&#xA;    }&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And I pass the following as query variables:</p>&#xA;&#xA;<pre><code>{&#xA;  ""first"": 1,&#xA;  ""after"": null&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem is it bails out with the following:</p>&#xA;&#xA;<pre><code>{&#xA;  ""errors"": [&#xA;    {&#xA;      ""message"": ""Int isn't a defined input type (on $first)"",&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 3,&#xA;          ""column"": 3&#xA;        }&#xA;      ],&#xA;      ""fields"": [&#xA;        ""query FileListQuery""&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I honestly have no clue why it complains about the Int type…</p>&#xA;&#xA;<p>If I get rid of the problematic <code>$first</code> query variable in the request, it works fine.</p>&#xA;&#xA;<p>This:</p>&#xA;&#xA;<pre><code>query FileListQuery(&#xA;  $after: String&#xA;) {&#xA;  viewer {&#xA;    currentUser {&#xA;      docs(first: 10, after: $after) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            name&#xA;            __typename&#xA;          }&#xA;          cursor&#xA;        }&#xA;        pageInfo {&#xA;          endCursor&#xA;          hasNextPage&#xA;          hasPreviousPage&#xA;          startCursor&#xA;        }&#xA;      }&#xA;      id&#xA;    }&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Produces this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""viewer"": {&#xA;      ""currentUser"": {&#xA;        ""docs"": {&#xA;          ""edges"": [&#xA;            {&#xA;              ""node"": {&#xA;                ""id"": ""1"",&#xA;                ""name"": ""First Doc"",&#xA;                ""__typename"": ""Doc""&#xA;              },&#xA;              ""cursor"": ""MQ==""&#xA;            }&#xA;          ],&#xA;          ""pageInfo"": {&#xA;            ""endCursor"": ""MQ=="",&#xA;            ""hasNextPage"": false,&#xA;            ""hasPreviousPage"": false,&#xA;            ""startCursor"": ""MQ==""&#xA;          }&#xA;        },&#xA;        ""id"": ""1""&#xA;      },&#xA;      ""id"": ""VIEWER""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any hints, ideas on how to fix this? I use the graphql gem v1.6.3.</p>&#xA;",355357,,,,2017-06-16 12:04:17,graphql-ruby: Int isn't a defined input type (on $first),<ruby-on-rails><ruby><graphql><graphql-ruby>,1,2,0,2017-06-16 10:47:16
44589353,2,,44574964,10,,"<p>You don't even need Relay connections to support pagination. Your query could simply accept a page number and size (or limit/offset) as arguments and return a list - done.&#xA;But, if you wanted Relay connection for e.g. <code>Book</code> type, you'd do something like the following:</p>&#xA;&#xA;<pre><code>Relay relay = new Relay();&#xA;GraphQLOutputType book = ...; //build your normal Book object type&#xA;GraphQLObjectType bookEdge = relay.edgeType(book.getName(), book, null, Collections.emptyList());&#xA;GraphQLObjectType bookConnection = relay.connectionType(book.getName(), bookEdge, Collections.emptyList());&#xA;</code></pre>&#xA;&#xA;<p>As a result, you'd have a <code>BookConnection</code> type that conforms to the <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""noreferrer"">Relay connection spec</a>.</p>&#xA;&#xA;<p>As for the example with basic GraphQL, you have a simple web app <a href=""https://github.com/graphql-java/todomvc-relay-java"" rel=""noreferrer"">here</a>.</p>&#xA;&#xA;<p>The connection spec naturally fits a data store that supports cursor based pagination, but needs some creativity when used with different pagination styles.</p>&#xA;&#xA;<p>1) If you wish to use simple offset based paging, you can decide to treat <code>after</code> as the offset (meaning a number would be passed), and <code>first</code> as the limit:</p>&#xA;&#xA;<pre><code>SELECT * FROM ORDER BY timestamp OFFSET $after LIMIT $first&#xA;</code></pre>&#xA;&#xA;<p>The same for <code>before</code> and <code>last</code>, just different direction.</p>&#xA;&#xA;<p>2) Another way is to treat <code>after</code>/<code>before</code> as the last seen value of the sort column (so an actual (obfuscated) value would be passed):</p>&#xA;&#xA;<pre><code>SELECT * FROM ORDER BY timestamp WHERE timestamp &gt; $after LIMIT $first&#xA;</code></pre>&#xA;&#xA;<p>I'd also recommend you take a look at my project, <a href=""https://github.com/leangen/graphql-spqr"" rel=""noreferrer"">graphql-spqr</a>, with <a href=""https://github.com/leangen/graphql-spqr-samples"" rel=""noreferrer"">an example app</a>, that makes developing GraphQL APIs dead simple.</p>&#xA;&#xA;<p>For example, you'd create a paginated result like this:</p>&#xA;&#xA;<pre><code>public class BookService {&#xA;    @GraphQLQuery(name = ""books"")&#xA;    //make sure the argument names and types match the Relay spec&#xA;    public Page&lt;Book&gt; getBooks(@GraphQLArgument(name = ""first"") int first, @GraphQLArgument(name = ""after"") String after) {&#xA;        //if you decide to fetch from a SQL DB, you need the limit and offset instead of a cursor&#xA;        //so, you can treat ""first"" as count as ""after"" as offset&#xA;        int offset = Integer.valueOf(after);&#xA;        List&lt;Book&gt; books = getBooksFromDB(first, offset);&#xA;        Page&lt;Book&gt; bookPage = PageFactory.createOffsetBasedPage(books, totalBookCount, offset);&#xA;        return bookPage;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>There's many other ways to create a <code>Page</code> instance, this is just the most straight-forward one.</p>&#xA;&#xA;<p>You'd then generate a schema from your Java class:</p>&#xA;&#xA;<pre><code>GraphQLSchema schema = new GraphQLSchemaGenerator()&#xA;       .withOperationsFromSingleton(new BookService())&#xA;       .generate();&#xA;GraphQL graphQL = GraphQLRuntime.newGraphQL(schema).build();&#xA;</code></pre>&#xA;&#xA;<p>And execute a query:</p>&#xA;&#xA;<pre><code>ExecutionResult result = graphQL.execute(""{books(first:10, after:\""20\"") {"" +&#xA;                ""   pageInfo {"" +&#xA;                ""       hasNextPage"" +&#xA;                ""   },"" +&#xA;                ""   edges {"" +&#xA;                ""       cursor, node {"" +&#xA;                ""           title"" +&#xA;                ""}}}}"");&#xA;</code></pre>&#xA;&#xA;<p>But, again, <strong>if you are not using Relay there's really no need to overcomplicate things</strong>. If your storage supports cursor-based pagination naturally, go for it. If it doesn't, just use the simple limit/offset arguments and return a list, and forget the connection spec. It was created to enable Relay to automatically manage paging in various scenarios, so it's almost always a total overkill if you're not using Relay and/or a DB with cursor-based pagination.</p>&#xA;",294657,,294657,2018-09-12 13:00:41,2018-09-12 13:00:41,"",,0,6,0,2017-06-16 12:32:56
44607578,1,44634444,,0,1043,"<p>I have a relay container that conditionally fetches some fields using <code>@include(if: $variable)</code>, but I have to write the directive for each individual field:</p>&#xA;&#xA;<pre><code>const relayOptions = {&#xA;  initialVariables: {&#xA;    expandDetails: false,&#xA;  },&#xA;  fragments: {&#xA;    company: Relay.QL`&#xA;      fragment on Company {&#xA;        id&#xA;        name&#xA;        employees @include(if: $expandDetails) {&#xA;          fullName&#xA;        }&#xA;        admins @include(if: $expandDetails) {&#xA;          fullName&#xA;        }&#xA;        departments @include(if: $expandDetails) {&#xA;          name&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there any way that I could write the directive only once, for example something like this (and I know this code won't work):</p>&#xA;&#xA;<pre><code>const relayOptions = {&#xA;  initialVariables: {&#xA;    expandDetails: false,&#xA;  },&#xA;  fragments: {&#xA;    company: Relay.QL`&#xA;      fragment on Company {&#xA;        id&#xA;        name&#xA;        @include(if: $expandDetails) {&#xA;          employees {&#xA;            fullName&#xA;          }&#xA;          admins {&#xA;            fullName&#xA;          }&#xA;          departments {&#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I tried some other crazy ways but none of them worked, I got this error:</p>&#xA;&#xA;<blockquote>&#xA;  <p>'@include' can't be applied to fragment definitions (allowed: fields, fragment spreads, inline fragments)</p>&#xA;</blockquote>&#xA;&#xA;<p>Edit: Note: I need to do that to avoid fetching data unnecessarily. I'd like to only fetch the data if the collapsible component displaying the data is expanded (planning to do that using <code>setVariables</code> after component is mounted).&#xA;In this example there are only 3 conditional fields, but in the actual case I'm trying to solve for there is a lot more than that.</p>&#xA;",5003820,,383759,2017-06-18 09:35:01,2017-06-19 15:27:05,Use @include directive for more than one field,<graphql><relayjs>,1,0,0,2017-06-17 17:45:36
44665457,2,,42235417,0,,<p>The typical pattern is to create a fragment for the content and then nest the elements in the query. E.g.</p>&#xA;&#xA;<pre><code>fragment ViewContent on ViewNode {&#xA;  name&#xA;}&#xA;&#xA;query ViewQuery {&#xA;  root {&#xA;    viewNode {&#xA;      ...ViewContent&#xA;      viewNode {&#xA;        ...ViewContent&#xA;        viewNode {&#xA;           ...ViewContent&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,6995981,,,,2017-06-21 01:30:24,"",,0,0,0,2017-06-21 01:30:24
44705358,1,,,0,451,"<p>I don't know why my loadMore doesn't work, this is my code in my pagination: </p>&#xA;&#xA;<pre><code>   todos(first: $count # count is default to 2&#xA;        ) @connection(key: ""TodoList_todos"") { #&#xA;          edges {&#xA;            cursor&#xA;            node {&#xA;              id,&#xA;              complete,&#xA;              ...Todo_todo,&#xA;            }&#xA;          }&#xA;           pageInfo {&#xA;              endCursor&#xA;              hasNextPage&#xA;              hasPreviousPage&#xA;              startCursor&#xA;           }&#xA;</code></pre>&#xA;&#xA;<p>Why would my hasMore() return false when hasNextPage returns true? how do I fix this? </p>&#xA;",5288560,,,,2017-06-24 03:03:09,I cannot do loadMore because hasMore() returns false always even if hasNextPage is true?,<reactjs><graphql><relayjs><relay>,1,0,0,2017-06-22 16:56:56
44732332,2,,44705358,1,,"<p>Are you setting getConnectionFromProps?<br>&#xA;Probably need to be like props.todos.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>module.exports = createPaginationContainer(&#xA;  Todos,&#xA;  {&#xA;    todos: graphql`&#xA;      todos(first: $count # count is default to 2&#xA;          ) @connection(key: ""TodoList_todos"") { #&#xA;            edges {&#xA;              cursor&#xA;              node {&#xA;                id,&#xA;                complete,&#xA;                ...Todo_todo,&#xA;          }&#xA;            }&#xA;             pageInfo {&#xA;                endCursor&#xA;                hasNextPage&#xA;                hasPreviousPage&#xA;                startCursor&#xA;             }&#xA;    `&#xA;  },&#xA;  {&#xA;    direction: 'forward',&#xA;    getConnectionFromProps: props =&gt; props.todos,&#xA;    getFragmentVariables: (vars, totalCount) =&gt; ({&#xA;      ...vars,&#xA;      count: totalCount,&#xA;    }),&#xA;    getVariables: (props, {count, cursor}) =&gt; ({&#xA;      count,&#xA;      cursor&#xA;    }),&#xA;    environment: environment,&#xA;    query: graphql`&#xA;      query TodosPaginationQuery($count: Int!, $cursor: String) {&#xA;        ...ShopList_shops&#xA;      }&#xA;    `&#xA;  }&#xA;);&#xA;</code></pre>&#xA;",4514256,,,,2017-06-24 03:03:09,"",,0,0,0,2017-06-24 03:03:09
44737454,1,45951319,,3,1293,"<p>I'm using Relay Modern for my app and am trying to update the cache after a mutation using the <a href=""https://facebook.github.io/relay/docs/mutations.html"" rel=""nofollow noreferrer""><code>updater</code> and <code>optimisticUpdater</code></a> but it doesn't quite work.</p>&#xA;&#xA;<p>Basically, I have a <code>Link</code> type with a <code>votes</code> connection - here's the relevant part of my schema:</p>&#xA;&#xA;<pre><code>type Link implements Node {&#xA;  createdAt: DateTime!&#xA;  description: String!&#xA;  id: ID!&#xA;  postedBy(filter: UserFilter): User&#xA;  url: String!&#xA;  votes(filter: VoteFilter, orderBy: VoteOrderBy, skip: Int, after: String, before: String, first: Int, last: Int): VoteConnection&#xA;}&#xA;&#xA;type Vote implements Node {&#xA;  createdAt: DateTime!&#xA;  id: ID!&#xA;  link(filter: LinkFilter): Link!&#xA;  updatedAt: DateTime!&#xA;  user(filter: UserFilter): User!&#xA;}&#xA;&#xA;# A connection to a list of items.&#xA;type VoteConnection {&#xA;  # Information to aid in pagination.&#xA;  pageInfo: PageInfo&#xA;&#xA;  # A list of edges.&#xA;  edges: [VoteEdge]&#xA;&#xA;  # Count of filtered result set without considering pagination arguments&#xA;  count: Int!&#xA;}&#xA;&#xA;# An edge in a connection.&#xA;type VoteEdge {&#xA;  # The item at the end of the edge.&#xA;  node: Vote&#xA;&#xA;  # A cursor for use in pagination.&#xA;  cursor: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here's the code for my <code>Link</code> component request the <code>votes</code> in a fragment:</p>&#xA;&#xA;<pre><code>class Link extends Component {&#xA;&#xA;  render() {&#xA;    const userId = localStorage.getItem(GC_USER_ID)&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {userId &amp;&amp; &lt;div onClick={() =&gt; this._voteForLink()}&gt;▲&lt;/div&gt;}&#xA;        &lt;div&gt;{this.props.link.description} ({this.props.link.url})&lt;/div&gt;&#xA;        &lt;div&gt;{this.props.link.votes.edges.length} votes | by {this.props.link.postedBy ? this.props.link.postedBy.name : 'Unknown'} {this.props.link.createdAt}&lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;&#xA;  _voteForLink = () =&gt; {&#xA;    const userId = localStorage.getItem(GC_USER_ID)&#xA;    const linkId = this.props.link.id&#xA;    CreateVoteMutation(userId, linkId, this.props.viewer.id)&#xA;  }&#xA;&#xA;}&#xA;&#xA;export default createFragmentContainer(Link, graphql`&#xA;  fragment Link_viewer on Viewer {&#xA;    id&#xA;  }&#xA;  fragment Link_link on Link {&#xA;    id&#xA;    description&#xA;    url&#xA;    createdAt&#xA;    postedBy {&#xA;      id&#xA;      name&#xA;    }&#xA;    votes(last: 1000, orderBy: createdAt_DESC) @connection(key: ""Link_votes"", filters: []) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          user {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`)&#xA;</code></pre>&#xA;&#xA;<p>Finally, this is the <code>CreateVoteMutation</code> with the <code>updater</code>:</p>&#xA;&#xA;<pre><code>const mutation = graphql`&#xA;  mutation CreateVoteMutation($input: CreateVoteInput!) {&#xA;    createVote(input: $input) {&#xA;      vote {&#xA;        id&#xA;        link {&#xA;          id&#xA;        }&#xA;        user {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;&#xA;export default (userId, linkId, viewerId) =&gt; {&#xA;  const variables = {&#xA;    input: {&#xA;      userId,&#xA;      linkId,&#xA;      clientMutationId: """"&#xA;    },&#xA;  }&#xA;&#xA;  commitMutation(&#xA;    environment,&#xA;    {&#xA;      mutation,&#xA;      variables,&#xA;      updater: (proxyStore) =&gt; {&#xA;        const createVoteField = proxyStore.getRootField('createVote')&#xA;        const newVote = createVoteField.getLinkedRecord('vote')&#xA;&#xA;        const viewerProxy = proxyStore.get(viewerId)&#xA;        const connection = ConnectionHandler.getConnection(viewerProxy, 'Link_votes')&#xA;        // `connection` is undefined, so the `newVote` doesn't get inserted&#xA;        if (connection) {&#xA;          ConnectionHandler.insertEdgeAfter(connection, newVote)&#xA;        }&#xA;      },&#xA;      onError: err =&gt; console.error(err),&#xA;    },&#xA;  )&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The call to <code>ConnectionHandler.getConnection(viewerProxy, 'Link_votes')</code> only returns <code>undefined</code>, so the <code>newVote</code> doesn't actually get inserted.</p>&#xA;&#xA;<p>Does anyone see what I'm doing wrong?</p>&#xA;",1779113,,710693,2017-08-11 00:28:46,2017-08-30 03:14:36,`updater` not working with Relay Modern because `ConnectionHandler.getConnection()` returns `undefined`,<reactjs><graphql><relayjs><relaymodern>,1,1,0,2017-06-24 14:28:38
44746923,1,,,43,26331,<p>I have a tree data structure that I would like to return via a GraphQL API. </p>&#xA;&#xA;<p>The structure is not particularly large (small enough not to be a problem to return it in one call).</p>&#xA;&#xA;<p>The maximum depth of the structure is not set.</p>&#xA;&#xA;<p>I have modeled the structure as something like:</p>&#xA;&#xA;<pre><code>type Tag{&#xA;    id: String!&#xA;    children: [Tag]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem appears when one wants to get the tags to an arbitrary depth.</p>&#xA;&#xA;<p>To get all the children to (for example) level 3 one would write a query like:</p>&#xA;&#xA;<p><code>&#xA;   {&#xA;      tags { &#xA;         id&#xA;         children {&#xA;              id&#xA;              children {&#xA;                  id&#xA;              }&#xA;         }&#xA;      }&#xA;   }&#xA;</code></p>&#xA;&#xA;<p>Is there a way to write a query to return all the tags to an arbitrary depth?</p>&#xA;&#xA;<p>If not what is the recommended way to model a structure like the one above in a GraphQL API.</p>&#xA;,4726353,,4726353,2017-06-25 18:35:41,2022-08-26 10:47:45,How to model recursive data structures in GraphQL,<graphql>,2,4,0,2017-06-25 13:38:39
44757064,1,44845079,,1,1351,"<p>I'm building a React Native application using GraphQL (Hosted on graph.cool) with a Relay Schema. &#xA;I have a QueryRenderer in the top-level component, fetching data for the presentational components using fragments, which is working fine. </p>&#xA;&#xA;<p>My problem: I want to do an introspection query to fetch possible enum values as a list, for a specific field in my schema and fetch these alongside the fragments.&#xA;My current query with fragments:</p>&#xA;&#xA;<pre><code>query ReportingContainerQuery {&#xA;    viewer {&#xA;        ...MainList_items&#xA;           ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The MainList_items fragment:</p>&#xA;&#xA;<pre><code>fragment AnimalList_items on Viewer {&#xA;    allAnimalCategories {&#xA;        edges {&#xA;            node{&#xA;                id&#xA;                ...AnimalListRow_item&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I got the following query working for fetching enumValues via introspection (using: <a href=""https://www.graph.cool/forum/t/how-to-access-the-possible-values-of-an-enum-type-created-inside-the-console/23/2"" rel=""nofollow noreferrer"">https://www.graph.cool/forum/t/how-to-access-the-possible-values-of-an-enum-type-created-inside-the-console/23/2</a>):</p>&#xA;&#xA;<pre><code>query {&#xA;    __type(name: ""JOURNAL_ENTRY_GENDER"") {&#xA;        enumValues {&#xA;            name&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But i can't seem to find a way to create a fragment that can be added to the top-level query.&#xA;I could just paste the introspection directly into the top-level query, but that would kind of work against the relay framework, as far as I understand it. Since doing it this way I would have to explicitly pass the result down as a props, instead of letting the presentational component specify what it needs and supplying that as a fragment to the QueryRenderer at the top-level and letting the relay framework implicitly pass the query result down to the component.</p>&#xA;",2978799,,2978799,2017-06-26 10:05:26,2017-06-30 11:11:15,Introspection query for EnumValues as a GraphQL fragment in react-component,<react-native><enums><graphql><relayjs>,1,0,0,2017-06-26 09:53:28
44761325,1,,,3,67,"<p>I have been trying to figure out how I want to implement pagination in my graphql api. I was thinking of following <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay Cursor Connections Specification</a></p>&#xA;&#xA;<p>This is simple enough building something that looks like</p>&#xA;&#xA;<pre><code>{&#xA;  allFilms {&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        title&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;      startCursor&#xA;      endCursor&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My question is around the cursor. I always thought the cursor was the equivalent of an id/primary key. From my reading it is not. It is a point/location in the connection.</p>&#xA;&#xA;<p>Can someone explain to me what it is and where it comes from. Is this a NoSql concept? I am guessing when connecting to a relational database the cursor would be the id/primary key?</p>&#xA;",799618,,,,2017-06-26 14:01:01,Where do my cursors come from for my edges?,<graphql>,1,0,0,2017-06-26 13:50:01
44804401,1,,,1,1327,"<p>I am using this nice <a href=""https://github.com/sysgears/apollo-universal-starter-kit"" rel=""nofollow noreferrer"">apollo-universal-starter-kit</a> in one of my projects. I have a task to add a filtering option to <a href=""https://apollo-universal-starter-kit.herokuapp.com/posts"" rel=""nofollow noreferrer"">this page</a> to filter posts that have more than 2 comments.</p>&#xA;&#xA;<p>The starter kit uses Apollo <a href=""https://github.com/apollographql/graphql-server"" rel=""nofollow noreferrer"">graphql-server</a> as the back-end. The schema description for the posts looks like this:</p>&#xA;&#xA;<pre><code># Post&#xA;type Post {&#xA;  id: Int!&#xA;  title: String!&#xA;  content: String!&#xA;  comments: [Comment]&#xA;}&#xA;&#xA;# Comment&#xA;type Comment {&#xA;  id: Int!&#xA;  content: String!&#xA;}&#xA;&#xA;# Edges for PostsQuery&#xA;type PostEdges {&#xA;  node: Post&#xA;  cursor: Int&#xA;}&#xA;&#xA;# PageInfo for PostsQuery&#xA;type PostPageInfo {&#xA;  endCursor: Int&#xA;  hasNextPage: Boolean&#xA;}&#xA;&#xA;# Posts relay-style pagination query&#xA;type PostsQuery {&#xA;  totalCount: Int&#xA;  edges: [PostEdges]&#xA;  pageInfo: PostPageInfo&#xA;}&#xA;&#xA;extend type Query {&#xA;  # Posts pagination query&#xA;  postsQuery(limit: Int, after: Int): PostsQuery&#xA;  # Post&#xA;  post(id: Int!): Post&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>postsQuery</code> is used to generate a paginated result of the posts</p>&#xA;&#xA;<p>Here is how <code>postsQuery</code> resolves (complete code <a href=""https://github.com/sysgears/apollo-universal-starter-kit/blob/master/src/server/modules/post/resolvers.js"" rel=""nofollow noreferrer"">here</a>)</p>&#xA;&#xA;<pre><code>async postsQuery(obj, { limit, after }, context) {&#xA;      let edgesArray = [];&#xA;      let posts = await context.Post.getPostsPagination(limit, after);&#xA;&#xA;      posts.map(post =&gt; {&#xA;        edgesArray.push({&#xA;          cursor: post.id,&#xA;          node: {&#xA;            id: post.id,&#xA;            title: post.title,&#xA;            content: post.content,&#xA;          }&#xA;        });&#xA;      });&#xA;&#xA;      let endCursor = edgesArray.length &gt; 0 ? edgesArray[edgesArray.length - 1].cursor : 0;&#xA;&#xA;      let values = await Promise.all([context.Post.getTotal(), context.Post.getNextPageFlag(endCursor)]);&#xA;&#xA;      return {&#xA;        totalCount: values[0].count,&#xA;        edges: edgesArray,&#xA;        pageInfo: {&#xA;          endCursor: endCursor,&#xA;          hasNextPage: values[1].count &gt; 0&#xA;        }&#xA;      };&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>And, here is a graphql query which is used on the front-end with React <code>post_list</code> component (complete code for the component is <a href=""https://github.com/sysgears/apollo-universal-starter-kit/blob/master/src/client/modules/post/containers/post_list.jsx"" rel=""nofollow noreferrer"">here</a>)</p>&#xA;&#xA;<pre><code>query getPosts($limit: Int!, $after: ID) {&#xA;    postsQuery(limit: $limit, after: $after) {&#xA;        totalCount&#xA;        edges {&#xA;            cursor&#xA;            node {&#xA;                ... PostInfo&#xA;            }&#xA;        }&#xA;        pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This was a long introduction :-), sorry</p>&#xA;&#xA;<p><strong>Question:</strong></p>&#xA;&#xA;<p>How can I add filtering option to the <code>post_list</code> component/page? I kind of understand the React side of the question, but I do not understand the graphql one. Should I add a new variable to the <code>postsQuery(limit: $limit, after: $after)</code> so it looks like <code>postsQuery(limit: $limit, after: $after, numberOfComments: $numberOfComments)</code>? And then somehow resolve it on the back-end? Or, I am on the wrong track and should think in the different direction? If so, can you point me to the right direction? :-)</p>&#xA;&#xA;<p>Thank you in advance!</p>&#xA;",1897222,,1897222,2017-06-28 15:11:14,2017-06-28 17:09:28,Add filtering option to the graphql paginated query,<reactjs><graphql><apollo><react-apollo><apollo-client>,1,0,0,2017-06-28 13:49:35
44833284,2,,44718542,2,,"<p>I was able to make it work, this is how I implemented the <code>updater</code> now:</p>&#xA;&#xA;<pre><code>NewLinkSubscription(&#xA;  proxyStore =&gt; {&#xA;    const linkField = proxyStore.getRootField('Link')&#xA;    const newLink = linkField.getLinkedRecord('node')&#xA;    const viewerProxy = proxyStore.get(this.props.viewer.id)&#xA;    const connection = ConnectionHandler.getConnection(viewerProxy, 'LinkList_allLinks', {&#xA;      last: 100,&#xA;      orderBy: 'createdAt_DESC'&#xA;    })&#xA;    if (connection) {&#xA;      const edge = ConnectionHandler.createEdge(proxyStore, connection, newLink, 'allLinks')&#xA;      ConnectionHandler.insertEdgeBefore(connection, edge)&#xA;    }&#xA;  },&#xA;  error =&gt; console.log(`An error occurred:`, error),&#xA;)&#xA;</code></pre>&#xA;",1779113,,,,2017-06-29 19:16:58,"",,0,0,0,2017-06-29 19:16:58
44843593,1,,,0,96,"<p>Here is my mutation class definition that I am using for creating fields. For update I am using another class which gives me updated custom field only which is also described below.  </p>&#xA;&#xA;<p>This is for create mutation.</p>&#xA;&#xA;<pre><code>import Relay from ""react-relay"";&#xA;&#xA;class CustomFieldCreateMutation extends Relay.Mutation {&#xA;&#xA;   constructor(props) {&#xA;      super(props);&#xA;   }&#xA;&#xA;   getMutation() {&#xA;      return Relay.QL `&#xA;                mutation customField { createField }&#xA;            `;&#xA;   }&#xA;&#xA;   getVariables() {&#xA;      return {&#xA;         customFieldDefinition: {&#xA;            name: this.props.customFieldName,&#xA;            schema: {&#xA;               type: this.props.customFieldType,&#xA;               format: this.props.customFieldFormat,&#xA;               title: this.props.title,&#xA;               allowedOperations: this.props.allowedOperations,&#xA;               allowedValues: this.props.allowedValues&#xA;            },&#xA;            associatedEntityTypes: this.props.associatedEntityTypes&#xA;         }&#xA;      };&#xA;   }&#xA;&#xA;   getFatQuery() {&#xA;      return Relay.QL `&#xA;                fragment on CreateCommon_CustomFieldDefinitionPayload {&#xA;                    customFieldEdge,&#xA;                    company{&#xA;                        customFields&#xA;                    }&#xA;                  }&#xA;            `;&#xA;   }&#xA;&#xA;   getConfigs() {&#xA;      return [{&#xA;         type: ""RANGE_ADD"",&#xA;         parentName: ""company"",&#xA;         parentID: this.props.company.id,&#xA;         connectionName: ""createField"",&#xA;         edgeName: ""customFieldEdge"",&#xA;         rangeBehaviors: {&#xA;            """": ""append""&#xA;         }&#xA;      }];&#xA;   }&#xA;}&#xA;&#xA;export default CustomFieldCreateMutation;&#xA;&#xA;//// This is for update mutation class.&#xA;&#xA;import Relay from ""react-relay"";&#xA;&#xA;class CustomFieldUpdateMutation extends Relay.Mutation {&#xA;&#xA;   constructor(props) {&#xA;      super(props);&#xA;   }&#xA;&#xA;   getMutation() {&#xA;      return Relay.QL `&#xA;            mutation customField { updateField }&#xA;        `;&#xA;   }&#xA;&#xA;   getVariables() {&#xA;      return {&#xA;         commonCustomFieldDefinition: {&#xA;            id: this.props.customFieldId,&#xA;            name: this.props.customFieldName,&#xA;            deleted: !this.props.isActive,&#xA;            schema: {&#xA;               type: this.props.customFieldType,&#xA;               title: this.props.title,&#xA;               format: this.props.customFieldFormat,&#xA;               allowedOperations: this.props.allowedOperations,&#xA;               allowedValues: this.props.allowedValues&#xA;            },&#xA;            associatedEntityTypes: this.props.associatedEntityTypes&#xA;         }&#xA;      };&#xA;   }&#xA;&#xA;   getFatQuery() {&#xA;      return Relay.QL `&#xA;            fragment on UpdateCommon_CustomFieldDefinitionPayload {&#xA;                customField&#xA;              }&#xA;        `;&#xA;   }&#xA;&#xA;   getConfigs() {&#xA;      return [{&#xA;         type: ""FIELDS_CHANGE"",&#xA;         fieldIDs: {&#xA;            customField: this.props.customFieldId&#xA;         }&#xA;      }];&#xA;   }&#xA;}&#xA;&#xA;export default CustomFieldUpdateMutation;&#xA;</code></pre>&#xA;",6836965,,7750640,2017-06-30 16:26:55,2017-06-30 16:26:55,How can we get last created field in graphQL create mutation call response,<javascript><reactjs><graphql><relayjs><relay>,0,3,0,2017-06-30 09:51:53
44845079,2,,44757064,2,,"<p>After some tinkering around i found a way to solve it - it leaves two places to maintain the fragments query, but it was the only way I found that solved it. :)</p>&#xA;&#xA;<p>In my component i defined the following fragment: </p>&#xA;&#xA;<pre><code>fragment GenderTile_items on __Type {&#xA;  enumValues{&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then in my main container, i expanded the query in the QueryRenderer with the following</p>&#xA;&#xA;<pre><code>query ReportingContainerQuery {&#xA;  viewer {&#xA;    ...MainList_items&#xA;       ...&#xA;  }&#xA;&#xA;  __type(name: ""JOURNAL_ENTRY_GENDER""){&#xA;     ...GenderTile_items&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The resulting enum data from the QueryRenderer is then available in the successblock by passing 'props.__type' down to the component with the corresponding fragment and from there accessing props.items.enumValues (As the prop for the data was defined as 'items' in the fragment (e.g GenderTile_<strong>items</strong> when following the naming convention 'FileName_propName'. (<a href=""https://facebook.github.io/relay/docs/fragment-container.html#data-dependencies-with-graphql"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/fragment-container.html#data-dependencies-with-graphql</a>)).</p>&#xA;&#xA;<p>I then ran into the problem where i wanted to fetch more than one type of enums and the query returned an error with duplicate __type assignments. This can be fixed this by using alias' like this:</p>&#xA;&#xA;<pre><code>query ReportingContainerQuery {&#xA;  viewer {&#xA;    ...MainList_items&#xA;       ...&#xA;  }&#xA;&#xA;  genderEnums: __type(name: ""JOURNAL_ENTRY_GENDER""){&#xA;     ...GenderTile_items&#xA;  }&#xA;&#xA;  otherEnums: __type(name: ""JOURNAL_ENTRY_OTHER""){&#xA;     ...OtherComponent_items&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The data is then available via props.[alias] (e.g. 'props.genderEnums' and 'props.otherEnums'), which you then pass to the component with the fragment and as above access it via props.items.enumValues.</p>&#xA;&#xA;<p>Hope that made sense for anyone else running into the same problem as me. :D</p>&#xA;",2978799,,,,2017-06-30 11:11:15,"",,0,0,0,2017-06-30 11:11:15
44854496,2,,41630743,19,,"<p>I know this question is 5 months old, but I hope this helps anyone else with this problem. He is passing his resolvers structured like</p>&#xA;&#xA;<pre><code>{&#xA;    Query: {&#xA;        GetAllFood(root) {&#xA;        return fetchFromAllFoodsEndpoint()&#xA;            .then((items) =&gt; {&#xA;            return mergeExtraFieldsByType(items);&#xA;            });&#xA;        },&#xA;    },&#xA;    FoodType: {&#xA;        __resolveType(food) {&#xA;        switch (food.type) {&#xA;            case 'pizza': return 'Pizza';&#xA;            case 'salad': return 'Salad';&#xA;            default: return 'BasicFood';&#xA;        }&#xA;        },&#xA;    },&#xA;    Pizza: {&#xA;        toppings({pizzaType}) {&#xA;        return fetchFromPizzaEndpoint(pizzaType);&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But he really wanted something like (not exactly, but I'm stressing the location of __resolveType relative to Query)</p>&#xA;&#xA;<pre><code>{&#xA;    Query: {&#xA;        GetAllFood(root) {&#xA;        return fetchFromAllFoodsEndpoint()&#xA;            .then((items) =&gt; {&#xA;            return mergeExtraFieldsByType(items);&#xA;            });&#xA;        },&#xA;    },&#xA;    FoodType: {&#xA;        __resolveType(data, ctx, info) {&#xA;            return whatIsTheType(data, ctx, info)&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The official documentation has an example <a href=""http://dev.apollodata.com/tools/graphql-tools/resolvers.html#Unions-and-interfaces"" rel=""noreferrer"">here</a>, but it ONLY includes the interface type, which I found confusing. I have an additional complete runnable example of Union types (configured identically to interfaces) available <a href=""https://gist.github.com/Piefayth/506d6c2dc375772121d6c6d7d349e918"" rel=""noreferrer"">here</a></p>&#xA;",2588895,,,,2017-06-30 20:37:47,"",,0,4,0,2017-06-30 20:37:47
44879933,2,,44601890,3,,"<p>Connection will help you <code>paginate</code> through the list of comments connected to the post with 4 default arguments (first, last, after and before) in the query, whereas field here would return a basic list of <code>CommentType</code></p>&#xA;&#xA;<p>For more on pagination with connection, read up here </p>&#xA;&#xA;<p><a href=""http://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">http://graphql.org/learn/pagination/</a></p>&#xA;",3302062,,,,2017-07-03 07:26:41,"",,0,0,0,2017-07-03 07:26:41
44882669,1,44898272,,0,1180,"<p>I have a Apollo GraphQL server talking to an API returning responses with roughly the following structure:</p>&#xA;&#xA;<pre><code>{&#xA;  ""pagination"": {&#xA;    ""page"": 1,&#xA;    // more stuff&#xA;  },&#xA;  sorting: {&#xA;    // even more stuff&#xA;  },&#xA;  data: [ // Actual data ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This structure is going to be shared across pretty much all responses from this API, that I'm using extensively. <code>data</code> is going to be an array most of the time, but can also be an object.</p>&#xA;&#xA;<p>How can I write this in an efficient way, so that I don't have to repeat all these <code>pagination</code> and <code>sorting</code> fields on every data type in my schemas?</p>&#xA;&#xA;<p>Thanks a lot!</p>&#xA;",1526814,,,,2017-08-10 02:14:54,Share structure between GraphQL schemas,<graphql><relay><graphql-js><apollo><react-apollo>,2,0,0,2017-07-03 09:57:47
44885085,1,,,4,1535,"<p>I've been trying relay-modern for some time, and I'm wondering what are the purposes of <code>createFragmentContainer</code> other than just for <em>describing</em> the fragment that <em>should</em> beloing to the <code>Component</code>.</p>&#xA;&#xA;<p>e.g. this is how documentation show how it is supposed to be</p>&#xA;&#xA;<p><strong>Parent.js</strong></p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  render={({error, props}) =&gt; {&#xA;    if (error || props) {&#xA;       return &lt;Child someData={someData}&gt;&#xA;    }&#xA;    return &lt;div&gt;Loading&lt;/div&gt;&#xA;  }}&#xA;&#xA;  query={graphql`&#xA;    query SomeQuery($id: ID!) {&#xA;      endpoint(id: $id) {&#xA;        ...Child_someData&#xA;      }&#xA;    }&#xA;  `}&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p><strong>Child.js</strong></p>&#xA;&#xA;<pre><code>export default createFragmentContainer( &#xA;  ({someData}) =&gt; &lt;header&gt;{someData.title} - {someData.name}&lt;/header&gt;,&#xA;  graphql`&#xA;    fragment Child_someData on EndPoint {&#xA;       title&#xA;       name&#xA;    }&#xA;  `&#xA;)&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p>But instead doing <code>Child.js</code> in that way, I can just rewrite or splitting the component with query to 2 different files like this:</p>&#xA;&#xA;<p><strong>ChildComponent.js</strong></p>&#xA;&#xA;<pre><code>export default ({someData}) =&gt; &lt;header&gt;{someData.title} - {someData.name}&lt;/header&gt;&#xA;</code></pre>&#xA;&#xA;<p><strong>Child.js</strong></p>&#xA;&#xA;<pre><code>export default graphql`&#xA;  fragment Child_someData on EndPoint {&#xA;    title&#xA;    name&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>and it is still going to work (<strong>Parent.js</strong> will still recognize the fragment). So this makes me wondering if <code>createFragmentContainer</code> just for syntactic sugar to make things tidier.</p>&#xA;&#xA;<p>If anyone can shed a light with this one, that would be awesome! can't find so much in the <a href=""https://facebook.github.io/relay/docs/fragment-container.html"" rel=""nofollow noreferrer"">documentation</a> about this</p>&#xA;",4162778,,710693,2017-08-11 00:28:31,2017-10-18 17:36:15,Relay Modern purpose of createFragmentContainer,<javascript><relayjs><graphql-js><relaymodern>,2,1,0,2017-07-03 12:02:03
44962729,1,44965973,,0,349,"<p>Morning guys, I'm currently working on writing GraphQL on top of REST API in it. Say that a JSON response is an object 'user' that contains elements such as id, name, email and an 'address' which is an object consisting of street, suite, city, and zipcode. How should I declare the type in the schema for this 'address' field, which contains multiple elements inside. I have seen the documentation and could not understand what would be the correct type for my scenario. </p>&#xA;&#xA;<p>The snippet of the schema related is below:</p>&#xA;&#xA;<pre><code>export default new GraphQLObjectType({&#xA;    name: 'User',&#xA;    description: 'User(s) object in JSONPlaceholder Fake API',&#xA;    fields: () =&gt; ({&#xA;        id: {&#xA;            type: GraphQLID&#xA;        },&#xA;        name: {&#xA;            type: GraphQLString&#xA;        },&#xA;        username: {&#xA;            type: GraphQLString&#xA;        },&#xA;        email: {&#xA;            type: GraphQLString&#xA;        },&#xA;        address: {&#xA;            type: (?)&#xA;        }&#xA;    })&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Below is my JSON API which I target.</p>&#xA;&#xA;<pre><code>{&#xA;  ""id"": 1,&#xA;  ""name"": ""Leanne Graham"",&#xA;  ""username"": ""Bret"",&#xA;  ""email"": ""Sincere@april.biz"",&#xA;  ""address"": {&#xA;    ""street"": ""Kulas Light"",&#xA;    ""suite"": ""Apt. 556"",&#xA;    ""city"": ""Gwenborough"",&#xA;    ""zipcode"": ""92998-3874"",&#xA;    ""geo"": {&#xA;      ""lat"": ""-37.3159"",&#xA;      ""lng"": ""81.1496""&#xA;    }&#xA;  },&#xA;  ""phone"": ""1-770-736-8031 x56442"",&#xA;  ""website"": ""hildegard.org"",&#xA;  ""company"": {&#xA;    ""name"": ""Romaguera-Crona"",&#xA;    ""catchPhrase"": ""Multi-layered client-server neural-net"",&#xA;    ""bs"": ""harness real-time e-markets""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think of creating separate objects and creating resolver to only fetch that particular 'address' object, but that means I'm querying twice. I assume there might be some workaround to avoid this.</p>&#xA;&#xA;<p>Thanks in advance!</p>&#xA;",8268612,,5855223,2017-07-07 04:57:38,2017-07-07 08:23:32,GraphQL on top of REST API,<javascript><json><rest><graphql>,1,0,0,2017-07-07 04:46:17
44975471,1,45010381,,1,1139,"<p>When using <code>react-apollo</code> with redux, data from the server is cached in the redux store under an <code>apollo</code> key:</p>&#xA;&#xA;<pre><code>{&#xA;    apollo: // results from Apollo queries&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>After creating your own reducers and corresponding state tree, your store might look like this:</p>&#xA;&#xA;<pre><code>{&#xA;    apollo: { ... },&#xA;    ui: {&#xA;        selectedItem: 2;&#xA;        showItems: 6&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Imagine that there is an action which changes the value of <code>ui.selectedItem</code>, and that this value is the index of an item buried somewhere in the <code>apollo</code> object. </p>&#xA;&#xA;<p>With <a href=""http://redux.js.org/docs/recipes/reducers/RefactoringReducersExample.html"" rel=""nofollow noreferrer"">reducer composition</a>, reducers for our <code>ui</code> state will rightly have no access to anything under the Apollo state.</p>&#xA;&#xA;<p>In our component we can subscribe to changes on our <code>ui</code> state via <code>mapStateToProps</code>, and we can map Apollo results to props using the <code>react-apollo</code> GraphQL container (or <code>@graphql</code> decorator).</p>&#xA;&#xA;<p>But how can we update our store with values that are computed from Apollo results and other state in our application?</p>&#xA;&#xA;<p>For example, if <code>apollo.item.list</code> is an array of items, and <code>ui.selectedItem</code> is the index you want to target in that list - how could the store contain a value for: </p>&#xA;&#xA;<pre><code>apollo.item.list[ui.selectedItem]&#xA;</code></pre>&#xA;",3252835,,3252835,2017-07-07 16:20:36,2017-08-05 14:26:18,React Apollo and Redux: Combine custom reducers with Apollo state,<node.js><reactjs><react-redux><graphql><react-apollo>,3,0,0,2017-07-07 16:14:52
44977258,2,,44348225,2,,"<p>You can now define the key for the queries cache store like this:</p>&#xA;&#xA;<pre><code> query AllItems($cursor: String, $limit: Int, $query: String) {&#xA;  items(cursor: $cursor, limit: $limit, query: $query) @connection(key: ""AllItemsQuery"") {&#xA;    count&#xA;    cursor&#xA;    has_next&#xA;    has_prior&#xA;    data{&#xA;      ...CoreItem&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3990170,,,,2017-07-07 18:13:04,"",,0,5,0,2017-07-07 18:13:04
44981204,2,,44975471,4,,"<p>You're right -- with reducer composition, each reducer should not have access to the rest of the state. The question is why would you even need your <strong>store</strong> to contain a separate value for <code>apollo.item.list[ui.selectedItem]</code>.</p>&#xA;&#xA;<p>Presumably you need this value to render the correct item inside your container. To calculate it, you just need an appropriate selector to call within mapStateToProps. Pass in the whole state, get the value you need. A simplified example: </p>&#xA;&#xA;<pre><code>const mapStateToProps = state =&gt; ({&#xA;  itemToShow: itemSelector(state)&#xA;})&#xA;&#xA;const itemSelector = ({ apollo, ui }) =&gt; apollo.item.list[ui.selectedItem]&#xA;</code></pre>&#xA;&#xA;<p>You'll need to wrap your container in both the <code>connect</code> and <code>graphql</code> HOCs to make that work, although as far as I can tell, whether you wrap it in one or the other first doesn't seem to matter. You can also look into using <a href=""https://github.com/reactjs/reselect"" rel=""nofollow noreferrer"">reselect</a> which is ideal for derived data like this.</p>&#xA;&#xA;<p><strong>Edit:</strong> Since Apollo's chunk of the store wasn't really designed to be used as described above, you may find it easier to break this up into two steps instead: First, assign ui.selectedItem to a prop in mapStateToProps. Then, if you wrap your container with the graphql HOC, you can reference that prop like so:</p>&#xA;&#xA;<pre><code>const mapStateToProps = state =&gt; ({ selectedItem });&#xA;const mapDataToProps = ({ ownProps: { selectedItem }, data }) =&gt; ({&#xA;  itemToShow: data.item.list[selectedItem]&#xA;});&#xA;const ContainerWithData = graphql(myQuery, { props: mapDataToProps })(MyContainer);&#xA;&#xA;export default connect(mapStateToProps)(ContainerWithData);&#xA;</code></pre>&#xA;&#xA;<p>Or you could use apollo-react's <code>compose</code> for a cleaner approach.</p>&#xA;",6024220,,6024220,2017-07-08 17:27:28,2017-07-08 17:27:28,"",,0,4,0,2017-07-08 00:04:15
45022395,1,,,0,111,"<p>This isn't exactly a programming question, as I don't have an issue writing the code, but a database design question.  I need to create an app that tracks sales goals vs. actual sales over time.  The thing is, that a persons goal can change (let's say daily at most).  </p>&#xA;&#xA;<p>Also, a location can have multiple agents with different goals that need to be added together for the location.</p>&#xA;&#xA;<p>I've considered basically running a timed task to save daily goals per agent into a field.  It seems that over the years that will be a lot of data, but it would let me simply query a date range and add all the daily goals up to get an goal for that date range.</p>&#xA;&#xA;<p>Otherwise, I guess I could simply write changes (i.e. March 2nd - 15 sales / week, April 12th, 16 sales per week) which would be less data, but much more programming work to figure out goals based on a time query.</p>&#xA;&#xA;<p>I'm assuming there is probably a best practice for this - anyone?</p>&#xA;",1341807,,,,2017-07-11 00:16:06,Database Design: How do I handle tracking goals vs. actuals over time?,<database><database-design><graphql>,1,0,0,2017-07-10 22:07:06
45044836,1,,,0,429,"<p>I am using neo4j dB and I have set up apollo graphql server (using graphql-server-express). Lets say my schema has 3 types namely ""Country"", ""State"" and ""People"" where 1 country can have multiple states and 1 state can have multiple people. </p>&#xA;&#xA;<p>//Sample <strong>schema.js</strong></p>&#xA;&#xA;<pre><code>import { makeExecutableSchema } from 'graphql-tools';&#xA;&#xA;import resolvers from './resolvers';&#xA;&#xA; const typeDefs = `&#xA; type Country {&#xA;   id: Int! &#xA;   name: String&#xA;   state: [State]&#xA;   people: [People]&#xA;&#xA;  }&#xA;&#xA; type State {&#xA;     id: Int!&#xA;     name: String&#xA;     countryID: CountryID&#xA;     people: [People]&#xA;&#xA;   }&#xA;&#xA;   type People {&#xA;     id: Int!&#xA;     name: String&#xA;     SSN: String&#xA;     stateid:StateID&#xA;     countryid:CountryID&#xA;    }&#xA;&#xA;&#xA;    type Query {&#xA;      Countries: [Country]&#xA;      States: [State]&#xA;      Peoples: [People]&#xA;&#xA;      }&#xA;&#xA;    schema {&#xA;     query: Query&#xA;&#xA;    }&#xA;   `;&#xA;&#xA;   export default makeExecutableSchema({&#xA;      typeDefs: typeDefs,&#xA;      resolvers,&#xA;    });&#xA;</code></pre>&#xA;&#xA;<p><strong>So, how should I write my resolver function in resolver.js file such that it would help me to fetch the data properly from any of the above types ?</strong> </p>&#xA;&#xA;<p>I tried to use the following query in resolver.js file (to query the Neo4j database using Cypher query language), but got the type error and i am unable to fix it.</p>&#xA;&#xA;<p>//Sample resolver.js file.</p>&#xA;&#xA;<pre><code>let neo4j = require('neo4j-driver').v1;&#xA;let driver = neo4j.driver(""bolt://localhost"", neo4j.auth.basic(""neo4j"", &#xA;  ""******""));&#xA;&#xA; const resolver = {&#xA;  Query: {&#xA;     Countries(_, params) {&#xA;     let session = driver.session();&#xA;    let query = ""MATCH (country:Country)  RETURN country;""&#xA;    return session.run(query, params)&#xA;      .then( result =&gt; { return result.records.map(record =&gt; { return &#xA;      record.get(""country"").properties })})&#xA;    },&#xA; },&#xA;&#xA; State:{&#xA;   state(State) {&#xA;    let session = driver.session(),&#xA;       params = {countryid: Country.id},&#xA;       query = `&#xA;        MATCH (s:State-[:PRESENT]-&gt;(c:Country)&#xA;        WHERE s.countryid = $countryid&#xA;        RETURN s;&#xA;       `&#xA;       return session.run(query, params)&#xA;         .then( result =&gt; { return result.records.map(record =&gt; { return &#xA;     record.get(""state"").properties })})&#xA;      },&#xA;    },&#xA;  };&#xA;&#xA;export default resolver;&#xA;</code></pre>&#xA;",3213011,,,,2017-07-11 21:33:46,How should I write a resolver while using apollo graphql server backed by neo4j database?,<node.js><neo4j><graphql><apollo-server>,0,2,0,2017-07-11 21:33:46
45092577,2,,44989304,0,,"<p>I think your environnement is just fine.</p>&#xA;&#xA;<p>Few things that might help : You might want to create a FragmentContainer and setup/run <a href=""https://facebook.github.io/relay/docs/relay-compiler.html"" rel=""nofollow noreferrer"">Relay Compiler</a> to generate the needed graphql files in order to Relay run your queries.</p>&#xA;&#xA;<p>You probably want declare and collocate the data requirements with App through a FragmentContainer. You need a Fragment Container because your data is masked in App hence not available through props (<a href=""https://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking"" rel=""nofollow noreferrer"">see more</a> here why it's masked). </p>&#xA;&#xA;<p>You'll need to use <a href=""https://facebook.github.io/relay/docs/fragment-container.html"" rel=""nofollow noreferrer"">createFragmentContainer()</a> like this :</p>&#xA;&#xA;<pre><code>App = createFragmentContainer(&#xA;  App,&#xA;  graphql`&#xA;    fragment App_users on User { // The fragment name should follow the convention &lt;FileName&gt;_&lt;propName&gt;, so maybe you might the App component to an another file.&#xA;       user(id: ""u01"") {&#xA;        id&#xA;        username&#xA;      }&#xA;    }&#xA;  `,&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>Modify the Query to : </p>&#xA;&#xA;<pre><code>graphql`&#xA;  viewer {&#xA;    ...App_users_viewer&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>When done, you should be able to run the Relay Compiler and have graphql generated files</p>&#xA;",2871398,,,,2017-07-13 23:51:31,"",,0,0,0,2017-07-13 23:51:31
45134730,2,,45134512,4,,"<p>The reason this isn't working as you'd expect is because you've altered the structure of your state, as well as what gets passed to your original reducers. Where before your store looked something like this:</p>&#xA;&#xA;<pre><code>{&#xA; loadUI: true&#xA; isNoMatch: false&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, you've basically told Redux to look for:</p>&#xA;&#xA;<pre><code>{&#xA; apollo: {&#xA;   // ✁&#xA; }&#xA; reducers: {&#xA;   loadUI: true&#xA;   isNoMatch: false&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When you use combineReducers, you are essentially creating isolated domains for your state -- instead of passing in the entire state to each reducer, redux will only pass in a slice of the state to each reducer and that reducer will only be able to alter that slice of state. By structuring your store as shown above, you've told redux to pass only the <code>apollo</code> slice of the state to the apollo reducer... and the <code>reducers</code> part of the state to your original reducers.</p>&#xA;&#xA;<p>I'm guessing you haven't made any changes to <code>preloadedState</code>. So what's happening is redux is looking for a property in <code>preloadedState</code> called <code>reducers</code> and passing that to your reducers. It can't find one, so it passes in undefined.</p>&#xA;&#xA;<p>The easiest fix here is, first, pick something more descriptive than <code>reducers</code> -- <code>ui</code> maybe? Change your combineReducers accordingly. Then update your <code>preloadedState</code> so that whatever intial state you had is nested inside <code>ui</code>. Then it should work as expected. Just keep in mind you'll need to update your selectors and/or mapStateToProps functions too!</p>&#xA;&#xA;<p><strong>Edit:</strong> You may want to read up more about how combineReducers works <a href=""http://redux.js.org/docs/recipes/reducers/UsingCombineReducers.html"" rel=""nofollow noreferrer"">here</a>.</p>&#xA;",6024220,,6024220,2017-07-17 01:16:16,2017-07-17 01:16:16,"",,0,1,0,2017-07-17 01:10:33
45171855,1,45625475,,4,895,"<p>I have the following setup in my React Project:</p>&#xA;&#xA;<pre><code>export default class OverviewScreen extends React.Component&lt;any, any&gt; {&#xA;&#xA;public render() {&#xA;&#xA;    return (&#xA;        &lt;QueryRenderer&#xA;            environment={environment}&#xA;            query={OverviewScreenQuery}&#xA;            render={this.queryRender}/&gt;&#xA;    );&#xA;}&#xA;&#xA;protected queryRender({error, props}): JSX.Element {&#xA;&#xA;    if (error) {&#xA;        return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA;    } else if (props) {&#xA;        return (&#xA;            &lt;div&gt;&#xA;                &lt;div&gt;&#xA;                    &lt;ActivityOfferList viewer={props.viewer} title=""Titel""/&gt;&#xA;                    &lt;ActivityTypeListsFragment viewer={props.viewer}/&gt;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;    return &lt;div&gt;Loading...&lt;/div&gt;;&#xA;}&#xA;}&#xA;&#xA;const OverviewScreenQuery = graphql`&#xA;query OverviewScreenQuery {&#xA;    viewer {&#xA;        ...HorizontalOfferList_viewer&#xA;        ...ActivityTypeLists_viewer&#xA;    }&#xA;}`;&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<pre><code>class ActivityTypeLists extends React.Component&lt;IHorizontalOfferListProps, any&gt; {&#xA;&#xA;public render() {&#xA;&#xA;    return (&#xA;        &lt;div&gt;&#xA;        {this.props.viewer.allActivityTypes.edges.map((typeEdge) =&gt; {&#xA;            let typeNode = typeEdge.node;&#xA;            return this.getCardListForActivityType(typeNode);&#xA;        })}&#xA;        &lt;/div&gt;&#xA;    );&#xA;}&#xA;&#xA;private getCardListForActivityType(typeNode: any) {&#xA;    console.log(typeNode);&#xA;&#xA;    return (&#xA;        &lt;CardList key={typeNode.__id} title={typeNode.title}&gt;&#xA;            {typeNode.activities.edges.map(({node}) =&gt; {&#xA;                return (&#xA;                    &lt;RelayPicturedTypeActivityCard key={node.__id} offer={node} activityType={typeNode}/&gt;&#xA;                );&#xA;            })}&#xA;        &lt;/CardList&gt;&#xA;    );&#xA;}&#xA;}&#xA;&#xA;export const ActivityTypeListsFragment = createFragmentContainer(ActivityTypeLists, graphql`&#xA;fragment ActivityTypeLists_viewer on Viewer {&#xA;    allActivityTypes(first: 5) {&#xA;        edges {&#xA;            node {&#xA;                ...PicturedTypeActivityCard_offer&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;`);&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<pre><code>export class PicturedTypeActivityCard extends React.Component&lt;any, any&gt; {&#xA;&#xA;    public render() {&#xA;        return (&#xA;            &lt;PicturedCard title={this.props.offer.title} subtitle={this.props.activityType.title} width={3}/&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;export const RelayPicturedTypeActivityCard = createFragmentContainer(PicturedTypeActivityCard, graphql`&#xA;    fragment PicturedTypeActivityCard_offer on ActivityType {&#xA;        title&#xA;        activities(first: 4) {&#xA;            edges {&#xA;            node {&#xA;                id&#xA;                title&#xA;            }&#xA;        }&#xA;    }&#xA;    }&#xA;`);&#xA;</code></pre>&#xA;&#xA;<p>Which should work and give me the correct result from the graphcool relay endpoint.</p>&#xA;&#xA;<p><strong>The Network call to the relay endpoint is indeed correct and I receive all the ActivityTypes and their activities and titles from my endpoint.</strong></p>&#xA;&#xA;<p>But somehow in the function getCardListForActivityType() the typeNode only contains the __id of the node as data and no title at all:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/CuO93.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CuO93.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>If I insert title and activities directly instead of using </p>&#xA;&#xA;<pre><code>...PicturedTypeActivityCard_offer&#xA;</code></pre>&#xA;&#xA;<p>then the data also gets passed down correctly. So something with the Fragment must be off.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Why is it that the network call is complete and uses the fragment correctly to fetch the data, but the node object never gets the fetched data?</strong> </p>&#xA;",1123709,,710693,2017-08-11 00:40:20,2018-08-13 01:43:00,Relay Modern node does not contain fragment properties,<graphql><relayjs><graphcool><relaymodern>,1,0,0,2017-07-18 15:59:02
45200349,1,,,0,105,"<p>I have a <code>Relay</code> container that defines the following initialVariables and fragments:</p>&#xA;&#xA;<pre><code>  initialVariables: {&#xA;    enableExistingThreadQuery: false,&#xA;    recipientValue: null,&#xA;    contactId: null,&#xA;  },&#xA;  fragments: {&#xA;    viewer: () =&gt; Relay.QL`&#xA;      fragment on viewer {&#xA;        organization @include(if: $enableExistingThreadQuery) {&#xA;          existingThread (recipientValue: $recipientValue, contactId: $contactId) {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>So I need this query to run when I set <strong>recipientValue</strong> and <strong>contactId</strong>:</p>&#xA;&#xA;<pre><code>relay.setVariables({&#xA;  recipientValue: ...,&#xA;  contactId: ...,&#xA;  enableExistingThreadQuery: true,&#xA;}, readyState =&gt; {&#xA;  console.log(readyState);&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The <strong>first</strong> time I set these variables, this successfully runs the query and we get the data on the frontend. However, <strong>readyState</strong> only logs once with the following sequence of events:</p>&#xA;&#xA;<ul>&#xA;<li>NETWORK_QUERY_START</li>&#xA;<li>CACHE_RESTORE_START</li>&#xA;<li>ABORT</li>&#xA;</ul>&#xA;&#xA;<p>With no errors, but <code>done</code> and <code>ready</code> are both <strong>false</strong>.</p>&#xA;&#xA;<p>The <strong>second</strong> time I make this call to <code>relay.setVariables</code> it loads the data from the cache and <code>done</code> and <code>ready</code> are both <strong>true</strong>.</p>&#xA;&#xA;<p>What might be causing setVariables to abort the first time it's called, even when the data is still successfully returned?</p>&#xA;",2855707,,2855707,2017-07-19 20:32:31,2017-07-25 07:10:58,Relay readyState ABORT on first setVariables,<javascript><reactjs><graphql><relay>,1,0,0,2017-07-19 20:24:28
45236135,2,,45212761,0,,"<p>From what I've learned in the past days, It's not possible to do this just with bookshelf and graphql's philosophy doesn't allow something like this.</p>&#xA;&#xA;<p>The best option is to use <a href=""https://github.com/facebook/dataloader"" rel=""nofollow noreferrer"">dataloader</a>. Using it with bookshelf should be straight forward. I'll have to play with it to figure out the best pattern to use it.</p>&#xA;&#xA;<p>An example loader for the Page would be something like </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>var PageLoader = new Dataloader(keys =&gt; {&#xA; return Page&#xA;  .where('homework_id', 'IN', keys)&#xA;  .fetchAll()&#xA;  .then(collection =&gt; {&#xA;    var groupedItems = _.groupBy(collection.models, (el) =&gt; el.get('homework_id'))&#xA;    return _.map(keys, key =&gt; groupedItems[key])&#xA;  })&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>This can then be used as following in the HomeworkType</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>...&#xA;pages: {&#xA;  type: new GraphQLList(PageType),&#xA;  description: 'pages in the homework',&#xA;  resolve: (homework) =&gt; PageLoader.load(homework.id)&#xA;},&#xA;...&#xA;</code></pre>&#xA;",972531,,,,2017-07-21 11:08:11,"",,0,0,0,2017-07-21 11:08:11
45236519,1,,,5,790,"<p>I'm using React Apollo to query all records in my datastore so I can create choices within a search filter.</p>&#xA;&#xA;<p>The important database model I'm using is <code>Report</code>.</p>&#xA;&#xA;<p>A <code>Report</code> has <code>doorType</code>, <code>doorWidth</code>, <code>glass</code> and <code>manufacturer</code> fields.</p>&#xA;&#xA;<p>Currently when the query responds, I'm passing <code>allReports</code> to multiple dumb components which go through the array and just get the unique items to make a selectable list, like so..</p>&#xA;&#xA;<pre><code>const uniqueItems = []&#xA;&#xA;items.map(i =&gt; {&#xA;  const current = i[itemType]&#xA;&#xA;  if (typeof current === 'object') {&#xA;    if (uniqueItems.filter(o =&gt; o.id !== current.id)) {&#xA;      return uniqueItems.push(current)&#xA;    }&#xA;  } else if (!uniqueItems.includes(current)) {&#xA;    return uniqueItems.push(current)&#xA;  }&#xA;&#xA;  return&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Obviously this code isn't pretty and it's a bit overkill.</p>&#xA;&#xA;<p>I'd like to dispatch an action when the query returns within my <code>SidebarFilter</code> components. Here is the query...</p>&#xA;&#xA;<pre><code>const withData = graphql(REPORT_FILTER_QUERY, {&#xA;  options: ({ isPublished }) =&gt; ({&#xA;    variables: { isPublished }&#xA;  })&#xA;})&#xA;&#xA;const mapStateToProps = ({&#xA;  reportFilter: { isPublished }&#xA;  // filterOptions: { doorWidths }&#xA;}) =&gt; ({&#xA;  isAssessment&#xA;  // doorWidths&#xA;})&#xA;&#xA;const mapDispatchToProps = dispatch =&gt;&#xA;  bindActionCreators(&#xA;    {&#xA;      resetFilter,&#xA;      saveFilter,&#xA;      setDoorWidths,&#xA;      handleDoorWidthSelect&#xA;    },&#xA;    dispatch&#xA;  )&#xA;&#xA;export default compose(connect(mapStateToProps, mapDispatchToProps), withData)(&#xA;  Filter&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>The Redux action <code>setDoorWidths</code> basically does the code above in the <code>SidebarFilter</code> component but it's kept in the store so I don't need to re-run the query should the user come back to the page.</p>&#xA;&#xA;<p>It's very rare the data will update and the sidebar needs to change.</p>&#xA;&#xA;<p>Hopefully there is a solution using the <code>props</code> argument to the <code>graphql</code> function. I feel like the data could be taken from <code>ownProps</code> and then an action could be dispatched here but the data could error or be loading, and that would break rendering.</p>&#xA;&#xA;<p>Edit:</p>&#xA;&#xA;<p>Query:</p>&#xA;&#xA;<pre><code>query ($isPublished: Boolean!){&#xA;  allReports(filter:{&#xA;    isPublished: $isPublished&#xA;  }) {&#xA;  id&#xA;  oldId&#xA;  dbrw&#xA;  core&#xA;  manufacturer {&#xA;    id&#xA;    name&#xA;  }&#xA;  doorWidth&#xA;  doorType&#xA;  glass&#xA;  testBy&#xA;  testDate&#xA;  testId&#xA;  isAssessment&#xA;  file {&#xA;    url&#xA;  }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8344099,,6024220,2017-07-22 21:09:47,2017-07-31 21:51:19,Dispatch Redux action after React Apollo query returns,<javascript><reactjs><redux><graphql><react-apollo>,2,0,0,2017-07-21 11:28:21
45245653,1,,,13,1952,"<p>I'm having some issues setting up a refetchContainer in Relay Modern. A parent component is the QueryRenderer, which runs an initial query, populating the child component's props appropriately (a-prop-riately? eh? eh?!) . The refetchContainer specifies all our variables, and on an input field's onChange event, re-runs a query with the new variables. This all works perfectly, except that the child's props are never updated with the new data received. I can drill down the Relay store and see that the query was indeed received with the appropriate data. Been bangin' my head against this for a while and I would appreciate some help. Probably something simple I'm missing. And Lord knows Relay Modern documentation is sparse.</p>&#xA;&#xA;<p>I've poked around and can't find an appropriate solution. This guy seems to be having a similar issue:&#xA;<a href=""https://stackoverflow.com/questions/45160928/relay-refetch-doesnt-show-the-result"">relay refetch doesn&#39;t show the result</a></p>&#xA;&#xA;<p>The parent component with QueryRenderer:</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import { connect } from 'react-redux';&#xA;import PropTypes from 'prop-types';&#xA;import { graphql, QueryRenderer } from 'react-relay';&#xA;import Search from './Search';&#xA;&#xA;const propTypes = {&#xA;  auth: PropTypes.object.isRequired,&#xA;};&#xA;&#xA;class SearchContainer extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;QueryRenderer&#xA;        query={graphql`&#xA;          query SearchContainerQuery($search: String!){&#xA;            users: searchUsers(search:$search, first:10){&#xA;              ...Search_users&#xA;            }&#xA;          }`}&#xA;        variables={{ search: 'someDefaultSearch' }}&#xA;        environment={this.props.auth.environment}&#xA;        render={({ error, props }) =&gt; {&#xA;          if (error) {&#xA;            console.log(error);&#xA;          }&#xA;          if (props) {&#xA;            return &lt;Search users={props.users} /&gt;;&#xA;          }&#xA;          return &lt;div&gt;No Dice&lt;/div&gt;;&#xA;        }}&#xA;      /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;SearchContainer.propTypes = propTypes;&#xA;&#xA;export default connect(state =&gt; ({ auth: state.auth }))(SearchContainer);&#xA;</code></pre>&#xA;&#xA;<p>The child component with createRefetchContainer:</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import PropTypes from 'prop-types';&#xA;import { createRefetchContainer, graphql } from 'react-relay';&#xA;&#xA;const propTypes = {&#xA;  relay: PropTypes.object.isRequired,&#xA;  users: PropTypes.object,&#xA;};&#xA;&#xA;const defaultProps = {&#xA;  users: {},&#xA;};&#xA;&#xA;class Search extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;input&#xA;          type=""text""&#xA;          onChange={(e) =&gt; {&#xA;            e.preventDefault();&#xA;            this.props.relay.refetch({&#xA;              search: e.target.value,&#xA;            });&#xA;          }}&#xA;        /&gt;&#xA;        &lt;ul&gt;&#xA;          {this.props.users.nodes.map(user =&gt;&#xA;            &lt;li key={user.id}&gt;{user.username}&lt;/li&gt;,&#xA;          )}&#xA;        &lt;/ul&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;Search.propTypes = propTypes;&#xA;Search.defaultProps = defaultProps;&#xA;&#xA;export default createRefetchContainer(&#xA;  Search,&#xA;  {&#xA;    users: graphql.experimental`&#xA;      fragment Search_users on SearchUsersConnection&#xA;      @argumentDefinitions(&#xA;        search: {type: ""String"", defaultValue: """"}&#xA;      ) {&#xA;        nodes {&#xA;            id&#xA;            displayName&#xA;            username&#xA;          }&#xA;      }&#xA;    `,&#xA;  },&#xA;  graphql.experimental`&#xA;    query SearchRefetchQuery($search: String!) {&#xA;      users: searchUsers(search:$search, first:10){&#xA;        ...Search_users @arguments(search: $search)&#xA;      }&#xA;    }&#xA;  `,&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>GraphQL looks like this:</p>&#xA;&#xA;<pre><code># A connection to a list of `User` values.&#xA;type SearchUsersConnection {&#xA;  # Information to aid in pagination.&#xA;  pageInfo: PageInfo!&#xA;&#xA;  # The count of *all* `User` you could get from the connection.&#xA;  totalCount: Int&#xA;&#xA;  # A list of edges which contains the `User` and cursor to aid in pagination.&#xA;  edges: [SearchUsersEdge]&#xA;&#xA;  # A list of `User` objects.&#xA;  nodes: [User]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Network calls are made appropriately, and data is returned as expected.&#xA;<a href=""https://i.stack.imgur.com/dD3CE.jpg"" rel=""noreferrer"">NetworkCalls</a></p>&#xA;&#xA;<p>It seems the @arguments directive can be left out of the refetch query here:</p>&#xA;&#xA;<pre><code>query SearchRefetchQuery($search: String!) {&#xA;      users: searchUsers(search:$search, first:10){&#xA;          ...Search_users @arguments(search: $search)&#xA;      }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(removing it seems to have no effect)</p>&#xA;&#xA;<p>I've tried adding the @arguments directive to the parent component's fragment as per the recommendation here: <a href=""https://stackoverflow.com/questions/44753480/pass-variables-to-fragment-container-in-relay-modern"">Pass variables to fragment container in relay modern</a>, to no effect.</p>&#xA;",8346298,,151461,2017-09-20 00:07:37,2018-01-03 16:25:56,Relay Modern RefetchContainer props aren't passed to component,<javascript><react-redux><graphql><relayjs><relaymodern>,2,7,0,2017-07-21 19:48:19
45280199,1,,,2,91,"<p>I've got a question about the <a href=""https://facebook.github.io/relay/docs/pagination-container.html"" rel=""nofollow noreferrer""><code>PaginationContainer</code></a> API in Relay Modern.</p>&#xA;&#xA;<p>When using <code>createPaginationContainer</code>, we're passing it a configuration object that also contains a <code>query</code> (as is the case in the <a href=""https://facebook.github.io/relay/docs/pagination-container.html#example"" rel=""nofollow noreferrer"">official example</a>).</p>&#xA;&#xA;<p>I was wondering why we have to do that seen that there still is a <code>QueryRenderer</code> on the top-level that could take care of building query at the root of the hierarchy. Couldn't we just omit this second query or what's the reason that we have to include it?</p>&#xA;&#xA;<p>I also noticed that the root query that's passed to the <code>QueryRenderer</code> also needs to have the <code>first</code> and <code>after</code> arguments to enable pagination. So, it seems like the <code>QueryRenderer</code> is still responsible to compose this query, so what's the role of the additional one that's passed to <code>createPaginationContainer</code>?</p>&#xA;",1779113,,,,2017-07-24 12:04:56,What's the role of the `query` that's passed to `createPaginationContainer` in Relay Modern?,<javascript><graphql><relayjs><relay><relaymodern>,0,0,0,2017-07-24 12:04:56
45282986,1,,,0,20,"<p>Should GraphQL server serving Relay have the data organized always from user down? Or is it better to have separate root queries for User (and profile), Friends, Matches?</p>&#xA;&#xA;<pre><code>User (viewer)&#xA;|&#xA;+ Profile&#xA;|&#xA;+ Friends&#xA;|  + Friend 1&#xA;|  + Friend 2&#xA;|&#xA;+ Matches&#xA;   + Match 1&#xA;     + Date&#xA;     + Location&#xA;     + Oponent&#xA;</code></pre>&#xA;",672226,,,,2017-07-24 14:19:40,Should Relay GraphQL be organized hierarchically from user down?,<graphql><relay>,0,3,0,2017-07-24 14:19:40
45288655,1,47070819,,4,2133,"<p>I'm using <code>react-relay/compat 1.1.0</code> and I need to write a mutation with the ability to upload a file.&#xA;In Relay Classic you can use <code>getFiles()</code> to support file uploads in mutations:</p>&#xA;&#xA;<pre><code>class AddImageMutation extends Relay.Mutation {&#xA;   getMutation() {&#xA;     return Relay.QL`mutation{ introduceImage }`;&#xA;   }&#xA;&#xA;   getFiles() {&#xA;     return {&#xA;       file: this.props.file,&#xA;     };&#xA;   }&#xA;   ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But haven't found any trace of functionality for uploading files in <a href=""https://facebook.github.io/relay/docs/relay-modern.html"" rel=""nofollow noreferrer"">Relay Modern</a> docs:</p>&#xA;&#xA;<pre><code>const {commitMutation} = require('react-relay');&#xA;&#xA;commitMutation(&#xA;  environment: Environment,&#xA;  config: {&#xA;    mutation: GraphQLTaggedNode,&#xA;    variables: Variables,&#xA;    onCompleted?: ?(response: ?Object) =&gt; void,&#xA;    onError?: ?(error: Error) =&gt; void,&#xA;    optimisticResponse?: ?() =&gt; Object,&#xA;    optimisticUpdater?: ?(store: RecordSourceSelectorProxy) =&gt; void,&#xA;    updater?: ?(store: RecordSourceSelectorProxy) =&gt; void,&#xA;    configs?: Array&lt;RelayMutationConfig&gt;,&#xA;&#xA;    // files: ... ?&#xA;  },&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>Is that supported yet in relay modern? and if so, what's the way of doing it? Thanks.</p>&#xA;",5003820,,5003820,2017-07-24 19:38:15,2017-11-02 19:33:03,How to do file uploads with Relay Modern mutations?,<graphql><relay><relaymodern>,2,0,0,2017-07-24 19:32:21
45316062,2,,44885085,0,,"<p>Your example if a fairly static implementation... I think what you need to consider is that these are containers that provide additional functionality, <a href=""https://facebook.github.io/relay/docs/fragment-container.html"" rel=""nofollow noreferrer"">fragmentContainer</a> being one of the more abstract layers.</p>&#xA;&#xA;<p>I would look more at how the <a href=""https://facebook.github.io/relay/docs/refetch-container.html"" rel=""nofollow noreferrer"">refetchContainer</a> and <a href=""https://facebook.github.io/relay/docs/pagination-container.html"" rel=""nofollow noreferrer"">paginationContainer</a> expand upon the idea of a <a href=""https://facebook.github.io/relay/docs/fragment-container.html"" rel=""nofollow noreferrer"">fragmentContainer</a> and also look at the Github repository itself,</p>&#xA;&#xA;<p><a href=""https://github.com/facebook/relay/blob/master/packages/react-relay/modern/ReactRelayFragmentContainer.js"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/blob/master/packages/react-relay/modern/ReactRelayFragmentContainer.js</a></p>&#xA;&#xA;<p>So certainly child containers could simply be a file filled with fragments that you are exporting out, but ideally you should think of them as containers which are extensions of React components. They are container fragments that bubble up into a compositional query which afford you conveniences for managing state in the context of React.</p>&#xA;",4280850,,,,2017-07-26 01:43:28,"",,0,0,0,2017-07-26 01:43:28
45329750,2,,45276709,0,,"<p>So I found a kind of a solution for the problem. You need to pass through the ID as a prop via the parent element. Looks like this:<br/>&#xA;<strong><code>App.js</code></strong><br>&#xA;<code>//call of the Event, passes the eventID from the Redux to the child element&#xA;    &lt;Eventoverview eventName={this.props.activeEvent.cell.id} /&gt;</code>&#xA;<br/>Then in the child element the graphql export looks like this:<br/>&#xA; <strong><code>Eventoverview.js</code><br/></strong>&#xA;<code>export default compose(</code><br/>&#xA;    <code>connect(mapStateToProps)</code> <br/>&#xA;<code>,graphql(Query1,{</code><br/>&#xA;   <code>options: (props)=&gt;({ variables: {&#xA;            eventName: {id:props.eventName}},}),&#xA;    name:""eventuser""</code><br/>&#xA;<code>}),graphql(Query2,{&#xA;    name:""alluser""</code><br/>&#xA;<code>}),graphql(Mutation1,{&#xA;    name:""updateEventdata""</code><br/>&#xA;<code>}))(Eventoverview);</code></p>&#xA;&#xA;<p>now the ID is used in the Query and i get my answers</p>&#xA;",8356603,,,,2017-07-26 14:22:50,"",,0,0,0,2017-07-26 14:22:50
45366842,2,,45360130,1,,"<p>It seems like that <code>createFragment</code> hab been removed from the API.</p>&#xA;&#xA;<p>If you want to create a fragment you can use <code>gql</code> from the <code>graphql-tag</code> package (included in <code>react-apollo</code>).</p>&#xA;&#xA;<p>So it could look like this:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const CommentsFragment = gql `&#xD;&#xA;fragment CommentsFragment on Comment {&#xD;&#xA;  id&#xD;&#xA;  createdAt&#xD;&#xA;  content&#xD;&#xA;}`;&#xD;&#xA;&#xD;&#xA;const CommentsQuery = gql `&#xD;&#xA;query Comments {&#xD;&#xA;  ...CommentsFragment&#xD;&#xA;}&#xD;&#xA;${CommentsFragment}&#xD;&#xA;`;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",4500001,,,,2017-07-28 06:58:41,"",,0,1,0,2017-07-28 06:58:41
45395521,2,,45269938,0,,"<p>It turns out it wasn't the sorting that was causing the anomaly.  It appears that subscriptions fail if the <code>__TYPENAME</code> of the returned object doesn't match something else here -- either the varname used in this routine ('instant_message' in the above code), or the varname of the array of objects returned in <code>props</code> to the render function. Lining up all these things so that they are identical fixes it. </p>&#xA;",364966,,,,2017-07-30 01:25:27,"",,0,0,0,2017-07-30 01:25:27
45434452,1,45443123,,0,1721,"<p>I'm using a stack of koa2, sequelize and graphql. I wan't to change the state field of the users model using graphql mutation and return the changed object.</p>&#xA;&#xA;<p>Currently my mutation looks like this:</p>&#xA;&#xA;<pre><code>mutation: new GraphQLObjectType({&#xA;    name: 'Mutation',&#xA;    fields: {&#xA;        setState: {&#xA;            type: userType,&#xA;            args: {&#xA;                input: {&#xA;                    type: userStateInputType&#xA;                }&#xA;            },&#xA;            resolve: resolver(db.user, {&#xA;                before: async (findOptions, {input}) =&gt; {&#xA;                    const {uuid, state} = input;&#xA;&#xA;                    await db.user.update(&#xA;                        {state},&#xA;                        {where: {uuid}}&#xA;                    );&#xA;&#xA;                    findOptions.where = {&#xA;                        uuid&#xA;                    };&#xA;&#xA;                    return findOptions;&#xA;                }&#xA;            })&#xA;        }&#xA;    }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>And that's the corresponding query:</p>&#xA;&#xA;<pre><code>mutation setstate{&#xA;  setState(input: {uuid: ""..UUID.."", state: ""STATE""}) {&#xA;    uuid&#xA;    state&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It's working, but I'm pretty sure there are better solutions for this.</p>&#xA;",1059828,,,,2017-08-01 16:29:07,Sequelize with GraphQl: How to update fields using mutation,<node.js><sequelize.js><graphql>,1,0,0,2017-08-01 09:47:14
45458428,1,45463585,,5,987,"<p>In an Apollo app (but also GraphQL/Relay), one can choose to colocate data requirements to components, or eventually assemble big GraphQL queries himself. We have choosen to colocate data requirements to components because we expect better maintainability on the long terme, as you don't need to look at the whole component tree or your page to see all the data requirements, and can add new requirements locally.</p>&#xA;&#xA;<p>I'd like to know better how to compose GraphQL fragments with Apollo client. I know how to do it, but I'd like to know how can I do it better.</p>&#xA;&#xA;<p>Currently, composing my fragments involve quite a bunch of boilerplate, particularly when I have components that just pass down the properties untouched.</p>&#xA;&#xA;<h1>Fragment declaration convention?</h1>&#xA;&#xA;<p>First, let's take a simple component:</p>&#xA;&#xA;<pre><code>export const User = ({&#xA;  user: {&#xA;    firstName,&#xA;    lastName,&#xA;    job,&#xA;    email,&#xA;    pictureUrl,&#xA;    color&#xA;  },&#xA;  ...props&#xA;}) =&gt; (&#xA;  &lt;UserWrapper {...props}&gt;&#xA;    &lt;UserAvatarWrapper&gt;&#xA;      &lt;Avatar&#xA;        firstName={firstName}&#xA;        lastName={lastName}&#xA;        color={color}&#xA;        src={pictureUrl}&#xA;      /&gt;&#xA;    &lt;/UserAvatarWrapper&gt;&#xA;    &lt;UserContentWrapper&gt;&#xA;      {(firstName || lastName) &amp;&amp;&#xA;        &lt;UserName&gt;&#xA;          {firstName}&#xA;          {"" ""}&#xA;          {lastName}&#xA;          {"" ""}&#xA;          {email &amp;&amp; &lt;UserEmailInline&gt;{email}&lt;/UserEmailInline&gt;}&#xA;        &lt;/UserName&gt;}&#xA;      {job &amp;&amp; &lt;UserJob&gt;{job}&lt;/UserJob&gt;}&#xA;    &lt;/UserContentWrapper&gt;&#xA;  &lt;/UserWrapper&gt;&#xA;);&#xA;User.fragments = {&#xA;  user: gql`&#xA;      fragment User on User {&#xA;          id&#xA;          firstName&#xA;          lastName&#xA;          pictureUrl: avatar&#xA;          job&#xA;          color&#xA;          email&#xA;      }&#xA;  `,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Here are some choices to be made. It seems there is some kind of convention used in most examples, but this convention is not explicit in the doc.</p>&#xA;&#xA;<ul>&#xA;<li><p>The key used on the <code>User.fragments</code>. Does it make sense to name it exactly like the propName <code>user</code> of the component? </p></li>&#xA;<li><p>The name of the fragment: it seems by convention people name it with the name of the component, and if useful, suffix them by the GraphQL type on which is the fragment. (here <code>UserUser</code> would probably be overkill suffixing).</p></li>&#xA;</ul>&#xA;&#xA;<p>I think it is good to follow the same convention across the same app, so that all fragment declarations are consistant. So, can someone more experienced help me clarify this convention that seems used in many Apollo examples?</p>&#xA;&#xA;<h1>Reducing fragment composition boilerplate ?</h1>&#xA;&#xA;<p>Lets consider now a <code>Relationship</code> component following the convention we've set up.</p>&#xA;&#xA;<pre><code>const Relationship = ({ user1, user2 }) =&gt; (&#xA;  &lt;RelationshipContainer&gt;&#xA;      &lt;RelationshipUserContainer&gt;&#xA;        &lt;User user={user1} /&gt;&#xA;      &lt;/RelationshipUserContainer/&gt;&#xA;      &lt;RelationshipUserContainer&gt;&#xA;        &lt;User user={user2} /&gt;&#xA;      &lt;/RelationshipUserContainer/&gt;&#xA;  &lt;/RelationshipContainer&gt;&#xA;);&#xA;Relationship.fragments = {&#xA;  user1: gql`&#xA;      fragment RelationshipUser1User on User {&#xA;          ...User&#xA;      }&#xA;      ${User.fragments.user}&#xA;  `,&#xA;  user2: gql`&#xA;      fragment RelationshipUser2User on User {&#xA;          ...User&#xA;      }&#xA;      ${User.fragments.user}&#xA;  `,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Note that here I'm declaring 2 fragments that look the same. I think it's necessary because there are 2 props and you should not necessarily assume that the data requirement on both props are the same. We could easily imagine a component with <code>me</code> props, and <code>friend</code> props, where you would receive more data for the <code>me</code> props.</p>&#xA;&#xA;<p>This works fine but it quite a lot of boilerplate and intermediate fragments that look quite unnecessary. Also it's not always convenient because from a component user point of view, you have to be aware of the 2 fragment names to be able to use it.</p>&#xA;&#xA;<p>I tried to simplify this with the following</p>&#xA;&#xA;<pre><code>Relationship.fragments = {&#xA;  user1: User.fragments.user,&#xA;  user2: User.fragments.user,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>This can work, but if you do this, then the fragment names are not anymore <code>RelationshipUserXUser</code>, but <code>User</code> instead, this means it breaks the encapsulation and that somehow you need to be aware that internally, the <code>Relationship</code> component is using the <code>User</code> component.</p>&#xA;&#xA;<p>If one day, the <code>Relationship</code> component switch to using an alternative representation like <code>UserAlt</code>, this would require refactoring from all components using the Relationship fragments, which is something I'd like to avoid. I think in such a case, the modifications should only have to happen in the <code>Relationship</code> component.</p>&#xA;&#xA;<h1>Conclusion</h1>&#xA;&#xA;<p>I'd like to know the best practices to compose fragments with Apollo, so that components remain truly encapsulated, and preferably without involving too much boilerplate.</p>&#xA;&#xA;<p>Am I already doing the right thing? </p>&#xA;&#xA;<p>Is all this boilerplate unavoidable if I really want to compose queries?</p>&#xA;",82609,,82609,2017-08-02 14:27:26,2017-08-02 14:27:26,Fragment composition with Apollo client: convention and boilerplate,<reactjs><graphql><apollo><react-apollo>,1,0,0,2017-08-02 10:35:12
45489378,1,,,2,287,"<p>I am quite new to Relay Modern so I may be doing something wrong here. Also I'm having a hard time finding documentation on how this should be done.</p>&#xA;&#xA;<p>I have an app which presents a virtual directory structure view built in React with the following structure:</p>&#xA;&#xA;<pre class=""lang-html prettyprint-override""><code>&lt;ProjectDrive&gt;&#xA;  &lt;QueryRenderer&gt;&#xA;     &lt;ProjectDriveContainer&gt;&#xA;        &lt;ProjectDriveComponent&gt;&#xA;</code></pre>&#xA;&#xA;<p>When the view loads the GraphQL query specified in the <code>QueryRenderer</code> is executed and the data is passed to the <code>ProjectDriveContainer</code> component and it renders correctly. This component is created like so:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const ProjectDriveContainer = createRefetchContainer(ProjectDriveComponent, {&#xA;        processMeta: TrackingBoardFragment.processMeta,&#xA;        directory: ProjectDriveComponentFragment.directory&#xA;}, ProjectDriveComponentRefetchQuery);&#xA;</code></pre>&#xA;&#xA;<p>A method for changing the directory performs a refetch with different variables and I can see this query executing and returning the correct data in the browser's network tab. The <code>componentWillReceiveProps</code> method receives the new props but these are the old original props - i.e. the new data has not replaced the object in the props.</p>&#xA;&#xA;<p>My queries look like this:</p>&#xA;&#xA;<p>Original query</p>&#xA;&#xA;<pre><code>query DriveDataQuery($processId: Int!, $boardClass: String!, $boardType: String!, $filters: JSONString, $directoryType: DirectoryType!, $root: Boolean!, $directoryId: ID) {&#xA;  processMeta(processId: $processId, boardClass: $boardClass, boardType: $boardType, filters: $filters) {&#xA;    ...TrackingBoardComponent_processMeta&#xA;  }&#xA;  userProcessOptions(processId: $processId) {&#xA;    ...NavbarComponent_userProcessOptions&#xA;  }&#xA;  directory(processId: $processId, directoryType: $directoryType, root: $root, directoryId: $directoryId) {&#xA;    ...ProjectDriveComponent_directory&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Refetch query:</p>&#xA;&#xA;<pre><code>query ProjectDriveComponentRefetchQuery($processId: Int, $directoryId: ID!, $directoryType: DirectoryType!, $root: Boolean!) {&#xA;    directory(processId: $processId, directoryType: $directoryType, root: $root, directoryId: $directoryId) {&#xA;        ...ProjectDriveComponent_directory&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What am I missing here?</p>&#xA;",285549,,,,2017-08-20 23:24:01,Relay Modern refetch does not pass new data,<reactjs><graphql><relay><relaymodern>,0,5,0,2017-08-03 16:04:06
45497041,2,,44774728,6,,"<p>For infinite loading, you would use a cursor. Referencing the example on the Apollo documentation, <a href=""http://dev.apollodata.com/react/pagination.html#cursor-pages"" rel=""noreferrer"">http://dev.apollodata.com/react/pagination.html#cursor-pages</a></p>&#xA;&#xA;<p>Tailoring this to your schema you've provided, it would look something like this (Untested)</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const ProductsListData = graphql(productInfo, {&#xD;&#xA;  props({ data: { loading, cursor, allProducts, fetchMore } }) {&#xD;&#xA;    return {&#xD;&#xA;      loading,&#xD;&#xA;      allProducts,&#xD;&#xA;      loadMoreEntries: () =&gt; {&#xD;&#xA;        return fetchMore({&#xD;&#xA;          variables: {&#xD;&#xA;            cursor: cursor,&#xD;&#xA;          },&#xD;&#xA;          updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xD;&#xA;            const previousEntry = previousResult.entry;&#xD;&#xA;            const newProducts = fetchMoreResult.allProducts;&#xD;&#xA;            return {&#xD;&#xA;              cursor: fetchMoreResult.cursor,&#xD;&#xA;              entry: {&#xD;&#xA;                allProducts: [...previousEntry.entry.allProducts, ...newProducts],&#xD;&#xA;              },&#xD;&#xA;            };&#xD;&#xA;          },&#xD;&#xA;        });&#xD;&#xA;      },&#xD;&#xA;    };&#xD;&#xA;  },&#xD;&#xA;})(ProductsList);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>You'll likely have to play around with the pathing of the objects as this should look similar to your schema. But for the most part this is what your infinite scrolling pagination implementation should look like.</p>&#xA;",4280850,,,,2017-08-04 01:44:46,"",,0,0,0,2017-08-04 01:44:46
45527064,2,,40326065,0,,"<p>I use the second approach. In this way, you can add more arguments to the same endpoint later on. Maybe a folder has a path or you like to filter on creation date.</p>&#xA;",261747,,,,2017-08-05 22:55:28,"",,0,0,0,2017-08-05 22:55:28
45534453,1,45536592,,16,6002,"<p>Using: ""react-apollo"": ""^1.4.3""</p>&#xA;&#xA;<p>In the parent component I query using GraphQL a parent node 'Fund' with children 'fundQuarterlyMetric'. This returns data in the following format:</p>&#xA;&#xA;<pre><code>{      &#xA;  id&#xA;  name&#xA;  ...&#xA;  fundQuarterlyMetrics (orderBy: asAtDate_ASC) {&#xA;    id&#xA;    year&#xA;    quarter&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When I try to create a new fundQuarterlyMetrics I have to update the local store on react-apollo using the update feature (<a href=""http://dev.apollodata.com/react/cache-updates.html#directAccess"" rel=""noreferrer"">Apollo Client docs</a>). It gives me an error:</p>&#xA;&#xA;<pre><code>   Can't find field Fund({}) on object (ROOT_QUERY) {&#xA;     ""Fund({\""id\"":\""cj57hpfips0x7014414u5tk8m\""})"": {&#xA;     ""type"": ""id"",&#xA;     ""id"": ""Fund:cj57hpfips0x7014414u5tk8m"",&#xA;     ""generated"": false&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>The thing is, is that when I console.log the proxy, I can see the Fund and it's children under data.... not sure what to do..</p>&#xA;&#xA;<p>UPDATE following comment:</p>&#xA;&#xA;<p>Here is the parent component data request:</p>&#xA;&#xA;<pre><code>export const fundPageQuery = gql`&#xA; query Fund($fundId: ID!) {&#xA;Fund(id: $fundId) {&#xA;  id&#xA;  name&#xA;  ....other variables&#xA;  fundQuarterlyMetrics (orderBy: asAtDate_ASC) {&#xA;    id&#xA;    year&#xA;    quarter&#xA;    ....other variables&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>}&#xA;    `;</p>&#xA;&#xA;<p>Here are the options I used:</p>&#xA;&#xA;<pre><code>var optionsForCreateFundMetric = {&#xA; update: (proxy, {data: {createFundMetrics}}) =&gt; {&#xA; try {&#xA;  console.log('proxy', proxy);&#xA;  const data = proxy.readQuery({query: FundQL.fundPageQuery});&#xA;  console.log('data', data);&#xA;  data.Fund.fundQuarterlyMetrics.push(createFundMetrics);&#xA;  proxy.writeQuery({query: FundQL.fundPageQuery, data})&#xA;} catch (e) {&#xA;  console.log('error adding to store', e);&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>}&#xA;    };</p>&#xA;&#xA;<pre><code>export default compose(&#xA; graphql(FundQL.createFundMetrics, {name: 'createFundMetrics', options: &#xA; optionsForCreateFundMetric}),&#xA; graphql(FundQL.updateFundMetrics, {name: 'updateFundMetrics'})&#xA; )(FundMetricsForm);&#xA;</code></pre>&#xA;&#xA;<p>Here is my create mutation:</p>&#xA;&#xA;<pre><code>export const createFundMetrics = gql`&#xA; mutation createFundQuarterlyMetric(&#xA;$fundId: ID&#xA;$year: Int!&#xA;$quarter: FUND_QUARTERLY_METRIC_QUARTER!&#xA;$netIRR: Float!&#xA;$tvpi: Float!&#xA;$rvpi: Float!&#xA;$dpi: Float!&#xA;$asAtDate: DateTime&#xA;$calledThisQuarter: Float!&#xA;$distributedThisQuarter: Float!&#xA;$cumulativeCalled: Float!&#xA;$cumulativeDistributed: Float!&#xA;$limitedPartnersNAV: Float!&#xA;$quarterlyValuationChangeLCY: Float&#xA;$quarterlyTotalReturn: Float&#xA; ) {&#xA;createFundQuarterlyMetric(&#xA;  fundId: $fundId&#xA;  year: $year&#xA;  quarter: $quarter&#xA;  netIRR: $netIRR&#xA;  tvpi: $tvpi&#xA;  rvpi: $rvpi&#xA;  dpi: $dpi&#xA;  asAtDate: $asAtDate&#xA;  calledThisQuarter: $calledThisQuarter&#xA;  distributedThisQuarter: $distributedThisQuarter&#xA;  cumulativeCalled: $cumulativeCalled&#xA;  cumulativeDistributed: $cumulativeDistributed&#xA;  limitedPartnersNAV: $limitedPartnersNAV&#xA;  quarterlyValuationChangeLCY: $quarterlyValuationChangeLCY&#xA;  quarterlyTotalReturn: $quarterlyTotalReturn&#xA;) {&#xA;  id&#xA;  year&#xA;  quarter&#xA;  netIRR&#xA;  tvpi&#xA;  rvpi&#xA;  dpi&#xA;  asAtDate&#xA;  calledThisQuarter&#xA;  distributedThisQuarter&#xA;  cumulativeCalled&#xA;  cumulativeDistributed&#xA;  limitedPartnersNAV&#xA;  quarterlyValuationChangeLCY&#xA;  quarterlyTotalReturn&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>}&#xA;`;</p>&#xA;&#xA;<p>SOLUTION&#xA;Thanks Daniel - I had to return the fund ID to make it work so thank you!</p>&#xA;&#xA;<pre><code>export default compose(&#xA; graphql(FundQL.createFundMetrics, {name: 'createFundMetrics', options: &#xA;optionsForCreateFundMetric, variables: {fundId: &#xA;createFundQuarterlyMetric.fund.id}}),&#xA; graphql(FundQL.updateFundMetrics, {name: 'updateFundMetrics'})&#xA; )(FundMetricsForm);&#xA;</code></pre>&#xA;",8011705,,8011705,2017-08-07 00:09:23,2019-03-05 04:11:50,"Apollo-client (react) - Update on create mutation - ""Can't find field Fund({}) on object (ROOT_QUERY)""",<javascript><reactjs><graphql><react-apollo><apollo-client>,1,2,0,2017-08-06 17:02:17
45535690,2,,45516743,8,,"<p>For anyone with the same problem, here is what the code looked like when I finally got it to work:</p>&#xA;&#xA;<pre><code>      $('button').click(function() {&#xA;      event.preventDefault();&#xA;      var entry = $('#entry').val()&#xA;      console.log(entry);&#xA;&#xA;&#xA;      $.ajax({&#xA;          method: ""POST"",&#xA;          url: ""https://api.github.com/graphql"",&#xA;          contentType: ""application/json"",&#xA;          headers: {&#xA;            Authorization: ""bearer ***********""&#xA;          },&#xA;          data: JSON.stringify({&#xA;            query: `query ($entry: String!) {repository(name: $entry, &#xA;            owner: ""*******"") { pullRequests(last: 100) {&#xA;              nodes {&#xA;                state&#xA;                headRepository {&#xA;                  owner {&#xA;                    login&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }`,&#xA;        variables: {&#xA;          ""entry"": $('#entry').val()&#xA;        }&#xA;      })&#xA;    })&#xA;</code></pre>&#xA;",8419641,,,,2017-08-06 19:16:50,"",,0,1,0,2017-08-06 19:16:50
45557380,1,,,5,2954,"<p>It's possible to pass a query, but apparently not a fragment:</p>&#xA;&#xA;<pre><code>server.use('/graphiql', graphiqlExpress({&#xA;    endpointURL: '/graphql',&#xA;    query: `# Welcome to GraphiQL&#xA;&#xA;query PostsForAuthor {&#xA;  author(id: 1) {&#xA;    firstName&#xA;    posts {&#xA;      title&#xA;      votes&#xA;    }&#xA;  }&#xA;}`}));&#xA;</code></pre>&#xA;&#xA;<p><hr>&#xA;<strong>Update 10/12/2017</strong>&#xA;It is possible to send fragments along with a query using Apollo's client:</p>&#xA;&#xA;<p><a href=""http://dev.apollodata.com/core/fragments.html"" rel=""nofollow noreferrer"">http://dev.apollodata.com/core/fragments.html</a></p>&#xA;&#xA;<p>This is not a solution to the original question, however; I would like to pass fragments to a graphiql server instance <em>at startup</em>.</p>&#xA;",591529,,591529,2018-02-12 19:56:28,2018-09-26 07:36:45,Is there a way to pass a fragment to graphiql?,<graphql><apollo-server><graphiql>,2,0,0,2017-08-08 00:10:16
45586037,1,45591588,,0,570,"<p>My resolver get </p>&#xA;&#xA;<pre><code>{ adminMsg: &#xA;   [ &#xA;     {active: “y”, text1: “blah1"" } , &#xA;     {active: “n”, text1: “blah2"" } &#xA;   ] };&#xA;</code></pre>&#xA;&#xA;<p>My query:</p>&#xA;&#xA;<pre><code>{&#xA;  adminWarn {&#xA;    adminMsg {&#xA;      active, text1&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want only array-elements with condition: active = 'y'</p>&#xA;&#xA;<p>I find in GQL Dokumentation no way to write this condition im my query. &#xA;Is there any solution in GQL?</p>&#xA;",1514029,,,,2017-08-09 13:07:49,How can I select a part of a array of objects in a GraphQL query?,<graphql>,1,0,0,2017-08-09 08:58:42
45586892,1,,,0,228,"<p>I would like to specify inner constraints in a GraphQL query that would limit the results of the outermost query as part of a query / predicate builder I'm working on. I'm not sure if this is considered to be within GraphQL's capabilities but it makes sense to me as something that people would want to do.</p>&#xA;&#xA;<p>For example, I might want to show a list of blog posts that were recently commented on like this:</p>&#xA;&#xA;<pre><code>{&#xA;  posts{&#xA;    title&#xA;    date&#xA;    comments(since: $earliestDate){&#xA;      body&#xA;      date&#xA;      author {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The normal behaviour of this would be to bring back all blog posts and only comments that met the criteria. </p>&#xA;&#xA;<pre><code>{&#xA;  ""posts"": [&#xA;    { &#xA;      ""title"": ""Post 1"",&#xA;      ""date"": ""2017-07-31""&#xA;      ""comments"": [&#xA;      ]&#xA;    },&#xA;    { &#xA;      ""title"": ""Post 2"",&#xA;      ""date"": ""2017-06-10"",&#xA;      ""comments"": [&#xA;        {&#xA;          ""body"": ""Comment text"",&#xA;          ""date"": ""2017-08-09"",&#xA;          ""author"": {&#xA;             ""name"": ""Michael""&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I want my query to prevent the retrieval of ""Post 1"" because it has no comments in the last month, but I'm not sure that's something GraphQL will make easy to do. </p>&#xA;&#xA;<p>Is there functionality within GraphQL to support returning this result?</p>&#xA;&#xA;<pre><code>{&#xA;  ""posts"": [&#xA;    { &#xA;      ""title"": ""Post 2"",&#xA;      ""date"": ""2017-06-10"",&#xA;      ""comments"": [&#xA;        {&#xA;          ""body"": ""Comment text"",&#xA;          ""date"": ""2017-08-09"",&#xA;          ""author"": {&#xA;             ""name"": ""Michael""&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;",191991,,,,2017-08-09 15:09:47,Using GraphQL structures to build complex database queries,<graphql>,1,0,0,2017-08-09 09:35:32
45599231,2,,45595990,8,,"<p>You'd need to define a resolver for both the <code>country</code> field on the Root Query and the <code>state</code> field on the Country type. Here's an example you can copy and paste into <a href=""https://launchpad.graphql.com/new"" rel=""noreferrer"">Launchpad</a> and see it in action.</p>&#xA;&#xA;<p>The set up for something like Graphene would be a little different, but the idea is the same: the object returned by your <code>country</code> query is made available to the resolver for every field under the <code>state</code> type. You use the <code>id</code> argument passed to the <code>state</code> field to filter the data on that object (in this example, the returned object has a <code>states</code> property) and return the appropriate state.</p>&#xA;&#xA;<pre><code>import { makeExecutableSchema } from 'graphql-tools';&#xA;&#xA;const countries = [&#xA;  {&#xA;    id: 1,&#xA;    name: 'bar',&#xA;    states: [&#xA;      {&#xA;        name: 'foo',&#xA;        id: 20&#xA;      }&#xA;    ]&#xA;  },&#xA;  { id: 2 },&#xA;];&#xA;&#xA;const typeDefs = `&#xA;  type Query {&#xA;    country(id: Int!): Country&#xA;  }&#xA;  type Country {&#xA;    id: Int&#xA;    state(id: Int!): State&#xA;  }&#xA;  type State {&#xA;   id: Int&#xA;   name: String&#xA;  }&#xA;`&#xA;&#xA;const resolvers = {&#xA;  Query: {&#xA;    country: (obj, args, context) =&gt; {&#xA;      return countries.find(country =&gt; country.id === args.id)&#xA;    },&#xA;  },&#xA;  Country: {&#xA;    state: (obj, args, context) =&gt; {&#xA;      return obj.states.find(state =&gt; state.id === args.id)&#xA;    },&#xA;  }&#xA;}&#xA;&#xA;export const schema = makeExecutableSchema({&#xA;  typeDefs,&#xA;  resolvers,&#xA;})&#xA;</code></pre>&#xA;&#xA;<p><strong>Edit:</strong> Assuming the object returned by <code>CountryModel.objects.get(id=Schema.decode(id))</code> includes a <code>states</code> attribute that is a list of states, you should be able to do something like:</p>&#xA;&#xA;<pre><code>class Country(graphene.ObjectType):&#xA;  state = graphene.Field(State,&#xA;                          id=graphene.String()&#xA;                          )&#xA;  # other fields&#xA;  def resolve_state(self, args, context, info):&#xA;    id = args.get('id')&#xA;    if id is not None:&#xA;        return list(filter(lambda x: x.id == id, self.states)&#xA;    return None&#xA;</code></pre>&#xA;",6024220,,6024220,2017-08-09 21:57:34,2017-08-09 21:57:34,"",,0,2,0,2017-08-09 19:33:45
45625475,2,,45171855,1,,"<p>This is indeed correct behavior.</p>&#xA;&#xA;<p>Your components must, individually, specify all their <em>own</em> data dependencies, Relay will only pass to the component the data it asked for. Since your component is not asking any data, it's receiving an empty object.</p>&#xA;&#xA;<p>That <code>__id</code> you see is used internally by Relay and you should not rely on it (that is why it has the <code>__</code> prefix).</p>&#xA;&#xA;<p>Basically, the prop <code>viewer</code> on <code>ActivityTypeLists</code> component will have exactly the same format than the query requested on the <code>ActivityTypeLists_viewer</code> fragment, <em>without</em> any other fragments from other components that you are referencing there.</p>&#xA;&#xA;<p>This is known as data masking, see more in the following links:</p>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/docs/en/thinking-in-relay.html#data-masking"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/en/thinking-in-relay.html#data-masking</a>&#xA;<a href=""https://facebook.github.io/relay/docs/en/graphql-in-relay.html#relaymask-boolean"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/en/graphql-in-relay.html#relaymask-boolean</a></p>&#xA;",710693,,710693,2018-08-13 01:43:00,2018-08-13 01:43:00,"",,0,0,0,2017-08-11 01:02:59
45645502,1,,,1,6589,"<p>I'm brand new to graphql and I'm just trying to construct a simple query that will filter for results with a plannedExpirationDate value after a certain datetime. How do I write that filter?</p>&#xA;&#xA;<pre><code>{&#xA;  loans (filters: {gender: male, status:funded, country: [""KE"", ""US""]}, sortBy: newest, limit: 2) {&#xA;    totalCount&#xA;    values {&#xA;      name&#xA;      status&#xA;      loanAmount&#xA;      image {&#xA;        url(presetSize: small)&#xA;      }&#xA;      activity {&#xA;        name&#xA;      }&#xA;      plannedExpirationDate&#xA;      location {&#xA;        country {&#xA;          isoCode&#xA;          name&#xA;        }&#xA;      }&#xA;      lenders (limit: 100) {&#xA;        totalCount&#xA;      }&#xA;      ... on LoanPartner {&#xA;        partnerName&#xA;      }&#xA;      ... on LoanDirect {&#xA;        trusteeName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",7246171,,,,2017-08-13 06:27:57,Filtering by date in graphql,<api><filter><graphql>,1,0,0,2017-08-12 00:52:35
45648621,1,45648870,,0,258,"<p>I've build a component which basically list entries in a table, on top of that, i have another component to which filters can be applied. It all works really great with Apollo.</p>&#xA;&#xA;<p>I'm trying to add deep linking into the filters, which on paper seems incredible simple, and i almost had i working.</p>&#xA;&#xA;<p>Let me share some code.</p>&#xA;&#xA;<pre><code>const mapStateToProps = ({ activeObject }) =&gt; ({ activeObject });&#xA;&#xA;@withRouter&#xA;@connect(mapStateToProps, null)&#xA;@graphql(FILTER_REPORT_TASKS_QUERY, {&#xA;  name: 'filteredTasks',&#xA;  options: (ownProps) =&gt; {&#xA;    const filters = queryString.parse(location.search, { arrayFormat: 'string' });&#xA;&#xA;    return {&#xA;      variables: {&#xA;        ...filters,&#xA;        id: ownProps.match.params.reportId,&#xA;      },&#xA;    };&#xA;  },&#xA;})&#xA;export default class TasksPage extends Component {&#xA;  static propTypes = {&#xA;    filteredTasks: PropTypes.object.isRequired,&#xA;    activeObject: PropTypes.object.isRequired,&#xA;    match: PropTypes.object.isRequired,&#xA;  };&#xA;&#xA;  constructor(props) {&#xA;    super(props);&#xA;&#xA;    const filters = queryString.parse(location.search, { arrayFormat: 'string' });&#xA;    this.state = { didSearch: false, initialFilters: filters };&#xA;    this.applyFilter = this.applyFilter.bind(this);&#xA;&#xA;  }&#xA;&#xA;  applyFilter(values) {&#xA;    const variables = { id: this.props.match.params.reportId };&#xA;    variables.searchQuery = values.searchQuery === '' ? null : values.searchQuery;&#xA;    variables.categoryId = values.categoryId === '0' ? null : values.categoryId;&#xA;    variables.cardId = values.cardId === '0' ? null : values.cardId;&#xA;&#xA;    /*&#xA;    this.props.history.push({&#xA;      pathname: `${ this.props.history.location.pathname }`,&#xA;      search: '',&#xA;    }); &#xA;    return null;&#xA;    */&#xA;&#xA;    this.props.filteredTasks.refetch(variables);&#xA;    this.setState({ didSearch: true });&#xA;  }&#xA;&#xA;  ..... Render functions.&#xA;</code></pre>&#xA;&#xA;<p>Basically it calls the apply filter method, when a filter is chosen.</p>&#xA;&#xA;<p>Which all works great, my problem is that when the <code>activeObject</code> is updated (By selecting a entry in the list). It seems to run my HOC graphql, which will apply the filters from the URL again, ignoring the filters chosen by the user.</p>&#xA;&#xA;<p>I tried to remove the query strings from the url, once filters are applied, but i get some unexpected behavior, basically it's like it doesn't fetch again.</p>&#xA;&#xA;<p>How can i prevent Apollo from fetching, just because the redux pushes new state?</p>&#xA;",1009465,,,,2017-08-12 09:50:34,"Apollo seems to refresh, when state is mapped to props, how can i prevent it?",<reactjs><react-redux><apollo>,1,0,0,2017-08-12 09:22:45
45648870,2,,45648621,0,,"<p>I actually solved this by changing the order of the HOC's.</p>&#xA;&#xA;<pre><code>@graphql(FILTER_REPORT_TASKS_QUERY, {&#xA;  name: 'filteredTasks',&#xA;  options: (ownProps) =&gt; {&#xA;    const filters = queryString.parse(location.search, { arrayFormat: 'string' });&#xA;    return {&#xA;      variables: {&#xA;        ...filters,&#xA;        id: ownProps.match.params.reportId,&#xA;      },&#xA;    };&#xA;  },&#xA;})&#xA;@withRouter&#xA;@connect(mapStateToProps, null)&#xA;</code></pre>&#xA;",1009465,,,,2017-08-12 09:50:34,"",,0,0,0,2017-08-12 09:50:34
45742006,1,,,1,96,"<p>The flow I'm trying to achieve is </p>&#xA;&#xA;<ol>&#xA;<li>User clicks a button ""Create X""</li>&#xA;<li>create a blank X using a relay mutation</li>&#xA;<li>open a modal to edit X</li>&#xA;</ol>&#xA;&#xA;<p>I have a server side mutation which returns x (of type <code>X</code>), its parent, and the edge between them so I can do a <code>RANGE_ADD</code> clientside and update the store.</p>&#xA;&#xA;<pre><code>const mutation = new CreateBlankXMutation({ ... })&#xA;Relay.Store.commitUpdate(mutation, {&#xA;  onSuccess: ({ createBlankXMutation }) =&gt; {&#xA;    const { x } = createBlankXMutation&#xA;    showModal(EditXModal, { x })&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p><code>showModal</code> is a redux action which creates a component from the first argument, and supplies it props from the second argument.</p>&#xA;&#xA;<p><code>EditXModal</code> is a Relay Container, </p>&#xA;&#xA;<pre><code>{&#xA;  fragments: {&#xA;    x: () =&gt; Relay.QL`&#xA;      fragment on X { ... }&#xA;    `&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>the specific error I'm getting is </p>&#xA;&#xA;<pre><code>RelayContainer: component `Container` was rendered with variables &#xA;that differ from the variables used to fetch fragment `creative`. &#xA;The fragment was fetched with variables `(not fetched)`, &#xA;but rendered with variables `{}`.&#xA;</code></pre>&#xA;&#xA;<p>You usually get that error when you forget to compose your Fragments properly, so in <code>CreateBlankXMutation</code>, I tried to add <code>EditXModal.getFragment(...)</code> to <code>getFatQuery</code> and the <code>REQUIRED_CHILDREN</code> config (both times under <code>x</code>) - no dice, same error.</p>&#xA;&#xA;<p>If I ""inspect"" the object (<code>console.log</code>) I can see that the fragments are being populated correctly after the mutation - <code>x</code> looks like <code>{ id: ""..."", ..., _someField: ... }</code>, but the fragments are resolved properly once the modal is loaded (<code>x</code> looks identical - with <code>_...</code> fragment properties, still).</p>&#xA;",877279,,877279,2017-08-17 19:12:54,2017-08-17 19:12:54,Use result of Relay Mutation as a Relay Container Prop,<reactjs><graphql><relayjs><react-relay>,1,0,0,2017-08-17 17:54:59
45742959,2,,45742006,-1,,"<p>I fixed it, but I don't like how I fixed it, so I'd still appreciate insight from others.</p>&#xA;&#xA;<pre><code>Relay.Store.commitUpdate(mutation, {&#xA;  onSuccess: ({ createBlankXMutation }) =&gt; {&#xA;    const { x: { id: xId } } = createBlankXMutation&#xA;&#xA;    // re-fetch all xs in the parent container&#xA;    this.props.relay.forceFetch(null, (readyState) =&gt; {&#xA;      if (readyState.done) {&#xA;        const { xList } = this.props // all xs in the parent&#xA;        const x = xList.find((x) =&gt; x.id === xId)&#xA;&#xA;        this.props.showModal(EditXModal, { x })&#xA;      }&#xA;    })&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>The parent fetches the appropriate fragments, so when the object is loaded by EditXModal, all the fragments are available to be resolved properly.</p>&#xA;",877279,,,,2017-08-17 18:53:15,"",,0,0,0,2017-08-17 18:53:15
45786737,2,,45784283,0,,<p>thanks! just adding this line solved my problem:   </p>&#xA;&#xA;<pre><code>implicit val businessUserFormat = Json.format[BusinessUserRow]&#xA;</code></pre>&#xA;,4104734,,,,2017-08-20 20:57:30,"",,0,0,0,2017-08-20 20:57:30
45787021,1,,,7,25177,<p>I'm using the following query &#xA;<code>https://www.instagram.com/graphql/query/?query_id=17851374694183129&amp;id={acountId}&amp;first=1000&amp;after={cursor}</code>&#xA;to get an user followers. The information I need is the <code>followed_by_count</code> index that's only available per user on <code>https://www.instagram.com/{username}?__a=1</code></p>&#xA;&#xA;<p>Is there a <code>query_id</code> that includes the <code>followed_by_count</code> in the result?</p>&#xA;,7817385,,,,2021-04-16 16:47:24,How to use Instagram graphql?,<instagram><graphql>,1,1,0,2017-08-20 21:38:39
45802064,1,45821909,,4,527,"<p>I'm building an app as my first real foray into React, Relay and GraphQL, using Relay Modern.</p>&#xA;&#xA;<p>The basic case is, I have a login form component that doesn't really need any data; that is to say, the component renders a form, and has a corresponding mutation, but doesn't need to query anything.</p>&#xA;&#xA;<p>It seems that providing a Relay style query fragment is a necessity when calling <code>createFragmentContainer</code>, which in turn ensures that the <code>this.props.relay</code> will not be <code>null</code> in the context of the component.</p>&#xA;&#xA;<p>Right now, I'm using a standard (non-Relay) React component for the login form, but as a result I'm unable to access the Relay environment to pass it through to the mutation.</p>&#xA;&#xA;<p>My question - is there a way to essentially pass an ""empty"" Relay fragment? Or is there some better idiom that is recommended in this case?</p>&#xA;",3211286,,3211286,2017-08-21 17:59:53,2017-08-22 15:41:39,Relay container with no data,<reactjs><graphql><relay><relaymodern>,1,0,0,2017-08-21 16:43:27
45821909,2,,45802064,4,,"<p>You actually just use a normal component then create a mutation file with the mutation in it. Run the relay compiler to create the graphql fragment for the mutation and then call on the mutation in the form submit. The mutation does need your environment. Here is the relay modern docs:</p>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/docs/mutations.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/mutations.html</a></p>&#xA;&#xA;<p>You will need to store the result of the mutation somewhere and then append the auth token to your next requests, but that shouldn't be terribly hard to do. Just onCompleted and store the result somewhere.</p>&#xA;&#xA;<p>Your environment should be a seperate file that you import for mutations and query renders. Only paginationContainer inherits encironment from a queryRenderer.</p>&#xA;",561236,,561236,2017-08-22 15:41:39,2017-08-22 15:41:39,"",,0,3,0,2017-08-22 15:38:03
45822227,2,,45573693,1,,"<p>I hope I am understanding your question correctly, bit your QueryRenderer should have an error object that conains the error&#xA;<a href=""https://facebook.github.io/relay/docs/query-renderer.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/query-renderer.html</a></p>&#xA;&#xA;<pre><code>render={({error, props}) =&gt; {&#xA;if (error) {&#xA;  return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA;} else if (props) {&#xA;  return &lt;div&gt;{props.page.name} is great!&lt;/div&gt;;&#xA;}&#xA;return &lt;div&gt;Loading&lt;/div&gt;;&#xA;</code></pre>&#xA;",561236,,,,2017-08-22 15:54:58,"",,0,3,0,2017-08-22 15:54:58
45828426,1,45828574,,1,1575,"<p>My goal is to traverse a graphql Java document object and return the max depth.</p>&#xA;&#xA;<p>Example:  Depth 0</p>&#xA;&#xA;<pre><code>{&#xA;   name &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example:  Depth 1</p>&#xA;&#xA;<pre><code>{&#xA;   viewer{&#xA;     viewerId&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example:  Depth 2</p>&#xA;&#xA;<pre><code>{&#xA;   viewer{&#xA;     albums{&#xA;       albumId&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example:  Depth 2.  As you can see both albums/songs are under same parent 'viewer'</p>&#xA;&#xA;<pre><code>{&#xA;   viewer{&#xA;     albums{&#xA;       albumId&#xA;     }&#xA;     songs{&#xA;        songId&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example:  Depth 3</p>&#xA;&#xA;<pre><code>{&#xA;   viewer{&#xA;     albums{&#xA;       tracks{&#xA;          trackId&#xA;       }&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have written the base code to traverse it but my code doesn't work for the 2nd version of depth = 2.  It returns depth = 3 instead of 2.  The reason is because it's counting twice under the same parent.  Essentially the logic is this: depth = depth + 1 whenever a field has children.</p>&#xA;&#xA;<pre><code>import graphql.language.Document;&#xA;import graphql.language.Node;&#xA;import graphql.language.OperationDefinition;&#xA;&#xA;public int checkDepthLimit(String query) {&#xA;    Document document;&#xA;    try {&#xA;        document = documentParser.parseDocument(query);&#xA;    } catch (Exception e) {}&#xA;&#xA;    Optional&lt;Node&gt; queryNode = document.getChildren().stream()&#xA;            .filter(n -&gt; (n.getClass() == OperationDefinition.class))&#xA;            .findFirst();&#xA;&#xA;    return checkDepthLimit(queryNode.get());&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<pre><code>private int checkDepthLimit(Node queryNode) {&#xA;&#xA;    int depth = 0;&#xA;    String nodeType = queryNode.getClass().getSimpleName().toUpperCase();&#xA;&#xA;    if (nodeType.equals(""FIELD"")) {&#xA;        if (!queryNode.getChildren().isEmpty()) {&#xA;            depth += 1;&#xA;        }&#xA;    }&#xA;&#xA;    List&lt;Node&gt; nodeChildren = queryNode.getChildren();&#xA;    for (int i = 0; i &lt; nodeChildren.size(); i++) {&#xA;        depth += checkDepthLimit(nodeChildren.get(i));&#xA;    }&#xA;    return depth;&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<pre><code>String query = ""{&#xA;       viewer{&#xA;           viewerId&#xA;       }""&#xA;QueryComplexity c = new QueryComplexity();&#xA;int depth = c.checkDepthLimit(query);&#xA;</code></pre>&#xA;&#xA;<p>I am stuck and would very much appreciate if someone with deeper knowledge of recursion would be able to help me.</p>&#xA;",1172490,,472495,2017-08-23 08:13:13,2019-12-15 21:35:08,How can I recursively traverse a graphql document in java and find the deepest level it reaches,<java><recursion><graphql><graphql-java>,2,0,0,2017-08-22 23:30:26
45828574,2,,45828426,3,,"<p>The error is where you iterate the children. As you already recognized (""counting twice""), you add the depth of every child to the current depth, but you should only add the deepest one.</p>&#xA;&#xA;<p>This does the trick:</p>&#xA;&#xA;<pre><code>    List&lt;Node&gt; nodeChildren = queryNode.getChildren();&#xA;    int maxChildDepth = 0;&#xA;    for (int i = 0; i &lt; nodeChildren.size(); i++) {&#xA;        final int currentChildDepth = checkDepthLimit(nodeChildren.get(i));&#xA;        maxChildDepth = Math.max(maxChildDepth, currentChildDepth);&#xA;    }&#xA;    depth += maxChildDepth;&#xA;    return depth;&#xA;</code></pre>&#xA;",3577940,,,,2017-08-22 23:54:37,"",,0,1,0,2017-08-22 23:54:37
45844302,1,54356815,,5,1637,"<p>I have implemented a java based GraphQL server using the <a href=""https://github.com/graphql-java/graphql-java-tools"" rel=""noreferrer"">GraphQL-Java-tools</a>. Now I need to implement the Relay based pagination with the Java-GraphQL server that I have. </p>&#xA;&#xA;<p>I couldn't find anything helpful out there. Can anyone please help me in pointing out to the right place to find how to implement Relay based Pagination in Java_GraphQL server? </p>&#xA;&#xA;<p>Thanks in anticipation.</p>&#xA;",5212325,,,,2019-01-24 23:19:44,Relay based Pagination in Java for Java-GraphQL server,<java><pagination><graphql><relay><graphql-java>,1,0,0,2017-08-23 15:50:23
45871504,2,,45361050,1,,"<p>I'm having the exact same problem. Basically, Relay doesn't know how to deal with queries spreading fragments on the root. </p>&#xA;&#xA;<p>That said, you could try to refactor your query to</p>&#xA;&#xA;<pre><code>query frontendQuery {&#xA;  allTodos {&#xA;    ...AllTodo_todos&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and redefine your fragment container to</p>&#xA;&#xA;<pre><code>export default createFragmentContainer(AllTodo, {&#xA;  todos: graphql`&#xA;    fragment AllTodo_todos on Todo {&#xA;      id&#xA;      description&#xA;      complete&#xA;    }&#xA;  `&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><s>In my case it's even a little bit more complicated because I'm using a refetch container and the only solution I've found so far is to put my field under another root field; the old and trusty <code>viewer</code></s></p>&#xA;&#xA;<p>EDIT: I found a way to avoid moving stuff under viewer. Basically you pass all the data from the <code>QueryRenderer</code> as a prop for the corresponding container. To have an idea see: <a href=""https://github.com/facebook/relay/issues/1937"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/issues/1937</a></p>&#xA;",667598,,667598,2017-08-24 22:44:48,2017-08-24 22:44:48,"",,0,0,0,2017-08-24 21:55:11
45900157,2,,45397142,3,,<p>Let's try following:</p>&#xA;&#xA;<p>1) Get todos from your DB like </p>&#xA;&#xA;<pre><code>const todos = await Todo.find({});&#xA;</code></pre>&#xA;&#xA;<p>You can get todos for a specific user as per your Todo Schema. Todo.find({ userid: context.user._id});</p>&#xA;&#xA;<p>2) once you get your todos then get cursor:</p>&#xA;&#xA;<pre><code>const cursor = offsetToCursor(todos.length);&#xA;</code></pre>&#xA;&#xA;<p>This worked for me. Give it a try.</p>&#xA;,5241027,,,,2017-08-26 22:27:03,"",,0,0,0,2017-08-26 22:27:03
45906130,1,,,0,522,"<p>Im developing a React Native app using Relay modern, GraphQL, and Graphcool. I'm trying to fetch the posts from the DB, and I have 3 files, Post.js, PostList, and the index.js.</p>&#xA;&#xA;<p><strong>PostList.js:</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default createFragmentContainer(PostList, graphql`&#xA;  fragment PostList_viewer on Viewer {&#xA;    allPosts(last: 100, orderBy: createdAt_ASC) @connection(key: ""PostList_allPosts"", filters: []) {&#xA;      edges {&#xA;        node {&#xA;          ...Post_post&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`)&#xA;</code></pre>&#xA;&#xA;&#xA;&#xA;<p><strong>Post.js</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export default createFragmentContainer(Post, graphql`&#xA;  fragment Post_post on Post {&#xA;    id&#xA;    content&#xA;    createdAt&#xA;    author {&#xA;      id&#xA;      username&#xA;    }&#xA;  }&#xA;`)&#xA;</code></pre>&#xA;&#xA;&#xA;&#xA;<p><strong>index.js</strong></p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const Feed = () =&gt; (&#xA;  &lt;QueryRenderer&#xA;    environment={environment }&#xA;    query={AllPostQuery}&#xA;    render={({ error, props }) =&gt; {&#xA;      if (error) {&#xA;        return &lt;div&gt;{error.message}&lt;/div&gt;&#xA;      } else if (props) {&#xA;        return &lt;PostList viewer={props.viewer} /&gt;&#xA;      }&#xA;      return &lt;Text&gt;Loading&lt;/Text&gt;&#xA;    }}&#xA;  /&gt;&#xA;)&#xA;</code></pre>&#xA;&#xA;&#xA;&#xA;<p>When I console log <code>this.props.viewer.allPosts</code> inside <strong>PostList.js</strong> I get <code>{ edges: [ null, null, null ], ...</code>. I have 3 posts in the DB so it's finding the posts, but why are they null? Pl</p>&#xA;",4980591,,,,2017-09-04 10:30:01,GraphQL + Relay modern fragment gives me an array of null posts,<javascript><reactjs><react-native><graphql><relay>,1,0,0,2017-08-27 14:38:42
45911490,1,,,2,284,"<p>Here is my definition for Client and ClientInput for GraphQL</p>&#xA;&#xA;<pre><code>type Client {&#xA;  _id: String&#xA;  short_name: String&#xA;  full_name: String&#xA;  address: String&#xA;  contact_name: String&#xA;  contact_email: String&#xA;  contract_currency: String&#xA;  location: String&#xA;}&#xA;&#xA;input ClientInput {&#xA;  short_name: String&#xA;  full_name: String&#xA;  address: String&#xA;  contact_name: String&#xA;  contact_email: String&#xA;  contract_currency: String&#xA;  location: String  &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>They are more or less the same. Why do they choose to invent an input type? </p>&#xA;&#xA;<p>Here is what I found from their official document:</p>&#xA;&#xA;<blockquote>&#xA;  <p>input is another special type in graphql, because in graphql you can't&#xA;  mix input and output types in your schema.</p>&#xA;</blockquote>&#xA;&#xA;<p>I am still not fully clear why. Why in graphql, I can't mix input and output type? </p>&#xA;",887103,,,,2017-08-28 07:40:13,Why does GraphQL choose to use an 'input' type?,<graphql>,1,0,0,2017-08-28 03:38:03
45948368,1,45950243,,2,1289,"<p>I know how to use fragments, my problem right now is that fragments can only be used within queries/mutations for a type.</p>&#xA;&#xA;<p>Eg.</p>&#xA;&#xA;<pre><code>paginationFragment on Person&#xA;</code></pre>&#xA;&#xA;<p>I guess what I am looking for is similar to fragments but more general.</p>&#xA;&#xA;<p>Eg. I have a PersonBrowseQuery, EventsBrowseQuery, BookmarkBrowseQuery etc. All have a meta field containing my pagination data </p>&#xA;&#xA;<pre><code>meta {&#xA;  total&#xA;  per_page&#xA;  current_page  &#xA;&#xA;  etc.    &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to factor this to a reusable thing?</p>&#xA;",749276,,,,2017-08-30 00:43:23,How to reuse fiedls in graphql queries,<graphql><graphql-js><react-apollo>,1,0,0,2017-08-29 21:09:27
45969209,1,,,0,88,<p>I have two GraphQL schemas. One is written in Javascript and the other is written in Java.</p>&#xA;&#xA;<p>Is there any way for me to combine the two into a single GraphQL implementation.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<p>GraphQL Server A can query the following:</p>&#xA;&#xA;<pre><code>{&#xA;    cats&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>GraphQL Server B can query the following:</p>&#xA;&#xA;<pre><code>{&#xA;    dogs&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want my GraphQL Server to be able to query by somehow combining the two together</p>&#xA;&#xA;<pre><code>{&#xA;    cats&#xA;    dogs&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to know if there is something that exists that does this already or if I have to do it myself. If I have to do it myself where should I start?</p>&#xA;,1953420,,,,2018-02-23 20:01:57,Use a GraphQL API in another GraphQL API,<javascript><java><backend><graphql>,1,0,0,2017-08-30 20:30:03
46035125,2,,45906130,0,,"<p>first of all if you run into problems try to log the ""root"" object which is <code>props</code> not a branch inside of it - this will make easier for you to undestrand data structure. </p>&#xA;&#xA;<p>Also, as far as I know Relay does some magic which makes data available for you only in files where you defined a fragment, so in PostList.js you will not see details of the post. Try printing data from Post.js. That's possibly the reason why you see <code>null</code> values printed.</p>&#xA;&#xA;<p>Also data from GraphQL be will be available for you under variable name derived from fragment name after <code>_</code> (underscore), so in your example it will be <code>post</code> not <code>allPosts</code>.</p>&#xA;",4105584,,,,2017-09-04 10:30:01,"",,0,1,0,2017-09-04 10:30:01
46064498,1,,,4,1155,"<p>I've successfully built a GraphQL based API using Graphene-Django.  In doing this, I used Relay.</p>&#xA;&#xA;<p>My front-end colleagues are annoyed with having to specify ""edges &amp; node"" and then pull out the data they want from the similar looking response.</p>&#xA;&#xA;<p>Is there a way to use Relay without ""edges &amp; node""?</p>&#xA;&#xA;<p>Robert</p>&#xA;",8202482,,,,2017-09-10 12:03:22,GraphQL : Using Relay without having to use edges & node,<graphql><graphene-python>,1,0,0,2017-09-05 23:06:41
46078858,1,46125163,,2,2652,"<p>I have the following types and:</p>&#xA;&#xA;<pre><code>union U = B|C|D&#xA;&#xA;type A = { childs: U }&#xA;</code></pre>&#xA;&#xA;<p>that I use with this fragment which works fine and apollo client is able to resolve child objects correctly</p>&#xA;&#xA;<pre><code>fragment A on A {&#xA;    childs {&#xA;        ...B&#xA;        ...C&#xA;        ...D&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>when I convert this into </p>&#xA;&#xA;<pre><code>fragment A on A {&#xA;    childs {&#xA;        U&#xA;    }&#xA;}&#xA;&#xA;fragment U on U {&#xA;    ...B&#xA;    ...C&#xA;    ...D&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>the apollo client is not able to resolve the childs anymore, all objects are empty without any fields. Is there any way to merge the fragments?</p>&#xA;",184883,,,,2017-09-08 22:12:36,How to merge graphQL fragments for request with apollo client,<graphql><react-apollo><apollo-client>,1,0,0,2017-09-06 15:13:51
46082048,1,,,0,1734,"<p>In my Graphene-Django project, I have this structure:</p>&#xA;&#xA;<p>Project level:</p>&#xA;&#xA;<pre><code>schema.py&#xA;</code></pre>&#xA;&#xA;<p>App level:</p>&#xA;&#xA;<pre><code>schema.py&#xA;queries.py&#xA;mutations.py&#xA;</code></pre>&#xA;&#xA;<p>This works well but the queries file has grown quite large.  Is there a way to split <em>class Query</em> into multiple classes and/or multiple files?</p>&#xA;&#xA;<p>Robert</p>&#xA;",8202482,,178800,2018-01-25 15:46:12,2022-06-24 14:02:51,GraphQL: Can Queries & Mutations be split into separate classes?,<django><graphql><graphene-python>,1,0,0,2017-09-06 18:28:36
46112105,1,,,1,449,"<p>I'm having this weird issue, basically:</p>&#xA;&#xA;<ol>&#xA;<li>graphql request made from <code>QueryRenderer</code></li>&#xA;<li>Response comes back from the server contains data (inspected from Network tab in dev tools)</li>&#xA;<li><code>props</code> populated in <code>QueryRenderer</code> <code>render({ error, props })</code> function</li>&#xA;<li>the <code>props</code> get passed down into child component with <code>createFragmentContainer</code> which renders the value</li>&#xA;<li>The rendered value for <strong>one field is different</strong> from the response</li>&#xA;</ol>&#xA;&#xA;<p>I'm not sure what relay is doing when it is looking up the data from its own store, but I suspect it is because missing <code>id</code> declaration in a type, here is the code examples:</p>&#xA;&#xA;<p>App.js</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  environment={env}&#xA;  query={graphql`&#xA;    query ScoreboardContainerQuery($ID: ID!) {&#xA;      scoreboard(id: $ID) {&#xA;        ...Scoreboard_scoreboard&#xA;      }&#xA;    }&#xA;  `}&#xA;  variables={{ID: gameID}}&#xA;&#xA;  render={({ error, props }) =&gt; {&#xA;    return &lt;Scoreboard scoreboard={props ? props.scoreboard : undefined} /&gt;&#xA;  }}&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p>Scoreboard.js</p>&#xA;&#xA;<pre><code>const Scoreboard = ({ scoreboard }) =&gt; (&#xA;  &lt;main&gt;&#xA;    {scoreboard.matches.map(match =&gt; &lt;Match key={match.id} match={match} /&gt;)}&#xA;  &lt;/main&gt;&#xA;)&#xA;&#xA;export default createFragmentContainer(Scoreboard, {&#xA;  scoreboard: graphql`&#xA;  fragment Scoreboard_scoreboard on FootballScoreboard {&#xA;    matches {&#xA;      ...Match_match&#xA;    }&#xA;  }&#xA;  `,&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Match.js</p>&#xA;&#xA;<pre><code>const Match = ({ match }) =&gt; (&#xA;  &lt;div&gt;&#xA;    &lt;div&gt;&#xA;      {match.homeTeam.displayName}-&#xA;      {match.homeTeam.score}&#xA;    &lt;/div&gt;&#xA;    &lt;div&gt;&#xA;      {match.awayTeam.displayName}-&#xA;      {match.awayTeam.score}&#xA;    &lt;/div&gt;&#xA;  &lt;/div&gt;&#xA;)&#xA;&#xA;export default createFragmentContainer(Match, {&#xA;  match: graphql`&#xA;    fragment Match_match on Match {&#xA;      date&#xA;      homeTeam { // this is a Team type&#xA;        id&#xA;        displayName&#xA;        score&#xA;      }&#xA;      awayTeam { // this is a Team type&#xA;        id&#xA;        displayName&#xA;        score&#xA;      }&#xA;    }&#xA;  `,&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>sample response for <code>matches</code> from server:</p>&#xA;&#xA;<pre><code>matches = [&#xA;  {&#xA;    ""date"": ""2017-09-03T06:00:00Z"",&#xA;    ""homeTeam"": {&#xA;      ""id"": ""330"",&#xA;      ""displayName"": ""STG"",&#xA;      ""score"": ""20""&#xA;    },&#xA;    ""awayTeam"": {&#xA;      ""id"": ""332"",&#xA;      ""displayName"": ""CBY"",&#xA;      ""score"": ""0""&#xA;    }&#xA;  },&#xA;  {&#xA;    ""date"": ""2017-08-27T06:00:00Z"",&#xA;    ""homeTeam"": {&#xA;      ""id"": ""329"",&#xA;      ""displayName"": ""PEN"",&#xA;      ""score"": ""14""&#xA;    },&#xA;    ""awayTeam"": {&#xA;      ""id"": ""330"",&#xA;      ""displayName"": ""STG"",&#xA;      ""score"": ""0""&#xA;    }&#xA;  },&#xA;  {&#xA;    ""date"": ""2017-08-12T05:00:00Z"",&#xA;    ""homeTeam"": {&#xA;      ""id"": ""330"",&#xA;      ""displayName"": ""STG"",&#xA;      ""score"": ""42""&#xA;    },&#xA;    ""awayTeam"": {&#xA;      ""id"": ""337"",&#xA;      ""displayName"": ""GCT"",&#xA;      ""score"": ""0""&#xA;    }&#xA;  },&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>the rendered value:</p>&#xA;&#xA;<pre><code>(&#xA;  &lt;main&gt;&#xA;    &lt;div&gt;&#xA;      &lt;div&gt;STG-42&lt;/div&gt;&#xA;      &lt;div&gt;CBY-6&lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div&gt;&#xA;      &lt;div&gt;PEN-0&lt;/div&gt;&#xA;      &lt;div&gt;STG-42&lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div&gt;&#xA;      &lt;div&gt;STG-42&lt;/div&gt;&#xA;      &lt;div&gt;GCT-18&lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;  &lt;/main&gt;&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>So all <code>STG</code> value is overridden to 42, and it shouldn't be. </p>&#xA;&#xA;<p>Is this issue caused because there is no <code>id</code> in the <code>Match</code> type which the response is an array? &#xA;and that's why relay is looking for the <code>Team</code> with same id?</p>&#xA;",4162778,,,,2017-10-26 00:52:27,Relay QueryRenderer fragmentContainer passed props different from server response because id conflict,<javascript><graphql><relayjs><relay><relaymodern>,1,0,0,2017-09-08 08:33:31
46136946,1,,,1,432,"<p>So, I am passing store thru ApolloProvider</p>&#xA;&#xA;<pre><code>  &lt;ApolloProvider store={store} client={apolloClient}&gt;&#xA;</code></pre>&#xA;&#xA;<p>Now, ApolloProvider is putting it, the store, in client. But its putting the store object, not the actual reducer object. So, I am getting the following, which seems odd to me..</p>&#xA;&#xA;<pre><code>client&#xA;   ---&gt; store&#xA;  -----------&gt; getState&#xA;  -----------&gt; dispatch&#xA;</code></pre>&#xA;&#xA;<p>but no ""state""? I mean, sure if I would call getState(), but that seems quite different from when I usually do redux without Apollo. I get my ""state tree""... here, I am getting it...</p>&#xA;&#xA;<p>What is the ""normal"" or ""best practices"" when using redux w/ graphql?</p>&#xA;&#xA;<p>It seems excessive to access a state prop like so:</p>&#xA;&#xA;<pre><code>if (this.props.client.state.getState().whatever.foo)&#xA;</code></pre>&#xA;",1054992,,1054992,2017-09-10 17:55:01,2020-06-01 11:11:57,GraphQL and ApolloProvider and store... its very nested,<redux><graphql><apollo>,1,0,0,2017-09-10 03:12:28
46140205,2,,46133654,1,,"<p>Some of your parer rules should really be lexer rules. And <code>SourceCharacter</code> should probably be a <code>fragment</code>.</p>&#xA;&#xA;<p>Also, instead of <code>EscapedTripleQuote* | SourceCharacter*</code>, you probably want <code>( EscapedTripleQuote | SourceCharacter )*</code>. The first matches <code>aaa...</code> or <code>bbb...</code>, while you probably meant to match <code>aababbba...</code></p>&#xA;&#xA;<p>Try something like this instead:</p>&#xA;&#xA;<pre><code>string&#xA; : Triplequotedstring &#xA; | StringValue &#xA; ;&#xA;&#xA;Triplequotedstring&#xA; : '""""""' TriplequotedstringPart*? '""""""'&#xA; ;&#xA;&#xA;StringValue&#xA; : '""' ( ~[""\\\n\r\u2028\u2029] | EscapedChar )* '""'&#xA; ;&#xA;&#xA;// Fragments never become a token of their own: they are only used inside other lexer rules&#xA;fragment TriplequotedstringPart : EscapedTripleQuote | SourceCharacter;&#xA;fragment EscapedTripleQuote : '\\""""""';&#xA;fragment SourceCharacter :[\u0009\u000A\u000D\u0020-\uFFFF];&#xA;</code></pre>&#xA;",50476,,50476,2017-09-11 05:04:53,2017-09-11 05:04:53,"",,0,4,0,2017-09-10 11:27:48
46140507,2,,46064498,1,,"<p>Edges and node are part of specification of the pagination.&#xA;If you don't need pagination, you can use simple lists(graphene.List) without edges and node</p>&#xA;&#xA;<p>see:&#xA;<a href=""http://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">documentation</a></p>&#xA;",1306579,,,,2017-09-10 12:03:22,"",,0,0,0,2017-09-10 12:03:22
46157806,1,,,1,469,"<pre><code>export default Relay.createContainer(Component,{&#xA; initialVariables :{&#xA;   state:null&#xA; },&#xA; fragments:{&#xA;   store :() =&gt; Relay.QL`&#xA;    fragment on Store {&#xA;      stateInfo(state : $state){     //Repeat taking a state value from a list [""AZ"",""AK""...}&#xA;          name&#xA;          area&#xA;          population&#xA;       }&#xA;    }&#xA;   `&#xA; }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>From the Above relay container, I am trying to get state Info of 10 states hitting a webservice which accepts one state ant a time. My Question .</p>&#xA;&#xA;<ol>&#xA;<li>How Do I loop queries inside the fragments accepting one state values , and hit the webservicce and gather response in one shot?</li>&#xA;<li>How do I access the response in such scenarios ?</li>&#xA;</ol>&#xA;",4391508,,,,2017-09-11 14:12:51,how to call multiple queries inside relay fragments?,<reactjs><graphql><relay><react-router-relay>,0,0,0,2017-09-11 14:12:51
46162227,1,,,0,141,"<p>I have a collection container and offset pagination container in my React + Relay Classic app. Pagination must be composable, because I can have several collections for using this pagination container.</p>&#xA;&#xA;<p>My parent container contain all pagination variables (in my case it is limit and offset) because they must exist there for proper fetch. So, when I click in pagination container next page, click handler must setVariables of parent container.</p>&#xA;&#xA;<p>At this moment I'm using workaround and send relay.variables and relay.setVariables to pagination container via props with another names (parentRelayVariables and setParentVariables) and still seek for a best solution.</p>&#xA;&#xA;<pre><code>class PostsPagination extends React.Component {&#xA;  static propTypes = {&#xA;    posts: PropTypes.shape({&#xA;      pageInfo: PropTypes.shape({&#xA;        hasNextPage: PropTypes.bool.isRequired,&#xA;      }).isRequired,&#xA;      totalCount: PropTypes.number.isRequired,&#xA;    }),&#xA;    setParentRelayVariables: PropTypes.func.isRequired,&#xA;    parentRelayVariables: PropTypes.shape({&#xA;      offset: PropTypes.number.isRequired,&#xA;    }).isRequired,&#xA;    left: PropTypes.bool.isRequired,&#xA;  };&#xA;&#xA;  renderFirstPage(e) {&#xA;    e.preventDefault();&#xA;    this.props.setParentRelayVariables({ offset: 0 });&#xA;  }&#xA;&#xA;  renderNextPage(e) {&#xA;    e.preventDefault();&#xA;    this.props.setParentRelayVariables({&#xA;      offset: this.props.parentRelayVariables.offset + 5,&#xA;    });&#xA;  }&#xA;&#xA;  renderAnotherPage(e, page) {&#xA;    e.preventDefault();&#xA;    this.props.setParentRelayVariables({&#xA;      offset: (page - 1) * 5,&#xA;    });&#xA;  }&#xA;&#xA;  render() {&#xA;    const currentPage = this.props.parentRelayVariables.offset&#xA;      ? (this.props.parentRelayVariables.offset / 5) + 1&#xA;      : 1;&#xA;&#xA;    const totalPages = Math.ceil(this.props.posts.totalCount / 5);&#xA;&#xA;    const pages = createPagesArray(currentPage, totalPages);&#xA;&#xA;    return (&lt;div className=""row paginate""&gt;&#xA;      &lt;ul&gt;&#xA;        &lt;li key=""first""&gt;&#xA;          &lt;a&#xA;            className={this.props.parentRelayVariables.offset ? '' : 'inactive'}&#xA;            href=""""&#xA;            role=""button""&#xA;            onClick={e =&gt; this.renderFirstPage(e)}&#xA;          &gt;В начало&lt;/a&gt;&#xA;        &lt;/li&gt;&#xA;        {pages.map(page =&gt; &lt;li key={page}&gt;&#xA;          &lt;a&#xA;            className={page === currentPage ? 'active' : ''}&#xA;            href=""""&#xA;            role=""button""&#xA;            onClick={e =&gt; this.renderAnotherPage(e, page)}&#xA;          &gt;&#xA;            {page}&#xA;          &lt;/a&gt;&#xA;        &lt;/li&gt;)}&#xA;        &lt;li key=""last""&gt;&#xA;          &lt;a&#xA;            href=""""&#xA;            className={this.props.posts.pageInfo.hasNextPage ? '' : 'inactive'}&#xA;            role=""button""&#xA;            onClick={e =&gt; this.renderNextPage(e)}&#xA;          &gt;&#xA;            Далее&#xA;          &lt;/a&gt;&#xA;        &lt;/li&gt;&#xA;      &lt;/ul&gt;&#xA;    &lt;/div&gt;);&#xA;  }&#xA;}&#xA;&#xA;export default Relay.createContainer(PostsPagination, {&#xA;  fragments: {&#xA;    posts: () =&gt; Relay.QL`&#xA;        fragment on PostConnection {&#xA;            pageInfo {&#xA;                hasNextPage,&#xA;            },&#xA;            totalCount&#xA;        },&#xA;    `,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",6717050,,6717050,2017-09-11 19:46:13,2017-09-11 19:46:13,How to change parent props.relay.variables from child component?,<reactjs><pagination><graphql><relayjs>,0,2,0,2017-09-11 18:31:45
46220464,1,,,3,538,"<p>I'm trying to create an API with <strong>GraphQL</strong> on top of <strong>Hive</strong>, has anyone done something of the sort?</p>&#xA;&#xA;<p>Thanks</p>&#xA;",7015788,,2482874,2017-09-15 14:12:47,2020-06-26 15:18:40,how to create an API with GraphQL on top of Hive?,<api><hive><graphql>,1,1,0,2017-09-14 13:28:04
46287606,1,,,1,250,"<p>My Schema.graphql of Relay, this is the structure I'm trying to achieve,</p>&#xA;&#xA;<pre><code>type Root {&#xA;  viewer: Viewer&#xA;}&#xA;&#xA;type Viewer {&#xA;  categories(id: ID): Category&#xA;  subCategories(CategoryId: ID!) : [SubCategory]&#xA;  items(SubCategoryId: ID): Item&#xA;  shopItems(ShopId: ID, SubCategoryId:ID): Item&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now the server, my viewer.js looks like this,</p>&#xA;&#xA;<pre><code>const Viewer = new GraphQLObjectType({&#xA;  name: 'viewer',&#xA;  fields: {&#xA;    categories,&#xA;    subCategories,&#xA;    Items,&#xA;    shopItems,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>and the root is,</p>&#xA;&#xA;<pre><code>const RootQuery = new GraphQLObjectType({&#xA;  name: 'query',&#xA;  fields: {&#xA;    viewer: {&#xA;      type: Viewer,&#xA;    },&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>It is giving me the structure I want, but I cannot resolve anything from rootQuery, viewer simply returns null because I'm not resolving the viewer type in rootQuery. Any ideas how to implement this Relay spec structure properly? Thanks guys</p>&#xA;",6797322,,3857002,2017-09-19 07:14:48,2017-09-20 13:49:15,Structuring the relay spec viewer in GraphQL,<graphql><relayjs><graphql-js>,2,0,0,2017-09-18 20:21:53
46323910,2,,46287606,0,,"<p>Stupid me, solved it by resolving viewer like this,</p>&#xA;&#xA;<pre><code>const RootQuery = new GraphQLObjectType({&#xA;  name: 'query',&#xA;  fields: {&#xA;    viewer: {&#xA;      type: Viewer,&#xA;      resolve(viewer, args) {&#xA;       return {viewer: viewer}&#xA;     }&#xA;    },&#xA;  },&#xA;});&#xA;</code></pre>&#xA;",6797322,,,,2017-09-20 13:49:15,"",,0,0,0,2017-09-20 13:49:15
46331377,1,,,0,587,"<p>I'm doing a mutation of multiple items. But the connection handler in updater returns undefined. I'm dealing with the shopItems type, Here's the relevant schema</p>&#xA;&#xA;<pre><code>type Mutation {&#xA;  shopItem(input: itemsInput): addedItems&#xA;}&#xA;&#xA;type addedItems {&#xA;  addedItems: [itemEdge]&#xA;}&#xA;&#xA;type itemEdge {&#xA;  cursor: Int&#xA;  node: itemNode&#xA;}&#xA;&#xA;type itemNode implements Node {&#xA;  id: ID!,&#xA;  name: String,&#xA;  price: Int&#xA;}&#xA;&#xA;type Root {&#xA;  viewer: viewer&#xA;}&#xA;&#xA;type viewer {&#xA;  id: ID!&#xA;  shopItems(ShopId: ID, SubCategoryId:ID, first:Int, last: Int): Item&#xA;}&#xA;&#xA;type Item {&#xA;  pageInfo: PageInfo&#xA;  edges: [itemEdge]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this is the fragment for shopItems query, </p>&#xA;&#xA;<pre><code>module.exports = createFragmentContainer(&#xA;  Item,&#xA;  graphql`&#xA;    fragment item_viewer on viewer {&#xA;      // the global parent viewer id&#xA;      id,&#xA;      shopItems(first:$first,last:$last,ShopId:$ShopId,SubCategoryId:$SubCategoryId) @connection(key: ""item_shopItems"",filters:[""first"",""last""]){&#xA;&#xA;     // didn't want the pageInfo here yet but relay compiler enforces this because of @connection. It's basically returning null.&#xA;        pageInfo {&#xA;          hasNextPage&#xA;          endCursor&#xA;        }&#xA;        edges {&#xA;          cursor // returns null as well&#xA;          node {&#xA;            id&#xA;            name&#xA;            price&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>the mutation for adding shopItems returns array of addedItems,</p>&#xA;&#xA;<pre><code>mutation addShopItemMutation($input: itemsInput) {&#xA;    shopItem(input: $input) {&#xA;      addedItems {&#xA;        node {&#xA;          id&#xA;          name&#xA;          price&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;&#xA;commitMutation(&#xA;        environment,&#xA;        {&#xA;        ...&#xA;        updater: (store) =&gt; {&#xA;          const payload = store.getRootField('shopItem');&#xA;&#xA;          //I've seen everyone using getLinkedRecord, but in my case the mutation return type is an array and it gives an error so I'm using getLinkedRecords. I think this is where the problem lies.&#xA;&#xA;          const newItem = payload.getLinkedRecords('addedItems');&#xA;          this.sharedUpdate(store, this.props.viewerId, newItem)&#xA;        }&#xA;      })&#xA;&#xA;sharedUpdate(store, viewerId, newItem) {&#xA;&#xA;    //viewerProxy here is not undefined&#xA;    const viewerProxy = store.get(viewerId);&#xA;&#xA;    //conn is undefined&#xA;    const conn = ConnectionHandler.getConnection(&#xA;    viewerProxy,&#xA;    'item_shopItems',&#xA;    );&#xA;    if(conn)  {&#xA;      ConnectionHandler.insertEdgeAfter(conn, newItem);&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>For some reason the connection returns undefined. Also when I console.log viewerProxy, I do see the connection key ""item_shopItems"" but the new edge doesn't appear there. Just in case, I'm using Node Js - Express on server side.</p>&#xA;&#xA;<p>Another problem is that the addedItem is not singular, but an array.</p>&#xA;",6797322,,,,2017-10-16 06:04:54,after mutation relay modern connection handler is undefined,<graphql><relayjs><relay><relaymodern>,1,0,0,2017-09-20 20:37:45
46342191,1,,,1,1173,"<p>After much reading Apollo React documentation I am unable to create a GraphQL query using a Redux provided props variable <code>displayLocation</code> of the <code>DiscoveryList</code> component. Flow type of <code>displayLocation</code> given below: -</p>&#xA;&#xA;<pre><code>type DisplayLocation = {&#xA;  lat: number,&#xA;  lng: number,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>I am getting the following error: - <code>Variable lat of type Float! was provided invalid value</code>, surprisingly the provided value to the float variable is <code>37.33233141</code>. Redux and Apollo Component integration code given below :- </p>&#xA;&#xA;<pre><code>export default compose(&#xA;  connect(({ displayLocation }) =&gt; ({ displayLocation }), {&#xA;    updateDisplayLocation,&#xA;  }),&#xA;  graphql(&#xA;    gql`&#xA;    query DiscoveryList($lat: Float!, $lng: Float!) {&#xA;      destinations(radius: {&#xA;        latitude: $lat,&#xA;        longitude: $lng,&#xA;        distance: 10000})&#xA;        { name&#xA;          id&#xA;          country_code&#xA;        }&#xA;      }`,&#xA;    {&#xA;      options: ({ displayLocation }) =&gt; ({&#xA;        variables: {&#xA;          lat: displayLocation.lat,&#xA;          lng: displayLocation.lng,&#xA;        },&#xA;      }),&#xA;    },&#xA;  ),&#xA;)(DiscoverList);&#xA;</code></pre>&#xA;&#xA;<p>Many thanks for your help. </p>&#xA;&#xA;<p>I was also wondering to feed redux props into the Apollo GraphQL query, should we <code>connect()</code> redux first and then Apollo <code>graphql()</code> or the other way around before exporting the component please?</p>&#xA;",1185085,,1185085,2017-09-21 13:38:45,2018-03-29 13:43:59,Apollo GraphQL variable Query,<reactjs><react-native><graphql><apollo><react-apollo>,1,5,0,2017-09-21 10:58:34
46382505,1,46386940,,1,1197,"<p>I am using <a href=""https://github.com/apollographql/react-apollo"" rel=""nofollow noreferrer""><code>react-apollo</code></a> to access a <code>graphql</code> in a web app.</p>&#xA;&#xA;<p>I have a query that looks like this that allows me to filter a schedule of games:</p>&#xA;&#xA;<pre><code>query($pagination:Int!, $divisionId:ID, $teamId:ID, $startDate:DateTime!, $endDate:DateTime!&#xA;){&#xA; games: allGames (&#xA; orderBy: date_ASC,&#xA; first: $pagination,&#xA; filter: {&#xA;   date_gte: $startDate,&#xA;   date_lte: $endDate,&#xA;   division: {id: $divisionId},&#xA;   OR: [&#xA;    {homeTeam: {id: $teamId} },&#xA;    {awayTeam: {id: $teamId} },&#xA;   ]&#xA;  }&#xA;){&#xA; id&#xA; .... more fields&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The <code>startDate</code> and <code>endDate</code> variables are required for every request, but the <code>teamId</code> and <code>divisionId</code> are not. I would like to display all <code>teamIds</code> and <code>divisionIds</code> in the initial request, and allow the use to filter / drill down as needed.</p>&#xA;&#xA;<p>I was looking to see if I could add a wildcard (<code>*</code>) or something of that sort, but I am not sure if it's possible.  With graphql mutations, a <code>null</code> value for a variable allows me to write a single mutation that is applicable to multiple use cases (partial updates &amp; creates), but I cannot figure out how to achieve similar functionality with queries.</p>&#xA;&#xA;<p>Do I need to call a different query for each of the filter scenarios (one for no <code>divisionId</code> &amp; <code>teamId</code>, one for just divisionId, one for just <code>teamId</code>, and one for both <code>divisionId</code> and <code>teamId</code>? Are <a href=""http://dev.apollodata.com/react/fragments.html"" rel=""nofollow noreferrer"">fragments</a> something that would help me achieve this with less overhead (because the last sentence makes the process seem a bit too cumbersome / not DRY).</p>&#xA;&#xA;<p>Or do i switch <code>division</code> and <code>id</code> to <code>division_in</code> and <code>id_in</code> and pass them (somewhat large) arrays with all the possible values for <code>divisionIds</code> and <code>teamdIds</code> as initial props? </p>&#xA;",5045662,,,,2017-09-24 05:35:17,Modeling optional filter params in react-apollo,<reactjs><graphql><apollo><react-apollo>,1,0,0,2017-09-23 17:41:03
46386940,2,,46382505,2,,"<p>So it turns out you an actually store the entire filter as a variable (which is pretty awesome). </p>&#xA;&#xA;<p>Here is the updated query:</p>&#xA;&#xA;<pre><code>query( $first:Int!, $skip:Int!, $gameFilter:GameFilter! ){&#xA;  games: allGames (&#xA;    orderBy: date_ASC,&#xA;    first: $first,&#xA;    skip: $skip,&#xA;    filter: $gameFilter&#xA;  ){&#xA;    id&#xA;    ... more fields&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the corresponding HOC:</p>&#xA;&#xA;<pre><code>export default graphql(gamesQuery, {&#xA;  options: props =&gt; ({&#xA;    return { variables: {props.gameFilter}&#xA;  });&#xA;})(GamesPage);&#xA;</code></pre>&#xA;&#xA;<p>Hat tip to these guys:</p>&#xA;&#xA;<ul>&#xA;<li><a href=""https://www.graph.cool/forum/t/optional-query-filters/355"" rel=""nofollow noreferrer"">https://www.graph.cool/forum/t/optional-query-filters/355</a></li>&#xA;<li><a href=""https://www.graph.cool/forum/t/is-it-possible-to-build-a-filter-query-dynamically/268"" rel=""nofollow noreferrer"">https://www.graph.cool/forum/t/is-it-possible-to-build-a-filter-query-dynamically/268</a></li>&#xA;</ul>&#xA;",5045662,,,,2017-09-24 05:35:17,"",,0,0,0,2017-09-24 05:35:17
46452868,1,47778329,,6,16275,"<p>I have this Graphql query</p>&#xA;<pre><code> &quot;{TABLE_NAME{&#xA;    id&#xA;    severity&#xA;    des&#xA;    ip&#xA;    hostname&#xA;    description&#xA;&#xA;  }&#xA;}&quot;; &#xA;</code></pre>&#xA;<p>That's return over 1000 records, how to do:</p>&#xA;<pre><code>SELECT COUNT(*) FROM TABLE_NAME&#xA;</code></pre>&#xA;<p>in Graphql ?</p>&#xA;",6605675,,6605675,2022-04-10 18:16:16,2022-04-10 18:16:16,Return Graphql Count,<graphql>,3,0,0,2017-09-27 16:26:22
46490229,1,,,7,2842,"<p>I'd like to know whether it is possible to get the ""original id"" of an object as the result of the query. Whenever I make a request to the server, it returns the node ""global identifier"", something like <code>U29saWNpdGFjYW9UeXBlOjEzNTkxOA==</code> .  </p>&#xA;&#xA;<p>The query is similar to this one:  </p>&#xA;&#xA;<pre><code>{&#xA;  allPatients(active: true) {&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        state&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>and the return is:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""cursor"": ""YXJyYXljb25uZWN0aW9uOjA="",&#xA;          ""node"": {&#xA;            ""id"": ""U29saWNpdGFjYW9UeXBlOjEzNTkxOA=="",&#xA;            ""state"": ""ARI"",&#xA;            ""name"": ""Brad""&#xA;          }&#xA;        }&#xA;      ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I get the ""original"" id of the object at the database level (e.g. '112') instead of that node unique identifier? </p>&#xA;&#xA;<p>ps.: I am using graphene-python and Relay on the server side.</p>&#xA;",2500462,,2500462,2017-09-29 13:55:40,2020-07-10 19:57:23,Retrieve the object ID in GraphQL,<python><graphql><graphene-python>,4,0,0,2017-09-29 13:49:57
46499322,2,,46498143,6,,"<p>You can use a search query with <a href=""https://help.github.com/articles/searching-issues-and-pull-requests/#search-by-milestone-on-an-issue-or-pull-request"" rel=""noreferrer""><code>milestone</code></a> filter : </p>&#xA;&#xA;<pre><code>{&#xA;  search(first: 100, type: ISSUE, query: ""user:callemall repo:material-ui milestone:v1.0.0-prerelease state:open"") {&#xA;    issueCount&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        ... on Issue {&#xA;          createdAt&#xA;          title&#xA;          url&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2614364,,,,2017-09-30 03:31:39,"",,0,1,0,2017-09-30 03:31:39
46546384,1,,,1,106,"<p>Maybe someone who has managed to pass this step is willing to provide some indications.</p>&#xA;&#xA;<p>I have a schema, a resolver, i request the query and i have a null response.&#xA;Please can you help on topic?</p>&#xA;&#xA;<pre><code>module.exports = {&#xA;  Query: {&#xA;    allLinks: async (root, {filter}, {mongo: {Links, Users}}) =&gt; {&#xA;      let query = filter ? {$or: buildFilters(filter)} : {};&#xA;      return await Links.find(query).toArray();&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>and the query request looks like this:</p>&#xA;&#xA;<pre><code>    query LinkListPageQuery {&#xA;  allLinks {&#xA;    ...LinkList_allLinks&#xA;  }&#xA;}&#xA;&#xA;fragment LinkList_allLinks on LinkConnection {&#xA;  edges {&#xA;    cursor&#xA;    ...Link_link&#xA;  }&#xA;}&#xA;&#xA;fragment Link_link on LinkEdge {&#xA;  node {&#xA;    id&#xA;    description &#xA;    url&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My schema looks like this:</p>&#xA;&#xA;<pre><code>const typeDefs = `&#xA;    type Link implements Node {&#xA;      id: ID!&#xA;      url: String!&#xA;      description: String!&#xA;      postedBy: User&#xA;      votes: [Vote!]!&#xA;    }&#xA;    interface Node {&#xA;      id: ID!&#xA;    }&#xA;    type Query {&#xA;      allLinks(filter: LinkFilter, first: Int): [LinkConnection]&#xA;      node(&#xA;        id: ID!&#xA;        ): Node&#xA;    }&#xA;    type LinkEdge {&#xA;      node: Link!&#xA;      cursor: String&#xA;    }&#xA;    type LinkConnection {&#xA;      pageInfo: PageInfo&#xA;      edges: LinkEdge&#xA;      count: Int&#xA;    }&#xA;    input LinkFilter {&#xA;      OR: [LinkFilter!]&#xA;      description_contains: String&#xA;      url_contains: String&#xA;    }&#xA;    }&#xA;  `;&#xA;</code></pre>&#xA;&#xA;<p>PS: This language schema is done according to <code>graphql-tools</code> package.</p>&#xA;&#xA;<p><strong>Resolver:</strong></p>&#xA;&#xA;<pre><code> Query: {&#xA;        users: async (root, { first, after }, { mongo: { Users }, user }) =&gt; {&#xA;          const queryData = await Users.find(query).toArray();&#xA;          first = first || queryData.length;&#xA;          after = after ? parseInt(fromCursor(after), 10) : 0;&#xA;          const edges = queryData.map((node, i) =&gt; ({&#xA;            cursor: toCursor(i+1),&#xA;            node: node._id,&#xA;          })).slice(after, first + after);&#xA;          const slicedUser = edges.map(({ node }) =&gt; node);&#xA;          return {&#xA;            edges,&#xA;            pageInfo: {&#xA;              startCursor: edges.length &gt; 0 ? edges[0].cursor : null,&#xA;              hasNextPage: first + after &lt; queryData.length,&#xA;              endCursor: edges.length &gt; 0 ? edges[edges.length - 1].cursor : null&#xA;            },&#xA;            count: queryData.length,&#xA;          };&#xA;        },&#xA;UserConnection: {&#xA;    edges: ({ edges }) =&gt; edges,&#xA;    pageInfo: ({ pageInfo }) =&gt; pageInfo,&#xA;    count: ({ count }) =&gt; count,&#xA;  },&#xA;&#xA;  UserEdge: {&#xA;    node: async ({ node },data, {dataloaders: {userLoader}}) =&gt; {&#xA;      const user = await userLoader.load(node);&#xA;      return user;&#xA;    },&#xA;    cursor: ({ cursor }) =&gt; cursor,&#xA;  },&#xA;</code></pre>&#xA;",8484035,,8484035,2017-12-08 10:11:36,2017-12-08 10:11:36,Null response in query for Relay Modern interogation on GraphQL,<mongodb><graphql><graphql-js><relaymodern>,0,0,0,2017-10-03 13:56:55
46553568,2,,46546908,0,,"<p>Your request is actually working fine. But the maximum depth you can view using <code>console.log</code> default to 2. You can use <a href=""https://nodejs.org/api/util.html#util_util_inspect_object_options"" rel=""nofollow noreferrer""><code>util.inspect</code></a> to change it, set the depth to <code>null</code> to view the full object :</p>&#xA;&#xA;<pre><code>const util = require('util');&#xA;&#xA;.....&#xA;&#xA;console.log('Body: ', util.inspect(body, {depth: null}));&#xA;</code></pre>&#xA;",2614364,,,,2017-10-03 21:16:53,"",,0,0,0,2017-10-03 21:16:53
46636192,2,,46635701,0,,"<p>The error was my, because y put the URL of the interface of GraphQL. The URL correct is <a href=""http://127.0.0.1:8000/"" rel=""nofollow noreferrer"">http://127.0.0.1:8000/</a><strong>graphql</strong></p>&#xA;",6637520,,,,2017-10-08 21:20:27,"",,0,0,0,2017-10-08 21:20:27
46644417,1,46665602,,0,502,"<p>I cant seem to get the ""count"" data to show up in the UI. I'm sure I'm missing something about using two fragments in the same container or rendering the edges array or async, maybe.&#xA;All other data is showing except <code>{this.props.link.votes.count}</code> which comes up empty in the UI while throwing no errors on the server or client in dev tools. Its just not showing up. &#xA;Any help would be greatly appreciated. Thank you.</p>&#xA;&#xA;<p>The react component looks like:</p>&#xA;&#xA;<pre><code>       &lt;div className=""f6 lh-copy gray""&gt;&#xA;        {"" ""}&#xA;        {this.props.link.votes.count} votes | by {"" ""}&#xA;        {this.props.link.postedBy&#xA;          ? this.props.link.postedBy.name&#xA;          : ""Unknown""}{"" ""}&#xA;        {timeDifferenceForDate(this.props.link.createdAt)}{"" ""}&#xA;      &lt;/div&gt;{"" ""}&#xA;</code></pre>&#xA;&#xA;<p>I've got this working graphql query that pulls up the correct data in graphiql.</p>&#xA;&#xA;<pre><code>{&#xA;  links(first: 20) {&#xA;    pageInfo {&#xA;      hasPreviousPage&#xA;      hasNextPage&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        url&#xA;        description&#xA;        votes {&#xA;          ...Link_votes&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment Link_votes on VoteConnection {&#xA;  edges {&#xA;    cursor&#xA;    node {&#xA;      count&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the output</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""links"": {&#xA;      ""pageInfo"": {&#xA;        ""hasPreviousPage"": false,&#xA;        ""hasNextPage"": false&#xA;      },&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""TGluazo1OWRiNDc4ODY5YmJkOTViOWY2YzVkMGY="",&#xA;            ""url"": ""afasfdasf"",&#xA;            ""description"": ""adasdf"",&#xA;            ""votes"": {&#xA;              ""edges"": [&#xA;                {&#xA;                  ""cursor"": ""YXJyYXljb25uZWN0aW9uOjA="",&#xA;                  ""node"": {&#xA;                    ""count"": ""3""&#xA;                  }&#xA;                }&#xA;              ]&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In my Link.js component i've got these fragments that duplicate the above graphql call</p>&#xA;&#xA;<pre><code>createFragmentContainer(&#xA;&#xA;&#xA;Link,&#xA;  graphql`&#xA;    fragment Link_votes on VoteConnection {&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          count&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;);&#xA;&#xA;export default createFragmentContainer(Link, {&#xA;  link: graphql`&#xA;    fragment Link_link on Link {&#xA;      id&#xA;      description&#xA;      url&#xA;      createdAt&#xA;      postedBy {&#xA;        id&#xA;        name&#xA;      }&#xA;      votes {&#xA;        ...Link_votes&#xA;      }&#xA;    }&#xA;  `&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The full Link.js file is in this <a href=""https://gist.github.com/idkjs/7d2004b57fc2d60d9f6357514c1f5b39"" rel=""nofollow noreferrer"">gist</a>.</p>&#xA;&#xA;<p>So the idea would be, given the structure of the 'link' node, this should work:</p>&#xA;&#xA;<pre><code>{this.props.link.votes.edges[0].node.count}&#xA;</code></pre>&#xA;&#xA;<p>'link' gets you the link you are on in the graphql response. 'votes' gets you the votes key which has an array of edges which always returns just one object in the array containing the count result for votes. So you want index 0 in that array which would be</p>&#xA;&#xA;<pre><code>`{ ""cursor"": ""YXJyYXljb25uZWN0aW9uOjA="",&#xA;   ""node"": { &#xA;      ""count"": ""3""&#xA;   }&#xA; }`&#xA;</code></pre>&#xA;&#xA;<p>If we want the node propery on index 0, we use dot notation, then same for the count property key on the object. This is not working. </p>&#xA;",2336356,,2336356,2017-10-09 18:28:53,2017-10-10 11:27:49,Rendering Relay Modern Fragments in React,<graphql><relayjs><react-relay><graphiql>,1,0,0,2017-10-09 10:36:24
46660411,1,46660475,,1,227,"<p>I'm trying to return create a paginated list. I used graphql to query the data. With my query, I pass the number of records I need (In a variable named <code>first</code>) and the ID of the last fetched record (In a varible called <code>after</code>). Now I managed to write a query (Note that I used <code>mongoose</code>) to fetch the records. Now what I need to do is get the relavant information to perform the pagination like <code>hasNextPage</code>, <code>hasPreviousPage</code>, <code>currentPage</code> and <code>totalPages</code>. </p>&#xA;&#xA;<p>To get most of these information I need to get the total number of records in the database. To do that I need to send another db request.</p>&#xA;&#xA;<p>I also need to know the position of the record in the table. No idea how.</p>&#xA;&#xA;<p>Here's the query:</p>&#xA;&#xA;<pre><code>new Promise((resolve, reject) =&gt;&#xA;  Company.where('_id')&#xA;    .gt(after)&#xA;    .limit(first)&#xA;    .lean()&#xA;    .exec((error, doc) =&gt; {&#xA;      if (error) {&#xA;        reject(error);&#xA;      }&#xA;&#xA;      resolve({&#xA;        edges: doc,&#xA;        pageInfo: {&#xA;          hasNextPage: '...',&#xA;          hasPreviousPage: '...',&#xA;          currentPage: '...',&#xA;          totalPages: '...'&#xA;        }&#xA;      });&#xA;    }))&#xA;</code></pre>&#xA;&#xA;<p>Any idea how to do this efficiently?</p>&#xA;",734776,,,,2017-10-14 15:18:04,In mongo how to get the current position of the record in the table with the total records for pagination?,<mongodb><mongoose><graphql>,1,0,0,2017-10-10 06:58:01
46665602,2,,46644417,1,,"<p>This is what worked.</p>&#xA;&#xA;<pre><code>solution was to remove the Link_votes fragment container&#xA;```&#xA;createFragmentContainer(&#xA;  Link,&#xA;  graphql`&#xA;    fragment Link_votes on VoteConnection {&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          count&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;);&#xA;```&#xA;</code></pre>&#xA;&#xA;<p>in link fragment, use votes directly, </p>&#xA;&#xA;<pre><code>```&#xA;votes {&#xA;   edges {&#xA;      node {&#xA;         count&#xA;      }&#xA;   }&#xA;}&#xA;```&#xA;</code></pre>&#xA;&#xA;<p>I'm thinking this was a case of just over thinking. I will leave this here in case it helps anyone.</p>&#xA;",2336356,,,,2017-10-10 11:27:49,"",,0,0,0,2017-10-10 11:27:49
46684945,2,,42652411,2,,"<p>Using Relay's modern API, compose a <code>refetchContainer</code> from <code>SearchResult</code> component because of the need <em>""an option to execute a new query with different variables and render the response of that query instead when the request comes back""</em>.</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import debounce from 'debounce';&#xA;import { graphql, createRefetchContainer } from 'react-relay';&#xA;&#xA;class SearchResult extends React.Component {&#xA;  componentWillReceiveProps(nextProps) {&#xA;    if (this.props.query != nextProps.query) {&#xA;      debounce(() =&gt; this._searchMovies(), 600);&#xA;    }&#xA;  }&#xA;&#xA;  _searchMovies() {&#xA;    const refetchVariables = fragmentVariables =&gt; ({&#xA;      query: this.props.query&#xA;  });&#xA;&#xA;    this.props.relay.refetch(refetchVariables, null);&#xA;  }&#xA;&#xA;  render() {&#xA;    var { viewer: { moviesByTitle: movies } } = this.props;&#xA;    return (&#xA;      &lt;div className=""searchResult""&gt;&#xA;        {movies.edges.map((edge, i) =&gt;&#xA;          &lt;div key={i} className=""rowItem scrollRowItem""&gt;&#xA;            &lt;Movie movie={edge.node} /&gt;&#xA;          &lt;/div&gt;)}&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;&#xA;// Similar query syntax as Relay Classic&#xA;// Only syntactic difference is with absence of Movie.getFragment&#xA;module.exports = createRefetchContainer(SearchResult, {&#xA;    viewer: graphql`&#xA;      fragment SearchResult_viewer on SearchResult {&#xA;        @argumentDefinitions(&#xA;          query: {type: ""String"", defaultValue: """"}&#xA;        ) {&#xA;        moviesByTitle(title: $query, first: 10) {&#xA;          edges {&#xA;            node {&#xA;              ...Movie_movie&#xA;            }&#xA;          }&#xA;        }&#xA;      }`&#xA;    },&#xA;    graphql`&#xA;      query MoviesRefetchQuery($query: String) {&#xA;        viewer {&#xA;          ...SearchResult_viewer @arguments(query: $query)&#xA;        }&#xA;      }&#xA;   `);&#xA;</code></pre>&#xA;",5189811,,,,2017-10-11 09:44:38,"",,0,0,0,2017-10-11 09:44:38
46701746,1,,,22,5812,"<p>The following executes correctly in graphiQL</p>&#xA;&#xA;<pre><code>fragment BookGridFields on Book {&#xA;  _id&#xA;  title&#xA;}&#xA;&#xA;{&#xA;  allBooks {&#xA;    ...BookGridFields&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p>My question is, it possible to specify the fragment right in my schema, right below where my Book type is defined, like so</p>&#xA;&#xA;<pre><code>type Book {&#xA;  _id: String&#xA;  title: String&#xA;  pages: Int&#xA;  weight: Float&#xA;  authors: [Author]&#xA;}&#xA;&#xA;fragment BookGridFields on Book {&#xA;  _id&#xA;  title&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So that I could just run queries like this</p>&#xA;&#xA;<pre><code>{&#xA;  allBooks {&#xA;    ...BookGridFields&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>without needing to define the fragment as part of my query.</p>&#xA;&#xA;<p>Currently the above errors with</p>&#xA;&#xA;<blockquote>&#xA;  <p>Unknown fragment \""BookGridFields\""</p>&#xA;</blockquote>&#xA;",352552,,,,2018-04-20 14:14:20,"Add graphQL fragment to schema, and have available for all queries",<javascript><graphql><graphql-js>,1,6,0,2017-10-12 05:01:57
46756026,2,,46755660,1,,"<p>i think you made a typo, try to change your code from this</p>&#xA;&#xA;<p><code>field :viewer, types.UserType do</code> to  <code>field :viewer, Types::UserType do</code></p>&#xA;",6891676,,,,2017-10-15 14:17:15,"",,0,1,0,2017-10-15 14:17:15
46763853,2,,46331377,0,,"<p>you need using pagination for shopItems query:</p>&#xA;&#xA;<pre><code>module.exports = createPaginationContainer(&#xA;  ShopItems,&#xA;  {&#xA;    viewer: graphql`&#xA;      fragment ShopItems_viewer on Viewer {&#xA;        id&#xA;        shopItems(&#xA;          first: $count&#xA;          after: $cursor&#xA;          ShopId: $ShopId&#xA;          SubCategoryId: $SubCategoryId&#xA;        )&#xA;          @connection(&#xA;            key: ""ShopItems_shopItems""&#xA;            filters: [""ShopId"", ""SubCategoryId""]&#xA;          ) {&#xA;          edges {&#xA;            cursor&#xA;            node {&#xA;              id&#xA;              name&#xA;              price&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  },&#xA;  {&#xA;    direction: 'forward',&#xA;    getConnectionFromProps(props) {&#xA;      return props.viewer.shopItems;&#xA;    },&#xA;    getFragmentVariables(prevVars, totalCount) {&#xA;      return {&#xA;        ...prevVars,&#xA;        count: totalCount&#xA;      };&#xA;    },&#xA;    getVariables(props, { count, cursor }, fragmentVariables) {&#xA;      return {&#xA;        count,&#xA;        cursor,&#xA;        ShopId: fragmentVariables.ShopId,&#xA;        SubCategoryId: fragmentVariables.SubCategoryId&#xA;      };&#xA;    },&#xA;    query: graphql`&#xA;      query ShopItemsQuery(&#xA;        $count: Int!&#xA;        $cursor: String&#xA;        $ShopId: ID&#xA;        $orderBy: ID&#xA;      ) {&#xA;        viewer {&#xA;          ...ShopItems_viewer&#xA;        }&#xA;      }&#xA;    `&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>note: <code>filters: []</code> in <code>@connection</code> without <code>after</code>, <code>first</code>, <code>before</code> and <code>last</code></p>&#xA;&#xA;<p>the mutation:</p>&#xA;&#xA;<pre><code>/**&#xA; * @flow&#xA; */&#xA;import { commitMutation, graphql } from 'react-relay';&#xA;import { ConnectionHandler } from 'relay-runtime';&#xA;import environment from '../utils/createRelayEnvironment';&#xA;&#xA;type Options = {&#xA;  onSuccess: Function,&#xA;  onFailure: Function&#xA;};&#xA;&#xA;const defaultCallbacks: Options = { onSuccess: () =&gt; {}, onFailure: () =&gt; {} };&#xA;&#xA;const mutation = graphql`&#xA;  mutation AddShopItemMutation($input: itemsInput) {&#xA;    shopItem(input: $input) {&#xA;      addedItems {&#xA;        cursor&#xA;        node {&#xA;          id&#xA;          name&#xA;          price&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;function sharedUpdater(store, viewer, addedItemsEdge, nameConnection, filters) {&#xA;  const viewerProxy = store.get(viewer.id);&#xA;&#xA;  const connection = ConnectionHandler.getConnection(&#xA;    viewerProxy,&#xA;    nameConnection,&#xA;    filters // your connection undefined is do missing filters&#xA;  );&#xA;&#xA;  if (connection) {&#xA;    ConnectionHandler.insertEdgeBefore(connection, addedItemsEdge);&#xA;  }&#xA;}&#xA;&#xA;let nextClientMutationId = 0;&#xA;&#xA;function commit(&#xA;  viewer: Object,&#xA;  input: Object,&#xA;  nameConnection: string,&#xA;  filters: Object, // { ShopId: ID, SubCategoryId: ID };&#xA;  // const { ShopId, SubCategoryId } = this.context.relay.variables&#xA;  cb: Options = defaultCallbacks&#xA;): any {&#xA;  nextClientMutationId += 1;&#xA;&#xA;  return commitMutation(environment, {&#xA;    mutation,&#xA;    variables: {&#xA;      input: {&#xA;        ...input,&#xA;        clientMutationId: nextClientMutationId&#xA;      }&#xA;    },&#xA;    onCompleted: cb.onSuccess,&#xA;    onError: cb.onFailure,&#xA;    updater(store) {&#xA;      const payload = store.getRootField('addShopItem');&#xA;&#xA;      sharedUpdater(&#xA;        store,&#xA;        viewer,&#xA;        payload.getLinkedRecords('addedItems'),&#xA;        nameConnection,&#xA;        filters&#xA;      );&#xA;    }&#xA;  });&#xA;}&#xA;&#xA;export default { commit };&#xA;</code></pre>&#xA;",5826897,,,,2017-10-16 06:04:54,"",,0,0,0,2017-10-16 06:04:54
46816047,2,,44885085,0,,"<p>Relay compiler will find your <code>Child.js</code> file so the fragment will be created and your query will be fetched. &#xA;However, the difference is <code>createFragmentContainer</code> is a HOC that Relay uses to guarantee that the component won't render until all necessary data is available. This is the purpose of <code>FragmentContainer</code> and that's why you should use it.</p>&#xA;",8652467,,,,2017-10-18 17:36:15,"",,0,0,0,2017-10-18 17:36:15
46915261,1,,,0,93,"<p>I'm building my first SaaS B2C application using ReactJS + Relay + GraphQL + MongoDb. As an example, the application would have the following objects:</p>&#xA;&#xA;<ul>&#xA;<li>User </li>&#xA;<li>Customer</li>&#xA;<li>StockItem</li>&#xA;<li>StockLevel</li>&#xA;<li>PriceList</li>&#xA;<li>Sales</li>&#xA;<li>Returns</li>&#xA;</ul>&#xA;&#xA;<p>For each object I can see its listing (ex: List of items on stock - StockItem List), as well details of an object. An object can be created, edited or deleted (CRUD).</p>&#xA;&#xA;<p>Using REST I would build for each object a data fetcher. So once the user goes to list Sales, i.e., the client would go to the server and fetch all available Sales. If the user clicks to detail it, a new REST call would be done to get this specific Sales details, and so on.</p>&#xA;&#xA;<p>Using GraphQL I understood that I should create a big <code>viewer</code> query briging all those objects and fields to the application, and use fragments to access them for each object. </p>&#xA;&#xA;<p>Doing so, I can't understand what will happen if another user changes some object, as all data is going to be loaded at once in the beginning of the application. Will Relay reload the fragment once a new screen is opened working in the same way it is done using REST? Should I build an update mechanism ? If so, what are the ways to go. </p>&#xA;&#xA;<p>Remember I have 40+ different objects</p>&#xA;&#xA;<p>Or maybe I need to build one query for each object the same way I do using REST?</p>&#xA;",2697571,,2697571,2017-10-24 17:03:08,2017-10-25 23:53:01,Update client data on database update,<reactjs><graphql><relayjs>,1,3,0,2017-10-24 16:09:12
46915805,1,,,1,1801,"<p>I´m building a SaaS B2B application composed of several different objects. Examples:</p>&#xA;&#xA;<ul>&#xA;<li>Users</li>&#xA;<li>Customers</li>&#xA;<li>StockItens</li>&#xA;<li>StockLevels</li>&#xA;<li>PriceList</li>&#xA;<li>Sales</li>&#xA;<li>Returns</li>&#xA;<li>Etc...</li>&#xA;</ul>&#xA;&#xA;<p>I´ll have around 40 different objects, that can be listed and created, edited, and deleted individually.</p>&#xA;&#xA;<p>Facing the GraphQL concepts for the first time, should I build a large schema for all objects, like the example below, or should I keep each object on its own query.</p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    Users {&#xA;      id&#xA;      firstName &#xA;      lastName&#xA;      address&#xA;      city&#xA;      ...&#xA;    }&#xA;    Customers {&#xA;        id&#xA;        firstName&#xA;        lastName&#xA;        address&#xA;        city&#xA;        rating&#xA;        ...&#xA;&#xA;    }&#xA;    StockItens {&#xA;        id &#xA;        item_id&#xA;        sales {&#xA;            id&#xA;            dateTime&#xA;            qty&#xA;            unitValue&#xA;            totalValue&#xA;            ...&#xA;        }&#xA;        ...&#xA;    }&#xA;    StockLevels {&#xA;        ...&#xA;    }&#xA;    PriceList {&#xA;        ...&#xA;    }&#xA;    Sales {&#xA;        id&#xA;        dateTime&#xA;        qty&#xA;        unitValue&#xA;        totalValue&#xA;        ...&#xA;    }&#xA;    Returns {&#xA;        ...&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Looking for the first option (keeping everything into one single query) seens logical as I will be using fragments to access the desired piece of information, but then I will have a huge schema with lots of inter relations. </p>&#xA;&#xA;<p>PLease advice what would be the best practice on that use case.</p>&#xA;",2697571,,,,2017-10-25 08:08:00,GraphQL with multiple objects: should I keep all objects in a single query?,<graphql>,1,0,0,2017-10-24 16:39:45
46932923,1,,,3,224,"<p>I´m using Relay Modern to build my component and I want to pass a varible to the fragment so that it can be used as a GraphQL argument on my query.</p>&#xA;&#xA;<p>Here is the code I´m using:</p>&#xA;&#xA;<pre><code>class Test extends Component {&#xA;    static propTypes = {&#xA;       userId: PropTypes.string.isRequired&#xA;    }&#xA;&#xA;    render = () =&gt; {&#xA;&#xA;        return (&#xA;&#xA;            &lt;p&gt;User Id: {this.props.userId}&lt;/p&gt;&#xA;            &lt;p&gt;User name: {this.props.viewer.name}&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;export default createFragmentContainer(&#xA;    Test,&#xA;    graphql`&#xA;        fragment Test_viewer on Viewer {&#xA;            user(id: $userId) { &lt;&lt;=== The $userId must be the this.props.userId passed&#xA;                id&#xA;                name&#xA;            }&#xA;        }&#xA;    `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>When issuing the query GraphQL server returns error saying <code>Variable \""$userId\"" is not defined by operation \""UserQuery\"".""</code>.</p>&#xA;&#xA;<p>My query in the parent component:</p>&#xA;&#xA;<pre><code>const UserQuery = graphql` &#xA;&#xA;  query AdminQuery {&#xA;    viewer {&#xA;      ...Test_viewer&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>How can I make the code above work ?</p>&#xA;",2697571,,,,2017-10-25 23:40:49,How to pass a variable data to createFragementContainer,<javascript><reactjs><graphql><relayjs><relay>,1,0,0,2017-10-25 12:49:32
46943655,2,,46932923,0,,"<p>You need to pass your variable at the query level:</p>&#xA;&#xA;<pre><code>const UserQuery = graphql` &#xA;  query AdminQuery($userId: ID!) {&#xA;    viewer {&#xA;      ...Test_viewer&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>When using this query on a <code>&lt;QueryRenderer /&gt;</code> element, you will also pass the variables as prop:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  query={UserQuery}&#xA;  variables={{&#xA;    userId: 'USER_ID',&#xA;  }}&#xA;  // ... others props&#xA;/&gt;&#xA;</code></pre>&#xA;",3076424,,,,2017-10-25 23:40:49,"",,0,0,0,2017-10-25 23:40:49
46943747,2,,46915261,0,,"<p>Yes, you need to build one query for each object.</p>&#xA;&#xA;<p>The queries are called with <code>&lt;QueryRenderer /&gt;</code> with Relay.<br>&#xA;You will have one <code>&lt;QueryRenderer /&gt;</code> associated with a query each time you want to query something in a batch.</p>&#xA;&#xA;<p>For example, let's imagine 2 pages: <code>/users</code> and <code>/sales</code>, which are both lists.</p>&#xA;&#xA;<p><code>/users</code> can render, somewhere:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  environment={...}&#xA;  query={graphql`&#xA;    query UsersPageQuery {&#xA;      users(first: 10) {&#xA;        edges { node {&#xA;          ...UsersPage_user&#xA;        }}&#xA;      }&#xA;    }&#xA;  `&#xA;  // ... others props&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p>And <code>/sales</code> can render, somewhere:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  environment={...}&#xA;  query={graphql`&#xA;    query SalesPageQuery {&#xA;      sales(first: 10) {&#xA;        edges { node {&#xA;          ...SalesPage_sale&#xA;        }}&#xA;      }&#xA;    }&#xA;  `&#xA;  // ... others props&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p><strong>Do not</strong> load all the data at once.<br>&#xA;A good idea would be to have one <code>&lt;QueryRenderer /&gt;</code> per view, like a list, or a item details view. Same splitting as in REST ;)</p>&#xA;",3076424,,,,2017-10-25 23:53:01,"",,0,1,0,2017-10-25 23:53:01
46954416,2,,46952486,1,,"<p>You can use fragment query like this, which returns same result</p>&#xA;&#xA;<pre><code>{&#xA;  user{&#xA; ... userPayload&#xA;  }&#xA;}&#xA;&#xA;fragment userPayload on User{&#xA;  userId&#xA;  firstName&#xA;  lastName&#xA;  pincode&#xA;  state&#xA;  country&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think this is the one you want</p>&#xA;",6414472,,,,2017-10-26 12:31:22,"",,0,0,0,2017-10-26 12:31:22
46993002,2,,46992669,2,,"<p>Yes it is possible, and you've answered your own question, this is correct:</p>&#xA;&#xA;<pre><code>({ data: { search: { edges} }}) =&gt; &lt;Component data={edges} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>Your <code>Component</code> will now get your <code>edges</code> array as a prop named <code>data</code></p>&#xA;",6061010,,,,2017-10-28 18:21:28,"",,0,4,0,2017-10-28 18:21:28
47016917,2,,47016207,1,,"<p>Sometimes, services provides two endpoints: Relay endpoint (with edges and nodes) and simple endpoint.</p>&#xA;&#xA;<p>Looks like GitHub only have a Relay endpoint. In this case, the only thing you can do is to manually format the response on your frontend.</p>&#xA;&#xA;<p>Actually, such complex response structure is needed because we often need to do a pagination. Take a look at the example:</p>&#xA;&#xA;<pre><code>{&#xA;    getArticle(id: ""some-id"") {&#xA;        id&#xA;        userId&#xA;        user {&#xA;            id&#xA;            name&#xA;        }&#xA;        tags(first: 10, after: ""opaqueCursor"") {&#xA;            edges {&#xA;                node {&#xA;                    id&#xA;                    name&#xA;                    itemsCount&#xA;                }&#xA;            }&#xA;            pageInfo {&#xA;                hasNextPage&#xA;                hasPreviousPage&#xA;                endCursor&#xA;                startCursor&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>pageInfo</code> is located at the same level as <code>edges</code>. </p>&#xA;&#xA;<p>So if you later will need to do a pagination, it would be better to keep the response format as is.</p>&#xA;",954883,,,,2017-10-30 13:50:21,"",,0,0,0,2017-10-30 13:50:21
47047198,2,,47038659,0,,"<p>Subscriptions: <a href=""https://facebook.github.io/relay/docs/subscriptions.html#updating-the-client-on-each-response"" rel=""nofollow noreferrer"">Updating the client on each response</a></p>&#xA;&#xA;<pre><code>const LinkSubscription = graphql`&#xA;  subscription LinkSubscription {&#xA;    Link(filter: { mutation_in: [CREATED] }) {&#xA;      node {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export const test = () =&gt; {&#xA;  const subscriptionConfig = {&#xA;    subscription: LinkSubscription,&#xA;    variables: {},&#xA;    onCompleted: () =&gt; {&#xA;      alert('done!');&#xA;    },&#xA;    updater: (Store, data) =&gt; {&#xA;      const newLink = Store.getRootField('Link').getLinkedRecord('node');&#xA;      const viewerProxy = Store.getRoot().getLinkedRecord('viewer');&#xA;&#xA;      const connection = ConnectionHandler.getConnection(&#xA;        viewerProxy,&#xA;        '&lt;nameConnection&gt;', // 'Viewer_links' or &lt;Name_links&gt;&#xA;        { mutation_in: ['CREATED'] }&#xA;      );&#xA;      const edge = ConnectionHandler.createEdge(&#xA;        Store,&#xA;        connection,&#xA;        newLink,&#xA;        'LinkEdge'&#xA;      );&#xA;      if (connection) {&#xA;        ConnectionHandler.insertEdgeBefore(connection, edge);&#xA;        console.log('DONE');&#xA;      }&#xA;    },&#xA;    onError: error =&gt; console.log('An error occured:', error)&#xA;  };&#xA;&#xA;  requestSubscription(Environment, subscriptionConfig);&#xA;};&#xA;</code></pre>&#xA;",5826897,,5826897,2017-11-02 15:35:04,2017-11-02 15:35:04,"",,0,1,0,2017-11-01 02:12:01
47057420,1,47057656,,2,1915,"<p>I am pretty new with both Django and Graphene, and couldn't get around a problem which might be fairly simple, but I had no luck with the docs or google to get an answer.</p>&#xA;&#xA;<p>Let's say I have the following model:</p>&#xA;&#xA;<pre><code>class Law(models.Model):&#xA;    year = models.IntegerField(default=None)&#xA;    number = models.IntegerField(default=None)&#xA;    description = TextField(default=None)&#xA;    body = models.TextField(default=None)&#xA;</code></pre>&#xA;&#xA;<p>And the following schema:</p>&#xA;&#xA;<pre><code>class LawType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = models.Law&#xA;        filter_fields = {&#xA;            ""year"": [""exact""],&#xA;            ""number"": [""exact""],&#xA;            ""description"": [""contains""],&#xA;            ""body"": [""icontains""],&#xA;        }&#xA;        interfaces = (graphene.Node, )&#xA;&#xA;class Query(graphene.AbstractType):&#xA;    all_laws = DjangoFilterConnectionField(LawType)&#xA;&#xA;    def resolve_all_laws(self, args, context, info):&#xA;        return models.Law.objects.all()&#xA;</code></pre>&#xA;&#xA;<p>How do I make a query or define a FilterSet class so that it will return a list of objects such that a word is found in the description <strong>or</strong> in the body?</p>&#xA;&#xA;<pre><code>{&#xA;    allLaws(description_Icontains: ""criminal"", body_Icontains: ""criminal"") {&#xA;        edges{&#xA;            node{&#xA;                year&#xA;                number&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I couldn't find an answer in the <a href=""http://docs.graphene-python.org/projects/django/en/latest/filtering/#"" rel=""nofollow noreferrer"">graphene-django documentation</a> nor in the <a href=""https://django-filter.readthedocs.io/en/latest/index.html"" rel=""nofollow noreferrer"">django-filter documentation</a>.</p>&#xA;&#xA;<p>Any clues? Thanks in advance</p>&#xA;",3782345,,,,2017-11-01 14:55:09,Django-graphene: how to filter with an OR operator,<python><django><graphql><graphene-python>,1,0,0,2017-11-01 14:40:42
47058707,1,47060337,,0,484,"<p>I'm trying to send a one-off query using Relay. So, I don't necessarily want to use <code>QueryRenderer</code> but rather have a simple API to send a query without binding the result to a React component.</p>&#xA;&#xA;<p>Previously, this was possible with the <code>fetch</code> method on <code>network</code>:</p>&#xA;&#xA;<pre><code>const checkVoteQueryText = `&#xA;  query CheckVoteQuery($userId: ID!, $linkId: ID!) {&#xA;    viewer {&#xA;      allVotes(filter: {&#xA;        user: { id: $userId },&#xA;        link: { id: $linkId }&#xA;      }) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }`&#xA;const checkVoteQuery = { text: checkVoteQueryText }&#xA;const result = await this.props.relay.environment._network.fetch(checkVoteQuery, {userId, linkId})&#xA;</code></pre>&#xA;&#xA;<p>It seems however that <code>fetch</code> has been deprecated in some newer version of Relay. Is there an alternative that can be used now?</p>&#xA;&#xA;<p>If Relay doesn't allow for one-off queries, I'd probably just <code>graphql-request</code> or plain JS fetch to get the job done. But it would be nice to be able to use Relay for this as it already knows my endpoint.</p>&#xA;",1779113,,,,2017-11-01 17:19:41,How to send one-off query with Relay?,<javascript><reactjs><graphql><relayjs>,1,0,0,2017-11-01 15:49:02
47069966,1,,,0,619,"<p>Currently, we stumbled across a problem doing mutation in relay modern. We have a diary which contains many entries. Whenever user add a entry which day of diary doesn't exist, we also create a diary before create a entry. Everything works as expected but the UI doesn't update immediately after the mutations. Here's the code.</p>&#xA;&#xA;<p>AddDiaryMutation</p>&#xA;&#xA;<pre><code>import { commitMutation, graphql } from 'react-relay';&#xA;&#xA;const mutation = graphql`&#xA;mutation AddDiaryMutation($input: AddDiaryInput!) {&#xA;  createDiary(input: $input) {&#xA;     diary {&#xA;        id&#xA;        ...EntryList_entries&#xA;     }&#xA;  }&#xA;}&#xA;`;&#xA;&#xA;let clientMutationId = 0;&#xA;&#xA;const commit = (environment, { date }, callback) =&gt;&#xA;commitMutation(environment, {&#xA;    mutation,&#xA;    variables: {&#xA;      input: {&#xA;        date,&#xA;        clientMutationId: clientMutationId++&#xA;      }&#xA;    },&#xA;    onCompleted: response =&gt; {&#xA;    const id = response.createDiary.diary.id;&#xA;    callback(id);&#xA;  }&#xA;});&#xA;&#xA;export default { commit };&#xA;</code></pre>&#xA;&#xA;<p>AddEntryMutation will get the id from AddDiaryMutation response to add entry.</p>&#xA;&#xA;<pre><code>import { commitMutation, graphql } from 'react-relay';&#xA;import { ConnectionHandler } from 'relay-runtime';&#xA;&#xA;const mutation = graphql`&#xA;mutation AddEntryMutation($input: AddEntryInput!) {&#xA;   createEntry(input: $input) {&#xA;     entryEdge {&#xA;       node {&#xA;         id&#xA;         project {&#xA;           name&#xA;         }&#xA;         speaker {&#xA;            name&#xA;         }&#xA;        } &#xA;      }&#xA;     }&#xA;    }&#xA;   `;&#xA;&#xA;function sharedUpdater(store, diaryId, newEdge) {&#xA;    const diaryProxy = store.get(diaryId);&#xA;    const conn = ConnectionHandler.getConnection(diaryProxy, &#xA;       'EntryList_entries');&#xA;    ConnectionHandler.insertEdgeAfter(conn, newEdge);&#xA;} &#xA;&#xA;let clientMutationId = 0;&#xA;&#xA;  const commit = (environment, { diaryId, ...rest }, callback) =&gt;&#xA;     commitMutation(environment, {&#xA;       mutation,&#xA;       variables: {&#xA;         input: {&#xA;            ...rest,&#xA;            clientMutationId: clientMutationId++&#xA;         }&#xA;       },&#xA;       updater: store =&gt; {&#xA;          const payload = store.getRootField('createEntry');&#xA;          const newEdge = payload.getLinkedRecord('entryEdge');&#xA;          sharedUpdater(store, diaryId, newEdge);&#xA;       },&#xA;       onCompleted: () =&gt; callback()&#xA;});&#xA;&#xA;export default { commit };&#xA;</code></pre>&#xA;&#xA;<p>EntryList fragment</p>&#xA;&#xA;<pre><code>fragment EntryList_entries on Diary {&#xA;  entries(first: 20) @connection(key: ""EntryList_entries"", filters: []) &#xA;{&#xA;    edges {&#xA;      node {&#xA;        ...Entry_entry&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Entry fragment</p>&#xA;&#xA;<pre><code>fragment Entry_entry on Entry {&#xA;  id&#xA;  project {&#xA;    name&#xA;  }&#xA;  speaker {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5140060,,,,2017-11-05 13:30:43,Relay not updating after doing subsequent mutations,<relayjs><graphql-js><relaymodern><graphql-relay>,1,0,0,2017-11-02 07:39:40
47088220,1,47088520,,1,537,"<p>When saving an entity with mongoose and graphql the following happens:</p>&#xA;&#xA;<p>First method to save:</p>&#xA;&#xA;<pre><code>create(budgetProps){&#xA;   const budget = new Budget(budgetProps);&#xA;   return budget.save();&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The result is as follows:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""addBudget"": {&#xA;      ""_id"": ""59fbdefaa7b0a81180dd2c9c"",&#xA;      ""tiempoAproximado"": 2245.5,&#xA;      ""User"": {&#xA;        ""name"": null,&#xA;        ""organization"": null&#xA;      },&#xA;      ""Vehicle"": {&#xA;        ""name"": null,&#xA;        ""type"": null&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Using this method:</p>&#xA;&#xA;<pre><code>create(budgetProps){&#xA;  const budget = new Budget(budgetProps);&#xA;  return budget.save().then((res)=&gt;{&#xA;           Budget.findById(res._id)&#xA;              .populate('User')&#xA;              .populate('Vehicle')&#xA;              .exec((err, newBudget)=&gt; {&#xA;                 return newBudget;&#xA;              });&#xA;        });&#xA;  },&#xA;</code></pre>&#xA;&#xA;<p>I get the following:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""addBudget"": null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the Schema:</p>&#xA;&#xA;<pre><code> const typeDefs = `&#xA;   scalar Date&#xA;&#xA;   input UserInput {&#xA;      _id: ID,&#xA;      name: String,&#xA;      organization: String,&#xA;      phones: [String],&#xA;      emails: [String],&#xA;      type: String,&#xA;      password: String,&#xA;      percentaje: String&#xA;   }&#xA;&#xA;   input VehicleDescriptionInput {&#xA;      es: String,&#xA;      en: String&#xA;   }&#xA;&#xA;   input VehicleInput{&#xA;      _id: ID,&#xA;      name: String,&#xA;      passengers: Int,&#xA;      largeBags: Int,&#xA;      smallBags: Int,&#xA;      doors: Int,&#xA;      type: String,&#xA;      status: Boolean,&#xA;      imagesUrls: [String],&#xA;      description: VehicleDescriptionInput&#xA;   }&#xA;&#xA;   input FinalTotalCostInput {&#xA;      es: String,&#xA;      en: String   &#xA;   }&#xA;&#xA;   input BudgetTotalCostInput {&#xA;      es: String,&#xA;      en: String&#xA;   }&#xA;&#xA;   input BudgetInput {&#xA;      finalTotalCost: FinalTotalCostInput,&#xA;      budgetTotalCost: BudgetTotalCostInput,&#xA;      destinoInicial: String,&#xA;      destinoFinal: String,&#xA;      tiempoAproximado: Float,&#xA;      distancia: Float,&#xA;      tollCost: Float,&#xA;      tolls: [String],&#xA;      budgetDate: Date,&#xA;      aprove: Boolean,&#xA;      User: UserInput,&#xA;      Vehicle: VehicleInput&#xA;   }&#xA;&#xA;   type Mutation {&#xA;      addBudget(data: BudgetInput): Budget&#xA;   }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Here is the resolver:</p>&#xA;&#xA;<pre><code>Mutation: {&#xA;  addBudget: (_, {data}) =&gt;{&#xA;    return BudgetController.create(data);  &#xA;  }&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>Finally here is the mutation with its variables:</p>&#xA;&#xA;<pre><code>mutation addBudget($budget: BudgetInput) {&#xA;  addBudget(data: $budget) {&#xA;    _id&#xA;    User{&#xA;      name&#xA;      organization&#xA;    }&#xA;    Vehicle{&#xA;      name&#xA;      type&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;{&#xA;  ""budget"": {&#xA;    ""finalTotalCost"": {&#xA;      ""es"": ""100 peso"",&#xA;      ""en"": ""10 dolars""&#xA;    },&#xA;    ""budgetTotalCost"": {&#xA;      ""es"": ""80 peso"",&#xA;      ""en"": ""8 dolars""&#xA;    },&#xA;    ""destinoInicial"": ""Queretaro"",&#xA;    ""destinoFinal"": ""Sonora"",&#xA;    ""tiempoAproximado"": 2245.5,&#xA;    ""distancia"": 100.565,&#xA;    ""tollCost"": 20.5,&#xA;    ""tolls"": [&#xA;      ""GDL"",&#xA;      ""Marina"",&#xA;      ""Culap"",&#xA;      ""Malageña""&#xA;    ],&#xA;    ""budgetDate"": ""2017/07/21"",&#xA;    ""aprove"": false,&#xA;    ""User"": {&#xA;      ""_id"": ""59fbcc42aa82460924e5fbad""&#xA;    },&#xA;    ""Vehicle"": {&#xA;      ""_id"": ""59fbcbe4aa82460924e5fbac""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The entity is stored properly in the database, when Console.log the result of the populated search results are correct then I do not understand what is happening.</p>&#xA;&#xA;<p>You can find the whole app in the following link: <a href=""https://github.com/corrortiz/acroRide"" rel=""nofollow noreferrer"">GitHub Repo</a></p>&#xA;",6055185,,,,2017-11-03 04:32:18,Data null after saving entity with Moongose and GraphQL,<node.js><mongodb><mongoose><graphql><graphql-js>,1,0,0,2017-11-03 03:53:10
47108403,2,,47053844,3,,"<p>So I assumed you are using JavaScript as the language. What you need in this case is not to use direct query, rather use fragments</p>&#xA;&#xA;<p>So the query would become</p>&#xA;&#xA;<pre><code>{&#xA;    items(ids:[""1"",""2""]) {&#xA;       ...data&#xA;    }}&#xA;&#xA;    fragment data on Item {&#xA;        id&#xA;      valueA&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Next in the resolver we need to access these fragments to find the fields which are part of the fragment and then resolve the data based on the same. Below is a simple nodejs file with same</p>&#xA;&#xA;<pre><code>const util = require('util');&#xA;&#xA;var { graphql, buildSchema } = require('graphql');&#xA;&#xA;var schema = buildSchema(`&#xA;    type Item {&#xA;        id: String,&#xA;        valueA: Float,&#xA;        valueB: Float&#xA;    }&#xA;&#xA;    type Query {&#xA;        items(ids: [String]!): [Item]&#xA;    }&#xA;`);&#xA;&#xA;var root = { items: (source, args, root) =&gt; {&#xA;        var fields = root.fragments.data.selectionSet.selections.map(f =&gt; f.name.value);&#xA;        var ids = source[""ids""];&#xA;&#xA;        var data = ids.map(id =&gt; {return {id: id}});&#xA;        if (fields.indexOf(""valueA"") != -1)&#xA;        {&#xA;            // Query api/a/items?id=[ids]&#xA;            //append to data;&#xA;            console.log(""calling API A"")&#xA;            data[0][""valueA""] = 0.12;&#xA;            data[1][""valueA""] = 0.15;&#xA;        }&#xA;&#xA;        if (fields.indexOf(""valueB"") != -1)&#xA;        {&#xA;            // Query api/b/items?id=[ids]&#xA;            //append to data;&#xA;            console.log(""calling API B"")&#xA;            data[0][""valueB""] = 0.10;&#xA;            data[1][""valueB""] = 0.11;&#xA;        }&#xA;        return data&#xA;},&#xA;};&#xA;&#xA;graphql(schema, `{items(ids:[""1"",""2""]) {&#xA;       ...data&#xA;    }}&#xA;&#xA;    fragment data on Item {&#xA;        id&#xA;      valueA&#xA;    }&#xA;&#xA;    `, root).then((response) =&gt; {&#xA;    console.log(util.inspect(response, {showHidden: false, depth: null}));&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>If we run it, the output is</p>&#xA;&#xA;<pre><code>calling API A&#xA;{ data: &#xA;   { items: [ { id: '1', valueA: 0.12 }, { id: '2', valueA: 0.15 } ] } }&#xA;</code></pre>&#xA;&#xA;<p>If we change the query to</p>&#xA;&#xA;<pre><code>{&#xA;    items(ids:[""1"",""2""]) {&#xA;       ...data&#xA;    }}&#xA;&#xA;    fragment data on Item {&#xA;        id&#xA;        valueA&#xA;        valueB&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The output is</p>&#xA;&#xA;<pre><code>calling API A&#xA;calling API B&#xA;{ data: &#xA;   { items: &#xA;      [ { id: '1', valueA: 0.12, valueB: 0.1 },&#xA;        { id: '2', valueA: 0.15, valueB: 0.11 } ] } }&#xA;</code></pre>&#xA;&#xA;<p>So this demonstrates how you can avoid call for api A/B when their fields are not needed. Exactly as you had asked for</p>&#xA;",2830850,,,,2017-11-04 07:12:30,"",,0,2,0,2017-11-04 07:12:30
47111719,1,47453331,,-1,221,<p>Let's say I have two components (A and B) that rely on the same data. </p>&#xA;&#xA;<p>Component A is connected to graphql using apollo's graphql HOC and gets <code>players</code> array from the server. </p>&#xA;&#xA;<p>Component B also relies on the same <code>players</code> array.</p>&#xA;&#xA;<p>How am I supposed to pass that data (<code>players</code> array) from Component A to B? Using redux and connecting both Component A and B to it? Or by connecting Component B to apollo's graphql HOC and sending again that same query but this time for Component B?</p>&#xA;,6372449,,6600419,2017-11-05 14:08:44,2017-11-23 10:32:31,where to store data on client side in apollo graphql?,<javascript><reactjs><redux><graphql>,1,0,0,2017-11-04 14:22:38
47159445,1,,,2,72,"<h1>Scenario</h1>&#xA;&#xA;<p>I have a GraphQL endpoint with the following schema, that allows me to get weather statistics for a given city:</p>&#xA;&#xA;<pre><code>type Weather {&#xA;  name: String&#xA;  times: [Float]&#xA;  temp: [Float]&#xA;  hum: [Float]&#xA;}&#xA;&#xA;type Query {&#xA;  weather(city: String): Weather&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am trying to build an application in which the user can select one or more cities and a component will display the list of cities and plot the statistics.</p>&#xA;&#xA;<pre><code>function ViewStats({cities}) {&#xA;&#xA;    const temp = cities.map(city =&gt; ({x: city.times, y: city.temp}));&#xA;    const hum = cities.map(city =&gt; ({x: city.times, y: city.hum}));&#xA;&#xA;    return (&#xA;        &lt;div&gt;&#xA;            &lt;h1&gt;Weather stats for {cities.map(city =&gt; city.name).join(', ')}.&lt;/h1&gt;&#xA;            &lt;Plot title=""Temperature"" series={temp} /&gt;&#xA;            &lt;Plot title=""Humidity"" series={hum} /&gt;&#xA;        &lt;/div&gt;&#xA;    );&#xA;}&#xA;&#xA;const ViewStatsDecorated = decorateSomehowWithGraphQL(ViewStats);&#xA;&#xA;function App() {&#xA;    return &lt;ViewStatsDecorated cities={['new-york', 'paris', 'bangkok']} /&gt;;&#xA;}&#xA;</code></pre>&#xA;&#xA;<h1>Question</h1>&#xA;&#xA;<p>Is it possible to decorate the ViewStats component so that a separate query is done for each city? I would like to take advantage of the caching capability of Apollo, i.e. if two cities are selected, and a new one is added to the list, only one query has to be done.&#xA;The list of selected cities is kept in a Redux store.</p>&#xA;",5130022,,5130022,2017-11-07 14:15:51,2017-11-07 14:15:51,Building a comparison view with Apollo GraphQL,<reactjs><redux><graphql><apollo><react-apollo>,0,0,0,2017-11-07 13:41:27
47237136,1,,,7,612,"<p>I'm working with Relay Modern on Project. But I'm not sure how to send data from a place when I put fragment&#xA;to place where Is component placed. </p>&#xA;&#xA;<p>for example:</p>&#xA;&#xA;<p>this is components composition </p>&#xA;&#xA;<pre><code>-Page (QueryRenderer)&#xA;---Header&#xA;---body&#xA;  ---List&#xA;     --UserAutocomplete&#xA;</code></pre>&#xA;&#xA;<p>List is Fragment, something like  <code>fragment PaymentsList on Payment</code>&#xA;UserAutocomplete is also fragment but on RootQuery <code>fragment UserAutocomplete_users on RootQuery</code></p>&#xA;&#xA;<p>Actually, I put  bout this fragment in query for QueryRenderer&#xA;<code>&#xA;graphql`&#xA;  query PaymentQuery {&#xA;    ...PaymentsList&#xA;    ...UserAutocompleteFragment_users&#xA;  }&#xA;</code></p>&#xA;&#xA;<p>But then I got data for UserAutocomplete here and I must send this data for UserAtocomplete component down through props.&#xA;  Is there some better way something like got this data from a store instead of sending them through props?</p>&#xA;",2025586,,,,2017-11-11 10:58:58,How to send data from fragment to deep nested component?,<graphql><relay><relaymodern>,0,4,0,2017-11-11 10:58:58
47243634,2,,47016207,1,,"<p>You can remove the <code>edges</code> query if you know you aren't searching along those relationships. Cursor-based pagination will work by checking the <code>pageInfo</code> value <code>hasNextPage</code> and using <code>endCursor</code> as the <code>after</code> query parameter: </p>&#xA;&#xA;<pre><code> viewer {&#xA;      repositories(first: 30,after:""&lt;CURSOR_STRING&gt;"") {&#xA;        totalCount&#xA;        pageInfo{&#xA;          hasNextPage&#xA;          endCursor&#xA;        }&#xA;        nodes{&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>returns</p>&#xA;&#xA;<pre><code>""viewer"": {&#xA;  ""repositories"": {&#xA;    ""totalCount"": 38,&#xA;    ""pageInfo"": {&#xA;      ""hasNextPage"": true,&#xA;      ""endCursor"": ""Y3Vyc29yOnYyOpHOAl/5mw==""&#xA;    },&#xA;    ""nodes"": [&#xA;      {&#xA;        ""name"": ""AllStarRoom""&#xA;      },&#xA;      {&#xA;        ""name"": ""shimsham""&#xA;      },&#xA;      {&#xA;        ""name"": ""Monitor-Docs""&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1375964,,,,2017-11-11 22:50:09,"",,0,0,0,2017-11-11 22:50:09
47250102,1,,,0,174,"<p>I'm using query options to pass dynamic variables for my query but it seems that if I set <code>defaultProps</code>, graphql is unable to pick up the props value.</p>&#xA;&#xA;<p>My code as below:</p>&#xA;&#xA;<pre><code>Page.defaultProps = {&#xA;   startDate: moment().hour(15).toISOString(),&#xA;   endDate: moment().add(1).hour(3).toISOString(),&#xA;};&#xA;&#xA;&#xA;export default compose(graphql(myQuery, { options: (props: IPageProps) =&gt; ({ variables: { range: { start: props.startDate, end: props.endDate }}}))(Page);&#xA;</code></pre>&#xA;&#xA;<p>Logging out props show that the defaultProps take time to be actually included when the component loads, and the variables will always become <code>{ startDate: undefined, endDate: undefined }</code></p>&#xA;&#xA;<p>Is there a better way of handling this?</p>&#xA;",3890983,,,,2017-11-12 20:18:50,GraphQL Apollo query options do not take defaultProps,<reactjs><graphql><apollo>,1,0,0,2017-11-12 14:45:08
47251104,1,,,4,334,"<p>I'm trying to use <code>createRefetchContainer</code> of the Relay Modern. but the props aren't passed down to my component from the result of the refetch query. The refetch query runs okay and the response will come back from the server, but the ui doesn't get updated. or to be more precise the props of the refetch container don't get updated.</p>&#xA;&#xA;<p>Here is my relay decorator:</p>&#xA;&#xA;<pre><code>@compose(&#xA;  queryRenderer(graphql`&#xA;      query UsersQuery($page: Int, $count: Int) {&#xA;          users(page: $page, count: $count) {&#xA;              ...Users_users&#xA;          }&#xA;      }&#xA;  `, {&#xA;    page: 1,&#xA;    count: 25&#xA;  }),&#xA;  refetchContainer(&#xA;    graphql`&#xA;        fragment Users_users on UserPaginationResult {&#xA;            data {&#xA;                ...UserRow_user&#xA;            }&#xA;            pageInfo {&#xA;                totalCount&#xA;                pagesCount&#xA;            }&#xA;        }&#xA;    `,&#xA;    graphql`&#xA;        query UsersRefetchQuery($page: Int!,$count: Int!) {&#xA;            users(page: $page, count: $count) {&#xA;                ...Users_users&#xA;            }&#xA;        }&#xA;    `&#xA;  )&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>And here is my refetch function:</p>&#xA;&#xA;<pre><code>loadMore(page) {&#xA;    const { count } = this.state;&#xA;    const { relay: { refetch } } = this.props;&#xA;&#xA;    refetch({ page, count });&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>versions:</p>&#xA;&#xA;<pre><code>""react-relay"": ""^1.4.1"",&#xA;""relay-compose"": ""^1.0.6"",&#xA;""relay-runtime"": ""^1.4.1""&#xA;</code></pre>&#xA;",5607525,,,,2017-11-12 16:24:03,Relay modern: refetch doesn't update props,<reactjs><graphql><relay><relaymodern><react-relay>,0,1,0,2017-11-12 16:24:03
47253510,2,,47250102,1,,"<p>That's tricky. The easiest thing would be just to declare the defaults twice:</p>&#xA;&#xA;<pre><code>const DEFAULT_START = moment().hour(15).toISOString()&#xA;const DEFAULT_END = moment().add(1).hour(3).toISOString()&#xA;&#xA;Page.defaultProps = {&#xA;   startDate: DEFAULT_START,&#xA;   endDate: DEFAULT_END,&#xA;}&#xA;&#xA;const options = ({ startDate: start = DEFAULT_START, endDate: end = DEFAULT_END }) =&gt; ({ variables: { range: { start, end } } })&#xA;&#xA;export default compose(graphql(myQuery, { options })(Page);&#xA;</code></pre>&#xA;&#xA;<p>If you don't need to reference <code>startDate</code> or <code>endDate</code> outside of the query, doing it this way would mean you could skip including them as <code>defaultProps</code> altogether.</p>&#xA;",6024220,,,,2017-11-12 20:18:50,"",,0,1,0,2017-11-12 20:18:50
47264353,2,,47263641,1,,"<p>In your schema you have</p>&#xA;&#xA;<pre><code>    productTax(tax_rate: Float!): [Float!]&#xA;</code></pre>&#xA;&#xA;<p>so graphql is expecting an array of float values. It seems that it should be</p>&#xA;&#xA;<pre><code>    productTax(tax_rate: Float!): Float!&#xA;</code></pre>&#xA;&#xA;<p>since your <code>productTax()</code> method is returning one float value.</p>&#xA;&#xA;<p>You can also add default tax rate. I don't see you are passing it anyway, so</p>&#xA;&#xA;<pre><code>    productTax(tax_rate: Float = 20): Float!&#xA;</code></pre>&#xA;",2707017,,2707017,2017-11-13 12:55:11,2017-11-13 12:55:11,"",,0,0,0,2017-11-13 12:25:59
47359214,2,,47142986,2,,"<p>All your queries and mutations in Relay need to be statically available for the compiler to generate the runtime artifacts. Any dynamic behavior needs to be controlled by graphql variables and fragments. Make sure you look through the graphql spec well.</p>&#xA;&#xA;<p>For your case above a fragment would serve you well. The fragment can even be defined in a different file. I will give an example where you define a child component called UserComponent that will be responsible for displaying user info and a fragment that specifies what fields are required. You can then use the fragment in the parent component query. Assuming you are using react and your user type is called User.</p>&#xA;&#xA;<pre><code>/UserComponent.js&#xA;...&#xA;const UserComponent = ({ user }) =&gt; {...};&#xA;...&#xA;export default createFragmentContainer(&#xA;  ChildComponent,&#xA;  graphql`&#xA;    fragment UserComponent_user on User {&#xA;      id&#xA;      username&#xA;      email&#xA;      firstName&#xA;      lastName&#xA;      jobTitle&#xA;      phone&#xA;    }&#xA;  `&#xA;);&#xA;&#xA;/Component.js&#xA;const ComponentQuery = graphql`&#xA;query ComponentQuery ($companyId: ID!) {&#xA;  viewer {&#xA;    company(id: $companyId) {&#xA;      id&#xA;      name&#xA;      enabled&#xA;      users {&#xA;        ...UserComponent_user&#xA;      }&#xA;    }&#xA;  }&#xA;}`;&#xA;</code></pre>&#xA;&#xA;<p>Every time you need to render the UserComponent make sure you include that fragment in some top level query.</p>&#xA;",6524306,,,,2017-11-17 21:02:00,"",,0,0,0,2017-11-17 21:02:00
47368091,1,,,1,419,"<p>I am trying to correctly type a react component with flow and apollo graphql. I keep getting a flow error message. I am using react-apollo 2.0.1 and flow 0.53.1</p>&#xA;&#xA;<pre><code>// @flow&#xA;/**&#xA;*&#xA;* CompanyName&#xA;*&#xA;*/&#xA;&#xA;import React from 'react';&#xA;import { graphql } from 'react-apollo';&#xA;import gql from 'graphql-tag';&#xA;import type { OperationComponent, ChildProps } from 'react-apollo';&#xA;&#xA;type Company = {&#xA;  id: string,&#xA;  name: string,&#xA;};&#xA;&#xA;type Response = {&#xA;  company: Company,&#xA;};&#xA;&#xA;type Props = {&#xA;  className: ?string,&#xA;};&#xA;&#xA;&#xA;class CompanyName extends React.Component&lt;ChildProps&lt;Props, Response&gt;&gt; {&#xA;  render() {&#xA;    return (&#xA;      &lt;span className={this.props.className}&gt;&#xA;        {!!this.props.data.company &amp;&amp; this.props.data.company.name}&#xA;      &lt;/span&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;const query = gql`&#xA;  query {&#xA;    company {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const withCompanyName: OperationComponent&lt;Response, Props&gt; = graphql(query);&#xA;&#xA;export default withCompanyName(CompanyName); // this line gives a flow error&#xA;</code></pre>&#xA;&#xA;<p>I get an error on the last line of code saying that the type is incompatible. Everything else validates correctly.</p>&#xA;&#xA;<p>The error message is: CompanyName (class type: CompanyName) This type is incompatible with StatelessComponent (union: type application of polymorphic type: type <code>StatelessComponent</code> | class type: type application of identifier <code>React$Component</code>)</p>&#xA;&#xA;<p>I am able to get it to work properly if I change it to a stateless functional component, but I need to get this working for class components.</p>&#xA;&#xA;<p><strong>Update:</strong>&#xA;Here is my .flowconfig</p>&#xA;&#xA;<pre><code>[ignore]&#xA;&#xA;[include]&#xA;&#xA;[libs]&#xA;&#xA;[options]&#xA;module.name_mapper='.*\(.gql\)' -&gt; 'empty/object'&#xA;</code></pre>&#xA;&#xA;<p>I am using the empty package to prevent gql imports from causing a flow error.</p>&#xA;",6689367,,6689367,2017-11-22 16:27:12,2017-11-22 16:27:12,How to flow type a React Component in apollo graphql,<flowtype><react-apollo>,0,1,0,2017-11-18 16:03:55
47442879,1,,,1,176,"<p>I have the following query</p>&#xA;&#xA;<pre><code>const ITEM_COMMENTS_QUERY = gql`&#xA;  query Search($id: UUID, $per_page: Int) {&#xA;    item(id: $id) {&#xA;      id&#xA;      comments(page: 1, per_page: $per_page) {&#xA;        edges {&#xA;          id&#xA;          author {&#xA;            id&#xA;            first_name&#xA;            last_name&#xA;          }&#xA;          content&#xA;        }&#xA;        total_count&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>and the following mutation</p>&#xA;&#xA;<pre><code>  const CREATE_COMMENT_MUTATION = gql`&#xA;  mutation create_comment($id: UUID!, $content: String!) {&#xA;    create_comment(id: $id, content: $content, type: COMMENT_TYPE_ITEM) {&#xA;      id&#xA;      ... on ItemComment {&#xA;        item {&#xA;          id&#xA;          comments(page: 1, per_page: 100) {&#xA;            edges {&#xA;              id&#xA;              author {&#xA;                id&#xA;                first_name&#xA;                last_name&#xA;              }&#xA;              content&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>and the response is correct, but apollo store doesn't update.&#xA;(I have dataIdFromObject: <code>elm =&gt; elm.id</code>)</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/9RXgm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9RXgm.png"" alt=""response""></a></p>&#xA;",3765750,,3283644,2018-02-16 10:15:03,2018-02-16 10:15:03,Why doesn't apollo store update?,<reactjs><redux><graphql><apollo><react-apollo>,1,0,0,2017-11-22 19:51:42
47456950,2,,47454158,1,,"<p>Beyond requesting specific fields, GraphQL does not have any baked-in means of filtering or reducing the results of a query. Any filtering, sorting, etc. has to be implemented when creating the schema for the endpoint.</p>&#xA;&#xA;<p>You would have to consult the documentation for the endpoint you're using (<a href=""http://graphql.org/learn/introspection/"" rel=""nofollow noreferrer"">or run an introspection query</a>) to determine if there are any argument that can be passed to the <code>sports</code> field to prevent sports without events from being returned by the server.</p>&#xA;",6024220,,,,2017-11-23 13:41:53,"",,0,0,0,2017-11-23 13:41:53
47457327,2,,47246635,2,,"<p>You must break your mind and think in Graph way model :)</p>&#xA;&#xA;<p>Type Company(node) &lt;- CompanyDepartmentConection (name of connection edge) -> Type Department(node)</p>&#xA;&#xA;<p>based on this very useful <a href=""https://dev-blog.apollodata.com/explaining-graphql-connections-c48b7c3d6976"" rel=""nofollow noreferrer"">article</a>, anyway i do for you eg. Schema</p>&#xA;&#xA;<h1>Concept</h1>&#xA;&#xA;<pre><code>interface Node {&#xA;  id: ID!&#xA;  name: String&#xA;}&#xA;&#xA;type Company implements Node {&#xA;  id: ID!&#xA;  name: String&#xA;  departmentsConnection: CompanyDepartmentConnection&#xA;}&#xA;type CompanyDepartmentConnection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [CompanyDepartmentEdge]&#xA;}&#xA;type CompanyDepartmentEdge {&#xA;  cursor: String!&#xA;  node: Company&#xA;  linkedAt: DateTime&#xA;}&#xA;</code></pre>&#xA;",2416997,,,,2017-11-23 14:03:43,"",,0,0,0,2017-11-23 14:03:43
47459521,1,49007461,,0,3021,"<p>This is example from the <a href=""https://facebook.github.io/relay/docs/fragment-container.html"" rel=""nofollow noreferrer"">docs</a>. The problem is, what if I also need some other data in my TodoItem component that is completely on a different location in the data graph and can't come through Todo->TodoItem chain.</p>&#xA;&#xA;<pre><code>class TodoItem extends React.Component {&#xA;  render() {&#xA;    const item = this.props.data;&#xA;&#xA;  }&#xA;}&#xA;module.exports = createFragmentContainer(&#xA;  TodoItem,&#xA;  graphql`&#xA;    fragment TodoItem on Todo {&#xA;      text&#xA;      isComplete&#xA;    }&#xA;  `,&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>It seems that Relay/GraphQL demands that the view is composed in the same hierarchy as the data model. Is there a way for a component to access other fragments? I don't know, something like this:</p>&#xA;&#xA;<pre><code>module.exports = createFragmentContainer(&#xA;  TodoItem,&#xA;  graphql`&#xA;    fragment TodoItem on Todo {&#xA;      text&#xA;      isComplete&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    fragment FriendItem on Friends {&#xA;      name&#xA;    }&#xA;  `,&#xA;);&#xA;</code></pre>&#xA;",672226,,,,2019-02-26 02:13:10,Multiple Relay fragments in one React component?,<reactjs><graphql><relay><relaymodern>,1,0,0,2017-11-23 16:05:11
47527379,1,,,2,131,"<p>Let's say I have a query</p>&#xA;&#xA;<pre><code>query {&#xA;  project(thing: ""cats"") {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That returns</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""project"": null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>because the project for cats doesn't yet exist. Now I would like to create it using Relay (classic). My mutation looks something like this (simplified a bit by hardcoding variables etc.):</p>&#xA;&#xA;<pre><code>export class CreateProjectMutation extends Relay.Mutation {&#xA;  getMutation () {&#xA;    return Relay.QL`&#xA;      mutation {&#xA;        createProject (input: { thing: ""cats"" }) {&#xA;          project {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getFatQuery () {&#xA;    return Relay.QL`&#xA;      fragment on ProjectCreationPayload @relay(pattern: true) {&#xA;        project&#xA;      }&#xA;    `;&#xA;  }&#xA;&#xA;  getConfigs () {&#xA;    return [{&#xA;      type: 'FIELDS_CHANGE',&#xA;      fieldIDs: {&#xA;&#xA;        // PROBLEM: There is no project id yet to change!&#xA;        project: this.props.project.id&#xA;      }&#xA;    }];&#xA;  }&#xA;&#xA;  static fragments = {&#xA;    project: () =&gt; Relay.QL`&#xA;      fragment on Project {&#xA;        id&#xA;      }&#xA;    `&#xA;  };&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So the problem is that I cannot do a FIELDS_CHANGE because the project does not yet have an id attached to it. How could I replace the existing </p>&#xA;&#xA;<pre><code>{ project: null }&#xA;</code></pre>&#xA;&#xA;<p>in the client store with the mutation payload (project id that is generated server-side)?</p>&#xA;",1915428,,,,2017-11-29 08:36:06,How to add data from the mutation with no previous id,<graphql><relay>,1,0,0,2017-11-28 08:51:26
47543584,2,,47543472,2,,"<p>Use <a href=""https://reactjs.org/docs/react-component.html#componentwillreceiveprops"" rel=""nofollow noreferrer"">componentWillReceiveProps</a> in your Form component</p>&#xA;&#xA;<pre><code>class Form extends React.Component {&#xA;&#xA;    ...&#xA;&#xA;    componentWillReceiveProps(nextProps) {&#xA;        if (nextProps.loading) return&#xA;        this.setState({&#xA;           name: nextProps.name&#xA;        })&#xA;    }&#xA;&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This will only set the state once as soon as the data is available, since QueryRenderer only calls render once after the data has loaded.</p>&#xA;",1826354,,1826354,2017-11-29 18:54:06,2017-11-29 18:54:06,"",,0,5,0,2017-11-29 01:22:27
47548320,1,47559383,,1,2643,"<p>actually, all my queries have no filter, just retrieve all the records from the tables</p>&#xA;&#xA;<p>I've read this link:&#xA;<a href=""https://github.com/graphql/graphql-js/issues/640"" rel=""nofollow noreferrer"">https://github.com/graphql/graphql-js/issues/640</a></p>&#xA;&#xA;<p>it's about building a manual filter, but the discussion doesn't end with a clear solution.</p>&#xA;&#xA;<p>there is a way to in apollo client, to send a parameter to a query?</p>&#xA;&#xA;<p>in mutation I use, but I have doubt about using the query</p>&#xA;&#xA;<p>one  query is by example:</p>&#xA;&#xA;<pre><code>query TourList {&#xA;&#xA;    tours {&#xA;      id&#xA;      name&#xA;      price&#xA;      country&#xA;      seatsmax&#xA;      seatsmin&#xA;      datestart&#xA;      dateend&#xA;      organizer_id&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>how to filter by organizer_id ?  I'm using sequelize ...</p>&#xA;",8055073,,2293534,2017-11-29 15:10:04,2017-11-29 18:25:40,"apollo client, query with filter",<graphql><apollo-client><apollo-server>,1,0,0,2017-11-29 08:36:36
47561987,2,,47422865,3,,"<p>You could do something with <code>union</code> types and <code>inline/fragments</code></p>&#xA;&#xA;<pre><code>union Chart = LineChart | PieChart | BarChart&#xA;&#xA;type Query {&#xA;  charts(&#xA;    source: String!&#xA;    query: String!&#xA;    appId: String!&#xA;    apiKey: String!&#xA;    filterKey: String&#xA;    filterValues: [String]&#xA;  ): [Chart]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then you can have your <code>charts</code> resolver bring ALL the charts and write your queries like</p>&#xA;&#xA;<pre><code>fragment Identifiers on Chart {&#xA;  __typename&#xA;  id&#xA;}&#xA;query {&#xA;  charts(...) {&#xA;    ...on LineChart {&#xA;      ...Identifiers&#xA;      seriesData&#xA;    }&#xA;    ...on PieChart {&#xA;      ...Identifiers&#xA;      labels&#xA;      values&#xA;    }&#xA;    ...on BarChart {&#xA;      ...Identifiers&#xA;      seriesData&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The <code>Identifiers</code> will provide you with some information about what type you're dealing with and it's <code>id</code>, but you can extend it to whatever you like as long as those fields are common to all types on that union (or you can spread it only on some of the types).</p>&#xA;&#xA;<p>There are 2 ways you can go about if you don't want to bring in all the charts:</p>&#xA;&#xA;<ol>&#xA;<li>Add inline fragments for only the types you want, but the rest will still be there, in the form of empty objects.</li>&#xA;<li>Pass another argument to the resolver representing the type/s you want</li>&#xA;</ol>&#xA;&#xA;<p>P.S. You can get as granular as you like, there are also <code>interfaces</code> and <code>input types</code>. </p>&#xA;",6273042,,,,2017-11-29 21:18:09,"",,0,1,0,2017-11-29 21:18:09
47584319,1,47610968,,1,672,"<p>I'm using Relay Modern to try to load data into a <code>FragmentContainer</code>. I'm using the familiar Container (Smart) / Presenter (Dumb) pattern and the data is not being passed into my child Container as expected. However, if I use Relay's <code>@relay(mask: false)</code> directive to see if the fragment's data is properly loaded by <code>QueryRenderer</code>, <strong>the fragment data is there</strong>.</p>&#xA;&#xA;<p>I don't understand why the data is not being sent to my Container. Any help is much appreciated.</p>&#xA;&#xA;<p><code>ScreenContainer.js</code> (renders <code>QueryRenderer</code>):</p>&#xA;&#xA;<pre><code>/* ScreenContainer.js */&#xA;&#xA;import ScreenPresenter from './ScreenPreseenter';&#xA;const query = graphql`&#xA;query ScreenContainerQuery($id: ID!) {&#xA;  viewer {&#xA;    User(id: $id) {&#xA;      id&#xA;      ...NestedFragmentContainer_user&#xA;    }&#xA;  }&#xA;}`&#xA;export default class ScreenContainer extends Component {&#xA;  render() {&#xA;    &lt;QueryRenderer &#xA;      query={query} &#xA;      variables={{id: id}} &#xA;      render={() =&gt; &lt;ScreenPresenter /&gt;} &#xA;    /&gt;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>ScreenPresenter.js</code>:</p>&#xA;&#xA;<pre><code>/* ScreenPresenter.js */&#xA;&#xA;import NestedFragmentContainer from './NestedFragment';&#xA;&#xA;export default class ScreenPresenter extends Component {&#xA;  render() {&#xA;    return &lt;NestedFragmentContainer /&gt;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And finally, <code>NestedFragmentContainer.js</code>:</p>&#xA;&#xA;<pre><code>/* ./NestedFragmentContainer.js */&#xA;&#xA;class NestedFragmentContainer extends Component {&#xA;  render() {&#xA;    const { user } = this.props;&#xA;    console.log(user); // &lt;-- Always null, not undefined&#xA;    return &lt;Text&gt;{user.account.name}&lt;/Text&gt;;&#xA;  }&#xA;}&#xA;export default createFragmentContainer(&#xA;  NestedFragmentContainer,&#xA;  graphql`&#xA;    fragment NestedFragmentContainer_user on User {&#xA;      account {&#xA;        name&#xA;      }&#xA;    }&#xA;  `&#xA;</code></pre>&#xA;&#xA;<p>Furthermore, whenever <code>NestedFragmentContainer</code> renders, I see an error that its <code>user</code> prop is <code>undefined</code>. However, <code>console.log()</code> shows that its value is in fact <code>null</code>, and not <code>undefined</code>.</p>&#xA;&#xA;<pre><code>Warning: createFragmentContainerSpecResolver: Expected prop `user` &#xA;to be supplied to Relay(NestedFragmentContainer)`, but got &#xA;`undefined`. Pass an explicit `null` if this is intentional.&#xA;</code></pre>&#xA;&#xA;<p>Does anyone have any idea why the FragmentContainer isn't being rendered with its data?</p>&#xA;",3798957,,,,2017-12-02 18:10:43,Relay-Modern FragmentContainer data not populated,<javascript><reactjs><graphql><relaymodern><react-relay>,2,3,0,2017-11-30 23:27:49
47590134,1,,,11,3975,"<p>I have a GraphQL query that looks like this</p>&#xA;&#xA;<pre><code>{&#xA;  allContentfulDocuments {&#xA;    edges {&#xA;      node {&#xA;        documents {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there any way to flatten the <code>edges</code> and <code>node</code> layers, into something that essentially works like this query would:</p>&#xA;&#xA;<pre><code>{&#xA;  allContentfulDocuments {&#xA;    documents {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3962001,,,,2022-01-19 17:53:42,"Is there a way to ""spread"" or ""flatten"" a GraphQL response?",<graphql>,2,8,0,2017-12-01 09:20:19
47598692,2,,47584319,0,,"<p>You should check in the render function inside the QueryRenderer component if the data is actually coming or there is an error. Then, if the data is there you have to pass the user through the props. I haven’t used Relay much but I hope this can help</p>&#xA;",7920554,,,,2017-12-01 17:39:16,"",,0,0,0,2017-12-01 17:39:16
47610968,2,,47584319,1,,"<p>Assuming the query was successful, the data needs to get passed to the rendered component. As stated in Relay modern docs: </p>&#xA;&#xA;<blockquote>&#xA;  <p>QueryRenderer is the root of a Relay tree. It takes a query, fetches the data and calls the render callback with the data. </p>&#xA;</blockquote>&#xA;&#xA;<p>In your case, the <code>queryRenderer</code> should look like this:</p>&#xA;&#xA;<pre><code>render() {&#xA;    return (&#xA;      &lt;QueryRenderer&#xA;        environment={environment}&#xA;        query={query}&#xA;        variables={{id: id}}&#xA;        render={({error, props}) =&gt; {&#xA;          if (error) {&#xA;            return &lt;div&gt;{error.message}&lt;/div&gt;&#xA;          } else if (props) {&#xA;            /*  Here is the crucial part */&#xA;            return &lt; ScreenPresenter data={props.viewer} /&gt;               &#xA;          }&#xA;          return &lt;div&gt;Loading&lt;/div&gt;&#xA;        }}&#xA;      /&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then you will be able to pass the props down from the container component (smart) to the presentational one (dumb).</p>&#xA;",5954939,,,,2017-12-02 18:10:43,"",,0,0,0,2017-12-02 18:10:43
47626611,2,,47626401,1,,<p>Add </p>&#xA;&#xA;<pre><code>componentWillReceiveProps(nextProps) {&#xA;const defaultSelectedId = (nextProps.query &amp;&amp; !nextProps.query.loading) ? &#xA;           nextProps.query.defaultId : ''&#xA;     this.setState ({ &#xA;         id: defaultSelectedId&#xA;     })&#xA;&#xA;}&#xA;</code></pre>&#xA;,2971707,,2971707,2017-12-04 18:04:00,2017-12-04 18:04:00,"",,0,3,0,2017-12-04 04:39:52
47637552,1,,,0,72,"<p>I want to pull down a subset of fields of an object from the server, for example:</p>&#xA;&#xA;<pre><code>query retrieveUserBasics($id: String!) {&#xA;  user(id: $id) {&#xA;    name&#xA;    age&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then on a subsequent page I want to download more information about the same user, for example, using a query like:</p>&#xA;&#xA;<pre><code>query retrieveUserDetails($id: String!) {&#xA;  user(id: $id) {&#xA;    birthDate&#xA;    favouriteColor&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I was hoping that I could run these two queries at different times and the object would be combined as I ran them, however I see an error occurs in the Apollo reducer (path in the store):</p>&#xA;&#xA;<pre><code>apollo.reducerError.error = { type: 'WriteError }&#xA;</code></pre>&#xA;&#xA;<p>I'm assuming this is because Apollo finds an existing object in the store and doesn't know what to do with the new result. The <code>error</code> prop in my component is not defined, and the <code>loading</code> prop remains <code>true</code>.</p>&#xA;&#xA;<p>Is there a way for me to get the result I want, or do I need to rethink how I perform this operation?</p>&#xA;&#xA;<p>Versions:</p>&#xA;&#xA;<ul>&#xA;<li>react <code>16.0.0-alpha.12</code></li>&#xA;<li>react-apollo <code>1.4.16</code></li>&#xA;<li>redux <code>3.7.2</code></li>&#xA;</ul>&#xA;",687581,,687581,2017-12-04 17:03:55,2017-12-04 17:03:55,Incrementally adding to cached GraphQL object using Apollo,<graphql><apollo><react-apollo>,0,2,0,2017-12-04 16:15:43
47704992,1,47705476,,0,989,"<p>I'm trying to merge 2 dot notation strings into a GrahQL query with only javascript (it can be ES6/typescript).</p>&#xA;&#xA;<p>For example, let say that I have an array of strings</p>&#xA;&#xA;<pre><code>[&#xA;    'firstName', &#xA;    'lastName', &#xA;    'billing.address.street', &#xA;    'billing.address.zip', &#xA;    'shipping.address.street', &#xA;    'shipping.address.zip'&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>The expected query string output would be (white spaces are not important)</p>&#xA;&#xA;<p><code>firstName, lastName, shipping{address{street, zip}}, billing{address{street, zip }}</code></p>&#xA;&#xA;<p>I can convert 1 by 1 the dot notation to a query string, but how do I merge all of that together? I got a function that take <code>street.name</code> and output <code>street { name }</code>. So this function would do it</p>&#xA;&#xA;<pre><code>convertToString(inputString) {&#xA;    let result = '';&#xA;&#xA;    if (inputString.indexOf('.') === -1) {&#xA;      result = inputString;&#xA;    } else {&#xA;      const inputArray = inputString.split('.');&#xA;      for (let i = inputArray.length - 1; i &gt;= 0; i--) {&#xA;        if (i === 0) {&#xA;          result = inputArray[i] + result;&#xA;        } else {&#xA;          result = '{' + inputArray[i] + result + '}';&#xA;        }&#xA;      }&#xA;    }&#xA;    return result;&#xA;}&#xA;&#xA;console.log(convertToString('address.street')); // address { street }&#xA;</code></pre>&#xA;&#xA;<p>But then how would I loop through all strings and get only 1 GraphQL query string that combines the same properties into a group. The main issue is how do I merge the 2 dot notation strings without losing anything and without having duplicates (at this point, I can get this <code>address { name } address { zip }</code> but when this runs on the GraphQL server, only the latter is kept and so only the <code>zip</code> shows up in the result.</p>&#xA;&#xA;<p>I tried creating temporary object that represent the structure, but that didn't work out so good.</p>&#xA;",1212166,,1212166,2017-12-12 14:43:39,2017-12-12 14:43:39,How can I merge 2 dot notation strings to a GraphQL query string,<javascript><graphql><graphql-js>,1,0,0,2017-12-07 22:36:21
47707561,1,,,10,2098,"<p>Currently having an issue with the relay approach to nested pagination. An example below to illustrate what I mean:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""locations"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Location_254""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Location_247""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Location_217""&#xA;          }&#xA;        },&#xA;      ]&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Here I have 3 locations returned from a query. Now I wanted to paginate on these locations and look at their 'history'.</p>&#xA;&#xA;<pre><code>query {&#xA;  locations {&#xA;    edges {&#xA;      node {&#xA;        history(&#xA;          first:10&#xA;          after:""eyJzbm9vemVJZCI6Mzg3fQ==""&#xA;        )&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This would paginate 10 results after the specified cursor. My issue is, is that this cursor is specific to the location it was obtained from. The cursor it is referring to paginate after, only applies to the location it came from.</p>&#xA;&#xA;<p>Nested pagination tries to paginate on ALL locations here, when in actuality, the cursor being used, was grabbed from a specific location.</p>&#xA;&#xA;<p>Am I seeing this incorrectly, or is there a better way I could be approaching this issue?</p>&#xA;&#xA;<p>Regards, Sebastian</p>&#xA;",7701038,,,,2017-12-08 04:08:44,Nested pagination with relay graphql,<graphql><relay>,0,5,0,2017-12-08 04:08:44
47751285,1,,,1,431,"<p>I want to create a subscription, but when I am compiling to relay I am getting this error:&#xA;<code>&#xA;ERROR:&#xA;Expected null to be a GraphQL composite type.&#xA;</code></p>&#xA;&#xA;<p>I think what my <em>graphql</em> definition is wrong, but I have no clue about how to check it. Sadly the documentation at relay site is too simple. Do you know what are the rules in order to create a proper graphql for a subscription?</p>&#xA;",2776626,,,,2018-08-14 16:27:16,Relay subscription error: Expected null to be a GraphQL composite type,<reactjs><graphql><relayjs><relay>,2,2,0,2017-12-11 10:51:17
47779413,1,47840608,,0,182,"<p>I'm working on Search functionality. On input change happen some stuff and I get array of arrays:&#xA;<code>&#xA; pages level 1 [1,17] &#xA; pages level 2 [15]&#xA; pages level 3 [16]</code></p>&#xA;&#xA;<p>What I want is to create specific Object of pages from that array (this is not a problem) and put it to the Apollo query to be like this:</p>&#xA;&#xA;<pre><code>folders(search: [...some conditions]) {&#xA;data {&#xA;  id&#xA;  title&#xA;&#xA;  pages(search: [{field: ""id"", value: ""1""}, {field: ""id"", value: ""17"", type: OR}]) {&#xA;    data {&#xA;      id&#xA;      title&#xA;      pages(search: [{field: ""id"", value: ""15""}]) {&#xA;        data {&#xA;          id&#xA;          title&#xA;          pages(search: [{field: ""id"", value: ""16""}]) {&#xA;            data {&#xA;              id&#xA;              title&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And this is the place where I stuck! I can't use pure Apollo variables, because I don't know how deep this tree of pages can be, and also I think Apollo doesn't let me do some loop inside the query. </p>&#xA;&#xA;<p>I think that I have to create this object inside my component, because there I can also save it to the Redux store.</p>&#xA;&#xA;<p>I made something like that:</p>&#xA;&#xA;<pre><code>const thePages = SearchInTree.createQueryFragmentWithPages();&#xA;const ACCURATE_SEARCH_QUERY = gql`&#xA;  query SecondSearch{folders(search: [...some conditions]) {&#xA;    data {&#xA;      id&#xA;      title&#xA;&#xA;      ${thePages}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>where <code>thePages</code> - result of static method (where I'm going to create needed Object or a String) of my component class.  But in this case I've got another issue - Apollo doesn't want to see any changes inside my static, because query lies outside of my class.</p>&#xA;&#xA;<p>Also I tried to take out this logic into separate component and there pull out the data from the Redux store. But than I don't know how to insert this component into my query.</p>&#xA;&#xA;<p>I know that I missed something, maybe another way, I don't know...&#xA;Please, help!</p>&#xA;",4218804,,4218804,2017-12-12 19:04:08,2017-12-15 22:19:54,"React - Apollo, how to put Object inside the query?",<reactjs><apollo><react-apollo>,1,0,0,2017-12-12 18:39:27
47794776,1,,,0,121,"<p>I am composing 2 queries in a <code>hoc</code> with <code>react-apollo</code>.  Here is my code:</p>&#xA;&#xA;<pre><code>let queries = compose(&#xA;  graphql(gql`&#xA;    query getUnitSubcategories($input: UnitSubcategorySearchInput) {&#xA;      allUnitSubcategories(input:$input) {&#xA;        edges {&#xA;          node {&#xA;            unitSubcategoryId&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `, {&#xA;    name: 'subcategories',&#xA;    options: {&#xA;      variables: {&#xA;        input: {&#xA;          activeFlag: true,&#xA;        }&#xA;      }&#xA;    }&#xA;  }),&#xA;  graphql(gql`&#xA;    query getFinancialTransactions($input: FinancialTransactionLineSearchInput) {&#xA;      allFinancialTransactionLines(input: $input) {&#xA;        pageInfo {&#xA;          total&#xA;        }&#xA;        edges {&#xA;          node {&#xA;            financialTransaction {&#xA;              financialTransactionId&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `, {&#xA;    name: 'financialTransactions',&#xA;    options: {&#xA;      variables: {&#xA;        input: {&#xA;          unitSubcategories: [&#xA;            ....&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  })&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>You can see that I am getting the <code>unitSubcategories</code> in the first query and they need to be passed to the second query.  So I don't want to kick off the second query until I have a result from my first query.  What is the best way to do this?</p>&#xA;",968801,,,,2017-12-14 07:58:36,How do I make graphql calls in series? react-apollo,<apollo><react-apollo>,1,1,0,2017-12-13 13:57:16
47801555,2,,44520038,2,,<p>You need to add a relay directive to your fragment spread: &#xA;<code>&#xA;...SomeFragment_authorData @relay(mask: false)&#xA;</code></p>&#xA;,1038901,,,,2017-12-13 20:24:31,"",,0,1,0,2017-12-13 20:24:31
47844337,1,,,0,846,"<p>A question about general react program flow/good practices. I need to know the user's GPS coordinates, so I have a parent component for my map class which gets the users lat/lng, and then once that is received, I generate a component which has a graphQL function wrapped around it that uses the lat/lng I retrieved and finds locations available near the user. Once these lat/lng location values are retrieved, I generate a new component which passes the locations in as props so the google map can generate markers for them. is this the proper react/apollo way to handle this scenario? If not, how can I improve it? </p>&#xA;&#xA;<p>Code below:</p>&#xA;&#xA;<pre><code>import React, {Component} from 'react'&#xA;import MapContainer from './Map/GoogleMap'&#xA;import { graphql } from 'react-apollo'&#xA;import gql from 'graphql-tag'&#xA;&#xA;export default class Home extends Component {&#xA;&#xA;  constructor(props) {&#xA;    super(props);&#xA;&#xA;    this.state = {&#xA;      lat: 0,&#xA;      lng: 0&#xA;    }&#xA;  }&#xA;&#xA;  componentDidMount() {&#xA;  //retrieve the users GPS coordinates&#xA;    navigator.geolocation.getCurrentPosition(&#xA;      position =&gt; {&#xA;        this.setState({ lat: position.coords.latitude, lng: position.coords.longitude});&#xA;      },&#xA;      error =&gt; console.log(error)&#xA;    );&#xA;  }&#xA;&#xA;  render(){&#xA;  //kind of buggy here, on first render, this.props.lat is undefined, then after this.state.lat !== 0, it runs the graphQL query, so then this.state.lat value gets set to this.props.lat, and this.state.lat is reset to 0. Probably should be a better way to do this...&#xA;    if(!this.props.lat){&#xA;      if(this.state.lat === 0){&#xA;        return &lt;p&gt;Getting your location..&lt;/p&gt;&#xA;      }&#xA;    }&#xA;&#xA;    if(this.props.retrieveLocationsQuery &amp;&amp; this.props.retrieveLocationsQuery.loading) {&#xA;      return &lt;div&gt;Getting the freshest spots&lt;/div&gt;&#xA;    }&#xA;    if(this.props.retrieveLocationsQuery &amp;&amp; this.props.retrieveLocationsQuery.error) {&#xA;      return &lt;div&gt;Error&lt;/div&gt;&#xA;    }&#xA;    let renderedComponent = this.props.retrieveLocationsQuery&#xA;    ? &lt;MapContainer lat={this.props.lat} lng={this.props.lng} locations={this.props.retrieveLocationsQuery.locations} /&gt;&#xA;    : &lt;LocationQuery lat={this.state.lat} lng={this.state.lng} /&gt;&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {renderedComponent}&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;const RETRIEVE_LOCATIONS_QUERY = gql`&#xA;  query locations ($lat: Float!, $lng: Float!){&#xA;    locations (lat: $lat, lng: $lng){&#xA;      id&#xA;      loc {&#xA;        lat&#xA;        lng&#xA;      }&#xA;      title&#xA;      description&#xA;      times&#xA;      createdBy {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;const LocationQuery = graphql(RETRIEVE_LOCATIONS_QUERY, {name: 'retrieveLocationsQuery'})(Home)&#xA;</code></pre>&#xA;",5175802,,,,2017-12-16 09:41:23,Run React-Apollo queries by conditionally rendering components?,<reactjs><google-maps><components><react-apollo>,0,4,0,2017-12-16 09:41:23
47864537,1,,,2,105,"<p>I found out that you can do this via the REST API, but ideally I want to stick to the GraphQL API in my program. I've been scouring the <a href=""https://developer.github.com/v4/"" rel=""nofollow noreferrer"" title=""API Docs"">API Documentation</a> but I am also pretty shaky and new to GraphQL so I can not seem to find a way to mutate the repository and set the archive state.</p>&#xA;&#xA;<p>I only need to archive, no need for un-archive.</p>&#xA;",8460761,,,,2017-12-20 02:59:03,How do I archive a repository via Githubs GraphQL API?,<github-api><github-graphql>,1,0,0,2017-12-18 08:28:48
47908161,1,47911269,,0,893,"<p>I'm trying to implement Relay Connections in Apollo, but I have some problems with the specification.</p>&#xA;&#xA;<p>Schema looks like this:</p>&#xA;&#xA;<pre><code>type PageInfo {&#xA;  startCursor: String!,&#xA;  endCursor: String!,&#xA;  hasNextPage: Boolean!,  &#xA;  hasPreviousPage: Boolean!&#xA;}&#xA;&#xA;type User : Node {&#xA;  id: ID!&#xA;  firstname: String&#xA;  lastname: String&#xA;}&#xA;&#xA;type UserConnection : Connection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [UserEdge!]!&#xA;}&#xA;&#xA;type UserEdge : Edge {&#xA;  cursor: String!&#xA;  node: User!&#xA;}&#xA;&#xA;extend type Query {&#xA;  users(first: Int, after: ID, order: String): UserConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Let's say I have 100 users in db;&#xA;When I query with limit ex.users(first: 10), PageInfo.endCursor refers to the 10nth edge or the 100th?</p>&#xA;&#xA;<p>More Questions:</p>&#xA;&#xA;<p>1.Should I make another query to get hasPreviousPage, hasNextPage.</p>&#xA;&#xA;<p>2.Are there any code examples(with resolvers) that have a similar structure?</p>&#xA;&#xA;<p>3.Are there any graphql chats (gitter, irc)?</p>&#xA;",6557434,,6557434,2017-12-20 14:30:06,2017-12-20 17:18:26,GraphQL Relay Connections Specification for Apollo,<graphql><relayjs><apollo><relay><apollo-server>,1,0,0,2017-12-20 14:24:45
47911269,2,,47908161,0,,"<p>endCursor refers to the 10th, i.e. it's equal to the cursor field of the last edge in the result.</p>&#xA;&#xA;<ol>&#xA;<li><p>Generally-speaking, cursor-based pagination like this isn't bi-directional. So you can't know both <code>hasNextPage</code> and <code>hasPreviousPage</code>. But whichever you're fetching, you don't need to do issue it in another query, fetch as much data as you can in one query, that's the point!</p></li>&#xA;<li><p>There must be loads of examples of Relay's pagination around by now, I don't know any off the top of my head.</p></li>&#xA;<li><p>There's a slack team for Apollo and for GraphQL itself. <code>apollographql.slack.com</code> and <code>graphql.slack.com</code></p></li>&#xA;</ol>&#xA;",15687,,,,2017-12-20 17:18:26,"",,0,1,0,2017-12-20 17:18:26
47915868,1,47943253,,2,1232,"<p>I'm just getting going with Apollo GraphQL on a simple React Native app and am really impressed by what it can do. But I'm not quite wrapping my head around how it integrates with the Redux store. Essentially, I need to pass some user input from my <code>searchReducer</code> into my GraphQL query. I thought I could simply pass the connected component to my GraphQL query and supply a variable, but it's not finding the <code>prop</code> <code>searchInput</code>. Here's the code:</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import { FlatList, Text, StyleSheet } from 'react-native';&#xA;import { connect } from 'react-redux';&#xA;import Repository from './Repository';&#xA;import { graphql } from 'react-apollo';&#xA;import gql from 'graphql-tag';&#xA;&#xA;const query = gql`&#xA;    query repositoryOwner($login: String!) {&#xA;        repositoryOwner(login: $login) {&#xA;            url,&#xA;            avatarUrl(size: 100),&#xA;            repositories(first: 5) {&#xA;                nodes {&#xA;                    name,&#xA;                    description&#xA;                }&#xA;            }&#xA;        }&#xA;    }`;&#xA;&#xA;class RepositoryList extends Component {&#xA;&#xA;    renderItem = ({ item }) =&gt; {&#xA;        return &lt;Repository name={item.name} description={item.description} /&gt;;&#xA;    }&#xA;&#xA;    render() {&#xA;&#xA;        const { repositoryOwner } = this.props.data;&#xA;        const data = repositoryOwner ? repositoryOwner.repositories.nodes : [];&#xA;&#xA;        return (&#xA;            &lt;FlatList data={data}&#xA;                renderItem={(repo) =&gt; this.renderItem(repo)} keyExtractor={(item, index) =&gt; index} /&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;const mapStateToProps = (state) =&gt; {&#xA;&#xA;    return {&#xA;        search: state.searchReducer&#xA;    };&#xA;};&#xA;&#xA;const withStore = connect(mapStateToProps)(RepositoryList);&#xA;&#xA;export default graphql(query, {&#xA;    options: ({ search: { searchInput }}) =&gt; ({ variables: { login: searchInput }})&#xA;})(withStore);&#xA;</code></pre>&#xA;&#xA;<p>I thought that by passing the <code>connect</code>ed React component, it would find the <code>search</code> <code>prop</code> specified by <code>mapStateToProps</code>. However, it gives:</p>&#xA;&#xA;<blockquote>&#xA;  <p>TypeError: undefined is not an object (evaluating _ref3.search.searchInput).</p>&#xA;</blockquote>&#xA;&#xA;<p>So obviously it's not finding that <code>prop</code>. My question is, what is the idiomatic way to use <code>props</code> from the Redux store as variables in an Apollo GraphQL connected component?</p>&#xA;",6727053,,,,2017-12-22 14:39:45,How To Pass Props From Redux Store into Apollo GraphQL Query,<react-native><graphql><react-apollo><apollo-client>,1,2,0,2017-12-20 23:40:00
47943253,2,,47915868,5,,"<p>To create an answer that goes more into detail and is useful for other users:</p>&#xA;&#xA;<p>To use props from the redux <code>connect</code> higher order component make sure that the function is applied last. This can be done in your example by</p>&#xA;&#xA;<pre><code>const WithGraphql = graphql(/* ... */)(RepositoryList);&#xA;&#xA;export default connect(mapStateToProps)(WithGraphql);&#xA;</code></pre>&#xA;&#xA;<p>Alternatively you can use <code>compose</code> from <em>redux</em> or <em>react-apollo</em>.&#xA;Compose applies functions from last to first. For two arguments compose can be written as the following:</p>&#xA;&#xA;<pre><code>compose = (f, g) =&gt; (...args) =&gt; f(g(...args))&#xA;</code></pre>&#xA;&#xA;<p>Make sure to list connect first here and then graphql. This creates a new function that you then have to apply to your component <code>RepositoryList</code>:</p>&#xA;&#xA;<pre><code>export default compose(&#xA;  connect(mapStateToProps),&#xA;  graphql(/* ... */),&#xA;)(RepositoryList); &#xA;</code></pre>&#xA;",3849167,,,,2017-12-22 14:39:45,"",,0,2,0,2017-12-22 14:39:45
47947016,2,,45245653,5,,"<p>Oh I think I got through a similar problem. If I remember correctly I believe the ""id"" Relay is using to identify the component to pass the props to, is including the variables for the initial query so try unwrapping your container fragment from the QueryRenderer's query. </p>&#xA;&#xA;<p>The setup that worked for me is something like the following:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;  variables={{search: 'someDefaultSearch', count: 10}}&#xA;  query={graphql`&#xA;    query SearchContainerQuery($search: String!, $count: Int!){&#xA;      # if we want defaults we need to ""prepare"" them from here&#xA;      ...Search_users @arguments(search: $search, count: $count)&#xA;    }&#xA;  `}&#xA;  environment={this.props.auth.environment}&#xA;  render={({ error, props: relayProps }) =&gt; {&#xA;    // I use relayProps to avoid possible naming conflicts&#xA;    if (error) {&#xA;      console.log(error);&#xA;    }&#xA;    if (relayProps) {&#xA;      // the users props is ""masked"" from the root that's why we pass it as is&#xA;      return &lt;Search users={relayProps} /&gt;;&#xA;    }&#xA;    return &lt;div&gt;No Dice&lt;/div&gt;;&#xA;  }}&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p>And the refetchContainer would look something like:</p>&#xA;&#xA;<pre><code>export default createRefetchContainer(&#xA;  Search,&#xA;  {&#xA;    users: graphql`&#xA;      # In my schema the root is called RootQueryType &#xA;      fragment Search_users on RootQueryType&#xA;      @argumentDefinitions(&#xA;        search: {type: ""String""}&#xA;        count: {type: ""Int!""}&#xA;      ) {&#xA;        searchUsers(search: $search, first: $count) {&#xA;          nodes {&#xA;            id&#xA;            displayName&#xA;            username&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  },&#xA;  graphql`&#xA;    query SearchRefetchQuery($search: String!, $count: Int!) {&#xA;      ...Search_users @arguments(search: $search, count: $count)&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>Notice that the above example assumes Relay v1.3 where <code>graphql.experimental</code> is deprecated. Also, I don't remember if with the <code>@arguments</code> trick it's possible to make your approach of aliasing the <code>searchUsers</code> work.</p>&#xA;&#xA;<p>My last suggestion is turning your debugger on and see whats going on when you get the data. </p>&#xA;&#xA;<p>Finally, as per your comments, I agree this might be a BUG. Let's see how things evolve in the issue you reported.</p>&#xA;",667598,,,,2017-12-22 20:25:37,"",,0,0,0,2017-12-22 20:25:37
47963690,1,47963786,,1,94,"<p>I move all seperate querys into my main viewing component and pass the data via props to each component. So I can have a single query request for each page instead of 5 or 6.</p>&#xA;&#xA;<p>Now I'm facing my first problem. I have 2 querys with variables and when I modify a variable it set the <code>data:{ loading }</code> prop to <code>true</code> so my whole interface is showing a loading spinner even if only one thing is actually loading.</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/XLoZq.png"" rel=""nofollow noreferrer"">Here how it lookls like if I press a button on the top right</a></p>&#xA;&#xA;<p>My query object looks like this:</p>&#xA;&#xA;<pre><code>const query = gql`&#xA;  query SumaryPage($limitIOChart: Int!, $limitAHChat: Int!) {&#xA;    IOBalance: getIncomeOutcome(limit: 1) {&#xA;      income&#xA;      outcome&#xA;      total&#xA;    }&#xA;    AccountBalanceData: getAccountBalance {&#xA;      id&#xA;      name&#xA;      balance&#xA;    }&#xA;    TransactionHistoryData: getTransactions(limit: 5) {&#xA;      id&#xA;      name&#xA;      amount&#xA;      date&#xA;      type&#xA;    }&#xA;    IOChart: getIncomeOutcome(limit: $limitIOChart, orderBy: ASC) {&#xA;      month&#xA;      year&#xA;      income&#xA;      outcome&#xA;    }&#xA;    AmountHistoryData: getAmountHistory(limit: $limitAHChat, orderBy: ASC) {&#xA;      month&#xA;      year&#xA;      amount&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Is there a better approach to still have a single query per ""page"" but avoid having only a single loading prop?</p>&#xA;",7630280,,,,2017-12-24 20:23:56,"Separate loading prop for each ""subquery""",<react-apollo>,1,1,0,2017-12-24 20:04:51
48017187,1,48023740,,10,2725,"<p>I'm using Apollo Client and React and I'm looking for a strategy to keep my component and component data requirements colocated in such a way that it can be accessible to parent/sibling/child components that might need it for queries and mutations. I want to be able to easily update the data requirements which in turn will update the fields that are queried by some parent component or returned by a mutation in a parent/sibling/child in order to accurately update my Apollo cache.</p>&#xA;<p>I have tried creating a global high level <code>graphql</code> directory where all my <code>queries/mutations.graphql</code> files are located, importing all the related fragment files located throughout my app, and then importing those directly, but this can get tedious and doesn't follow the parent/child theme where parent queries include children fragments. Also in large projects you end up traversing long file paths when importing.</p>&#xA;<p>I have also tried just creating fragment files colocated in the global <code>graphql</code> directory that correspond to component files but this doesn't give me the &quot;component/data requirement&quot; colocation I'm looking for.</p>&#xA;<p>This works:</p>&#xA;<pre><code>class CommentListItem extends Component {&#xA;  static fragments = {&#xA;    comment: gql`&#xA;      #...&#xA;    `,&#xA;  }&#xA;}&#xA;class CommentList extends Component {&#xA;  static fragments = {&#xA;    comment: gql`&#xA;      #...&#xA;      ${CommentListItem.fragments.comment}&#xA;    `,&#xA;  }&#xA;}&#xA;class CommentsPage extends Component {&#xA;  static fragments = {&#xA;    comment: gql`&#xA;      #...&#xA;      ${CommentList.fragments.comment}&#xA;    `,&#xA;  }&#xA;}&#xA;graphql(gql`&#xA;  query Comments {&#xA;    comments {&#xA;      ...CommentsListItemComment&#xA;    }&#xA;  }&#xA;  ${CommentsPage.fragments.comment}&#xA;`)&#xA;</code></pre>&#xA;<p>However, if I want a mutation in a descendent of <code>CommentsPage</code> I can't reference the fragment composition from <code>CommentsPage.fragments.comment</code>.</p>&#xA;<p>Is there a preferred method or best practice for this type of thing?</p>&#xA;",7165303,,10158227,2021-09-07 17:46:31,2021-09-07 17:46:31,Organization structure for fragment composition in large react-apollo apps,<reactjs><graphql><apollo><apollo-client><react-apollo>,1,0,0,2017-12-29 03:54:39
48029321,1,48030790,,1,393,"<p>I understand that GitHub's GraphQL API <a href=""https://developer.github.com/v4/guides/resource-limitations/"" rel=""nofollow noreferrer"">has a rate limit</a>, which requires you to use slicing with <code>first</code>, <code>last</code>, <code>before</code>, <code>after</code>, etc. However, what if I just want a count of a particular field? For example, I don't want to get all of a user's followers, I just want to get the follower count. Here's the query:</p>&#xA;&#xA;<pre><code>query {&#xA;    user(login: ""parkerziegler"") {&#xA;      login,&#xA;      name,&#xA;      avatarUrl(size: 200)&#xA;      bio,&#xA;      company,&#xA;      location,&#xA;      createdAt,&#xA;      followers {&#xA;        // what can I do here to get the count rather than info on followers?&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In general, <strong>I'm interested in how to deal with these types of calculations in GraphQL, i.e. SUM or ORDER BY</strong>. I'm guessing these need to be implemented on the server, but just curious if anyone has any insights. I've been reading a bit about <a href=""http://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">pagination</a> but don't know if it's the solution for my problem.</p>&#xA;",6727053,,2614364,2017-12-30 16:34:26,2017-12-30 16:34:26,Working With Rate Limits on GitHub's GraphQL API,<github><graphql><github-api><github-graphql>,1,0,0,2017-12-29 22:58:09
48045346,2,,45557380,0,,"<p>As you noticed (and as detailed <a href=""https://github.com/graphql/graphiql"" rel=""nofollow noreferrer"">here</a>) GraphiQL takes a <code>query</code> argument:</p>&#xA;&#xA;<blockquote>&#xA;  <p>query: an optional GraphQL string to use as the initial displayed query, if undefined is provided, the stored query or defaultQuery will be used.</p>&#xA;</blockquote>&#xA;&#xA;<p>If putting a fragment in as the value for that argument doesn't work, then I don't believe there is any way to start with a fragment ... but really why would you even  want to?  A fragment by itself isn't executable, and the whole idea is to start GraphiQL with a (executable) query.</p>&#xA;&#xA;<p>If all you want is to be able to copy/paste in some text that you use frequently in your queries, a bookmarklet might be a better idea.</p>&#xA;",5921,,,,2017-12-31 20:01:13,"",,0,1,0,2017-12-31 20:01:13
48064198,1,48380289,,0,86,"<p>I am using neo4j(3.1), GraphQL and Nodejs. For now, I have 3 graphql types namely Country, State and City and these types have following relation in Neo4j dB.</p>&#xA;&#xA;<p>(City)-[:PRESENT_IN]->(State)-[:PRESENT_IN]->(Country)</p>&#xA;&#xA;<p>My graphql Type is like below:</p>&#xA;&#xA;<pre><code>Type Country{&#xA;name: String,&#xA;states: [State]&#xA;}&#xA;&#xA;Type State{&#xA;name: String,&#xA;cities: [City]&#xA;}&#xA;&#xA;Type City{&#xA;name: String,&#xA;id: Int&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And my Query schema is:</p>&#xA;&#xA;<pre><code>type Query{&#xA; countries(limit: Int): [Country]&#xA; states(limit: Int): [State]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So , when I ran the query ""countries"" in GraphiQl, I was hoping to get the <strong>cities</strong> too available in a particular state present in one country <strong>i.e. traversing to depth 2</strong> , but I am getting null when it comes to array of ""cities"" field,&#xA;Although the data comes for field ""states"".</p>&#xA;&#xA;<p>Here is the query execution done in GraphiQL:</p>&#xA;&#xA;<pre><code> countries(limit:1) {&#xA;   name&#xA;    states{&#xA;      name    &#xA;       cities{&#xA;         name&#xA;         id&#xA;       }&#xA;    }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>and Here is the execution result:</p>&#xA;&#xA;<pre><code>""countries"": {&#xA;  ""name"": ""Country 1"",&#xA;  ""states"": [&#xA;    {&#xA;      ""name"": ""State A"",&#xA;      ""cities"": null ---&gt; Here it is coming null&#xA;    },&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What I wanted to return was:</p>&#xA;&#xA;<pre><code>""countries"": {&#xA;  ""name"": ""Country 1"",&#xA;  ""states"": [&#xA;    {&#xA;      ""name"": ""State A"",&#xA;        ""cities"": [&#xA;          {&#xA;           name: City 1&#xA;           id: 1&#xA;          },&#xA;        ]&#xA;    },&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For my cypher query, I have used pattern comprehension as in this link: <a href=""https://neo4j.com/blog/cypher-graphql-neo4j-3-1-preview/"" rel=""nofollow noreferrer"">https://neo4j.com/blog/cypher-graphql-neo4j-3-1-preview/</a></p>&#xA;&#xA;<p>My cypher query is:</p>&#xA;&#xA;<pre><code>// For Query ""countries""&#xA;    MATCH (c:Country)&#xA;    RETURN c{&#xA;      .name,&#xA;      states: [(s:State)-[:PRESENT_IN]-&gt;(c) | s{.*}]&#xA;    } LIMIT $limit&#xA;&#xA;//For Query ""states""&#xA;    MATCH (s:State)&#xA;    RETURN s{&#xA;      .name,&#xA;      cities: [(ct:City)-[:PRESENT_IN]-&gt;(s) | ct{.*}]&#xA;    } LIMIT $limit&#xA;</code></pre>&#xA;&#xA;<p>So, could anyone tell me what I am doing wrong here ? I looked into the neo4j docs and other blogs, but I am unable to figure it out. Any help or insight would be really helpful !</p>&#xA;",3213011,,,,2018-01-22 11:14:46,Getting null while trying to traverse to depth 2 of graphql type using neo4j pattern comprehension in nodejs environment,<node.js><neo4j><graphql>,1,0,0,2018-01-02 16:09:37
48099876,2,,47910822,2,,"<p>You can use this query for fetch your users orders list</p>&#xA;&#xA;<pre><code>let query = Storefront.buildQuery { $0&#xA;            .customer(customerAccessToken: token) { $0&#xA;                .orders(first: 20) { $0&#xA;                    .edges { $0&#xA;                        .node { $0&#xA;                            .id()&#xA;                            .orderNumber()&#xA;                            .totalPrice()&#xA;                            .currencyCode()&#xA;                            .customerLocale()&#xA;                            .customerUrl()&#xA;                            .email()&#xA;                            .phone()&#xA;                            .processedAt()&#xA;                            .subtotalPrice()&#xA;                            .totalRefunded()&#xA;                            .totalShippingPrice()&#xA;                            .totalTax()&#xA;                            .shippingAddress( { $0&#xA;                                .address1()&#xA;                                .address2()&#xA;                                .city()&#xA;                                .company()&#xA;                                .country()&#xA;                                .countryCode()&#xA;                                .firstName()&#xA;                                .formatted()&#xA;                                .formattedArea()&#xA;                                .lastName()&#xA;                                .latitude()&#xA;                                .longitude()&#xA;                                .name()&#xA;                                .phone()&#xA;                                .province()&#xA;                                .provinceCode()&#xA;                                .zip()&#xA;                            })&#xA;                            .lineItems(first: 50) { $0&#xA;                                .edges { $0&#xA;                                    .cursor()&#xA;                                    .node { $0&#xA;                                        .quantity()&#xA;                                        .title()&#xA;                                        .variant{ $0&#xA;                                            .id()&#xA;                                            .image({ $0&#xA;                                                .altText()&#xA;                                                .id()&#xA;                                                .src()&#xA;                                            })&#xA;                                            .price()&#xA;                                            .sku()&#xA;                                        }&#xA;                                        .customAttributes{ $0&#xA;                                            .key()&#xA;                                            .value()&#xA;                                        }&#xA;&#xA;                                    }&#xA;                                }&#xA;                            }&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>This query return user's orders list in iOS, Hopefully it will be work for you.</p>&#xA;",3659252,,,,2018-01-04 16:47:59,"",,0,1,0,2018-01-04 16:47:59
48100824,1,,,0,288,"<p>I am writing a UI application in reactjs and want to get data to render using graphql. I am using Relay for the same. However, the graphql query I built in Relay.createContainer is adding extra ""id"" field. Is there a way in relay/graphql to exclude these unnecessary fields, and include only what is given in query while creating. Below is the code snippet:&#xA;In RelayRoute.jsx::</p>&#xA;&#xA;<pre><code>TPRelayRoute.queries = {&#xA;    enterprise: () =&gt; {&#xA;        return Relay.QL`&#xA;          query etp_ptp{&#xA;            enterprise&#xA;          }`;&#xA;    }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>In UITable.jsx::</p>&#xA;&#xA;<pre><code>export default Relay.createContainer(UITable, {&#xA;      initialVariables: {&#xA;          count: 20&#xA;      },&#xA;      fragments: {&#xA;          enterprise: () =&gt; {&#xA;                return Relay.QL`&#xA;            fragment etp on Enterprise {&#xA;              etpInfo{&#xA;                erInfo{&#xA;                  payments(first:$count){&#xA;                    edges{&#xA;                      node{&#xA;                        enterprise{&#xA;                          id&#xA;                        }&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }`;&#xA;          }&#xA;      }&#xA;  });&#xA;</code></pre>&#xA;&#xA;<p>Query which is being sent:&#xA;{""query"":""query etp_ptp {enterprise {<strong><em>id</em></strong>,...F0}} fragment F0 on Enterprise {etpInfo {erInfo {<strong><em>paymentsEEVLi</em></strong>:payments(first:20) {edges {node {enterprise{id,__typename},id,__typename},cursor},pageInfo {hasNextPage,hasPreviousPage}}}},<strong><em>id</em></strong>}"",""variables"":{}}</p>&#xA;&#xA;<p>Query expected to be sent:&#xA;{""query"":""query etp_ptp {enterprise {...F0}} fragment F0 on Enterprise {etpInfo {erInfo {payments(first:20) {edges {node {enterprise{id,__typename},id,__typename},cursor},pageInfo {hasNextPage,hasPreviousPage}}}}}"",""variables"":{}}</p>&#xA;",4361067,,,,2018-01-22 02:50:36,How to avoid adding extra fields in graphql query built in Relay.createcontainer?,<reactjs><graphql><relayjs><graphql-js>,1,0,0,2018-01-04 17:47:30
48116781,1,48117383,,27,9210,"<p>I'm using Github API v4 to run search query.</p>&#xA;&#xA;<p>From the API documentation I can understand that the following query gives me pageInfo but I don't know how to use it to traverse.</p>&#xA;&#xA;<pre><code>query {&#xA;  search(first: 100, type:USER, query:""location:usa repos:&gt;0 language:java"") {&#xA;    pageInfo {&#xA;      startCursor&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    userCount&#xA;    nodes {&#xA;        ... on User {&#xA;        bio&#xA;        company&#xA;        email&#xA;        id&#xA;        isBountyHunter&#xA;        isCampusExpert&#xA;        isDeveloperProgramMember&#xA;        isEmployee&#xA;        isHireable&#xA;        isSiteAdmin&#xA;        isViewer&#xA;        location&#xA;        login&#xA;        name&#xA;        url&#xA;        websiteUrl&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And response is:</p>&#xA;&#xA;<pre><code>{&#xA;    ""data"": {&#xA;        ""search"": {&#xA;            ""pageInfo"": {&#xA;                ""startCursor"": ""Y3Vyc29yOjE="",&#xA;                ""hasNextPage"": true,&#xA;                ""endCursor"": ""Y3Vyc29yOjEwMA==""&#xA;            },&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;",4988996,,4988996,2018-01-12 16:38:16,2022-06-28 09:21:15,GitHub API v4: How can I traverse with pagination? (GraphQL),<rest><github><graphql><github-api><github-graphql>,1,0,0,2018-01-05 15:38:02
48117383,2,,48116781,32,,"<p>According to <a href=""http://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">graphql documentation</a> there are more than one pagination model.</p>&#xA;<p>GitHub is using <strong>complete connection model</strong></p>&#xA;<p>In this model you can traverse with adding <strong>after:&quot;Y3Vyc29yOjEwMA==&quot;</strong> to your search query.</p>&#xA;<pre><code>query {&#xA;  search(first: 100, after:&quot;Y3Vyc29yOjEwMA==&quot;, type:USER, query:&quot;location:usa repos:&gt;0 language:java&quot;) {&#xA;    pageInfo {&#xA;      startCursor&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    userCount&#xA;    nodes {&#xA;        ... on User {&#xA;        bio&#xA;        company&#xA;        email&#xA;        id&#xA;        isBountyHunter&#xA;        isCampusExpert&#xA;        isDeveloperProgramMember&#xA;        isEmployee&#xA;        isHireable&#xA;        isSiteAdmin&#xA;        isViewer&#xA;        location&#xA;        login&#xA;        name&#xA;        url&#xA;        websiteUrl&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4988996,,406249,2022-06-28 09:21:15,2022-06-28 09:21:15,"",,0,0,0,2018-01-05 16:17:51
48130732,1,,,1,600,"<p>I'm using <code>gatsby-source-contentful</code> where I have a type called <code>ContentfulBlogPost</code>, whose schema looks something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  id&#xA;  title&#xA;  body&#xA;  date&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Date is a string (in <code>YYYY-MM-DD</code> format), auto-magically handled by Gatsby's data layer as a Moment object; I can call <code>fromNow</code> and <code>formatString</code> on it and all that.</p>&#xA;&#xA;<p>What I want is to use GraphQL to query for a list of posts from a given year, based on that date field.</p>&#xA;&#xA;<p>If I do this:</p>&#xA;&#xA;<pre><code>{&#xA;   allContentfulBlogPost(&#xA;     filter: { date: { regex: ""/^2017/"" } }&#xA;   ) {&#xA;     ...&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>then I get this error: <code>""Cannot read property 'fromNow' of undefined""</code></p>&#xA;&#xA;<p>What I <em>really</em> want is to be able to filter the <code>allContentfulBlogPost</code> data set by date, either by transforming the date into an integer/string year and finding on that, or by asking for all items whose date falls between Jan 1 and Dec 31 of the given year.</p>&#xA;&#xA;<p>Right now, I have a query running in <code>gatsby-node</code> that pulls in <em>all</em> blog posts, then groups them by year in JS and then passes the array of posts into a template. This works, but it really seems like there should be a GraphQL way of doing this?</p>&#xA;",497583,,,,2018-01-06 18:53:12,gatsbyjs - How to get Contentful posts filtered by year?,<reactjs><graphql><contentful><gatsby>,0,1,0,2018-01-06 18:53:12
48142347,1,,,1,1339,"<p>How do I sort in GraphQL using case insensitive?&#xA;Currently I get all entries with uppercase before lowercase.&#xA;Is there a way to ignore titalcase?&#xA;My query looks like this:</p>&#xA;&#xA;<pre><code>{&#xA;  allToolsJson(sort: {order: ASC, fields: [name]}) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3215856,,,,2018-01-07 22:59:04,GraphQL sorting case insensitive,<database><api><sorting><search><graphql>,0,3,0,2018-01-07 22:59:04
48177349,1,,,0,111,"<p>I have project, where I use <code>redux</code>, <code>react-apollo</code> and I wonder, is any chance to provide data from <code>react-apollo</code> to <code>redux</code> through reducer. Pseudo code below.</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>...&#xD;&#xA;import { graphql } from 'react-apollo'&#xD;&#xA;import gql from 'graphql-tag'&#xD;&#xA;&#xD;&#xA;const query = gql`&#xD;&#xA;{&#xD;&#xA;  ...&#xD;&#xA;}`&#xD;&#xA;&#xD;&#xA;/* Function, which I want to returns data from graphql */&#xD;&#xA;const getDate = () =&gt; {&#xD;&#xA;  return graphql(query)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;/*---- Reducer ----*/&#xD;&#xA;export default (state = getDate(), action) =&gt; {&#xD;&#xA;  console.log(state) // function, instead data&#xD;&#xA;  ...&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",7852453,,,,2018-01-14 13:54:41,Provide Data from GraphQL to Redux,<javascript><reactjs><facebook-graph-api><redux><react-apollo>,1,1,0,2018-01-09 22:06:32
48202002,1,48205169,,5,2213,"<p>I'am new to GraphQL but I really like it. Now that I'am playing with interfaces and unions, I'am facing a problem with mutations.</p>&#xA;&#xA;<p>Suppose that I have this schema :</p>&#xA;&#xA;<pre><code>interface FoodType {&#xA;  id: String&#xA;  type: String&#xA;}&#xA;&#xA;type Pizza implements FoodType {&#xA;  id: String&#xA;  type: String&#xA;  pizzaType: String&#xA;  toppings: [String]&#xA;  size: String&#xA;}&#xA;&#xA;type Salad implements FoodType {&#xA;  id: String&#xA;  type: String&#xA;  vegetarian: Boolean&#xA;  dressing: Boolean&#xA;}&#xA;&#xA;type BasicFood implements FoodType {&#xA;  id: String&#xA;  type: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, I'd like to create new food items, so I started doing something like this :</p>&#xA;&#xA;<pre><code>type Mutation {&#xA;    addPizza(input:Pizza):FoodType&#xA;    addSalad(input:Salad):FoodType&#xA;    addBasic(input:BasicFood):FoodType&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This did not work for 2 reasons :</p>&#xA;&#xA;<ol>&#xA;<li>If I want to pass an object as parameter, this one must be an ""input"" type. But ""Pizza"", ""Salad"" and ""BasicFood"" are just ""type"".</li>&#xA;<li>An input type cannot implement an interface.</li>&#xA;</ol>&#xA;&#xA;<p>So, my question is : How do you work with mutations in this context of interface without having to duplicate types too much? I'd like to avoid having a Pizza type for queries and an InputPizza type for mutations.</p>&#xA;&#xA;<p>Thank you for your help. </p>&#xA;",1508466,,1508466,2018-01-16 08:56:51,2018-01-16 08:56:51,GraphQL: best way to manage mutations with interfaces?,<interface><graphql><apollo><mutation>,1,0,0,2018-01-11 07:40:15
48242062,1,48279184,,7,3063,"<p>I have a thread with a list of messages, which is fetched with a <code>GET_THREAD_MESSAGES</code> query. That query is paginated, and depending on if a user has seen the thread before or not might load the first page, last page or only the new messages. (i.e. any of <code>first/after/before/last</code> could be passed with any values)</p>&#xA;&#xA;<pre><code>thread(id: ""asdf"") {&#xA;  messageConnection(after: $after, first: $first, before: $before, last: $last) {&#xA;    edges {&#xA;      cursor&#xA;      node { ...messageInfo }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I have a <code>sendMessage</code> mutation, which I call and then in the <code>update</code> method of that mutation I want to optimistically add that sent message to the threads messages for a nicer UX. Without pagination, I know I would do that something like:</p>&#xA;&#xA;<pre><code>const data = store.readQuery({&#xA;  query: GET_THREAD_MESSAGES,&#xA;  variables: { id: message.threadId }&#xA;})&#xA;&#xA;data.messageConnection.edges.push(newMessageEdge);&#xA;&#xA;store.writeQuery({&#xA;  query: GET_THREAD_MESSAGES,&#xA;  variables: { id: message.threadId },&#xA;  data,&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Unfortunately, since I know have pagination the <code>store.readQuery</code> call throws an error saying “It can’t find the field <code>messageConnection</code> of that thread” because the field is now something like <code>messageConnection({ after: 'jfds1223asdhfl', first: 50, before: null, last: null })</code>. The <a href=""https://www.apollographql.com/docs/react/recipes/pagination.html#connection-directive"" rel=""nofollow noreferrer"">Apollo docs</a> say that one should use the <code>@connection</code> directive in the query to work around that. I've tried to update the query to look something like this:</p>&#xA;&#xA;<pre><code>thread(id: ""asdf"") {&#xA;  messageConnection(...) @connection(key: ""messageConnection"") {&#xA;    edges {&#xA;      cursor&#xA;      node { ...messageInfo }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Unfortunately, when I use that the optimistic update is returned and shown         correctly, but as soon as the server returns the actual message that was stored I get an error saying <code>""Missing field cursor in { node: { id: '...', timestamp: '...'""</code>, because obviously the message that the server returns is not a <code>MessageConnectionEdge</code>, it's just the node, and thusly doesn't have a cursor field.</p>&#xA;&#xA;<p>How can I tell Apollo to only replace the node of the optimistic response, not the entire edge? Is there another way to work around the original issue maybe?</p>&#xA;",2115623,,1727948,2018-09-04 10:54:50,2019-08-13 01:41:10,How to update a paginated list after a mutation?,<javascript><graphql><apollo><react-apollo><apollo-client>,2,1,0,2018-01-13 16:49:57
48245829,2,,48245570,15,,"<p>The issue was that I needed to wrap the response in a 'data' key, so the response I needed was:</p>&#xA;&#xA;<pre><code>{&#xA;    ""data"": {&#xA;         ""hello"": ""hello""&#xA;    }   &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>As I said, I am brand new to graphql/apollo</p>&#xA;",5183828,,,,2018-01-14 01:07:45,"",,0,0,0,2018-01-14 01:07:45
48277651,1,48278830,,16,4106,"<p>I'am new to GraphQL but I really like it. Now that I'am playing with interfaces and unions, I'am facing a problem with mutations.</p>&#xA;&#xA;<p>Suppose that I have this schema :</p>&#xA;&#xA;<pre><code>interface FoodType {&#xA;    id: String&#xA;    type: String&#xA;    composition: [Ingredient]&#xA;  }&#xA;&#xA;  type Pizza implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    pizzaType: String&#xA;    toppings: [String]&#xA;    size: String&#xA;    composition: [Ingredient]&#xA;  }&#xA;&#xA;  type Salad implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    vegetarian: Boolean&#xA;    dressing: Boolean&#xA;    composition: [Ingredient]&#xA;  }&#xA;&#xA;  type BasicFood implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    composition: [Ingredient]&#xA;  }&#xA;&#xA;  type Ingredient {&#xA;      name: String&#xA;      qty: Float&#xA;      units: String&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Now, I'd like to create new food items, so I started doing something like this :</p>&#xA;&#xA;<pre><code>type Mutation {&#xA;    addPizza(input:Pizza):FoodType&#xA;    addSalad(input:Salad):FoodType&#xA;    addBasic(input:BasicFood):FoodType&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This did not work for 2 reasons :</p>&#xA;&#xA;<ol>&#xA;<li>If I want to pass an object as parameter, this one must be an ""input"" type. But ""Pizza"", ""Salad"" and ""BasicFood"" are just ""type"".</li>&#xA;<li>An input type cannot implement an interface.</li>&#xA;</ol>&#xA;&#xA;<p>So, I need to modify my previous schema like this :</p>&#xA;&#xA;<pre><code>interface FoodType {&#xA;    id: String&#xA;    type: String&#xA;    composition: [Ingredient]&#xA;}&#xA;&#xA;type Pizza implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    pizzaType: String&#xA;    toppings: [String]&#xA;    size: String&#xA;    composition: [Ingredient]&#xA;}&#xA;&#xA;type Salad implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    vegetarian: Boolean&#xA;    dressing: Boolean&#xA;    composition: [Ingredient]&#xA;}&#xA;&#xA;type BasicFood implements FoodType {&#xA;    id: String&#xA;    type: String&#xA;    composition: [Ingredient]&#xA;}&#xA;&#xA;type Ingredient {&#xA;        name: String&#xA;        qty: Float&#xA;        units: String&#xA;}&#xA;&#xA;type Mutation {&#xA;    addPizza(input: PizzaInput): FoodType&#xA;    addSalad(input: SaladInput): FoodType&#xA;    addBasic(input: BasicInput): FoodType    &#xA;}&#xA;&#xA;input PizzaInput {&#xA;    type: String&#xA;    pizzaType: String&#xA;    toppings: [String]&#xA;    size: String&#xA;    composition: [IngredientInput]&#xA;}&#xA;&#xA;input SaladInput {&#xA;    type: String&#xA;    vegetarian: Boolean&#xA;    dressing: Boolean&#xA;    composition: [IngredientInput]&#xA;}&#xA;&#xA;input BasicFoodInput {&#xA;    type: String&#xA;    composition: [IngredientInput]&#xA;}&#xA;&#xA;input IngredientInput {&#xA;        name: String&#xA;        qty: Float&#xA;        units: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So, here I defined my 3 creation methods for Pizza, Salad and Basic food.&#xA;I need to define 3 input types (one for each food)&#xA;And I also need to define a new input type for Ingredients.</p>&#xA;&#xA;<p>It makes lot of duplication. Are you ok with that? Or there is a better way to deal with this?</p>&#xA;&#xA;<p>Thank you</p>&#xA;",1508466,,1508466,2018-01-17 06:57:37,2021-11-05 04:01:06,GraphQL how to avoid duplicate code between input and output types,<interface><graphql><apollo>,2,0,0,2018-01-16 09:13:02
48280378,1,49107525,,0,106,"<p>I am using Neo4j dB and using pattern comprehension to return the values. I have 2 types Person and Friend:&#xA; (p:Person)-[:FRIEND_WITH]->(f:Friend)  </p>&#xA;&#xA;<pre><code>Type Person{&#xA;  id: String&#xA;  name: String&#xA;  friends: [Friend]&#xA;}&#xA;&#xA; Type Friend{&#xA;  id: String&#xA;  name: String&#xA;&#xA;}   &#xA;&#xA; type Query {&#xA;    persons( limit:Int = 10): [Person]&#xA;    friends( limit:Int = 10): [Friend]&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>What i want to do is to pull the array list of field <strong>friends</strong> (present in Person Type) in ascending order when the ""persons"" query executes. For e.g.</p>&#xA;&#xA;<pre><code>  {&#xA;  ""data"": {&#xA;   ""persons"": {&#xA;     ""id"": ""1"",&#xA;     ""name"": ""Timothy"",&#xA;     ""friends"": [&#xA;       {&#xA;        ""id"": ""c3ef473"",&#xA;        ""name"": ""Adam"",     &#xA;       },&#xA;       {&#xA;        ""id"": ""ef4e373"",&#xA;        ""name"": ""Bryan"",     &#xA;       }, &#xA;       (  &#xA;        ""id"": ""e373ln45"",&#xA;        ""name"": ""Craig"",     &#xA;       },    &#xA;</code></pre>&#xA;&#xA;<p>How should I do it ? I researched regarding the sorting, but I did not find anything specific on the array object's sorting when we are using pattern comprehension in neo4j. Any suggestions would be really helpful !</p>&#xA;",3213011,,,,2018-03-05 09:51:17,How to add sorting for field object of graphql type which refers to different graphql type?,<neo4j><graphql>,1,0,0,2018-01-16 11:37:45
48291951,1,,,0,79,"<p>I have a set of data that looks like this. I cannot determine how to list out the contents under <code>entries</code> in the example below, (if it's possible.)</p>&#xA;&#xA;<p>Below is an example of the data structure. Each object follows the same layout as the first entry. Thanks for any pointers you can give me!</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>entries: {&#xD;&#xA;    2018-01-14T14:30:00-05:00: {&#xD;&#xA;        name: ""Jerry"",&#xD;&#xA;        guess: 75&#xD;&#xA;    },&#xD;&#xA;    2018-01-14T15:15:00-05:00: {},&#xD;&#xA;    2018-01-14T19:15:00-05:00: {},&#xD;&#xA;    2018-01-14T23:00:00-05:00: {},&#xD;&#xA;    2018-01-15T00:00:00-05:00: {},&#xD;&#xA;    2018-01-15T03:15:00-05:00: {},&#xD;&#xA;    2018-01-15T06:30:00-05:00: {},&#xD;&#xA;    2018-01-15T07:15:00-05:00: {},&#xD;&#xA;    2018-01-15T11:30:00-05:00: {},&#xD;&#xA;    2018-01-15T15:45:00-05:00: {},&#xD;&#xA;    2018-01-15T19:15:00-05:00: {},&#xD;&#xA;    2018-01-15T18:45:00-05:00: {},&#xD;&#xA;    2018-01-16T14:45:00-05:00: {},&#xD;&#xA;    2018-01-16T18:45:00-05:00: {}&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",6025788,,6025788,2018-01-17 01:10:14,2018-01-17 02:26:42,GraphQL - Querying a list of objects with varying attribute names?,<database><list><nosql><graphql><graphql-js>,1,0,0,2018-01-17 00:31:39
48351767,1,,,4,4962,"<p>With React-Apollo, is it possible to refetch again until the fetched data has a certain value?</p>&#xA;&#xA;<p>Say I have a component who keeps pinging the server until the server gives back a certain response.</p>&#xA;&#xA;<pre><code>graphql(gql`&#xA;  query {&#xA;    ping {&#xA;      response&#xA;    }&#xA;  }&#xA;`)(MyComponent)&#xA;</code></pre>&#xA;&#xA;<p>The server either returns</p>&#xA;&#xA;<pre><code>ping: {&#xA;  response: ""busy""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>or</p>&#xA;&#xA;<pre><code>ping: {&#xA;  response: ""OK""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want this component to keep pinging the server every one second (polling) until the response is ""OK"". What is the easiest way to do it with Apollo?</p>&#xA;",667027,,,,2019-11-01 21:35:24,How to refetch until certain value is returned from the server? (React-Apollo),<javascript><graphql><apollo><react-apollo>,3,0,0,2018-01-20 01:32:57
48374068,2,,48100824,0,,<p>Relay requires a (globally unique!) ID field to be able to distinguish between records in its local store. If the backend cannot supply this then Relay will not be able to function correctly.</p>&#xA;,151433,,,,2018-01-22 02:50:36,"",,0,0,0,2018-01-22 02:50:36
48433829,2,,48412084,0,,<p>Also when using resolvers and returning N parent objects you would end up with N+1 fetches for every child object which is much slower than fetching n pages of child objects and grouping by the parent object id.</p>&#xA;,9264867,,,,2018-01-25 00:27:51,"",,0,0,0,2018-01-25 00:27:51
48531577,1,,,1,394,"<p>I have this situation:</p>&#xA;&#xA;<p><em>TeamComponent.js:</em></p>&#xA;&#xA;<pre><code>....more code&#xA;  &lt;WorkItemComponent workType=""Beautiful""&gt;&#xA;  &lt;WorkItemComponent workType=""VeryBad""&gt;&#xA;....more code&#xA;</code></pre>&#xA;&#xA;<p><em>WorkItemComponent.js:</em></p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import { graphql } from ""react-apollo"";&#xA;import { compose, withHandlers } from ""recompose"";&#xA;import MY_BEAUTIFUL_WORKTYPE_QUERY from ""./MY_BEAUTIFUL_WORKTYPE_QUERY"";&#xA;import MY_VERYBAD_WORKTYPE_QUERY from ""./MY_VERYBAD_WORKTYPE_QUERY"";&#xA;import AmazingComponent from ""./AmazingComponent"";&#xA;&#xA;class WorkItemComponent extends Component {&#xA;  &lt;AmazingComponent/&gt;&#xA;}&#xA;&#xA;export default compose(&#xA;  graphql(MY_BEAUTIFUL_WORKTYPE_QUERY), // &lt;-- here I need to change this query&#xA;  choosing from [MY_BEAUTIFUL_WORKTYPE_QUERY, MY_VERYBAD_WORKTYPE_QUERY] based on ""workType"" prop in parent component ""TeamComponent"".&#xA;  withHandlers({&#xA;    ...&#xA;  })&#xA;)(WorkItemComponent);&#xA;</code></pre>&#xA;&#xA;<p>I need to change the query ""<code>MY_BEAUTIFUL_WORKTYPE_QUERY</code>"" choosing  <em><code>MY_BEAUTIFUL_WORKTYPE_QUERY</code></em> or <em><code>MY_VERYBAD_WORKTYPE_QUERY</code></em>&#xA;   based on ""<code>workType</code>"" prop in parent component ""<code>TeamComponent</code>"".</p>&#xA;&#xA;<p><strong>But how?!</strong></p>&#xA;&#xA;<p>Maybe I have to rethink everything?</p>&#xA;&#xA;<p><strong>Where am I wrong?</strong></p>&#xA;",0,user4412054,,,2018-01-30 22:43:05,"React Apollo GraphQL, many queries, but one component to be reused",<reactjs><graphql><apollo><react-apollo><apollo-client>,1,0,0,2018-01-30 22:29:46
48535633,1,,,1,77,<p>I'm building an app where I'm evaluating which way to go or what to use using NodeJS... I want to build a tree graph structure like this</p>&#xA;&#xA;<p><code>parent -&gt; 2 children -&gt; each child also with 2 children -&gt; repeat...</code></p>&#xA;&#xA;<p>And I want to be able to fetch all the members from say <code>a particular parent to its relative 4th generation</code>. Is this possible and could an example be provided before I dive into GraphQL?</p>&#xA;,5582322,,5582322,2018-01-31 07:54:08,2018-01-31 07:54:08,Tree Graph Collection Querying in GraphQL,<graphql><graphql-js>,0,0,0,2018-01-31 06:15:45
48538868,2,,48532299,9,,"<p>What you want to achieve here if I understood correctly, you want to group articles by author.&#xA;You can achieve that if you query and apply filter to <code>allContentfulAuthor</code>&#xA;and request the <code>article</code> field, like so:</p>&#xA;&#xA;<pre><code>{&#xA;  allContentfulAuthor(filter: {slug: {eq: ""myslug""}}) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;        article {&#xA;          title&#xA;          slug&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note that the <code>article</code> name is your contentTypeId for your articles.  </p>&#xA;",787774,,,,2018-01-31 09:38:09,"",,0,10,0,2018-01-31 09:38:09
48592117,1,,,0,1089,"<p>We are currently exploring some of the undocumented apis in Relay Modern, and so far the best way we have found to grab data out of the Relay Store for use in the application is to call environment.lookup with a selector derived from a graphql query.</p>&#xA;&#xA;<p>this happened because it seems like the RecordSource.get method returns the object from the store but doesn't fetch any data for nodes nested under it. Is there a better way to fetch an object and all connected nodes to it?</p>&#xA;&#xA;<p>Our use case is we are using applyOptimisticUpdate to update Relay's store so that changes that are made prior to saving on our admin application are visible to all components that have requested that piece of data. So once we are done making these changes we'd like to requery the relay Store to get the current state of a record, clean it up for real mutation purposes, and send the updated payload to the server. </p>&#xA;&#xA;<p>Any insights would be appreciated and I will add documentation to Relay with findings (if so desired). </p>&#xA;",2642092,,,,2018-02-04 15:35:26,What is the proper way to get data out of Relay Modern's internal store?,<javascript><graphql><relayjs><relaymodern>,1,0,0,2018-02-02 23:04:06
48618669,1,,,1,1524,"<p>Is there a good solution to reuse same GraphQL fragments in multiple .graphql files?</p>&#xA;&#xA;<p>I am trying to have all the fragments in one file, and to use them in multiple queries.</p>&#xA;",1353322,,,,2018-05-21 17:40:40,GraphQL Fragments reusable across multiple files,<graphql>,1,0,0,2018-02-05 08:48:37
48634092,2,,48609666,0,,"<p>You should be able to call this mutation like</p>&#xA;&#xA;<pre><code>mutate({&#xA;  variables: {&#xA;    mother_id: mother.id,&#xA;    child_name: child.name&#xA;  }&#xA;})&#xA;  .then(() =&gt; {})&#xA;  .catch(() =&gt; {})&#xA;</code></pre>&#xA;&#xA;<p>Also note that you're defining $mother_id as an input, and using $id in the 4th line. You should be using something like:</p>&#xA;&#xA;<pre><code>mutation UpdateMother($mother_id: ID!, $child_name: String!) {&#xA;  updateMother(&#xA;    mother: {&#xA;      id: $mother_id&#xA;      child: {&#xA;        name: $child_name&#xA;      }&#xA;    }&#xA;  )&#xA;}&#xA;</code></pre>&#xA;",1573859,,,,2018-02-06 01:25:11,"",,0,2,0,2018-02-06 01:25:11
48663819,1,,,0,1265,"<p>This is a <a href=""https://www.apollographql.com/docs/react/recipes/prefetching.html"" rel=""nofollow noreferrer"">snippet</a> from the official Apollo Docs that help prefetching. However, my concern is that I am not using a functional component but a class component and I am not able to see 'client' in the props of the class. </p>&#xA;&#xA;<pre><code>const FeedEntry = ({ entry, currentUser, onVote, client }) =&gt; {&#xA;  const repoLink = `/${entry.repository.full_name}`;&#xA;  const prefetchComments = (repoFullName) =&gt; () =&gt; {&#xA;    client.query({&#xA;      query: COMMENT_QUERY,&#xA;      variables: { repoName: repoFullName },&#xA;    });&#xA;  };&#xA;&#xA;  return (&#xA;    &lt;div className=""media""&gt;&#xA;      ...&#xA;      &lt;div className=""media-body""&gt;&#xA;        &lt;RepoInfo&#xA;          description={entry.repository.description}&#xA;          stargazers_count={entry.repository.stargazers_count}&#xA;          open_issues_count={entry.repository.open_issues_count}&#xA;          created_at={entry.createdAt}&#xA;          user_url={entry.postedBy.html_url}&#xA;          username={entry.postedBy.login}&#xA;        &gt;&#xA;          &lt;Link to={repoLink} onMouseOver={prefetchComments(entry.repository.full_name)}&gt;&#xA;              View comments ({entry.commentCount})&#xA;          &lt;/Link&gt;&#xA;        &lt;/RepoInfo&gt;&#xA;      &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;  );&#xA;};&#xA;&#xA;const FeedEntryWithApollo = withApollo(FeedEntry);&#xA;</code></pre>&#xA;&#xA;<p>I am also using Graphql. Here is what my code looks like for two components which require data:</p>&#xA;&#xA;<p><strong>BAR GRAPH</strong></p>&#xA;&#xA;<pre><code>    class BarGraphData extends React.Component {&#xA;        constructor(props) {&#xA;            super(props);&#xA;            this.state = {&#xA;            data: {}&#xA;            }&#xA;        }&#xA;       componentWillReceiveProps(nextProps) {&#xA;        this.setState({&#xA;            data: nextProps.data ? nextProps.data : {}&#xA;        });&#xA;       }&#xA;      render(){ &#xA;        return (&lt;BarGraph data={this.state.data} /&gt;) &#xA;      }&#xA;    }&#xA;&#xA;export default graphql(BAR_GRAPH_QUERY, {&#xA;options: ({ year, month, name  }) =&gt; ({&#xA;    variables: { year, month, name }&#xA;})&#xA; })(BarGraphData);&#xA;</code></pre>&#xA;&#xA;<p><strong>Line chart:</strong></p>&#xA;&#xA;<pre><code>    class LineGraphData extends React.Component {&#xA;        constructor(props) {&#xA;            super(props);&#xA;            this.state = {&#xA;            data: {}&#xA;            }&#xA;        }&#xA;       componentWillReceiveProps(nextProps) {&#xA;        this.setState({&#xA;            data: nextProps.data ? nextProps.data : {}&#xA;        });&#xA;    }&#xA;       render(){ &#xA;        return (&lt;LineGraph data={this.state.data} /&gt;) &#xA;        }&#xA;    }&#xA;&#xA;   export default graphql(LINE_GRAPH_QUERY, {&#xA;   options: ({ year, month, name  }) =&gt; ({&#xA;    variables: { year, month, name }&#xA;   })&#xA;   })(LineGraphData); &#xA;</code></pre>&#xA;&#xA;<p>I want to prefetch data for the line chart on hovering the bargraph (as click an item on bargraph should show its line chart ). However I am not able to access 'client' although I have defined the apollo client higher up in my tree and without prefetching this works - but it is slow. </p>&#xA;",5930693,,,,2018-02-07 12:44:09,Pre-fetching queries in apollo-client react,<reactjs><graphql><react-apollo><apollo-client>,1,0,0,2018-02-07 12:27:41
48692917,1,48699344,,3,509,"<p>I'm working with GraphQL and having some trouble finding the best way to pipe variables from the query to the result.</p>&#xA;&#xA;<p>I have a schema like so: </p>&#xA;&#xA;<pre><code>type Fragment {&#xA;&#xA;# The id of the fragment&#xA;&#xA;  id: String!&#xA;&#xA;# The key of the fragment&#xA;  key: String!&#xA;&#xA;# The type of component&#xA;  component_type: String!&#xA;&#xA;# The params used to build the fragment&#xA;  params: JSON&#xA;&#xA;# Component data&#xA;  data: JSON&#xA;&#xA;  children: [JSON]&#xA;&#xA;  items: [JSON]&#xA;&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The fragment is meant as a ""cms"" fragment.  I want to pass some query data through to another backend after this resolves.</p>&#xA;&#xA;<p>My query looks like this: </p>&#xA;&#xA;<pre><code>  query getFragmentsWithItems($keys: [String!]! &#xA;                     $platform: PlatformType &#xA;                     $version: String&#xA;                     $userInfo: UserInput&#xA;                     $userId: Int&#xA;                     ) {                     &#xA;    fragmentsWithItems(keys: $keys, platform: $platform, version: $version, userInfo: $userInfo, userId: $userId) {&#xA;      key&#xA;      data &#xA;      children&#xA;      params&#xA;      items&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Here's the problem: I have some query data in the <code>data</code> field from the Fragment.  That data is not available until that <code>Fragment</code> has resolved.  I want to take that data and send it to a different backend.  I want to do this with GraphQL, and I was hoping to do something like:</p>&#xA;&#xA;<pre><code>Fragment: () =&gt; {&#xA;  async query(obj, args, context, info, {modles}) =&gt; {&#xA;    const items = await models.getItems(obj.query_string);&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I need the <code>user_info</code> and <code>user_id</code> that I passed to the original query.  Apparently that is only accessible from the <code>info</code> argument which is not meant to be used.</p>&#xA;&#xA;<p>The other path I've taken is to have a manual resolver that does something like so:</p>&#xA;&#xA;<pre><code>const resolveFI = ({ keys, platform, version, userInfo, userId, models }) =&gt; {&#xA;  if (!keys || !keys.length) {&#xA;    return Promise.resolve(null);&#xA;  }&#xA;  return models.release.get({ platform, version }).then(release =&gt;&#xA;    Promise.all(&#xA;      keys.map(key =&gt;&#xA;        models.fragments.get({&#xA;          key,&#xA;          platform,&#xA;          version,&#xA;          release: release.id&#xA;        })&#xA;      )&#xA;    ).then(data =&gt; {&#xA;      const promises = [];&#xA;      data.rows.forEach(r =&gt; {&#xA;        if (r.data.query_data) {&#xA;          const d = {&#xA;            // Can just ignore&#xA;            filters: r.data.query_data.filters || {},&#xA;            user_info: userInfo,&#xA;            user_id: userId&#xA;          };&#xA;          promises.push(&#xA;            new Promise(resolve =&gt; {&#xA;              resolve(&#xA;                models.itemSearch.get(d).then(i =&gt; ({ items: i.items, ...r }))&#xA;              );&#xA;            })&#xA;          );&#xA;        }&#xA;        ...etc other backends &#xA;</code></pre>&#xA;&#xA;<p>This works, however a manual promise chain seems to defeat the purpose of using GraphQL.</p>&#xA;&#xA;<p>The last thing I tried was making <code>items</code> a non-scalar type, something like:</p>&#xA;&#xA;<pre><code>type Fragment {&#xA;items: ItemSearchResult(user_info: UserInput) etc&#xA;</code></pre>&#xA;&#xA;<p>But since I can't pipe the actual result from Fragment to the ItemSearchResult that doesn't work.</p>&#xA;&#xA;<p>I realize this is pretty long-winded so I'm open to edits or clarifying.<br>&#xA;I'm looking to see if I've missed a better approach or if I should just bag it and have the client apps do the item query after they get the Fragment data back.</p>&#xA;",1703484,,,,2018-09-26 07:28:31,Pass through GraphQL variables to second function in an elegant manner,<graphql>,1,2,0,2018-02-08 19:00:34
48700479,1,,,4,805,"<p>I have used connection helper for implementing pagination in graphql apis.I want to implement connection more than once for same model but it gives me duplicate type error. Can anyone suggest solution for supporting pagination for more than one apis of same model.&#xA;I have used below code.</p>&#xA;&#xA;<p><code>connection :employees_index, function: Queries::Employees::Index.new</code></p>&#xA;&#xA;<p><code>connection :employees_user_index, function: Queries::Employees::UserIndex.new</code></p>&#xA;",6569232,,,,2019-08-01 10:50:27,Duplicate type definition found for name 'Connection' in graphql pagination,<ruby-on-rails><ruby><pagination><graphql><graphql-ruby>,1,0,0,2018-02-09 07:11:00
48737969,2,,45557380,1,,"<p>by <em>startup</em> do you mean from the server? if so I don't believe that's how fragments are used. my understanding is as follows:</p>&#xA;&#xA;<ol>&#xA;<li>on the server you provide Types (like <code>User</code>)</li>&#xA;<li>on the client you query those Types using queries and fragments</li>&#xA;</ol>&#xA;&#xA;<p>for instance, if you provide type <code>User</code> on the server, on the client graphQL you can use fragments to query that type:</p>&#xA;&#xA;<h3>graphQL (client)</h3>&#xA;&#xA;<pre><code>fragment authorData on AuthorType{&#xA;  firstName&#xA;  posts {&#xA;    title&#xA;    votes&#xA;  }&#xA;}&#xA;&#xA;query PostsForAuthor {&#xA;  author(id: 1) {&#xA;    ...authorData&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4823555,,5893995,2018-09-26 07:36:45,2018-09-26 07:36:45,"",,0,8,0,2018-02-12 00:28:12
48746179,2,,48745826,3,,"<p>I solved it myself.</p>&#xA;&#xA;<p>wrapping <code>[]</code> around did the trick: so it is:</p>&#xA;&#xA;<pre><code>sort: {fields: [frontmatter___id], order: ASC}&#xA;</code></pre>&#xA;",3955607,,,,2018-02-12 12:08:17,"",,0,1,0,2018-02-12 12:08:17
48786092,2,,45674423,7,,<p>It probably depends on the backend you are using but e.g. in graph.cool you could something like this:</p>&#xA;<pre><code>query {&#xA;  allPersons(filter: {&#xA;    age_gt: 18&#xA;  }) {&#xA;    firstName&#xA;    lastName&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,3293008,,2932698,2022-01-15 16:27:52,2022-01-15 16:27:52,"",,0,0,0,2018-02-14 11:27:48
48791038,2,,48788677,1,,"<p>If apollo works anything like relay in this matter, you could try using <code>componentWillReceiveProps</code>:</p>&#xA;&#xA;<pre><code>class ... extends Component {&#xA;&#xA;  componentWillReceiveProps({ metrics }) {&#xA;    if(metrics) {&#xA;      this.setState({&#xA;        metrics,&#xA;      })&#xA;    }  &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>something like this.</p>&#xA;",7120861,,,,2018-02-14 15:44:00,"",,0,3,0,2018-02-14 15:44:00
48872078,1,,,0,782,"<p>I've recently started learning and using graphQL and I see that a common pattern is to make queries flexible enough to accept inputs such as <code>_id</code>, <code>last</code>, <code>first</code>, <code>take</code>, etc.</p>&#xA;&#xA;<p>Is this the right way to form queries or are there any design patterns or best practices that can be followed ?. </p>&#xA;&#xA;<p>For example, here's a resolver for a collection that is searchable and limitable.</p>&#xA;&#xA;<pre><code>Query: {&#xA;clients: async (parent, args, context) =&gt; {&#xA;  return await mongoDb&#xA;    .getCollection(CLIENTS_COLLECTION)&#xA;    .aggregate([&#xA;      {&#xA;        $match: {&#xA;          name: {&#xA;            $regex: args.input.text ? new RegExp(args.input.text) : '',&#xA;            $options: 'i'&#xA;          }&#xA;        }&#xA;      },&#xA;      { $limit: args.input.take || LIMIT }&#xA;    ])&#xA;    .toArray();&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Should I also add inputs to find by <code>_id</code> in this same query? What about filtering and sorting? And is there such thing as too flexible?</p>&#xA;",7729975,,7729975,2018-02-19 18:36:02,2018-03-12 16:47:49,graphQL with mongoDB - is it possible to be TOO flexible with a query?,<mongodb><graphql><graphql-js>,1,1,0,2018-02-19 18:23:52
48877141,2,,48817281,3,,"<p>There's a number of ways you could implement pagination, but here's two simple example resolvers that use Mongoose to get you started:</p>&#xA;&#xA;<p><strong>Simple pagination using limit and skip</strong>:</p>&#xA;&#xA;<pre><code>(obj, { pageSize = 10, page = 0 }) =&gt; {&#xA;  return Foo.find()&#xA;    .skip(page*pageSize)&#xA;    .limit(pageSize)&#xA;    .exec()&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Using _id as a cursor</strong>:</p>&#xA;&#xA;<pre><code>(obj, { pageSize = 10, cursor }) =&gt; {&#xA;  const params = cursor ? {'_id': {'$gt': cursor}} : undefined&#xA;  return Foo.find(params).limit(pageSize).exec()&#xA;}&#xA;</code></pre>&#xA;",6024220,,,,2018-02-20 02:50:25,"",,0,1,0,2018-02-20 02:50:25
48930050,1,,,1,855,"<p>I'm working on a GraphCMS site in React and would like to set up a GraphQL query to filter posts. We have this query setup which works and fetches all posts (adoptions) :</p>&#xA;&#xA;<pre><code>export const allAdoptions = gql`&#xA;  query allAdoptions($first: Int!, $skip: Int!) {&#xA;    allAdoptions(orderBy: date_DESC, first: $first, skip: $skip) {&#xA;        id&#xA;        name&#xA;        date&#xA;        image {&#xA;          handle&#xA;        }&#xA;        desc&#xA;        sex&#xA;        species&#xA;        neutered&#xA;    },&#xA;    _allAdoptionsMeta {&#xA;      count&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>The code is available here : <a href=""https://github.com/foxreymann/foranimals/blob/master/src/components/Adoptions.js"" rel=""nofollow noreferrer"">https://github.com/foxreymann/foranimals/blob/master/src/components/Adoptions.js</a></p>&#xA;&#xA;<p>We'd like to set up a filter component to get posts by species: ""Cat"" for example, and we've tried just modifying the above query for species: ""Cat"" with no luck. Any advice much appreciated, thanks</p>&#xA;",2720854,,1048572,2022-06-19 14:06:38,2022-06-19 14:06:38,GraphQL query to filter GraphCMS posts,<reactjs><graphql-js><graphcms>,1,0,0,2018-02-22 14:35:35
48930543,2,,48930050,1,,"<p>Did you check: <a href=""https://graphcms.com/docs/api_simple/#filtering-entries"" rel=""nofollow noreferrer"">https://graphcms.com/docs/api_simple/#filtering-entries</a>?</p>&#xA;&#xA;<p>It should work like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  allAdoptions(&#xA;    filter: {&#xA;      species: ""maine-coon""&#xA;    }&#xA;  ) {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Michael</p>&#xA;",7280541,,,,2018-02-22 14:58:56,"",,0,3,0,2018-02-22 14:58:56
48931102,1,48940558,,1,813,"<p>I've created a graphQL server with following schema:</p>&#xA;&#xA;<pre><code>...&#xA;#charts interface&#xA;interface Chart {&#xA;  id: String!&#xA;  sql: String!&#xA;  title: String&#xA;  type: String!&#xA;  display: String!&#xA;}&#xA;type Layout{&#xA;  # Unique layout id&#xA;  id: String&#xA;  # The title displayed on the layout tab&#xA;  title: String&#xA;  # List of displayed charts&#xA;  charts: [Chart]&#xA;}&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>On my client I have a <code>&lt;SummaryLayout/&gt;</code> component with the following gql query:</p>&#xA;&#xA;<pre><code>gql`{&#xA;layout(id:""summary""){&#xA;  title&#xA;  charts {&#xA;    id,&#xA;    title,&#xA;    type,&#xA;    display&#xA;  }&#xA;}}`&#xA;</code></pre>&#xA;&#xA;<p>When loading the page the layout component displays all the charts as a grid on the page. The user can later add a new chart, so I have 2 mutations: one creating the chart and the other is adding the new chart to the layout:</p>&#xA;&#xA;<pre><code>const addToLayout = gql`&#xA;mutation addToLayout($layoutID: String!, $chartID: String!) {&#xA;  addToLayout(layoutID: $layoutID ,chartID:$chartID){&#xA;    id&#xA;    charts {&#xA;      id&#xA;      sql&#xA;      title&#xA;      type&#xA;      display&#xA;    }&#xA;  }&#xA;}`;&#xA;&#xA;const addChart = gql`&#xA;mutation addChart($chartConfig:ChartConfig!) {&#xA;  addChart(chartConfig:$chartConfig){&#xA;    id&#xA;    display&#xA;  }&#xA;}`;&#xA;&#xA;this.props.addChart({&#xA;    variables: {chartConfig: chartConfig}&#xA;    }).then((response) =&gt; {&#xA;       const chartID = response.data.addChart.id;&#xA;       console.log(""Chart added, DB ID:"", chartID);&#xA;       this.props.addToLayout({&#xA;            variables: {layoutID: ""summary"", chartID: chartID},&#xA;            update: (store, data) =&gt; {&#xA;              console.log(""STORE:"",store);&#xA;            }&#xA;          }).then((response) =&gt; {&#xA;            appState.toggleDialog(false);&#xA;          })&#xA;     });&#xA;</code></pre>&#xA;&#xA;<p>When I log the store I can see that the <code>Layout:summary</code> entry is updated, but it is not reflected at the UI, one more thing that popped is that there is another entry called <code>$ROOT_QUERY.layout({""id"":""summary""})</code> that is not updated with the new data:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/znz3j.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/znz3j.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>What am I missing?</p>&#xA;",1115237,,,,2018-02-23 03:15:31,React Apollo: Store updates after mutation but the ui does not reflect the change,<reactjs><graphql><store><apollo-client>,1,0,0,2018-02-22 15:25:25
48932519,2,,48932332,1,,"<p>The way I see it, there are two approaches you can take.</p>&#xA;&#xA;<p>The safer approach is to create a type containing a key and a value. Then, your dictionary would be a list of keys and values. Instead of accessing a property as <code>let value = dictionary[key]</code>, you would then need to use <code>let entry = dictionary.find((entry) =&gt; entry.key === key); let value = entry &amp;&amp; entry.value</code>.</p>&#xA;&#xA;<pre><code>// Before&#xA;{&#xA;  red: 1,&#xA;  blue: 2,&#xA;  green: 3,&#xA;}&#xA;&#xA;// After&#xA;[&#xA;  {key: 'red', value: 1},&#xA;  {key: 'blue', value: 2},&#xA;  {key: 'green', value: 3},&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>Typedefs:</p>&#xA;&#xA;<pre><code>type IntegerProperty {&#xA;    key: ID!&#xA;    value: Int&#xA;}&#xA;&#xA;type IntegerDictionary {&#xA;    values: [IntegerProperty!]!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>A quicker but less typesafe approach is to use something like <a href=""https://www.npmjs.com/package/graphql-type-json"" rel=""nofollow noreferrer""><code>graphql-type-json</code></a> or <a href=""https://www.npmjs.com/package/graphql-json-object-type"" rel=""nofollow noreferrer""><code>graphql-json-object-type</code></a>. These permit you to include arbitrary JSON in your GraphQL query; however, you then lose the guarantees that GraphQL makes on the format of your data.</p>&#xA;",1385269,,,,2018-02-22 16:30:31,"",,0,0,0,2018-02-22 16:30:31
48940240,1,48940648,,32,18395,"<p>If I have a set of field that is common to multiple types in my GraphQL schema, is there a way to do something like this?</p>&#xA;&#xA;<pre><code>type Address {&#xA;  line1: String&#xA;  city: String&#xA;  state: String &#xA;  zip: String&#xA;}&#xA;&#xA;fragment NameAndAddress on Person, Business {&#xA;  name: String&#xA;  address: Address&#xA;}&#xA;&#xA;type Business {&#xA;   ...NameAndAddress&#xA;   hours: String&#xA;}&#xA;&#xA;type Customer {&#xA;   ...NameAndAddress&#xA;   customerSince: Date&#xA;}&#xA;</code></pre>&#xA;",6402238,,,,2019-11-23 16:08:42,Using GraphQL Fragment on multiple types,<graphql><apollo>,2,0,0,2018-02-23 02:31:42
48966978,2,,48963342,4,,"<p>Finally … I got it to work … sorry for disturbance …</p>&#xA;&#xA;<pre><code>...&#xA;bids(filter: {user: {id_not: null}}, first: 3, orderBy: price_DESC) {&#xA;...&#xA;</code></pre>&#xA;",425586,,,,2018-02-24 19:55:36,"",,0,0,0,2018-02-24 19:55:36
48996811,1,,,11,5321,<p>I wanna send a csv file in repose of graphql query.&#xA;I am using Apollo server and Apollo client and Reactjs.&#xA;(send a csv file from server to client)</p>&#xA;&#xA;<p>can anybody give me an idea how can I implement it?</p>&#xA;,6365086,,6365086,2018-02-26 22:59:15,2022-01-12 13:21:08,How to send a file to response a graphql query? (send a csv file from server to client),<graphql><react-apollo>,2,3,0,2018-02-26 20:46:25
49007461,2,,47459521,3,,"<p>I'm not sure if that's what you want, (I'm also just starting with relay) but you can specify different fragments using <a href=""https://facebook.github.io/relay/docs/en/fragment-container.html#defining-containers"" rel=""nofollow noreferrer"">keys</a> in the <code>createFragmentContainer</code> function:</p>&#xA;&#xA;<p>Fragmentcontainer:</p>&#xA;&#xA;<pre><code>export default createFragmentContainer(TodoItem, {&#xA;  todo: graphql`&#xA;    fragment TodoItem_todo on Todo {&#xA;      text&#xA;      isComplete&#xA;    }&#xA;  `,&#xA;  friend: graphql`&#xA;    fragment FriendItem_friend on Friends {&#xA;      name&#xA;    }&#xA;  `,&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And then in your <code>queryRenderer</code> something like this:</p>&#xA;&#xA;<pre><code>query={graphql`&#xA;    query AppQuery {&#xA;        todos {&#xA;            ...TodoItem_todo&#xA;        }&#xA;        friends {&#xA;            ...FriendItem_friend&#xA;        }&#xA;    }&#xA;`}&#xA;</code></pre>&#xA;",1059828,,1751946,2019-02-26 02:13:10,2019-02-26 02:13:10,"",,0,2,0,2018-02-27 11:19:51
49045183,2,,48982960,2,,<p>Can't spread a fragment of type <code>Viewer</code> on the root of a query which is type <code>Query</code>. Spread that fragment on the <code>viewer</code> field of the query</p>&#xA;,3772797,,,,2018-03-01 08:06:27,"",,0,1,0,2018-03-01 08:06:27
49052191,2,,47590134,-2,,<p>You can achieve this by using <code>Array.prototype.map</code>.</p>&#xA;&#xA;<pre><code>data.allContentfulDocuments.edges.map(edge =&gt; &#xA;  edge.node.documents.map(document =&gt; ({ id: document.id }))&#xA;</code></pre>&#xA;,406249,,,,2018-03-01 14:45:48,"",,0,0,0,2018-03-01 14:45:48
49082397,2,,49078788,9,,"<p>I think I've figured it out. Please let me know if there's a more optimal answer.</p>&#xA;&#xA;<pre><code>query {&#xA;  search(first: 100, type: ISSUE, query: ""user:will-stone state:open"") {&#xA;    issueCount&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        ... on Issue {&#xA;          createdAt&#xA;          title&#xA;          url,&#xA;          repository {&#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",813020,,,,2018-03-03 08:53:06,"",,0,0,0,2018-03-03 08:53:06
49103041,1,49293254,,1,1462,"<p>For Apollo GraphQL:</p>&#xA;&#xA;<p>I'm trying to query on a field where it requires a UUID. But I don't need the field if the variable is null. I was wondering what's the best way to handle this? I'm currently passing a default documentId to work around this. </p>&#xA;&#xA;<p>This is an example of the query </p>&#xA;&#xA;<pre><code>query GetOverview($initialFetch: Boolean!, $documentId: UUID!) {&#xA;  organization {&#xA;  name&#xA;  inode(id: $documentId) @include(if: $initialFetch) {&#xA;    ... on Inode {&#xA;      inodeId&#xA;      parent {&#xA;        inodeId&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Variable: &#xA;<code>{ initialFetch: true, documentId: ... }</code></p>&#xA;&#xA;<p>This is the error I get back </p>&#xA;&#xA;<p><code>""Variable ""$documentId"" of required type ""UUID!"" was not provided.""</code></p>&#xA;",2085190,,2085190,2018-04-10 17:44:42,2018-04-10 17:44:42,Is it possible to query in graphql with null value UUID when @include false or @skip true,<reactjs><graphql><apollo><react-apollo><apollo-client>,1,1,0,2018-03-05 03:21:27
49107525,2,,48280378,0,,"<p>I used the <a href=""https://lodash.com/docs/4.17.5#sortBy"" rel=""nofollow noreferrer"">sortBy</a> function of lodash to return the result into an ascending order. &#xA;And here is the graphql resolver query: </p>&#xA;&#xA;<pre><code>    persons(_, params) {&#xA;       let query = `MATCH (p:Person)&#xA;                    RETURN p{&#xA;                   .id,&#xA;                   .name,&#xA;                   friends: [(p)-[:FRIEND_WITH]-&gt;(f:Friend)) | f{.*}]&#xA;                   }&#xA;&#xA;                   LIMIT $limit;`;&#xA;&#xA;      return dbSession().run(query, params)&#xA;     .then(result =&gt; {&#xA;       return result.records.map(record =&gt; {&#xA;         let item = record.get(""p"");&#xA;             item.friends = sortBy(item.friends, [function(i) {&#xA;             return i.name;&#xA;        }]);&#xA;          return item;&#xA;      })&#xA;    })&#xA;}&#xA;</code></pre>&#xA;",3213011,,,,2018-03-05 09:51:17,"",,0,0,0,2018-03-05 09:51:17
49202299,2,,49201960,2,,"<p>Ok, this request is hideous, but it should give you what you expect </p>&#xA;&#xA;<p><a href=""http://sqlfiddle.com/#!9/864b7b/17"" rel=""nofollow noreferrer"">SQL Fiddle</a></p>&#xA;&#xA;<p><strong>MySQL 5.6 Schema Setup</strong>:</p>&#xA;&#xA;<p><strong>Query 1</strong>:</p>&#xA;&#xA;<pre><code>SELECT * &#xA;FROM (&#xA;    SELECT * &#xA;    FROM T &#xA;    ORDER BY `VIEWS` DESC &#xA;    LIMIT 2&#xA;    ) A&#xA;&#xA;UNION ALL&#xA;&#xA;SELECT * &#xA;FROM (&#xA;    SELECT * &#xA;    FROM T T0&#xA;    WHERE NOT EXISTS (&#xA;        SELECT 1 &#xA;        FROM (&#xA;            SELECT ID &#xA;            FROM T &#xA;            ORDER BY `VIEWS` DESC &#xA;            LIMIT 2&#xA;            ) T1&#xA;        WHERE T1.ID = T0.ID&#xA;        )&#xA;    ORDER BY RAND()&#xA;    LIMIT 1&#xA;    ) B&#xA;</code></pre>&#xA;&#xA;<p><strong><a href=""http://sqlfiddle.com/#!9/864b7b/17/0"" rel=""nofollow noreferrer"">Results</a></strong>:</p>&#xA;&#xA;<pre><code>| id |      name | views |&#xA;|----|-----------|-------|&#xA;|  8 | Product 8 |    91 |&#xA;|  6 | Product 6 |    76 |&#xA;|  3 | Product 3 |    23 |&#xA;</code></pre>&#xA;",5546267,,5546267,2018-03-09 21:24:03,2018-03-09 21:24:03,"",,0,3,0,2018-03-09 21:18:51
49297055,2,,49296528,1,,"<p>The problem is that the user property of the <code>ExchangePinMutation.Data.ExchangePinForToken.User.Fragments</code> struct should be of the User fragment type, but the type is shadowed by the local ExchangePinMutation.Data.ExchangePinForToken.User type.</p>&#xA;&#xA;<p>I fixed my issue by renaming the <code>User</code> fragment to <code>UserFull</code> and creating a typealias: <code>typealias User = UserFull</code></p>&#xA;&#xA;<p>Almost no refactoring needed!</p>&#xA;&#xA;<p><a href=""https://github.com/apollographql/apollo-codegen/issues/394#issuecomment-373323235"" rel=""nofollow noreferrer"">https://github.com/apollographql/apollo-codegen/issues/394#issuecomment-373323235</a></p>&#xA;",4173828,,,,2018-03-15 10:28:02,"",,0,0,0,2018-03-15 10:28:02
49311322,2,,47240085,5,,"<p>I agree with @DanielRearden. You should make type-resolvers so you can go infinitely deep into the graph. I made a simple server example <a href=""https://github.com/konsumer/simple-graphql/"" rel=""noreferrer"">here</a> that shows deep relationships. Because all the noun-fields are references, it goes infinitely deep for any query.</p>&#xA;&#xA;<p>With that server, you can run a query like this, for example:</p>&#xA;&#xA;<pre><code>{&#xA;  hero {&#xA;    name&#xA;    friends {&#xA;      name&#xA;      friends {&#xA;        name&#xA;        friends {&#xA;          name&#xA;          friends: {&#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So, in your example, structure it like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  user {&#xA;    id&#xA;    otherStuff {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",656398,,656398,2018-06-22 04:13:30,2018-06-22 04:13:30,"",,0,0,0,2018-03-16 00:14:10
49340195,2,,49318706,0,,<p>Adding the new <code>distance</code> field to my GraphQL schema for the object type I was searching for and adding it as a returned field for the GraphQL query on the front end seemed to do the trick.</p>&#xA;,2491630,,,,2018-03-17 18:04:35,"",,0,0,0,2018-03-17 18:04:35
49344444,1,57420884,,8,9928,"<p>Based on my limited searching, it seems GraphQL can only support equal filtering. So, </p>&#xA;&#xA;<p>Is it possible to do Github GraphQL searching with the filtering conditions of, </p>&#xA;&#xA;<ul>&#xA;<li>stars > 10</li>&#xA;<li>forks > 3</li>&#xA;<li>total commit >= 5</li>&#xA;<li>total issues >= 1</li>&#xA;<li>open issues &lt;= 60</li>&#xA;<li>size > 2k</li>&#xA;<li>score > 5</li>&#xA;<li>last update is within a year</li>&#xA;</ul>&#xA;&#xA;<p>I.e., filtering will <em>all</em> above conditions. Is it possible?</p>&#xA;",2125837,,2125837,2018-03-18 20:57:54,2019-08-22 09:13:50,Github GraphQL Search with Filtering,<search><github><graphql><github-api><github-graphql>,2,1,0,2018-03-18 04:21:07
49370757,1,49373662,,1,1094,"<p>I have finally gotten Karate working with GraphQL and able to verify a simple 200 response though I am having trouble verifying the schema and then a response. I am super new so I apologize (not a programmer, just a tester).  I want to verify that the schema is correct and for example that the results simply return (providerID, firstName, lastName etc), not the data.  I then want to verify the data itself separately. The other thing I do not understand is how to pass in data, for example where I could change the Latitude, Longitude, MaxDistance etc and have it be a variable.  I see in the example how ""name"" as used as a variable yet these seem to be passed in differently so I'm unsure how to do it.  Sorry for not knowing so much, I appreciate the help. </p>&#xA;&#xA;<pre><code>Scenario: simple graphql request&#xA;    #Verify 200 response status returned    &#xA;    Given text query =&#xA;        """"""&#xA;     {&#xA;                    Results: getSearchResults(searchLatitude:""38.942833"", &#xA;    searchLongitude: ""-119.984549"", providerType: ""Primary Care Physicians"", &#xA;    sortBy: ""distance"", maxDistance:""600"",skip: 0, take: 10) {&#xA;                        providerID&#xA;                        firstName &#xA;                        lastName&#xA;                        mI&#xA;                        title&#xA;                        name&#xA;                        nameLFMT&#xA;                        status&#xA;                        specialties&#xA;                        locations&#xA;                        institutions&#xA;                        acceptNewPatient&#xA;                        imageUri&#xA;                        distanceToNearest&#xA;                    }&#xA;&#xA;    } &#xA;&#xA;        """"""&#xA;    And request { query: '#(query)' }&#xA;    When method post&#xA;    Then status 200&#xA;&#xA;    # pretty print the response&#xA;    * print 'response:', response&#xA;&#xA;&#xA;    # the '..' wildcard is useful for traversing deeply nested parts of the &#xA;    json&#xA;    * def results = get[0] response..Results&#xA;    * match results contains { ProviderId: 520, firstName: 'Richard', &#xA;lastName: 'Botto' }&#xA;</code></pre>&#xA;",4842886,,,,2018-03-19 22:50:09,Karate - GraphQL - How to verify schema and then response?,<java><automated-tests><cucumber><graphql><karate>,1,0,0,2018-03-19 19:19:03
49373662,2,,49370757,2,,"<p>Take a look at the <a href=""https://github.com/intuit/karate#replace"" rel=""nofollow noreferrer""><code>replace</code></a> keyword.</p>&#xA;&#xA;<p>Then try this:</p>&#xA;&#xA;<pre><code>Given text query =&#xA;    """"""&#xA; {&#xA;                Results: getSearchResults(searchLatitude:""&lt;searchLatitude&gt;"", &#xA;searchLongitude: ""&lt;searchLongitude&gt;"", providerType: ""Primary Care Physicians"", &#xA;sortBy: ""distance"", maxDistance:""600"",skip: 0, take: 10) {&#xA;                    providerID&#xA;                    firstName &#xA;                    lastName&#xA;                    mI&#xA;                    title&#xA;                    name&#xA;                    nameLFMT&#xA;                    status&#xA;                    specialties&#xA;                    locations&#xA;                    institutions&#xA;                    acceptNewPatient&#xA;                    imageUri&#xA;                    distanceToNearest&#xA;                }&#xA;&#xA;} &#xA;&#xA;    """"""&#xA;* replace query.searchLatitude = '38.942833'&#xA;* replace query.searchLongitude = '-119.984549'&#xA;</code></pre>&#xA;&#xA;<p>Once you get this working search the documentation for ""graphql"" for more ideas.</p>&#xA;&#xA;<p>For matching schema it should be easy:</p>&#xA;&#xA;<pre><code>* match results contains { ProviderId: '#number', firstName: '#string', lastName: '#string' }&#xA;</code></pre>&#xA;&#xA;<p>The doc has a whole section on <a href=""https://github.com/intuit/karate#fuzzy-matching"" rel=""nofollow noreferrer"">fuzzy matching</a>.</p>&#xA;",143475,,,,2018-03-19 22:50:09,"",,0,2,0,2018-03-19 22:50:09
49376618,2,,49237159,0,,"<p>Pagination using endCursor is the one solution. Like REST API, you cannot traverse all pages pragmatically. As you specified you can specify endCursor and traverse if there is next page</p>&#xA;",9489594,,,,2018-03-20 04:59:38,"",,0,0,0,2018-03-20 04:59:38
49387253,1,49388527,,0,807,"<p>In markdown how can I put a comma without it counting as code. I should add that this is in the variable section of the markdown page.</p>&#xA;&#xA;<p>Example:</p>&#xA;&#xA;<pre><code>array: [&#xA;  line one without comma,&#xA;  line with comma here, still the same line,&#xA;  new line&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>So if I were to loop through this I get something like:</p>&#xA;&#xA;<pre><code>line one without comma&#xA;line with comma here&#xA;still the same line&#xA;new line&#xA;</code></pre>&#xA;",8551819,,866026,2018-03-20 16:01:53,2018-03-20 16:01:53,How to put an inline comma in markdown?,<markdown><graphql><gatsby>,1,6,0,2018-03-20 14:43:54
49388527,2,,49387253,1,,"<p>After messing around with it for a while and trying a lot of different things I just tried wrapping the lines in "" "" and it ended up working. So if you want to include a comma as part of the array string element you just do it like so:</p>&#xA;&#xA;<pre><code>array: [&#xA;  line one without comma,&#xA;  ""line with comma here, still the same line"",&#xA;  new line&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>My new output looks like:</p>&#xA;&#xA;<pre><code>line one without comma&#xA;line with comma here, still same line&#xA;new line&#xA;</code></pre>&#xA;",8551819,,,,2018-03-20 15:43:50,"",,0,0,0,2018-03-20 15:43:50
49395613,1,,,5,718,"<p>I have a simple scenario here.</p>&#xA;&#xA;<p>I have a People sequelize model that has 5 fields: firstName, lastName, id, city, and zipCode. I also have a GraphQL Object that has the same fields.</p>&#xA;&#xA;<p>Every time I do a GraphQL query, for example:</p>&#xA;&#xA;<pre><code>{&#xA;   people(id:123){&#xA;    firstName&#xA;    lastName&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Sequelize sends a SQL statement like this:</p>&#xA;&#xA;<pre><code>SELECT `firstName`, `lastName`, `id`, `city`, `zipCode` FROM `People` WHERE `People`.`id` = 123;&#xA;</code></pre>&#xA;&#xA;<p>Is it possible that I can make Sequelize sends a SQL statement that is like this:</p>&#xA;&#xA;<pre><code>SELECT `firstName`, `lastName` FROM `People` WHERE `People`.`id` = 123;&#xA;</code></pre>&#xA;&#xA;<p>Basically what I want is that the SQL statement does not select any extra columns that I don't want.</p>&#xA;&#xA;<p>This is my resolve function in GraphQL query object:</p>&#xA;&#xA;<pre><code>resolve: function (root, args) {&#xA;   return Db.models.People.findAll({ where: args });&#xA;}&#xA;</code></pre>&#xA;",9525391,,,,2018-03-20 23:12:02,GraphQL query fields that matches with Sequelize Query,<node.js><sequelize.js><graphql><graphql-js>,0,4,0,2018-03-20 23:12:02
49405249,1,,,0,1614,"<p>What is the proper way to use a GraphQL Relay connection cursor with the Ant Design Table pagination?  It has really nice pagination, but the graphql server looks for a cursor and doens't need the ""total"" page number.   Any thoughts?</p>&#xA;",180975,,,,2018-04-01 13:28:54,Ant Design Table + GraphQL,<graphql><antd>,1,1,0,2018-03-21 11:33:20
49432648,2,,43878412,0,,"<p>See the answer here: <a href=""https://stackoverflow.com/a/47943253/763231"">https://stackoverflow.com/a/47943253/763231</a></p>&#xA;&#xA;<p><code>connect</code> must be the last decorator executed, <strong>after</strong> <code>graphql</code>, in order for <code>graphql</code> to include the props from Redux.</p>&#xA;",763231,,,,2018-03-22 15:32:12,"",,0,0,0,2018-03-22 15:32:12
49456022,2,,44830439,1,,"<p>I know this is an old question, but maybe somebody gets here like I did :) These __typename fields were most likely your problem, the query ended up looking differently than the query you were passing to you mock interface. The error basically meant that it couldn't find any matching mocks for that query.</p>&#xA;&#xA;<p>Anyway, here is a working example of this test, updated to work in Apollo 2.</p>&#xA;&#xA;<pre><code>it('executes a query', (done) =&gt; {&#xA;  const query = gql` query people { allPeople(first: 1) { people { name } } }`;&#xA;  const data = { allPeople: { people: [ { name: 'Luke Skywalker' } ] } };&#xA;&#xA;  const withGraphQL = graphql(query);&#xA;&#xA;  class Container extends React.Component {&#xA;    componentWillReceiveProps(props) {&#xA;      expect(props.data.loading).toBeFalsy();&#xA;      expect(props.data.error).toBeUndefined();&#xA;      expect(props.data.allPeople.people[0].name).toEqual(data.allPeople.people[0].name);&#xA;      done();&#xA;    }&#xA;    render() {&#xA;      return null;&#xA;    }&#xA;  };&#xA;&#xA;  const ContainerWithData = withGraphQL(Container);&#xA;&#xA;  mount(&lt;MockedProvider removeTypename mocks={[ { request: { query },   result: { data } } ]}&gt;&lt;ContainerWithData /&gt;&lt;/MockedProvider&gt;);&#xA;&#xA;});&#xA;</code></pre>&#xA;",730199,,,,2018-03-23 18:13:50,"",,0,0,0,2018-03-23 18:13:50
49485476,2,,49463986,2,,<p>try this!</p>&#xA;&#xA;<pre><code>query PostsWithAuthor {&#xA;  allPosts(filter: { author: null }) {&#xA;    id&#xA;    author {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,2946444,,,,2018-03-26 06:49:23,"",,0,0,0,2018-03-26 06:49:23
49518557,1,49742826,,2,2183,"<p>I have a problem with AWS AppSync and ApolloClient.&#xA;How can I use an association between users in the Amazon Service named AppSync, that is, a connection as node and edge. What I want to do is when I follow the users, I would like to see the flow of all users with a single request. &#xA;It is the request that I want to be. How do I build a structure for this?</p>&#xA;&#xA;<pre><code>query {&#xA;    getFeeds(id:""myUserId"") {&#xA;    following {&#xA;      userFeed {&#xA;        id&#xA;        ImageDataUrl&#xA;        textData&#xA;        date&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>The schema I created is as follows</strong></p>&#xA;&#xA;<pre><code>type Comments {&#xA;    id: ID!&#xA;    date: Int!&#xA;    message: String!&#xA;    user: User&#xA;}&#xA;type Feed {&#xA;    id: ID!&#xA;    user: User!&#xA;    date: Int!&#xA;    textData: String&#xA;    ImageDataUrl: String&#xA;    VideoDataUrl: String&#xA;    likes: Like&#xA;    comments: [Comments]&#xA;}&#xA;&#xA;#Objects&#xA;type Like {&#xA;    id: ID!&#xA;    number: Int!&#xA;    likers: [User]&#xA;}&#xA;}&#xA;type Query {&#xA;    getAllUsers(limit: Int): [User]&#xA;}&#xA;&#xA;type User {&#xA;    id: ID!&#xA;    name: String!&#xA;    email: String!&#xA;    imageUrl: String!&#xA;    imageThumbUrl: String!&#xA;    followers: [User]&#xA;    following: [User]&#xA;    userFeed: [Feed]&#xA;}&#xA;&#xA;schema {&#xA;    query: Query&#xA;}&#xA;</code></pre>&#xA;",4717684,,,,2018-04-09 22:51:02,AWS AppSync User relations for FriendsList,<amazon-web-services><amazon-dynamodb><graphql><apollo><aws-appsync>,1,0,0,2018-03-27 17:00:02
49521662,2,,49521575,9,,"<p>You should use an ampersand instead of a comma for multiple interfaces.&#xA;See here: <a href=""http://facebook.github.io/graphql/draft/#sec-Interfaces"" rel=""noreferrer"">http://facebook.github.io/graphql/draft/#sec-Interfaces</a></p>&#xA;&#xA;<pre><code>type Something implements First &amp; Second&#xA;</code></pre>&#xA;",184343,,,,2018-03-27 20:12:22,"",,0,0,0,2018-03-27 20:12:22
49556587,2,,46342191,-1,,"<p>Define like that:</p>&#xA;&#xA;<pre><code>type DisplayLocation = {&#xA;  lat: Float,&#xA;  lng: Float,&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>See more graph.</p>&#xA;",0,user7887589,4661692,2018-03-29 13:43:59,2018-03-29 13:43:59,"",,0,2,0,2018-03-29 12:51:38
49598575,2,,49405249,0,,"<p>I created a pagination component that replaced the actual <code>&lt;Table&gt;</code> component pagination.  Then I set <code>&lt;Table pagination={false}&gt;</code> and used my custom paginator to control the next and previous functionality without the numbered pages.</p>&#xA;&#xA;<p>I am using graphql-ruby so I actually needed to enable <a href=""https://github.com/facebook/relay/pull/2079"" rel=""nofollow noreferrer"">bidirectional pagination</a> instead of the classic docs from GraphQL.  It has since become a standard.</p>&#xA;",180975,,,,2018-04-01 13:28:54,"",,0,0,0,2018-04-01 13:28:54
49642804,2,,49641885,5,,"<p>GraphQL fields are resolved in a top-down fashion. That means <code>allPosts</code> is resolved first, then then <code>message</code> and <code>user</code> fields (simultaneously) and then the <code>name</code> field. This has to happen, as the ""parent"" or root field's resolved value determine's the value that's then passed to the resolver for its children fields as the root value. Information flows from ""higher"" resolvers to ""lower"" ones, but not the other way around.</p>&#xA;&#xA;<p>Your <code>orderBy</code> argument here probably should be an argument on the <code>allPosts</code> field rather than the <code>user</code> field. There's two reasons to do that: (1) conceptually, regardless of the sort criteria, you are sorting the Posts returned by <code>allPosts</code> -- by convention, it just makes sense to put the sort there; (2) the argument is probably needed by the <code>allPosts</code> resolver more than it's needed by the <code>user</code> resolver.</p>&#xA;&#xA;<p>To make the above work, you'll probably need to modify how you identify the sort criteria (making <code>field</code> a path like <code>user.name</code> for example). You may also need ""lift"" the logic for populating the users up into the <code>allPosts</code> resolver. For example:</p>&#xA;&#xA;<pre><code>resolve(parentValue, { sortBy: { path, direction } }) {&#xA;  const data = postData.map(post =&gt; {&#xA;    post.user = userMap[post.user]&#xA;    return post&#xA;  });&#xA;  // using lodash&#xA;  return orderBy(data, [(post) =&gt; get(post, path)], [direction])&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It <em>is</em> possible to determine the selection set for other fields inside the request, including the arguments, by parsing the <code>info</code> object that's passed in as the fourth parameter to the resolver function. It's a pain though and I don't know if this particular case really justifies doing all that. You can read more about that approach in <a href=""https://stackoverflow.com/questions/48094695/how-to-pass-root-parameters-in-the-resolver-function-of-a-nested-query/48096791#48096791"">this answer</a>.</p>&#xA;",6024220,,,,2018-04-04 04:29:58,"",,0,1,0,2018-04-04 04:29:58
49656708,1,,,0,591,"<p>In my react component I do get some data from graphQL server using react-apollo.&#xA;That's working fine, but this component is a <strong>child</strong> component and I need to get the graphQL data to a parent component. Is this possible at all or do I have to change my structure?</p>&#xA;&#xA;<p><strong>Child</strong></p>&#xA;&#xA;<pre><code>export class Child extends Component {&#xA;  const { contentList } = this.props&#xA;  render () {&#xA;    contentList.map(elm =&gt; return &lt;div&gt;elm&lt;/div&gt;)&#xA;  }&#xA;}&#xA;&#xA;export default compose(&#xA;  graphql(&#xA;    gql`&#xA;      query {&#xA;        contentList {&#xA;          _id&#xA;          title&#xA;        }&#xA;      }&#xA;    `, { name: 'contentList' }&#xA;  )&#xA;)(Child)&#xA;</code></pre>&#xA;&#xA;<p><strong>Parent</strong></p>&#xA;&#xA;<pre><code>export class Parent extends Component {&#xA;  constructor () {&#xA;    super()&#xA;    this.state = {&#xA;      data = null // &lt;-- Need to get the data of child here&#xA;    }&#xA;  }&#xA;&#xA;  render () {&#xA;    const { data } = this.state&#xA;    // Now I can use the data, which is fetched by the child component&#xA;    return &lt;Child /&gt;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3142695,,,,2018-04-04 17:21:22,"Child component fetches data, which should be passed to parent component",<javascript><reactjs><graphql>,1,9,0,2018-04-04 17:09:41
49656802,2,,49656708,0,,"<p>You can pass a function of parent to the childComponent via props and invoke that function from child when you have data.</p>&#xA;&#xA;<pre><code>export class Parent extends Component {&#xA;  constructor () {&#xA;    super();&#xA;    this.handleData = this.handleData.bind(this);&#xA;    this.state = {&#xA;      data = null // &lt;-- Need to get the data of child here&#xA;    }&#xA;  }&#xA;handleData(data){&#xA;//you can use data here&#xA;}&#xA;&#xA;  render () {&#xA;    const { data } = this.state&#xA;    // Now I can use the data, which is fetched by the child component&#xA;    return &lt;Child parentHandler=""this.handleData"" /&gt;&#xA;  }&#xA;}&#xA;&#xA;&#xA;export class Child extends Component {&#xA;  const { contentList, parentHandler } = this.props;&#xA;//call parentHandler with the data when you have data&#xA;  render () {&#xA;    contentList.map(elm =&gt; return &lt;div&gt;elm&lt;/div&gt;)&#xA;  }&#xA;}&#xA;&#xA;export default compose(&#xA;  graphql(&#xA;    gql`&#xA;      query {&#xA;        contentList {&#xA;          _id&#xA;          title&#xA;        }&#xA;      }&#xA;    `, { name: 'contentList' }&#xA;  )&#xA;)(Child)&#xA;</code></pre>&#xA;",9589327,,,,2018-04-04 17:15:32,"",,0,0,0,2018-04-04 17:15:32
49663571,1,,,3,73,<p>I am trying to integrate an Apollo client (graphql) to my application that is already developed with reactjs and redux.</p>&#xA;&#xA;<p>With the information I've got the Apollo client have a store as the redux have one too.</p>&#xA;&#xA;<p>Is it good to work with 2 stores in the application ? is it possible to have only one store ?</p>&#xA;,2272636,,2272636,2018-04-05 05:05:30,2018-05-14 02:06:48,Managing the stores of Redux and Apollo,<redux><graphql><apollo><react-apollo>,1,0,0,2018-04-05 03:15:15
49668518,1,,,0,207,"<p>I'm trying to update the values and connections on my current viewer within the Relay store.</p>&#xA;&#xA;<p>So without calling the mutation signIn if I print:</p>&#xA;&#xA;<pre><code>console.log(viewer.name) // ""Visitor""&#xA;console.log(viewer.is_anonymous) // true&#xA;</code></pre>&#xA;&#xA;<p>on Mutations we got the method updater which gives us the store, so in my mutation I'm doing something like this:</p>&#xA;&#xA;<pre><code>mutation SignInMutation($input: SignInInput!){&#xA;  signIn(input: $input){&#xA;      user {&#xA;          id&#xA;          name&#xA;          email&#xA;          is_anonymous&#xA;          notifications{&#xA;              edges{&#xA;                  node {&#xA;                      id&#xA;                      ...NotificationItem_notification&#xA;                  }&#xA;              }&#xA;          }&#xA;      }&#xA;      token&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So my updater method has:</p>&#xA;&#xA;<pre><code>const viewer = store.get(viewer_id);&#xA;const signIn = store.getRootField('signIn');&#xA;viewer.copyFieldsFrom(signIn.getLinkedRecord('user'))&#xA;</code></pre>&#xA;&#xA;<p>After this I updated the store I got the name email is_anonymous fields updated with the data that just came from the graphql endpoint (I mean now name is ""Erick"", is_anonymous is now false, which is great), but If I try to do viewer.notifications and render it, the length of the viewer.connections seem to be 0 even when it has notifications.</p>&#xA;&#xA;<p>How can I update my current viewer and add the notifications from the MutationPayload into the store without the need to force fetch?</p>&#xA;&#xA;<p>Im using the latest relay-modern and graphql.</p>&#xA;&#xA;<p>PS: Sorry for the bad formation, but is just impossible to format the code the way OF wants me to, i formated it to 4 spaces and still gave me errors.</p>&#xA;",913426,,151433,2018-04-18 06:37:18,2018-08-15 04:17:59,Update viewer fields and connection on Store,<graphql><relayjs>,1,0,0,2018-04-05 09:14:31
49703299,1,50161626,,1,113,<p>Is there any easy way to use the cursor in GraphQL while fetching data from MongoDB or the basic cursor which is commonly using in the database?</p>&#xA;,7208392,,,,2018-05-03 18:24:26,How to use cursor in graphql?,<mongodb><graphql>,1,0,0,2018-04-07 02:39:10
49718713,1,,,1,770,"<p>At the moment I have to loop through the existing records in the connection to check if the record already exists and only if it doesn't then I add the new edge to it. The reason I need to do this is that when the page is loaded the comments get retrieved by CommentsContainer but the subscription also gets all the comments which results in every comment being duplicated.</p>&#xA;&#xA;<p>App.js:</p>&#xA;&#xA;<pre><code>const AppContainer = compose(&#xA;  lifecycle({&#xA;    componentDidMount() {&#xA;      commentSubscription();&#xA;    },&#xA;  }),&#xA;)(App);&#xA;</code></pre>&#xA;&#xA;<p>My subscription:</p>&#xA;&#xA;<pre><code>import { requestSubscription, graphql } from 'react-relay';&#xA;import { ConnectionHandler } from 'relay-runtime';&#xA;&#xA;import environment from '../app/environment/environment';&#xA;&#xA;const subscription = graphql`&#xA;  subscription commentSubscription {&#xA;    commentAdded {&#xA;      id&#xA;      ...commentContainer_comment&#xA;      audio {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default () =&gt; requestSubscription(&#xA;  environment,&#xA;  {&#xA;    subscription,&#xA;    onError: error =&gt; console.error(error), // eslint-disable-line no-console&#xA;    updater: (store) =&gt; {&#xA;      const commentAdded = store.getRootField('commentAdded');&#xA;      const audioRecord = commentAdded.getLinkedRecord('audio');&#xA;      const audioId = audioRecord.getValue('id');&#xA;      const audioProxy = store.get(audioId);&#xA;      const connection = ConnectionHandler.getConnection(&#xA;        audioProxy,&#xA;        'commentsContainer_comments',&#xA;      );&#xA;&#xA;      if (connection) {&#xA;        const existingRecords = connection.getLinkedRecords('edges');&#xA;        const recordAlreadyExists = existingRecords.some((existingRecord) =&gt; {&#xA;          const node = existingRecord.getLinkedRecord('node');&#xA;          const existingId = node.getValue('id');&#xA;          const commentId = commentAdded.getValue('id');&#xA;&#xA;          return existingId === commentId;&#xA;        });&#xA;&#xA;        if (!recordAlreadyExists) {&#xA;          const edge = ConnectionHandler.createEdge(store, connection, commentAdded, 'CommentPayloadEdge');&#xA;&#xA;          ConnectionHandler.insertEdgeBefore(connection, edge);&#xA;        }&#xA;      }&#xA;    },&#xA;  },&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>CommentsContainer:</p>&#xA;&#xA;<pre><code>import { compose } from 'recompose';&#xA;import { graphql } from 'react-relay';&#xA;import { fragmentContainer } from 'recompose-relay-modern';&#xA;&#xA;import Comments from './comments';&#xA;&#xA;const fragments = graphql`&#xA;  fragment commentsContainer_audio on Audio {&#xA;    id&#xA;    ...commentBoxContainer_audio&#xA;    comments(&#xA;      first: $count&#xA;      after: $cursor&#xA;    ) @connection(key: ""commentsContainer_comments"") {&#xA;      edges {&#xA;        node {&#xA;          commentId&#xA;          ...commentContainer_comment&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default compose(&#xA;  fragmentContainer(fragments),&#xA;)(Comments);&#xA;</code></pre>&#xA;&#xA;<p>CommentContainer: </p>&#xA;&#xA;<pre><code>import { compose } from 'recompose';&#xA;import { fragmentContainer } from 'recompose-relay-modern';&#xA;import { graphql } from 'react-relay';&#xA;&#xA;import Comment from './comment';&#xA;&#xA;const fragments = graphql`&#xA;  fragment commentContainer_comment on Comment {&#xA;    id&#xA;    body&#xA;    dateAdded&#xA;    user {&#xA;      userName&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default compose(&#xA;  fragmentContainer(fragments),&#xA;)(Comment);&#xA;</code></pre>&#xA;&#xA;<p>Is this the correct way to use Relay subscriptions? It seems inefficient having to loop through every comment to check if it already exists.</p>&#xA;",5252988,,,,2018-04-17 08:38:31,Relay Subscriptions correct way to use?,<reactjs><graphql><relay>,1,0,0,2018-04-08 14:07:28
49722910,1,49723385,,4,6073,"<p>I have one DynamoDB table with all the data I need for the client, however, I want to shape the data the client receives to reduce client-side manipulation.</p>&#xA;&#xA;<p>My Schema:</p>&#xA;&#xA;<pre><code>type StateCounty {&#xA;    id: ID!&#xA;    StateName: String&#xA;    CountyName: String&#xA;    FIPSST: Int&#xA;    FIPSCNTY: Int   &#xA;    Penetration: String&#xA;    Date: String&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and to return a custom query I have the type:</p>&#xA;&#xA;<pre><code>type Query {&#xA;  getStateCountybyState(StateName: String): StateCountyConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This works - and with a simple query</p>&#xA;&#xA;<pre><code>query  getStateCountybyState {&#xA;     getStateCountybyState (StateName: ""Delaware"")   {&#xA;      items { &#xA;       StateName&#xA;       CountyName&#xA;       Date    &#xA;&#xA;    }&#xA;   }&#xA;  } &#xA;</code></pre>&#xA;&#xA;<p>the results are returned as expected:</p>&#xA;&#xA;<pre><code> {&#xA;      ""StateName"": ""Delaware"",&#xA;      ""CountyName"": ""Kent"",&#xA;      ""Date"": ""02-01-2017""&#xA;    },&#xA;    {&#xA;      ""StateName"": ""Delaware"",&#xA;      ""CountyName"": ""Sussex"",&#xA;      ""Date"": ""02-01-2016""&#xA;    },&#xA;    {&#xA;      ""StateName"": ""Delaware"",&#xA;      ""CountyName"": ""New Castle"",&#xA;      ""Date"": ""02-01-2018""&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>etc.</p>&#xA;&#xA;<p>I would like to return the data in the following format:</p>&#xA;&#xA;<pre><code> {&#xA;   ""StateName"": ""Delaware"" {&#xA;&#xA;     { ""CountyName"": ""Kent"",&#xA;      ""Date"": ""02-01-2017""&#xA;      },&#xA;     {&#xA;      ""CountyName"": ""Sussex"",&#xA;      ""Date"": ""02-01-2016""&#xA;     },&#xA;     {&#xA;      ""CountyName"": ""New Castle"",&#xA;      ""Date"": ""02-01-2018""&#xA;     }&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have tried adding  GroupCounty: [StateCountyGroup] to the schema:</p>&#xA;&#xA;<pre><code>type StateCounty {&#xA;    id: ID!&#xA;    StateName: String&#xA;    CountyName: String&#xA;    FIPSST: Int&#xA;    FIPSCNTY: Int   &#xA;    Penetration: String&#xA;    Date: String&#xA;    GroupCounty: [StateCountyGroup]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and then a reference to that in the query </p>&#xA;&#xA;<pre><code>query  getStateCountybyState {&#xA;     getStateCountybyState (StateName: ""Delaware"")   {&#xA;      items { &#xA;       StateName&#xA;       CountyName&#xA;       Date  &#xA;       GroupCounty: [StateCountyGroup] &#xA;    }&#xA;   }&#xA;  } &#xA;</code></pre>&#xA;&#xA;<p>I think my issue is within the resolver  - currently, it is configured to use the StateName as a key, but I am not sure how to pass the StateName from the primary query to the subquery.</p>&#xA;&#xA;<p>Resolver:</p>&#xA;&#xA;<pre><code>{&#xA;    ""version"" : ""2017-02-28"",&#xA;    ""operation"" : ""Query"",&#xA;    ""query"" : {&#xA;        ""expression"" : ""StateName = :StateName"",&#xA;        ""expressionValues"" : {&#xA;            "":StateName"" : { ""S"" : ""${context.arguments.StateName}"" },&#xA;        }&#xA;    },&#xA;    ""index"" : ""StateName-index-copy"",&#xA;    ""select"" : ""ALL_ATTRIBUTES"",&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any guidance appreciated - I have gone through the documentation several times, but cannot find an example.</p>&#xA;&#xA;<p><strong><em>UPDATE</em></strong></p>&#xA;&#xA;<p>I tried the suggestion below from Richard - and it is definitely on the right track, however, despite multiple variations on the theme, I either return null or the following error (I eliminated some of the county objects returned in the error for brevity):</p>&#xA;&#xA;<pre><code>""message"": ""Unable to convert set($myresponse = {\n  \""Delaware\"": &#xA;[{SSA=8000, Eligibles=32295, FIPS=10001, StateName=Delaware, SSACNTY=0, &#xA;Date=02-01-2016, CountyName=Kent, Enrolled=3066, Penetration=0.0949, &#xA;FIPSCNTY=1, FIPSST=10, SSAST=8, id=6865}, &#xA;{SSA=8010, Eligibles=91332, FIPS=10003, StateName=Delaware, SSACNTY=10, Date=02-01-2016, CountyName=New Castle, Enrolled=10322, Penetration=0.113, FIPSCNTY=3, FIPSST=10, SSAST=8, id=6866}, &#xA;{SSA=0, Eligibles=10, FIPS=10, StateName=Delaware, SSACNTY=0, Date=02-01-2018, CountyName=Pending County Designation, Enrolled=0, Penetration=0, FIPSCNTY=0, FIPSST=10, SSAST=0, id=325}, &#xA;{SSA=8000, Eligibles=33371, FIPS=10001, StateName=Delaware, SSACNTY=0, Date=02-01-2017, CountyName=Kent, Enrolled=3603, Penetration=0.108, FIPSCNTY=1, FIPSST=10, SSAST=8, id=3598}, &#xA;{SSA=8020, Eligibles=58897, FIPS=10005, StateName=Delaware, SSACNTY=20, Date=02-01-2016, CountyName=Sussex, Enrolled=3760, Penetration=0.0638, FIPSCNTY=5, FIPSST=10, SSAST=8, id=6867})    \nnull\n\n to class java.lang.Object.""&#xA;        }&#xA;      ]&#xA;    }&#xA;</code></pre>&#xA;",3208041,,3208041,2018-04-14 12:50:11,2018-04-16 13:13:16,AWS AppSync Query to shape response data (Similar to Group By in SQL),<amazon-dynamodb><graphql><aws-appsync>,1,0,0,2018-04-08 21:21:13
49804639,1,,,0,59,"<p>I am trying to make a query to get a list of participants. In GraphiQL, this works. However, on the front end with React-Native/RelayClassic, the query only returns one participants</p>&#xA;&#xA;<p>In GraphiQL:</p>&#xA;&#xA;<pre><code>query getJobInfo ($sessionToken: String!, $jobId: String!) {&#xA;  viewer(sessionToken: $sessionToken){&#xA;    job(jobId: $jobId){&#xA;      jobId&#xA;      title&#xA;      participants(first: 1000) {&#xA;        edges {&#xA;          node {&#xA;           userId&#xA;           firstName&#xA;           lastName&#xA;           profilePic&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>where edges returns many participants</p>&#xA;&#xA;<p>In RelayClassic:</p>&#xA;&#xA;<pre><code>const RelayCompletionPeople = &#xA;  Relay.createContainer(UnconnectedCompletionPeople, {&#xA;    initialVariables: {&#xA;      jobId: ""abcd123"",&#xA;    },&#xA;    fragments: {&#xA;      viewer: () =&gt; Relay.QL`&#xA;        fragment on Viewer {&#xA;          job(jobId: $jobId) {&#xA;            jobId&#xA;            title&#xA;            participants (first: 1000) {&#xA;              edges {&#xA;                node {&#xA;                  userId&#xA;                  firstName&#xA;                  lastName&#xA;                  profilePic&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      `&#xA;    }&#xA;  });&#xA;</code></pre>&#xA;&#xA;<p>where edges returns only one participant</p>&#xA;&#xA;<p>What it is that is causing this to happen?</p>&#xA;&#xA;<p>Are there other places in my code that I need to look in order to return a list?</p>&#xA;&#xA;<p>Any help would be greatly appreciated! I've been stuck on this for quite awhile.</p>&#xA;&#xA;<p><strong>Update</strong>:</p>&#xA;&#xA;<p>I found the issue. There was a parent relay container that conflicted with the number of participants that could reach the completionPeople container.</p>&#xA;",9009196,,9009196,2018-04-14 02:29:55,2018-04-14 02:29:55,"Query works in GraphIQL, but not in Relay Classic",<react-native><graphql><relayjs><relay><graphiql>,0,3,0,2018-04-12 19:40:02
49809261,1,49834443,,12,8541,"<p>I’m new with graphene and I have this:</p>&#xA;&#xA;<pre><code>from django.contrib.auth.models import User&#xA;&#xA;class UserType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = User&#xA;</code></pre>&#xA;&#xA;<p>Basically, using Django’s User class is giving me this error, because before using the django User class, I was using my own User definition and it worked. Why using the User class from the django authentication framework is giving me the error mentioned in the title:</p>&#xA;&#xA;<blockquote>&#xA;  <p>File “/usr/local/lib/python3.6/site-packages/graphql/type/typemap.py”,&#xA;  line 60, in reducer if type.name in map: AttributeError: type object&#xA;  ‘User’ has no attribute ‘name’</p>&#xA;</blockquote>&#xA;&#xA;<p>Am I missing something?</p>&#xA;&#xA;<p>Regards</p>&#xA;&#xA;<p>PD: I’m using Django 2.0.4&#xA;<br><br>&#xA;<strong>Traceback</strong><br></p>&#xA;&#xA;<pre><code>Unhandled exception in thread started by &lt;function check_errors.&lt;locals&gt;.wrapper at 0x107c49e18&gt;&#xA;Traceback (most recent call last):&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/utils/autoreload.py"", line 225, in wrapper&#xA;    fn(*args, **kwargs)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/management/commands/runserver.py"", line 120, in inner_run&#xA;    self.check(display_num_errors=True)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/management/base.py"", line 364, in check&#xA;    include_deployment_checks=include_deployment_checks,&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/management/base.py"", line 351, in _run_checks&#xA;    return checks.run_checks(**kwargs)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/checks/registry.py"", line 73, in run_checks&#xA;    new_errors = check(app_configs=app_configs)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 13, in check_url_config&#xA;    return check_resolver(resolver)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 23, in check_resolver&#xA;    return check_method()&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 397, in check&#xA;    for pattern in self.url_patterns:&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/utils/functional.py"", line 36, in __get__&#xA;    res = instance.__dict__[self.name] = self.func(instance)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 536, in url_patterns&#xA;    patterns = getattr(self.urlconf_module, ""urlpatterns"", self.urlconf_module)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/utils/functional.py"", line 36, in __get__&#xA;    res = instance.__dict__[self.name] = self.func(instance)&#xA;  File ""/usr/local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 529, in urlconf_module&#xA;    return import_module(self.urlconf_name)&#xA;  File ""/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/importlib/__init__.py"", line 126, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 994, in _gcd_import&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 971, in _find_and_load&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 955, in _find_and_load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 665, in _load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap_external&gt;"", line 678, in exec_module&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 219, in _call_with_frames_removed&#xA;  File ""/Users/freddy/PycharmProjects/DYD/DYD/urls.py"", line 19, in &lt;module&gt;&#xA;    from dyd_server.graphql import schema&#xA;  File ""/Users/freddy/PycharmProjects/DYD/dyd_server/graphql/__init__.py"", line 10, in &lt;module&gt;&#xA;    schema = graphene.Schema(query=RootQuery, mutation=Mutations)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/schema.py"", line 57, in __init__&#xA;    self.build_typemap()&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/schema.py"", line 123, in build_typemap&#xA;    schema=self&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 69, in __init__&#xA;    super(TypeMap, self).__init__(types)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/typemap.py"", line 16, in __init__&#xA;    self.update(reduce(self.reducer, types, OrderedDict()))&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 77, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 107, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/typemap.py"", line 80, in reducer&#xA;    field_map = type.fields&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/pyutils/cached_property.py"", line 16, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/definition.py"", line 180, in fields&#xA;    return define_field_map(self, self._fields)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/definition.py"", line 189, in define_field_map&#xA;    field_map = field_map()&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 250, in construct_fields_for_type&#xA;    map = self.reducer(map, field.type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 77, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 107, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/typemap.py"", line 80, in reducer&#xA;    field_map = type.fields&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/pyutils/cached_property.py"", line 16, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/definition.py"", line 180, in fields&#xA;    return define_field_map(self, self._fields)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/definition.py"", line 189, in define_field_map&#xA;    field_map = field_map()&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 250, in construct_fields_for_type&#xA;    map = self.reducer(map, field.type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphene/types/typemap.py"", line 78, in reducer&#xA;    return GraphQLTypeMap.reducer(map, type)&#xA;  File ""/usr/local/lib/python3.6/site-packages/graphql/type/typemap.py"", line 60, in reducer&#xA;    if type.name in map:&#xA;AttributeError: type object 'User' has no attribute 'name'&#xA;</code></pre>&#xA;",3005919,,100297,2018-04-13 06:50:16,2020-07-01 19:29:01,AttributeError: type object 'User' has no attribute 'name',<django><python-3.x><django-models><graphql><graphene-python>,2,3,0,2018-04-13 04:21:25
49861305,1,49865220,,2,1124,"<p>I use Django, <a href=""https://github.com/graphql-python/graphene-django"" rel=""nofollow noreferrer"">graphene-django</a> and <a href=""https://github.com/carltongibson/django-filter"" rel=""nofollow noreferrer"">django-filter</a> to build GraphQL api and have a problem with <code>orderBy</code>:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/3ISm2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3ISm2.png"" alt=""GraphiQL""></a></p>&#xA;&#xA;<p>In general: I have faculties, each one has several departments. I can sort faculties but can't do the same with departments. </p>&#xA;&#xA;<p>Django models:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>class Faculty(models.Model):&#xA;    code = models.CharField(...)&#xA;&#xA;class Department(models.Model):&#xA;    code = models.CharField(...)&#xA;    faculty = models.ForeignKey(&#xA;        Faculty,&#xA;        on_delete=models.CASCADE,&#xA;        related_name=""departments"",&#xA;    )&#xA;</code></pre>&#xA;&#xA;<p>To be able to sort faculties I added:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>import graphene&#xA;import django_filters&#xA;from graphene import relay, ObjectType&#xA;from django_filters import OrderingFilter&#xA;from graphene_django.types import DjangoObjectType&#xA;from graphene_django.filter import DjangoFilterConnectionField&#xA;&#xA;class FacultyFilter(django_filters.FilterSet):&#xA;    class Meta:&#xA;        model = Faculty&#xA;        fields = ['university']&#xA;    order_by = OrderingFilter(fields=('code',))&#xA;&#xA;class DepartmentFilter(django_filters.FilterSet):&#xA;    class Meta:&#xA;        model = Department&#xA;        fields = ['university', 'faculty']&#xA;    order_by = OrderingFilter(fields=('code',))&#xA;&#xA;class Query(object):&#xA;    faculty = relay.Node.Field(FacultyNode)&#xA;    all_faculties = DjangoFilterConnectionField(&#xA;        FacultyNode,&#xA;        filterset_class=FacultyFilter,&#xA;    )&#xA;&#xA;    department = relay.Node.Field(DepartmentNode)&#xA;    all_departments = DjangoFilterConnectionField(&#xA;        DepartmentNode,&#xA;        filterset_class=DepartmentFilter,&#xA;    )&#xA;</code></pre>&#xA;&#xA;<p>Why can't I sort a set of departments?</p>&#xA;",388427,,178800,2018-05-05 02:37:52,2018-05-05 02:37:52,"GraphQL: how to sort node's ""foreign key"" set items?",<python><django><graphql><graphene-python>,1,0,0,2018-04-16 15:44:43
49866240,2,,49543248,1,,"<p>Well I found the answer for those having the same issues. </p>&#xA;&#xA;<p>api-platform uses uuids and you have to search with this in graphql</p>&#xA;&#xA;<pre><code>query {&#xA;    user(id: ""users/1""){&#xA;        firstName&#xA;        lastName&#xA;    }   &#xA;}&#xA;</code></pre>&#xA;",6669846,,6130313,2018-04-17 14:22:25,2018-04-17 14:22:25,"",,0,6,0,2018-04-16 21:07:09
49873457,2,,49718713,2,,"<p>I cannot add comment i am under 50rep. I am struggling with subscriptions right now. I can tell you that loop is not the right way&#xA;""DataID (type): A globally unique or client-generated identifier for a record, stored as a string."" , this is form Relay Modern docs.&#xA;Relay is checking automatically an also throws error in console if finds a duplicate id. In my subscriptions i use 3 mutation types: CREATED, UPDATED, DELETED. So for each mutation type i use a switch:</p>&#xA;&#xA;<pre><code>updater: (store) =&gt; {&#xA;      const getRootField = store.getRootField('UserSubscription');&#xA;      const mutation = getRootField.getValue('mutation');&#xA;      const node = getRootField.getLinkedRecord('node');&#xA;      switch (mutation) {&#xA;        case 'CREATED': {&#xA;          const clientProxy = store.get('client:root:viewer:allUsers');&#xA;          const newEdge = ConnectionHandler.createEdge(&#xA;            store,&#xA;            clientProxy,&#xA;            node,&#xA;            'UserEdge',&#xA;          );&#xA;          ConnectionHandler.insertEdgeBefore(clientProxy, newEdge);&#xA;        }&#xA;          break;&#xA;        case 'UPDATED':&#xA;          console.log('Updated');&#xA;          break;&#xA;        case 'DELETED': {&#xA;          const nodeId = node.getDataID();&#xA;          console.log(nodeId);&#xA;          store.delete(nodeId);&#xA;        }&#xA;          break;&#xA;        default:&#xA;          console.log('Something is wrong');&#xA;      }&#xA;</code></pre>&#xA;",8484035,,,,2018-04-17 08:38:31,"",,0,0,0,2018-04-17 08:38:31
49885047,2,,45227332,14,,"<p>It seems comma separating the interfaces doesn't work anymore. I had to use ""&amp;"" instead to make it work (Apollo), see this answer <a href=""https://stackoverflow.com/a/49521662/1959584"">https://stackoverflow.com/a/49521662/1959584</a></p>&#xA;&#xA;<pre><code>type Something implements First &amp; Second&#xA;</code></pre>&#xA;",1959584,,,,2018-04-17 18:26:12,"",,0,1,0,2018-04-17 18:26:12
49930338,2,,46701746,17,,"<p>Per the graphql docs, I see that fragments are a part of the query api and not valid syntax for setting up a schema. This leads me to conclude that it is not currently possible to specify a fragment in a schema.</p>&#xA;&#xA;<p><a href=""https://graphql.org/learn/queries/#fragments"" rel=""noreferrer"">https://graphql.org/learn/queries/#fragments</a></p>&#xA;",6121634,,6121634,2018-04-20 14:14:20,2018-04-20 14:14:20,"",,0,3,0,2018-04-19 21:13:04
49955809,1,49957059,,0,141,"<p>I have started a project that in using node.js and express and it's connected to a mongodb, this database has three collections (Participants, Houses, and activities), one participant can have one house and any activities! I have already done the query in graphql for each one, but I don't know how I can do the query and retrieve the relations between them. For example how I can know with participants are on a determined house... </p>&#xA;",8331803,,5737950,2018-04-21 14:47:18,2018-04-21 22:26:39,Node.js Mongodb graphql,<node.js><mongodb><graphql>,2,0,0,2018-04-21 12:33:19
49957059,2,,49955809,0,,"<p>Please go through the GraphQL documentation </p>&#xA;&#xA;<p>GraphQL documentation out there tends to focus on queries, less on mutations, less on defining a schema, even less on setting up a server, and even less less on binding the server to an actual database.</p>&#xA;&#xA;<pre><code>type participant{&#xA;  _id: String&#xA;  title: String&#xA;  participantId:String&#xA;  ........&#xA;  house : house&#xA;}&#xA;&#xA;type house{&#xA;      _id: String&#xA;      title: String&#xA;      houseId:String&#xA;      ........&#xA;      activities : [activity]&#xA;    }&#xA;&#xA;type activity{&#xA;  _id: String&#xA;  name: String&#xA;  content: String&#xA;  post: Post&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is sample model, you can design schema as per your requirement </p>&#xA;&#xA;<p>Now you can try query like this </p>&#xA;&#xA;<pre><code>query {&#xA;  participants{&#xA;    _id&#xA;    title&#xA;    }&#xA;   house {&#xA;     _id&#xA;     houseId&#xA;    comments {&#xA;      _id&#xA;      postId&#xA;      content&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is sample query format </p>&#xA;",7986915,,7986915,2018-04-21 15:14:20,2018-04-21 15:14:20,"",,0,1,0,2018-04-21 15:00:04
49984309,2,,49429375,0,,"<p>The problem in the example code seems to be that nested objects do not seem to trigger the refetch. So, what I did to still trigger a refetch, is change the organisation of the state:</p>&#xA;&#xA;<pre><code>// Instead of&#xA;this.state = {&#xA;  filters: {&#xA;    brands: [1, 3],&#xA;    filetypes: [4, 5, 6],&#xA;  }&#xA;}&#xA;&#xA;// I'm now doing&#xA;this.state =  {&#xA;  filteredBrands: [1, 3],&#xA;  filteredFiletypes: [4, 5, 6]&#xA;}&#xA;</code></pre>&#xA;",5170812,,,,2018-04-23 15:06:33,"",,0,0,0,2018-04-23 15:06:33
49991030,2,,49957205,0,,"<p>As <a href=""https://stackoverflow.com/a/49957650/294657"">Andrew said</a>, and as the <a href=""http://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">official docs exemplify</a>, fragments are not defined in the schema but (ad hoc) in the query:</p>&#xA;&#xA;<pre><code>{&#xA;   user (id: ""123"") {&#xA;     ... UserFields &#xA;   }&#xA;}&#xA;&#xA;fragment UserFields on School {&#xA;   age&#xA;   jobTitle&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Unconditional fragments (like the one here) are used to avoid repetition. Imagine having multiple places where you want to select <code>age</code> and <code>jobTitle</code> in the same operation.</p>&#xA;&#xA;<p>Conditional fragments, on the other hand, are used to make a conditional selection depending on the concrete interface implementation or union subtype.</p>&#xA;",294657,,,,2018-04-23 22:54:05,"",,0,0,0,2018-04-23 22:54:05
50005910,2,,39504986,12,,"<p>Actually Graphql is quite self documented with Facebook's built-in <code>Graphiql</code> or the 3rd party tool like <code>Altair</code> because the queries/mutations are listed and return types are also shown there.</p>&#xA;&#xA;<p>One place I found need doc is the input query parameter which might require <code>specific format</code>. This can be achieved by adding a comment <strong>on top of</strong> those <code>arguments</code>. </p>&#xA;&#xA;<pre><code>  type Query {&#xA;      eventSearch(&#xA;        # comma separated location IDs. (eg: '5,12,27')&#xA;        locationIds: String,&#xA;        # Date Time should be ISO 8601: 'YYYY-DD-MM HH:mm:ss'. (eg: '2018-04-23 00:00:00')&#xA;        startDateTime: String!,&#xA;        endDateTime: String!): [Event]&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>It will be like below:</p>&#xA;&#xA;<h3>Graphiql:</h3>&#xA;&#xA;<p><img src=""https://i.stack.imgur.com/ve441.png"" alt=""Graphiql""></p>&#xA;&#xA;<h3>Altair:</h3>&#xA;&#xA;<p><img src=""https://i.stack.imgur.com/YJeLO.png"" alt=""Altair""></p>&#xA;",1486742,,,,2018-04-24 15:46:52,"",,0,0,0,2018-04-24 15:46:52
50026045,1,,,0,630,"<p>I created the following code to return the title, forename, and surname from a graphql response. I'm using these returned values to make an automated test that asserts their value:</p>&#xA;&#xA;<pre><code>const { createApolloFetch } = require('apollo-fetch');&#xA;&#xA;const uri = 'http://localhost:3000';&#xA;&#xA;const query = `{&#xA;    Post(id: 1) {&#xA;            id&#xA;            title&#xA;            forename&#xA;            surname&#xA;    }&#xA;}&#xA;`;&#xA;&#xA;const apolloFetch = createApolloFetch({ uri });&#xA;&#xA;const returnApolloBody = () =&gt; {&#xA;    return apolloFetch({query}).&#xA;    then(res =&gt; res.data)&#xA;        .catch(err =&gt; {&#xA;            throw new Error(err);&#xA;        });&#xA;};&#xA;&#xA;const responseForename = returnApolloBody().then(result =&gt; result.Post.forename);&#xA;const responseTitle = returnApolloBody().then(result =&gt; result.Post.title);&#xA;const responeSurname = returnApolloBody().then(result =&gt; result.Post.surname);&#xA;&#xA;module.exports = {&#xA;    responseForename: responseForename,&#xA;    responseTitle: responseTitle,&#xA;    responeSurname: responeSurname,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>However I realised this isn't the most efficient way, as I'm amking a separate http request for each value. I thought it would be much easier to store the entire response as a JSON value, and then extract the values from this variable, however I'm not having much luck. I have the following code, and the values are returned as undefined:</p>&#xA;&#xA;<pre><code>const { createApolloFetch } = require('apollo-fetch');&#xA;&#xA;const uri = 'http://localhost:3000';&#xA;&#xA;const query = `{&#xA;    Post(id: 1) {&#xA;            id&#xA;            title&#xA;            forename&#xA;            surname&#xA;    }&#xA;}&#xA;`;&#xA;&#xA;const apolloFetch = createApolloFetch({ uri });&#xA;&#xA;const returnApolloBody = () =&gt; {&#xA;    return apolloFetch({query}).&#xA;    then(res =&gt; res)&#xA;        .catch(err =&gt; {&#xA;            throw new Error(err);&#xA;        });&#xA;};&#xA;&#xA;const response = returnApolloBody().then(response =&gt; response);&#xA;&#xA;const forename = response.then(response =&gt; response.Post.forename);&#xA;const surname = response.then(response =&gt; response.Post.surname);&#xA;const title = response.then(response =&gt; response.Post.title);&#xA;&#xA;&#xA;module.exports = {&#xA;    forename: forename,&#xA;    title: title,&#xA;    surname: surname&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>What am I missing to allow me to store the entire response in a const, and then query specific properties in that const?</p>&#xA;&#xA;<p>Thanks in advance</p>&#xA;",7599466,,,,2018-04-25 17:57:41,"How to store ""apollo-fetch"" graphql response in a variable?",<node.js><graphql><apollo><apollo-client>,1,0,0,2018-04-25 15:26:34
50033816,1,,,1,564,"<p>Our app uses Algolia for searching which allows for two typical forms of pagination: by page <code>page=3&amp;hitsPerPage=5</code> or by offset <code>offset=10&amp;length=5</code></p>&#xA;&#xA;<p>GraphQL preferences cursor-based pagination where a recordID and length are provided <code>friendsConnection(first:5 after:""Y3Vyc29yMQ=="")</code></p>&#xA;&#xA;<p>Is there anyway to translate info from a cursor-based pagination request into a page or offset pagination request?</p>&#xA;",3926551,,,,2018-04-26 07:41:25,GraphQL cursor-based pagination converted into page or offset pagination,<search><pagination><graphql><algolia><graphql-ruby>,1,0,0,2018-04-26 02:13:14
50037428,2,,50033816,1,,"<p>Depending what you use Algolia for (having all records available), you're able to use the <code>index.browseFrom</code> method. This will use a cursor. The documentation for that is <a href=""https://www.algolia.com/doc/api-reference/api-methods/browse/?language=javascript"" rel=""nofollow noreferrer"">here</a></p>&#xA;",3185307,,,,2018-04-26 07:41:25,"",,0,2,0,2018-04-26 07:41:25
50150799,2,,50148891,0,,"<p>I figured this out here is the sample of code I have written </p>&#xA;&#xA;<p><code>const convertToClassicQuery = query =&gt; query.classic(RelayQL_GENERATED).node;</code></p>&#xA;&#xA;<p>Here is small library to transform the createContainer to accept relay  modern queries </p>&#xA;&#xA;<pre><code>import Relay from 'react-relay/classic';&#xA;&#xA;const RelayQL_GENERATED = require('react-relay/classic').QL; // eslint-disable-line&#xA;&#xA;const convertToClassicQuery = query =&gt; query.classic(RelayQL_GENERATED).node;&#xA;&#xA;const convertFragments = fragments =&gt; _.mapValues(fragments, fragment =&gt; () =&gt; convertToClassicQuery(fragment()));&#xA;&#xA;const convertFragmentProps = (fragmentProps) =&gt; {&#xA;  fragmentProps.fragments = convertFragments(fragmentProps.fragments); // eslint-disable-line&#xA;  return fragmentProps;&#xA;};&#xA;const createContainer = (Component, fragmentProps) =&gt; Relay.createContainer(Component, convertFragmentProps(fragmentProps));&#xA;&#xA;&#xA;module.exports = {&#xA;  createContainer,&#xA;};&#xA;</code></pre>&#xA;",580906,,,,2018-05-03 08:51:19,"",,0,0,0,2018-05-03 08:51:19
50182011,2,,49803653,2,,"<p>Not sure what fields you're getting, but I guess you don't get id from the mutation.&#xA;You always have to ask for node's id, so relay can match updated nodes in the store. And node's id have to be named id (not nodeId)</p>&#xA;&#xA;<pre><code>mutation EditPlanDialogMutation($input: UpdatePlanInput!) {&#xA;    updatePlan(input: $input) {&#xA;        plan {&#xA;            id&#xA;            ...fields&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",3739087,,3739087,2018-05-11 13:14:54,2018-05-11 13:14:54,"",,0,4,0,2018-05-04 19:35:27
50202964,1,,,2,194,"<p>I have a GraphQL+- query in which I want to get mutual friends of two people. But I really couldn't find any option to use some sort of intersection of two graphs... can someone help me? Here is my code:</p>&#xA;&#xA;<pre><code>{&#xA;  catarinas_friends(func: eq(name, ""Catarina""))&#xA;  {&#xA;    friend &#xA;    {&#xA;      name&#xA;    }&#xA;  }&#xA;&#xA;  michaels_friends(func: eq(name, ""Michael"")) {&#xA;    friend&#xA;    {&#xA;      name&#xA;    }&#xA;  }&#xA;# I want to intersect those two&#xA;}&#xA;</code></pre>&#xA;",7026647,,,,2019-10-10 19:03:54,Dgraph graph intersect,<nosql><bigdata><graphql><dgraph>,1,0,0,2018-05-06 18:06:02
50229341,1,,,0,314,"<p>I have two queries fetching the category types of a company.&#xA;The employee query includes a subset of types of the company query types in the database.&#xA;If I just query the employee query, the employee types array includes 2 elements.&#xA;If I just query the company query, the company types array includes 4 elements.&#xA;Well..&#xA;But if i query both, the types array of employee gets updated and suddenly includes 4 elements instead of 2.</p>&#xA;&#xA;<pre><code>query GetEmployee ($id: ID!) {&#xA;employee (id: $id) {&#xA;  id,&#xA;  companyTaskCategories{&#xA;      id,&#xA;      title,&#xA;      color,&#xA;      archived,&#xA;      types(restrictEmployee: true)  {&#xA;        id,&#xA;        title,&#xA;        archived,&#xA;      }&#xA;  }&#xA;}&#xA;&#xA;&#xA;query company {&#xA;company {&#xA;  id,&#xA;  taskCategories {&#xA;    id,&#xA;    title,&#xA;    color,&#xA;    archived,&#xA;    types(restrictEmployee: false) {&#xA;      id,&#xA;      title,&#xA;      archived,&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>}</p>&#xA;",9757233,,,,2018-05-08 08:43:30,Apollo GraphQL query overwrites subelement array with other query,<graphql><react-apollo><apollo-client>,1,0,0,2018-05-08 08:34:51
50242518,1,50243840,,2,6761,"<p>Using <code>apollo-client</code> and <code>graphql-tag</code> I'm trying to create a request something like:</p>&#xA;&#xA;<pre><code>gql`&#xA;    {&#xA;        data(&#xA;            filter: ${options.filter}&#xA;            sort: ${options.sort}&#xA;            limit: ${options.limit}&#xA;            offset: ${options.offset}&#xA;        ) {&#xA;            name&#xA;        }&#xA;    }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>However not all of these options are always set, sometimes I might only use limit and offset. But if I leave them unset I get <code>Expected type Int, found undefined.</code></p>&#xA;&#xA;<p>Should I loop through my options object beforehand and swap any <code>undefined</code> values with <code>null</code>? Or is there a better way to structure this?</p>&#xA;",1661462,,6024220,2018-05-09 02:51:31,2018-05-09 02:51:31,GrahpQL: Create requests with multiple optional arguments,<graphql><apollo><graphql-js><apollo-client>,1,0,0,2018-05-08 21:28:20
50243840,2,,50242518,4,,"<p>You should avoid using placeholders for values inside your query and use variables instead. So your query would now look like something like this:</p>&#xA;&#xA;<pre><code>const MY_QUERY = gql`&#xA;  query MyQuery($filter: String, $sort: String, $limit: Int, $offset: Int) {&#xA;    data (&#xA;      filter: $filter&#xA;      sort: $sort&#xA;      limit: $limit&#xA;      offset: $offset&#xA;    ) {&#xA;      name&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Note: the types you define for your variables will need to match whatever your schema is for the filter, sort, limit and offset arguments.</p>&#xA;&#xA;<p>Now you can pass in the variables when rendering your <code>Query</code> component:</p>&#xA;&#xA;<pre><code>&lt;Query query={MY_QUERY} variables={{ limit: 10, offset: 20 }}&gt;&#xA;  {({ loading, error, data }) =&gt; {&#xA;    // ...&#xA;  }}&#xA;&lt;/Query&gt;&#xA;</code></pre>&#xA;&#xA;<p>Or, using the HOC:</p>&#xA;&#xA;<pre><code>graphql(MY_QUERY, { options: (props) =&gt; ({ variables: { limit: 10, offset: 20 } }) }&#xA;</code></pre>&#xA;&#xA;<p>Or using the client directly:</p>&#xA;&#xA;<p>client.query({ query: MY_QUERY, variables: { limit: 10, offset: 20 } })</p>&#xA;&#xA;<p>If any of the variables are undefined, they'll be ignored without you having to do anything more.</p>&#xA;",6024220,,6024220,2018-05-09 00:38:53,2018-05-09 00:38:53,"",,0,3,0,2018-05-09 00:18:23
50246095,1,,,0,207,"<p>I am just fairly new in React and especially in GraphQL so right now, it's my first time using React-Apollo and I am using Apollo Boost. </p>&#xA;&#xA;<p>I am having an error (or lack thereof) when I used React-apollo's Mutation inside my render function. Here are snippets of my code (forgive the bad practices I made in this code, I will fix them once I fix the mutations):</p>&#xA;&#xA;<h2>index.js</h2>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import ReactDOM from 'react-dom';&#xA;import App from './App';&#xA;import { ApolloProvider } from ""react-apollo"";&#xA;import { ApolloClient, HttpLink, InMemoryCache } from ""apollo-boost"";&#xA;import registerServiceWorker from './registerServiceWorker';&#xA;&#xA;const client = new ApolloClient({&#xA;  link: new HttpLink({ &#xA;  uri: 'http://localhost:3000/graphql',&#xA;}),&#xA;  onError: ({ graphQLErrors, networkError }) =&gt; {&#xA;    if (graphQLErrors) {&#xA;      console.log(graphQLErrors);&#xA;    }&#xA;  },&#xA;  cache: new InMemoryCache()&#xA;});&#xA;&#xA;const AppWithProvider = () =&gt; (&#xA;  &lt;ApolloProvider client={client}&gt;&#xA;    &lt;App /&gt;&#xA;  &lt;/ApolloProvider&gt;&#xA;);&#xA;&#xA;ReactDOM.render(&lt;AppWithProvider /&gt;, document.getElementById('root'));&#xA;registerServiceWorker();&#xA;</code></pre>&#xA;&#xA;<h2>BOOK_CART</h2>&#xA;&#xA;<pre><code> const BOOK_CART = gql `mutation booking($rDateStart: Date!, $rDateEnd: Date!, $grade: Int!, $section: String!, $userId: ID!, $cartlabId: ID!){&#xA;       bookCart(rDateStart: $rDateStart, rDateEnd: $rDateEnd, grade: $grade, section: $section, userId: $userId, cartlabId: $cartlabId){&#xA;        id&#xA;        rDateStart&#xA;        rDateEnd&#xA;        }&#xA;      }&#xA;    `;&#xA;</code></pre>&#xA;&#xA;<h2>ReserveCartsForm Class</h2>&#xA;&#xA;<pre><code>class ReserveCartsForm extends React.Component {&#xA;constructor(props) {&#xA;    super(props);&#xA;      this.state = {&#xA;      userId: 1,&#xA;      classroom: '',&#xA;      subject: '',&#xA;      cart: '',&#xA;      timezone: '',&#xA;      reservationTime: '',&#xA;      endTime: '',&#xA;      open: false,&#xA;      date: '',&#xA;      fromDt: '',&#xA;      toDt: '',&#xA;      created: new Date().toISOString(),&#xA;      status: 'reserved'&#xA;    };&#xA;    this.handleChange = this.handleChange.bind(this);&#xA;    this.handleOnChange = this.handleOnChange.bind(this);&#xA;  }&#xA;  handleOnChange = (key, e) =&gt; {&#xA;    this.setState({ [key]: e.target.value });&#xA;  };&#xA;</code></pre>&#xA;&#xA;<h2>Render</h2>&#xA;&#xA;<pre><code>render() {&#xA;const { classes } = this.props;&#xA;const { userId, fromDt, toDt, classroom, cart, timezone, reservationTime, laboratory } = this.state;&#xA;&#xA;const fromDateTime = this.state.fromDt = Moment(this.state.date + "" "" + this.state.reservationTime).toISOString();&#xA;&#xA;const toDateTime = () =&gt; {&#xA;  this.state.endTime = Moment.utc(+Moment.utc(this.state.reservationTime, 'hh:mm A').add(40, 'm')).format('HH:mm');&#xA;  return this.state.toDt = Moment(this.state.date + "" "" + this.state.endTime).toISOString();&#xA;}&#xA;return &lt;div className={classes.root}&gt;&#xA;    &lt;br /&gt;&#xA;    &lt;br /&gt;&#xA;    &lt;Typography variant=""title"" className={classes.heading} component=""h3"" color=""primary""&gt;&#xA;      Make New Reservation&#xA;    &lt;/Typography&gt;&#xA;    &lt;br /&gt;&#xA;    &lt;Grid container spacing={24}&gt;&#xA;      &lt;Grid item xs={8} sm={7} md={6} lg={4} xl={3} className={classes.grid}&gt;&#xA;        &lt;Card className={classes.card}&gt;&#xA;          &lt;CardContent&gt;&#xA;            &lt;div className={classes.header}&gt;&#xA;              &lt;Typography variant=""headline"" component=""h1"" color=""inherit"" className={classes.title}&gt;&#xA;                Carts Reservation Form&#xA;              &lt;/Typography&gt;&#xA;            &lt;/div&gt;&#xA;            &lt;div className={classes.container}&gt;&#xA;              &lt;Mutation mutation={BOOK_CART}&gt;&#xA;                {bookCart =&gt; &lt;div&gt;&#xA;                &lt;FormGroup row={true} className={classes.formGroup}&gt;&#xA;                  &lt;form onSubmit={e =&gt; {&#xA;                    e.preventDefault(); console.log(this.state); bookCart({ variables: { rDateStart: fromDt, rDateEnd: toDt, grade: classroom.substring(1), section: classroom.substring(1, 1), userId: userId, cartlabId: cart } }); }}&gt;&#xA;                    &lt;FormControl className={classes.formControl}&gt;&#xA;                      &lt;InputLabel htmlFor=""carts""&gt;&#xA;                        Choose Cart&#xA;                      &lt;/InputLabel&gt;&#xA;                      &lt;Select value={cart} labelstyle={classes.select} onChange={this.handleChange} inputProps={{ name: ""cart"", id: ""carts"" }}&gt;&#xA;                        &lt;MenuItem value=""""&gt;&#xA;                          &lt;em&gt;None&lt;/em&gt;&#xA;                        &lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={1}&gt;iPad Carts&lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={2}&gt;MacBook Carts&lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={3}&gt;MacBook Air Carts&lt;/MenuItem&gt;&#xA;                      &lt;/Select&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;form className={classes.formControl} noValidate&gt;&#xA;                      &lt;TextField id=""date"" label=""Date"" type=""date"" className={classes.textField} InputLabelProps={{ shrink: true }} onChange={e =&gt; this.handleOnChange(""date"", e)} /&gt;&#xA;                    &lt;/form&gt;&#xA;                    &lt;FormControl className={classes.formControl}&gt;&#xA;                      &lt;InputLabel htmlFor=""timezone""&gt;&#xA;                        Choose Timezone&#xA;                      &lt;/InputLabel&gt;&#xA;                      &lt;Select value={timezone} labelstyle={classes.select} onChange={this.handleChange} inputProps={{ name: ""timezone"", id: ""timezone"" }}&gt;&#xA;                        &lt;MenuItem value=""""&gt;&#xA;                          &lt;em&gt;None&lt;/em&gt;&#xA;                        &lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={""P""}&gt;&#xA;                          Pre School (40 mins.)&#xA;                        &lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={""G""}&gt;&#xA;                          Grade School (50 mins.)&#xA;                        &lt;/MenuItem&gt;&#xA;                        &lt;MenuItem value={""H""}&gt;&#xA;                          High School (60 mins.)&#xA;                        &lt;/MenuItem&gt;&#xA;                      &lt;/Select&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;FormControl className={classes.formControl}&gt;&#xA;                      &lt;hr /&gt;&#xA;                      &lt;FormControl className={classes.container}&gt;&#xA;                        &lt;InputLabel htmlFor=""endTime""&gt;&#xA;                          Time of Borrowing&#xA;                        &lt;/InputLabel&gt;&#xA;                        &lt;Select value={reservationTime} labelstyle={classes.select} onChange={this.handleChange} inputProps={{ name: ""reservationTime"", id: ""endTime"" }}&gt;&#xA;                          &lt;MenuItem value={`7:40`}&gt;Period 1&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`8:20`}&gt;Period 2&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`9:00`}&gt;Period 3&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`9:40`}&gt;Period 4&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`10:20`}&gt;Period 5&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`11:00`}&gt;Period 6&lt;/MenuItem&gt;&#xA;                          &lt;MenuItem value={`11:40`}&gt;Period 7&lt;/MenuItem&gt;&#xA;                        &lt;/Select&gt;&#xA;                        &lt;FormHelperText id=""name-helper-text""&gt;&#xA;                          The time the reservation ends.&#xA;                        &lt;/FormHelperText&gt;&#xA;                      &lt;/FormControl&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;FormControl className={classes.formControl}&gt;&#xA;                      &lt;InputLabel htmlFor=""age-simple""&gt;&#xA;                        Subject&#xA;                      &lt;/InputLabel&gt;&#xA;                      &lt;Input id=""age-simple"" placeholder=""Subject"" onChange={e =&gt; this.handleOnChange(""subject"", e)} /&gt;&#xA;                      &lt;FormHelperText id=""name-helper-text""&gt;&#xA;                        The subject the carts will be used in&#xA;                      &lt;/FormHelperText&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;FormControl className={classes.formControl}&gt;&#xA;                      &lt;TextField id=""classroom"" label=""Classroom"" className={classes.textField} value={laboratory} onChange={e =&gt; this.handleOnChange(""classroom"", e)} /&gt;&#xA;                      &lt;FormHelperText id=""name-helper-text""&gt;&#xA;                        Where the carts will be used&#xA;                      &lt;/FormHelperText&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;FormControl className={classes.container} disabled&gt;&#xA;                      &lt;Input id=""fromDt"" className={classes.textField} value={fromDateTime} onChange={e =&gt; this.handleOnChange(""fromDt"", e)} /&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;br /&gt;&#xA;                    &lt;FormControl className={classes.container} disabled&gt;&#xA;                      &lt;Input id=""toDt"" className={classes.textField} value={toDateTime()} onChange={e =&gt; this.handleOnChange(""toDt"", e)} /&gt;&#xA;                    &lt;/FormControl&gt;&#xA;                    &lt;Button variant=""raised"" color=""primary"" type=""submit""&gt;&#xA;                      Reserve&#xA;                    &lt;/Button&gt;&#xA;                    &lt;/form&gt;&#xA;                  &lt;/FormGroup&gt;&#xA;                &lt;/div&gt;}&#xA;              &lt;/Mutation&gt;&#xA;            &lt;/div&gt;&#xA;          &lt;/CardContent&gt;&#xA;          &lt;CardActions&gt;&#xA;            &lt;Dialog open={this.state.open} onClose={this.handleClose} aria-labelledby=""alert-dialog-title"" aria-describedby=""alert-dialog-description""&gt;&#xA;              &lt;DialogTitle id=""alert-dialog-title""&gt;&#xA;                {""Cart reserved""}&#xA;              &lt;/DialogTitle&gt;&#xA;              &lt;DialogContent&gt;&#xA;                &lt;DialogContentText id=""alert-dialog-description""&gt;&#xA;                  You have reserved a cart. Click to confirm.&#xA;                &lt;/DialogContentText&gt;&#xA;              &lt;/DialogContent&gt;&#xA;              &lt;DialogActions&gt;&#xA;                &lt;Button onClick={this.handleClickClose} color=""primary""&gt;&#xA;                  Back&#xA;                &lt;/Button&gt;&#xA;                &lt;Button onClick={(this.props.onSubmit, this.handleClickClose)} color=""primary"" autoFocus&gt;&#xA;                  Confirm&#xA;                &lt;/Button&gt;&#xA;              &lt;/DialogActions&gt;&#xA;            &lt;/Dialog&gt;&#xA;          &lt;/CardActions&gt;&#xA;          &lt;br /&gt;&#xA;        &lt;/Card&gt;&#xA;      &lt;/Grid&gt;&#xA;    &lt;/Grid&gt;&#xA;  &lt;/div&gt;;&#xA;        }&#xA;  }&#xA;&#xA;&#xA;    ReserveCartsForm.propTypes = {&#xA;      classes: PropTypes.object.isRequired&#xA;    };&#xA;&#xA;    export default withStyles(styles)(ReserveCartsForm);&#xA;</code></pre>&#xA;&#xA;<p>I tried looking for examples such as <a href=""https://www.apollographql.com/docs/react/essentials/mutations.html"" rel=""nofollow noreferrer"">React Apollo 2.1 Mutations documentation here</a> and <a href=""https://stackoverflow.com/questions/49794036/mutation-not-triggered-with-new-react-apollo-version"">this question, too from here.</a> So these were the few examples on where my code came from for the mutations.</p>&#xA;&#xA;<p>Any suggestions would be very helpful and appreciated.</p>&#xA;",9760036,,,,2018-05-09 05:27:59,apollo boost mutations no response,<javascript><reactjs><graphql><react-apollo>,0,2,0,2018-05-09 05:27:59
50257339,1,50258013,,0,729,"<p>I’m new to Relay (with reactjs) and have a problem with updating my UI after a commit mutation in the viewer. In my example I have a Salutation Component with the first name of the user and to simplify this, I put a input field right after the output of the name.</p>&#xA;&#xA;<p>When the user changes the name in the textfield, I send this to my updatemutation and to the API. My problem is that I don’t know how to update the name above the input, after the new name was saved. Could anyone help me - what do I need to do in the updater?</p>&#xA;&#xA;<p>Many thanks!</p>&#xA;&#xA;<p><strong>The ""root""-Component:</strong></p>&#xA;&#xA;<pre><code>import React, {Component} from 'react';&#xA;import {QueryRenderer, graphql} from 'react-relay';&#xA;import environment from 'app/settings/createRelayEnvironment';&#xA;import Salutation from 'app/components/dashboard/includes/Salutation';&#xA;&#xA;&#xA;const DashboardQuery = graphql`&#xA;    query DashboardQuery {&#xA;        viewer {&#xA;            ...Salutation_viewer&#xA;        }&#xA;    }&#xA;`;&#xA;&#xA;class Dashboard extends Component {&#xA;    render() {&#xA;        return (&#xA;            &lt;QueryRenderer&#xA;                environment={environment}&#xA;                query={DashboardQuery}&#xA;                render={({error, props}) =&gt; {&#xA;                    if (error) {&#xA;                        return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA;                    } else if (props) {&#xA;                        return (&#xA;                            &lt;div&gt;&#xA;                                &lt;Salutation viewer={props.viewer}&gt;&lt;/Salutation&gt;&#xA;                            &lt;/div&gt;&#xA;                        );&#xA;                    }&#xA;&#xA;                    return &lt;div&gt;Loading&lt;/div&gt;;&#xA;                }}&#xA;            /&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;export default Dashboard;&#xA;</code></pre>&#xA;&#xA;<p><strong>The Salutation-component:</strong></p>&#xA;&#xA;<pre><code>import React, {Component} from 'react';&#xA;import {createFragmentContainer, graphql} from 'react-relay';&#xA;import PropTypes from 'prop-types';&#xA;import UpdateDashboardMutation from 'app/mutations/UpdateDashboardMutation';&#xA;&#xA;&#xA;class Salutation extends Component {&#xA;    render() {&#xA;        return (&#xA;            &lt;div className=""salutation""&gt;&#xA;                &lt;h2&gt;Willkommen {this.props.viewer.firstName}&lt;/h2&gt;&#xA;                &lt;input type=""text"" onChange={this._onChange.bind(this)}/&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;&#xA;    _onChange(event) {&#xA;        UpdateDashboardMutation(event.currentTarget.value);&#xA;    }&#xA;}&#xA;&#xA;Salutation.propTypes = {&#xA;    viewer: PropTypes.object&#xA;};&#xA;&#xA;export default createFragmentContainer(Salutation, graphql`&#xA;    fragment Salutation_viewer on Viewer {&#xA;        firstName&#xA;    }&#xA;`);&#xA;</code></pre>&#xA;&#xA;<p><strong>And the Updatemutation:</strong></p>&#xA;&#xA;<pre><code>import {commitMutation, graphql} from 'react-relay';&#xA;import environment from 'app/settings/createRelayEnvironment';&#xA;&#xA;&#xA;const mutation = graphql`&#xA;    mutation UpdateDashboardMutation($input: UpdateDashboardMutationInput!) {&#xA;        updateDashboard(input: $input) {&#xA;            ok,&#xA;            errors {&#xA;                field,&#xA;                messages&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;&#xA;&#xA;function UpdateDashboardMutation(firstName) {&#xA;    commitMutation(&#xA;        environment,&#xA;        {&#xA;            mutation,&#xA;            variables: {&#xA;                input: {&#xA;                    firstName&#xA;                }&#xA;            },&#xA;            updater(store) {&#xA;                // what i have to do here?&#xA;            }&#xA;        }&#xA;    );&#xA;}&#xA;&#xA;export default UpdateDashboardMutation;&#xA;</code></pre>&#xA;",6612945,,,,2018-05-09 16:25:00,Update Subcomponent with viewer after mutation in relay,<reactjs><graphql><relay><mutation>,1,0,0,2018-05-09 15:45:54
50261090,1,,,0,351,"<p>We are working with graphQL and React Apollo 2.1 to do some queries. The query has three nested components. The query works fine in graphiql and we get results for all fields. Once we put it into the app and make the call we get all the fields except the nested fields come back as null.  Below DeviceList calls the query connector witch calls the query. Any ideas?</p>&#xA;&#xA;<pre><code>export const mapDeviceQuery = gql &#xA;  query mapDeviceQuery($input: String, $type: DeviceSearchEnum) {&#xA;    devices(input: $input, type: $type) {&#xA;      id&#xA;      client&#xA;      productKey&#xA;      alias&#xA;      imei&#xA;      subFleet&#xA;      warranty&#xA;      isActive&#xA;      locate{&#xA;        latitude&#xA;        longitude&#xA;        speed&#xA;        heading&#xA;        date&#xA;        time&#xA;      }&#xA;      address{&#xA;        full&#xA;        street_address&#xA;        city&#xA;        state&#xA;        zip&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>deviceList.hoc.js</p>&#xA;&#xA;<pre><code>render = ({loading, error, data} = this.props) =&gt; {      &#xA;  let deviceList = [];&#xA;  if(data.devices){&#xA;    console.log(data.devices);&#xA;    for(let i=0; i&lt;data.devices.length; i++){&#xA;      if(data.devices[i].isActive){&#xA;        let d = data.devices[i];&#xA;        deviceList.push({&#xA;          key : i,&#xA;          alias  : d.alias,&#xA;          driver : d.driver,&#xA;          subFleet : d.subFleet,&#xA;          imei : d.imei,&#xA;          address : d.address.full,&#xA;          date : d.locate.date,&#xA;          time : d.locate.time&#xA;        });&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>queryconnector.js  </p>&#xA;&#xA;<pre><code> import React, { Component } from 'react';&#xA;    import { Query } from ""react-apollo"";&#xA;    const queryConnector = (queryGQL) =&gt; WrappedComponent =&gt; {&#xA;      class QueryConnector extends Component {&#xA;        render = () =&gt; {&#xA;          return (&#xA;            &lt;Query query={queryGQL}&gt;&#xA;              {({ loading, error, data }) =&gt; {&#xA;                console.log(loading)&#xA;                console.log(data)&#xA;                return (&#xA;                  &lt;WrappedComponent&#xA;                    runQuery={queryGQL} loading={loading} error={error} data={data}&#xA;                    {...this.props}&#xA;                  /&gt;&#xA;                )&#xA;              }}&#xA;            &lt;/Query&gt;&#xA;          )&#xA;        }&#xA;      }&#xA;      return QueryConnector&#xA;    }&#xA;    export default queryConnector&#xA;</code></pre>&#xA;",7833839,,7833839,2018-05-09 21:22:30,2018-05-09 21:22:30,Apollo boost receiving null on nested queries,<reactjs><graphql><apollo>,0,3,0,2018-05-09 19:54:38
50281297,1,,,1,272,"<p>I am trying to integrate with a remote schema using graphql-tools for node.</p>&#xA;&#xA;<p>I have the remote schema but unfortunately all of the queries are defined on the <code>Viewer</code> type rather than the <code>Query</code> type.</p>&#xA;&#xA;<p>I would like to use <code>graphql-tools</code> to transform the schema and move some of the fields from the <code>Viewer</code> type to the <code>Query</code> type.</p>&#xA;&#xA;<p>I have tried a couple of different methods: including <code>delegateToSchema</code> in a custom resolver and <code>ExtractField</code> transformations, but they haven't worked. <code>delegateToSchema</code> seems like the correct way to do it but unfortunately it can only delegate to a root type not a type like <code>Viewer</code>.</p>&#xA;&#xA;<p>Does anyone know how I could add a field to the <code>Query</code> type that delegates to a field on the <code>Viewer</code> type?</p>&#xA;",9773110,,7132550,2018-05-11 05:40:41,2018-05-11 05:40:41,Is there a easy way to move a field on a remote graphql schema?,<javascript><graphql><graphql-js><graphql-tools>,0,0,0,2018-05-10 20:48:40
50307749,1,50309315,,0,243,"<p>I have a simple component that fetches book titles</p>&#xA;&#xA;<pre><code>export const books = gql`&#xA;  query Query {&#xA;    books {&#xA;      title&#xA;    }&#xA;  }&#xA;`&#xA;&#xA;export default graphql(books)(BookList)&#xA;</code></pre>&#xA;&#xA;<p>Api I am using itself doesn't have any sort of pagination mechanism specified, but I am wondering if apollo / graphql provides one out of the box, if it does what is the correct way to paginate data?</p>&#xA;",911930,,,,2018-05-12 18:12:50,Using apollo and graphql higher order component to paginate data,<reactjs><graphql><apollo><apollo-client>,1,0,0,2018-05-12 15:18:23
50309315,2,,50307749,1,,"<p>You can use <code>skip</code> and <code>last</code> in your query</p>&#xA;&#xA;<p><code>skip</code> - no of record wants to skip</p>&#xA;&#xA;<p><code>last</code> - id of last record from previous records</p>&#xA;&#xA;<pre><code>export const books = gql`&#xA;  query Query {&#xA;    books(skip:10, last: '\\any valid id') {&#xA;      title&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>hope this will help</p>&#xA;",6998747,,,,2018-05-12 18:12:50,"",,0,0,0,2018-05-12 18:12:50
50342116,1,50349323,,5,3134,"<p>Does Apollo client have some sort of thing like <code>mapStateToProps</code> (Redux)?</p>&#xA;&#xA;<p>let's say I have a component, after query I know there's data in the cache so I do something like:</p>&#xA;&#xA;<pre><code>    class Container extends React.Component {&#xA;      ...&#xA;      ...&#xA;      render() {&#xA;        const notes = this.props.client.readFragment(NOTES_FRAGMENT)&#xA;        // notes has everything I need&#xA;        return (&lt;Child notes={notes} /&gt;);&#xA;      }&#xA;&#xA;    }&#xA;    export default WithApollo(Container);&#xA;</code></pre>&#xA;&#xA;<p>However when I have a sibling component which calls mutation and do update, the <code>&lt;Child /&gt;</code> component's props never get updates.</p>&#xA;&#xA;<pre><code>class AnotherContainer extends React.Component {&#xA;   render() {&#xA;     return(&#xA;       &lt;Mutation&#xA;          mutation={UPDATE_NOTE}&#xA;          update={(cache, {data: {updateNote}}) =? {&#xA;            const list = cache.readFragment({&#xA;              fragment: NOTES_FRAGMENT&#xA;            })&#xA;            // manipulate list&#xA;            cache.writeFragment({fragment:NOTES_FRAGMENT, data })&#xA;          }&#xA;        }&#xA;     )&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>so my question is, how do I update the <code>&lt;Child /&gt;</code> component's props whenever I do writeFragment? is there anything like mapStateToProps thing to ""connect"" the <code>notes</code> props to the cache, so whenever it updates, will trigger the React lifecycle? </p>&#xA;",247869,,,,2018-05-15 11:42:14,How to get updated data from apollo cache,<reactjs><redux><graphql><apollo><react-apollo>,1,0,0,2018-05-15 03:58:54
50369539,2,,50369374,0,,"<p>An enums in GraphQL.js are effectively just a String that's just limited to some set of values. So you can just do:</p>&#xA;&#xA;<pre><code>return {&#xA;  searchResult: 'Foo',&#xA;  error: 'Error1',&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note: when using them in a request, their behavior will be slightly different:</p>&#xA;&#xA;<pre><code>someQuery(someString: ""Foo"")&#xA;&#xA;someOtherQuery(someEnum: Foo)&#xA;</code></pre>&#xA;",6024220,,,,2018-05-16 11:20:01,"",,0,0,0,2018-05-16 11:20:01
50391585,2,,50390563,1,,"<p>As per graphql specification, endpoint should always return status 200:</p>&#xA;&#xA;<p><a href=""http://facebook.github.io/graphql/October2016/#sec-Errors"" rel=""nofollow noreferrer"">http://facebook.github.io/graphql/October2016/#sec-Errors</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>The errors entry in the response is a non‐empty list of errors, where&#xA;  each error is a map.</p>&#xA;  &#xA;  <p>If no errors were encountered during the requested operation, the&#xA;  errors entry should not be present in the result.</p>&#xA;  &#xA;  <p>Every error must contain an entry with the key message with a string&#xA;  description of the error intended for the developer as a guide to&#xA;  understand and correct the error.</p>&#xA;  &#xA;  <p>If an error can be associated to a particular point in the requested&#xA;  GraphQL document, it should contain an entry with the key locations&#xA;  with a list of locations, where each location is a map with the keys&#xA;  line and column, both positive numbers starting from 1 which describe&#xA;  the beginning of an associated syntax element.</p>&#xA;  &#xA;  <p>GraphQL servers may provide additional entries to error as they choose&#xA;  to produce more helpful or machine‐readable errors, however future&#xA;  versions of the spec may describe additional entries to errors.</p>&#xA;  &#xA;  <p>If the data entry in the response is null or not present, the errors&#xA;  entry in the response must not be empty. It must contain at least one&#xA;  error. The errors it contains should indicate why no data was able to&#xA;  be returned.</p>&#xA;  &#xA;  <p>If the data entry in the response is not null, the errors entry in the&#xA;  response may contain any errors that occurred during execution. If&#xA;  errors occurred during execution, it should contain those errors.</p>&#xA;</blockquote>&#xA;",1333744,,,,2018-05-17 12:32:51,"",,0,0,0,2018-05-17 12:32:51
50434037,1,,,0,321,"<p>Hello i have done my server grapqhl api. Currently i'm stack on relay pagination in client. I searched many articles about that. And everywhere pagination done with viewer root query field. Which about it in docs said that field is unnecassary. </p>&#xA;&#xA;<p>In other resourses: </p>&#xA;&#xA;<pre><code>query routesOrdersQuery {&#xA;  viewer {&#xA;    ...Order_order&#xA;  }&#xA;}&#xA;fragment Order_order on OrderType {&#xA;  orders() @connection {&#xA;    edges {&#xA;      node {&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>In my case:</p>&#xA;&#xA;<pre><code>query routesOrdersQuery {&#xA;  ...Order_order&#xA;}&#xA;fragment Order_order on Query {&#xA; orders(first: $first) @connection(key: ""Order_order"") {&#xA;   edges{&#xA;    node{&#xA;     id&#xA;    }&#xA;   }&#xA; }&#xA;}&#xA;</code></pre>&#xA;",4753316,,,,2018-05-29 22:21:41,Relay modern pagination without viewer,<pagination><graphql><relayjs><relaymodern>,1,0,0,2018-05-20 10:48:20
50454016,2,,48618669,6,,"<p>You mean, how to export/import fragment accross files ? I would do it like this</p>&#xA;&#xA;<pre><code>fragment MyReusableFragment_MyConnection on MyConnection {&#xA;  edges {&#xA;    node {&#xA;      _id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And import it :</p>&#xA;&#xA;<pre><code>#import ""./MyReusableFragment.graphql""&#xA;&#xA;query myQuery on MyConnection {&#xA;  ...MyReusableFragment_MyConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and reuse it around other file</p>&#xA;&#xA;<pre><code>#import ""./MyReusableFragment.graphql""&#xA;&#xA;query myOtherQuery on MyConnection {&#xA;  ...MyReusableFragment_MyConnection&#xA;}&#xA;</code></pre>&#xA;",2871398,,,,2018-05-21 17:40:40,"",,0,0,0,2018-05-21 17:40:40
50454550,1,,,0,294,"<p>OS: Windows 10 Pro<br>&#xA;apollo-client: 1.9.2<br>&#xA;react-redux: 5.0.6</p>&#xA;&#xA;<p>So, I'm attempting to read 'connect' a graphql resultset to redux but am receiving the above mentioned error message. My code is as follows:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>import { connect } from 'react-redux';&#xD;&#xA;&#xD;&#xA;class PhotoGrid extends React.Component {&#xD;&#xA;  render () {&#xD;&#xA;    const { data } = this.props;&#xD;&#xA;    const isNewPage = this.props.location.pathname.includes('new');&#xD;&#xA;    &#xD;&#xA;    if (data.loading) {&#xD;&#xA;      return &lt;p&gt;Loading ...&lt;/p&gt;;&#xD;&#xA;    }&#xD;&#xA;    if (data.error) {&#xD;&#xA;      return &lt;p&gt;{data.error.message}&lt;/p&gt;;&#xD;&#xA;    }&#xD;&#xA;    return (&#xD;&#xA;      &lt;div&gt;&#xD;&#xA;        &lt;div&gt;Total record count: {data._allPostsesMeta.count}&lt;/div&gt;&#xD;&#xA;        &lt;div className=""photo-grid""&gt;&#xD;&#xA;          { data.allPostses.map( (post,i) =&gt; &lt;Photo {...this.props} key={i} postIndexID={i} post={post} /&gt;) }&#xD;&#xA;        &lt;/div&gt;&#xD;&#xA;        {isNewPage &amp;&amp; (&#xD;&#xA;          &lt;div&gt;&#xD;&#xA;            &lt;div onClick={() =&gt; this.previousPage()}&gt;&#xD;&#xA;              Previous&#xD;&#xA;            &lt;/div&gt;&#xD;&#xA;            &lt;div onClick={() =&gt; this.nextPage()}&gt;&#xD;&#xA;              Next&#xD;&#xA;            &lt;/div&gt;&#xD;&#xA;          &lt;/div&gt;&#xD;&#xA;        )}&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;};&#xD;&#xA;&#xD;&#xA;const allPostsCommentsQuery = graphql(All_Posts_Comments_Query, {&#xD;&#xA;  options: ownProps =&gt; {&#xD;&#xA;    const page = parseInt(ownProps.match.params.page, 10);&#xD;&#xA;    const isNewPage = ownProps.location.pathname.includes('new');&#xD;&#xA;    const skip = isNewPage ? (page - 1) * parseInt(PRODUCTS_PER_PAGE) : 0;&#xD;&#xA;    const first = isNewPage ? parseInt(PRODUCTS_PER_PAGE) : parseInt(PRODUCTS_PER_PAGE);&#xD;&#xA;    const orderBy = isNewPage ? OrderBy : null;&#xD;&#xA;    fetchPolicy: 'network-only';&#xD;&#xA;    &#xD;&#xA;    return {&#xD;&#xA;      variables: { &#xD;&#xA;        __offline__: true,&#xD;&#xA;        first,&#xD;&#xA;        skip,&#xD;&#xA;        orderBy, &#xD;&#xA;      },&#xD;&#xA;    }&#xD;&#xA;  },&#xD;&#xA;});&#xD;&#xA;&#xD;&#xA;export default connect(allPostsCommentsQuery)(PhotoGrid)</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>What am I overlooking here?</p>&#xA;",5613904,,5613904,2018-05-22 17:32:30,2018-05-22 17:32:30,Can't read property 'bind' of undefined,<redux><react-redux><apollo><react-apollo>,0,2,0,2018-05-21 18:19:35
50548194,2,,50547791,0,,"<p>For now, I find a more or less clean way to do this:</p>&#xA;&#xA;<pre><code>Book: {&#xA;  async author(book, args, context, info) {&#xA;    let authorPromise = null;&#xA;&#xA;    async function getAuthor() {&#xA;      if (authorPromise === null) {&#xA;        authorPromise = book.author().get();&#xA;      }&#xA;&#xA;      return authorPromise;&#xA;    }&#xA;&#xA;    return new Proxy({}, {&#xA;      async get({}, name) {&#xA;        if (name === ""id"") {&#xA;          return book.author_id;&#xA;        }&#xA;&#xA;        if (name in authorFields) {&#xA;          const author = await getFile();&#xA;          return author[name];&#xA;        }&#xA;      },&#xA;    });&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It ensure me to do only one query per row, but leave me with another question about the joining of the tables, but I'll post it <a href=""https://stackoverflow.com/q/50548188/"">here</a> :-)</p>&#xA;",4032282,,,,2018-05-27 00:57:00,"",,0,0,0,2018-05-27 00:57:00
50595185,2,,50547791,0,,"<p>You don't have to make 1 + N query. You can batch N queries into 1. Just check out <a href=""https://github.com/facebook/dataloader"" rel=""nofollow noreferrer"">https://github.com/facebook/dataloader</a>.</p>&#xA;",2585852,,,,2018-05-30 01:33:55,"",,0,1,0,2018-05-30 01:33:55
50611652,2,,49782270,10,,"<p>For this purpose <code>react-apollo</code> exports a <code>compose</code> function. Using this function you may cleanly use several component enhancers at once. Including multiple graphql(), or even Redux connect() enhancers.</p>&#xA;&#xA;<pre><code>import { Mutation, compose, graphql } from ""react-apollo"";&#xA;&#xA;class AddTweet extends Component {&#xA;....&#xA;....&#xA;....&#xA;}&#xA;export default compose(&#xA;  graphql(GET_AUTHORS, { name: ""getAuthors"" }),&#xA;  graphql(ADD_TWEET, { name: ""addTweet"" }),&#xA;  connect(...), // incase you are using Redux&#xA;)(AddTweet);&#xA;</code></pre>&#xA;&#xA;<p>An important note is that <code>compose()</code> executes the last enhancer first and works its way backwards through the list of enhancers.</p>&#xA;&#xA;<p>One more thing lets say you were using <code>this.props.data</code> now you will get get <code>undefined</code>. just <code>console.log(this.props)</code> and you will see what is happening to props now. You will be having two properties now <code>getAuthors</code> and <code>addTweet</code>. So now it will be <code>this.props.name-in-compose.name-of-type-in-typeDefs</code> i.e. <code>this.props.getAuthors.getUsers</code>. It took me a bit to figure it out.</p>&#xA;",486064,,1287598,2018-12-05 15:52:42,2018-12-05 15:52:42,"",,0,2,0,2018-05-30 18:54:31
50626958,1,,,1,1802,"<p>I am using Relay and django-graphene version 2. Country.js is rendering av list of countries.</p>&#xA;&#xA;<p>Using fragments I get this error:&#xA;Warning: RelayModernSelector: Expected object to contain data for fragment <code>Country_country</code>, got <code>{""node"":{""__fragments"":{""Country_country"":{}},""__id"":""Q291bnRyeVR5cGU6MQ==""}}</code>. Make sure that the parent operation/fragment included fragment <code>...Country_country</code> without <code>@relay(mask: false)</code>.</p>&#xA;&#xA;<p>The QueryRenderer returns the correct list of countries without Country_country, just putting in the variable name.</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;      environment={environment}&#xA;      query={graphql`query CartContainerQuery {&#xA;        viewer {&#xA;          id&#xA;          countries(first: 3) {&#xA;            edges {&#xA;              node {&#xA;                ...Country_country&#xA;              }&#xA;            }&#xA;            pageInfo {&#xA;              startCursor&#xA;              endCursor&#xA;            }&#xA;          }&#xA;&#xA;      }&#xA;      }`}&#xA;      variables={{}}&#xA;      render={({error, props}) =&gt; {&#xA;        if (error) {&#xA;          console.log(error)&#xA;          return &lt;div&gt;Error!&lt;/div&gt;;&#xA;        }&#xA;        if (!props) {&#xA;          return &lt;div&gt;Loading...&lt;/div&gt;;&#xA;        }&#xA;        return (&#xA;          &lt;div&gt;&#xA;          {console.log(props)}&#xA;          &lt;Country country={props.viewer.countries.edges} /&gt;&#xA;          &lt;/div&gt;&#xA;        );&#xA;      }}&#xA;    /&gt;&#xA;</code></pre>&#xA;&#xA;<p>My fragment on Contry Container:</p>&#xA;&#xA;<pre><code>export default createFragmentContainer(&#xA;   Country,&#xA;   graphql`&#xA;   fragment Country_country on CountryType @relay(plural: true) {&#xA;       id&#xA;       name&#xA;     }&#xA;   `&#xA; )&#xA;</code></pre>&#xA;&#xA;<p>Graphene Schema:</p>&#xA;&#xA;<pre><code>class CountryType(DjangoObjectType, model=Country):&#xA;  class Meta:&#xA;    interfaces= (relay.Node,)&#xA;    filter_fields = ['name', 'id']&#xA;&#xA;class Viewer(graphene.ObjectType):&#xA;  class Meta:&#xA;    interfaces = [relay.Node, ]&#xA;&#xA;  countries = DjangoFilterConnectionField(CountryType)&#xA;  country = graphene.List(CountryType)&#xA;&#xA;  def resolve_country(self, info, **kwargs):&#xA;    return Country.objects.all()&#xA;&#xA;  def resolve_countries(self, info, **kwargs):&#xA;    return Country.objects.all()&#xA;&#xA;class Query(graphene.ObjectType):&#xA;  viewer = graphene.Field(Viewer)&#xA;  node = relay.Node.Field()&#xA;&#xA;  def resolve_viewer(self, info):&#xA;    return Viewer()&#xA;</code></pre>&#xA;&#xA;<p>If I try this query in QueryRenderer it also works fine:</p>&#xA;&#xA;<pre><code>query={graphql`query CartContainerQuery {&#xA;            viewer {&#xA;              id&#xA;              country {&#xA;                  ...Country_country&#xA;                }&#xA;            }&#xA;          }`}&#xA;</code></pre>&#xA;&#xA;<p>Am I using DjangoFilterConnectionField falsely?</p>&#xA;",9033890,,9033890,2018-05-31 15:47:50,2018-06-14 19:43:24,Relay Modern fragment error (expect object to contain data....),<reactjs><graphql><relay><django-filter><graphene-python>,1,0,0,2018-05-31 14:41:58
50658604,2,,50587057,2,,<p>I used the Float scalar of Graphql to byPass the issue</p>&#xA;,2272636,,,,2018-06-02 15:50:29,"",,0,0,0,2018-06-02 15:50:29
50670656,2,,50660045,0,,"<p>this is not answering your question but your question should usually not come up if you follow best practices: GraphQL queries should be static - that means you don't generate them from a variable input. Maybe you have a valid use case for this but I can hardly imagine any. Please let me know in the comments.</p>&#xA;&#xA;<p>When your client has a variable input for a field argument you want to use variables instead:</p>&#xA;&#xA;<pre><code>query getArticles($filter: ArticlesFilter) { # Please insert your input type name&#xA;  articles(where: $filter) {&#xA;    # ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can then pass in this input in the variables field of the query:</p>&#xA;&#xA;<pre><code>let givenObject = {""where"":{""publishedAt_lt"":""2018-01-01""}}; // said object&#xA;fetch('/graphql', {&#xA;  method: 'POST',&#xA;  body: JSON.stringify({&#xA;    query, // put the query string from above&#xA;    variables: {&#xA;      filter: givenObject,&#xA;    },&#xA;  }),&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>This is now plain JS, please refer to your client side library. I am sure they have a docs section about that. For react-apollo you can find the docs how to pass variables <a href=""https://www.apollographql.com/docs/react/essentials/queries.html#props"" rel=""nofollow noreferrer"">here</a>.</p>&#xA;",3849167,,,,2018-06-03 20:24:53,"",,0,1,0,2018-06-03 20:24:53
50708181,1,50713155,,0,851,"<h2>So I have a reactjs app using <strong>GraphQl</strong> and I'm trying to cut down the repetition through the use of <strong>fragments</strong>, however, its failing.</h2>&#xA;<p><strong>Fragment</strong> (companyQueries.js)</p>&#xA;<pre><code>export const CompanyFragment = gql`&#xA;  fragment company on WithApiKeys {&#xA;    company {&#xA;      id&#xA;      apiKeys {&#xA;        id&#xA;        token&#xA;        insertedAt&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p><strong>Beginning of usage</strong> (withCreateApiKeyMutation.js)</p>&#xA;<pre><code>import { graphql } from 'react-apollo'&#xA;import gql from 'graphql-tag'&#xA;import CompanyFragment from '../../../utils/QueryFragments/companyQueries'&#xA;&#xA;console.log(CompanyFragment)&#xA;const QUERY = gql`&#xA;  query {&#xA;    viewer {&#xA;      id&#xA;      ...company&#xA;    }&#xA;  }&#xA;  ${CompanyFragment}&#xA;</code></pre>&#xA;<hr />&#xA;<h2>Given this kind of export I would expect it to at least be able to compile, but it errors.</h2>&#xA;<p><strong>Error given by compiler</strong></p>&#xA;<p>Error on line 3 of <strong>companyQueries.js</strong></p>&#xA;<blockquote>&#xA;<p>TypeError: Object(...) is not a function</p>&#xA;<p>export const CompanyFragment = gql &lt;--line 3</p>&#xA;</blockquote>&#xA;<p><a href=""https://i.stack.imgur.com/iaUkN.png"" rel=""nofollow noreferrer"">picture of error</a></p>&#xA;<p>If anyone could provide an insight on this it would be greatly appreciated!</p>&#xA;",9367870,,-1,2020-06-20 09:12:55,2018-06-06 06:00:56,GraphQL Fragments error on export to query,<reactjs><graphql><apollo><react-apollo><recompose>,1,0,0,2018-06-05 20:09:30
50713155,2,,50708181,0,,<p>I guess you did not import or imported the wrong <code>gql</code>. In the last year the API was changed quite a bit.</p>&#xA;&#xA;<p>You should not import it like</p>&#xA;&#xA;<p><code>import { gql } from 'react-apollo';</code></p>&#xA;&#xA;<p>but from this package</p>&#xA;&#xA;<p><code>import gql from 'graphql-tag';</code></p>&#xA;,4500001,,,,2018-06-06 06:00:56,"",,0,1,0,2018-06-06 06:00:56
50726428,2,,49326217,0,,"<p>I think you have OneToOneField between this two model, if it's true, you can't have something like that because it's not logical</p>&#xA;&#xA;<p>imagine that, if a user has a Demographic, and you retrieve allUsers, then for each one, we have one Demographic and it's not logical to filter one Demographic. the only way to do this is to filter it with the UserNode(as you said and did)</p>&#xA;&#xA;<p>the Nested filtering just work if you have a ForeignKey or ManyToManyField to user model and then you can retrieve that in user with the separate filter</p>&#xA;&#xA;<p>I hope I've been able to make it clear to you</p>&#xA;",7205726,,7205726,2018-06-06 17:48:18,2018-06-06 17:48:18,"",,0,3,0,2018-06-06 17:38:53
50744171,1,,,1,3231,"<p>I have got the following need :  Using the graphql syntax, filter a collection according to multiple values on the same property and paginate the results</p>&#xA;&#xA;<p>Considering the following entity ...</p>&#xA;&#xA;<pre><code>/** ... APIResource annotations&#xA; */&#xA;class RssFeed {&#xA;    /** ... APIProperty annotations&#xA;    */&#xA;    private $category;&#xA;&#xA;    /** ... APIProperty annotations&#xA;    */&#xA;    private $url; &#xA;&#xA;    // ... getters&#xA;    // ... setters&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to filter the collection of <code>RssFeed</code> which <code>category</code> property is ""CategoryA"" or ""CategoryB"" and paginate the results.</p>&#xA;&#xA;<p>According to my knowledge, graphql does not allow to write a syntax similar to </p>&#xA;&#xA;<pre><code>rssfeed(category: [""CategoryA"",""CategoryB""]) &#xA;{&#xA;    edges { node {&#xA;    url,&#xA;    category&#xA;    } }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So I need to separate the search operation using distinct graphql queries (in the body) like</p>&#xA;&#xA;<pre><code>rssFeedsA: rssfeed(category: ""CategoryA"") &#xA;{&#xA;    edges { node {&#xA;    url,&#xA;    category&#xA;    } }&#xA;},&#xA;rssFeedsB: rssfeed(category: ""CategoryB"") &#xA;{&#xA;    edges { node {&#xA;    url,&#xA;    category&#xA;    } }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But, I can't paginate the global results.</p>&#xA;&#xA;<p>So, my question, is there any solution to filter on multiple values and paginate ?</p>&#xA;",8152865,,,,2018-06-07 15:50:24,"In graphql, filter on multiple values on the same property and paginate",<graphql><api-platform.com>,1,0,0,2018-06-07 14:46:06
50774034,1,,,3,2001,"<p>Okay, so I've been working with Prisma for a couple weeks now, and have made some great progress and I love the setup/ease of use of getting a lot of advanced features implemented.</p>&#xA;&#xA;<p>I'm at the point I'm trying to implement sorting on table fields. </p>&#xA;&#xA;<p>I have the options to (among other fields) sort by <code>term_ASC</code> and <code>term_DESC</code>. </p>&#xA;&#xA;<p>Assume the following query definition: <code>MyConnection(filter: String, order: MyOrderByInput, limit: Int, offset: Int): MyConnection!</code></p>&#xA;&#xA;<p>If I run the following code in the GraphQL Playground, it works fine:</p>&#xA;&#xA;<pre><code>query myPaginatedResults {&#xA;    myConnection(filter: ""lorem"", limit: 25, offset: 0, order: term_ASC) {&#xA;        aggregate {&#xA;            count&#xA;        }&#xA;        edges {&#xA;            node {&#xA;                id&#xA;                term&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Main point/question...</strong> &#xA;The usage of term_ASC/DESC works in playground, but how do I pass that in my JS?</p>&#xA;&#xA;<p>If I wrap it in quotes ""term_ASC"", errors ensue, and if it's not wrapped, then it (resolver/api) throw errors about an obviously undefined variable.</p>&#xA;&#xA;<pre><code>const myConnection = (parent, args, context, info) =&gt; {&#xA;  const where = args.filter&#xA;  ? {&#xA;    OR: [&#xA;      { term_contains: args.filter },&#xA;      { type_contains: args.filter },&#xA;      { id_in: args.filter },&#xA;    ],&#xA;  } : {}&#xA;&#xA;  const order = args.order;&#xA;  // const order = `title_ASC`;&#xA;  const skip = args.offset ? args.offset : 0;&#xA;  const limit = args.limit ? args.limit : 50;&#xA;&#xA;  // console.log(context.db.query);&#xA;  const results = context.db.query.myDbConnection({&#xA;    where,&#xA;    orderBy: order,&#xA;    first: limit,&#xA;    skip: skip,&#xA;  }, info);&#xA;&#xA;  return results;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So the portion where I'm trying to test how to pass this orderBy variable in through a variable (hard coded, commented out in this sample) or before passing into the resolver via my args.order, I can't figure out how that should be passed. </p>&#xA;",9679241,,,,2018-06-09 13:12:38,Prisma orderBy in a resolver/query outside of Playground,<graphcool><prisma><prisma-graphql>,1,0,0,2018-06-09 11:58:04
50805470,1,50822554,,7,5533,"<p>I have the following schema in AppSync for GraphQL</p>&#xA;<pre><code>input CreateTeamInput {&#xA;    name: String!&#xA;    sport: Sports!&#xA;    createdAt: String&#xA;}&#xA;&#xA;enum Sports {&#xA;    baseball&#xA;    basketball&#xA;    cross_country&#xA;}&#xA;type Mutation{&#xA;    createTeam(input: CreateTeamInput!): Team&#xA;}&#xA;</code></pre>&#xA;<p>However when I try to execute the query using AWS Amplify library via</p>&#xA;<pre><code>export const CreateTeam = `mutation CreateTeam($name: String!, $sport: String!){&#xA;  createTeam(input:{name:$name, sport:$sport}) {&#xA;    id,&#xA;    name,&#xA;    sport&#xA;  }&#xA;}&#xA;`;&#xA;&#xA;....&#xA;&#xA;API.graphql(graphqlOperation(CreateTeam, this.state))&#xA;</code></pre>&#xA;<p>I get the following error: <code>Validation error of type VariableTypeMismatch: Variable type doesn't match</code>.</p>&#xA;<p>How can I update my code to work with this enum type?</p>&#xA;",572209,,1480391,2021-03-17 19:56:04,2021-03-17 19:56:04,AppSync and GraphQL Enum mutations,<amazon-web-services><graphql><aws-amplify><aws-appsync>,2,2,0,2018-06-11 20:23:33
50806531,2,,50805470,1,,<p>$sport needs to be a Sports type not a String</p>&#xA;,1043698,,,,2018-06-11 21:50:56,"",,0,2,0,2018-06-11 21:50:56
50822554,2,,50805470,7,,"<p><code>CreateTeamInput.sport</code> field type is an enum, hence your <code>$sport</code> variable must be an enum. </p>&#xA;&#xA;<p>Try changing your query to:</p>&#xA;&#xA;<pre><code>export const CreateTeam = `mutation CreateTeam($name: String!, $sport: Sports!){&#xA;  createTeam(input:{name:$name, sport:$sport}) {&#xA;    id,&#xA;    name,&#xA;    sport&#xA;  }&#xA;};&#xA;</code></pre>&#xA;&#xA;<p><strong>Note:</strong>&#xA;As a convention, prefer using uppercase for your enum values so it's easy to tell them apart from strings.</p>&#xA;&#xA;<pre><code>enum SPORTS {&#xA;    BASEBALL&#xA;    BASKETBALL&#xA;    CROSS_COUNTRY&#xA;}&#xA;</code></pre>&#xA;",1060799,,,,2018-06-12 17:20:55,"",,0,1,0,2018-06-12 17:20:55
50864805,2,,50626958,0,,"<p>As I know and test right now, your graphene side is ok and the bug is from the ReactJS side, that's mean you are using DjangoFilterConnectionField truly.</p>&#xA;&#xA;<p>I have a lot of research about this but as I didn't see your React code completely, I have a little doubtful. anyway as I saw in this sample(<a href=""https://github.com/apollographql/relay-modern-hello-world/blob/master/src/App.js#L32"" rel=""nofollow noreferrer"">Query</a>, <a href=""https://github.com/apollographql/relay-modern-hello-world/blob/master/src/Feed.js#L21"" rel=""nofollow noreferrer"">Fragment</a>) you are using this wrong:</p>&#xA;&#xA;<pre><code>&lt;Country country={props.viewer.countries.edges} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>You should use it like this:</p>&#xA;&#xA;<pre><code>&lt;Country country={props.viewer.countries} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>as far as I understand you are required to pass the queried object to the child</p>&#xA;",7205726,,,,2018-06-14 19:43:24,"",,0,0,0,2018-06-14 19:43:24
50925774,2,,47928923,3,,"<p>Using strapi v3.0.0-alpha.12.4&#xA;you should specify &quot;where&quot; parameter to filter data.</p>&#xA;<p>In your case it should be:</p>&#xA;<pre><code>http://localhost:1337/graphql?query={users(where:{id:1}){id}}&#xA;</code></pre>&#xA;<p>From the official documentation (<a href=""https://strapi.io/documentation/3.x.x/guides/graphql.html"" rel=""nofollow noreferrer"">https://strapi.io/documentation/3.x.x/guides/graphql.html</a>):</p>&#xA;<blockquote>&#xA;<p>You can also apply different parameters to the query to make more complex queries.</p>&#xA;<p>limit (integer): Define the number of returned entries.</p>&#xA;<p>start (integer): Define the amount of entries to skip.</p>&#xA;<p>sort (string): Define how the data should be sorted.</p>&#xA;<p>where (object): Define the filters to apply in the query.</p>&#xA;<p>: Equals.</p>&#xA;<p>_ne: Not equals.</p>&#xA;<p>_lt: Lower than.</p>&#xA;<p>_lte: Lower than or equal to.</p>&#xA;<p>_gt: Greater than.</p>&#xA;<p>_gte: Lower than or equal to.</p>&#xA;<p>_contains: Contains.</p>&#xA;<p>_containss: Contains sensitive.</p>&#xA;</blockquote>&#xA;",4114495,,-1,2020-06-20 09:12:55,2018-06-19 10:08:35,"",,0,0,0,2018-06-19 10:08:35
50930754,2,,47222568,0,,"<p>You can chain them together:</p>&#xA;&#xA;<pre><code>import { changeFoo } from './myReduxActions';&#xA;&#xA;const QUERY = gql`{ FindSomething { Id, Value }}`;&#xA;&#xA;const myComponent = connect(&#xA;   store =&gt; ({&#xA;      foo: store.fooReducer.foo&#xA;   }),&#xA;   dispatch =&gt; ({&#xA;      changeFoo: (val) =&gt; dispatch(changeFoo(val))&#xA;   })&#xA;)(graphql(QUERY)(&#xA;   {props.data.loading &amp;&amp; return &lt;div&gt;Loading...&lt;/div&gt;}&#xA;&#xA;   let myNewFoo = 'abc';&#xA;   return props.data.FindSomething ?&#xA;       &lt;div&gt;{`Id is ${props.data.FindSomething.Id}, redux store value foo is ${props.foo}`}&#xA;       &lt;div onClick={() =&gt; props.ChangeFoo(myNewFoo)}&gt;&lt;/div&gt;&lt;/div&gt; :&#xA;       props.data.error ? &lt;div&gt;Error {props.data.error}&lt;/div&gt; : null;&#xA;));&#xA;</code></pre>&#xA;&#xA;<p>So you could do <code>connect(graphql(pureComponent)))</code> or written as <code>connect =&gt; graphql =&gt; component</code>. You can change the order of graphql and connect.</p>&#xA;",4625144,,,,2018-06-19 14:22:39,"",,0,0,0,2018-06-19 14:22:39
50964162,2,,50961807,0,,"<p>You can query the linksConnection related to the user, and therefore access cursors :</p>&#xA;&#xA;<pre><code>{&#xA;  linksConnection(where:{user:{id:""cjimzqrshb3nf0c29z1p7km0j""}}){&#xA;     pageInfo{&#xA;       endCursor&#xA;       startCursor&#xA;     }&#xA;     edges{&#xA;       cursor&#xA;     }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",7660935,,,,2018-06-21 08:44:31,"",,0,1,0,2018-06-21 08:44:31
50970599,1,50971656,,1,1319,"<p>I'm working on a GraphQL AppSync project for 6 months by now and I'm already quite familiar with the concept so far.</p>&#xA;&#xA;<p>But I came across one thing, which is not explained in tutorials or documentations at all.&#xA;What is the best practice of the return type of a Mutation? (especially of a partial update)</p>&#xA;&#xA;<p>Here is one simplified sample schema:</p>&#xA;&#xA;<pre><code>type Article {&#xA;    uuid: ID&#xA;    title: String&#xA;    description: String&#xA;    price: Int&#xA;    tax: Int&#xA;    category_uuid: ID&#xA;    status: Int&#xA;    type: Int&#xA;}&#xA;&#xA;input ArticleUpdateInput {&#xA;    uuid: ID!&#xA;    title: String&#xA;    description: String&#xA;    price: Int&#xA;    tax: Int&#xA;    category_uuid: ID&#xA;    status: Int&#xA;    type: Int&#xA;}&#xA;&#xA;type Mutation {&#xA;    updateArticle(input: ArticleUpdateInput!): Article!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The following mutation would be valid:</p>&#xA;&#xA;<pre><code>mutation foo {&#xA;    updateArticle(input: {&#xA;        uuid: ""c63c6dcb-6c09-4952-aae2-26e3fde47262"",&#xA;        title: ""BBQ Burger"",&#xA;        price: 699&#xA;    }) {&#xA;        __typename&#xA;        uuid&#xA;        title&#xA;        description&#xA;        price&#xA;        tax&#xA;        category_uuid&#xA;        status&#xA;        type&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Since I only specified the title and the price the other fields of the response will be null like so:</p>&#xA;&#xA;<pre><code>{&#xA;    ""data"": {&#xA;        ""updateArticle"": {&#xA;            ""__typename"": ""Article"",&#xA;            ""uuid"": ""c63c6dcb-6c09-4952-aae2-26e3fde47262"",&#xA;            ""title"": ""BBQ Burger"",&#xA;            ""description"": null,&#xA;            ""price"": 699,&#xA;            ""tax"": null,&#xA;            ""category_uuid"": null&#xA;            ""status"": null&#xA;            ""type"": null&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What would be a best practice here to avoid to return these null fields?&#xA;Should I trigger a getArticle query after the update and return the whole article record from the database? I think this would be very inefficient because if you want to add n articles, there will be 2*n roundtrips to the database.</p>&#xA;&#xA;<p>Any ideas so far?</p>&#xA;",5448519,,5448519,2018-06-21 14:37:54,2018-06-21 14:56:36,GraphQL partial update response type,<graphql><apollo><aws-appsync>,1,3,0,2018-06-21 14:08:35
50995166,1,51010288,,0,40,"<p>How can I filter my results based on my edges props? &#xA;For example: Getting user's new friends from 2 months ago.</p>&#xA;&#xA;<pre><code>type User {&#xA;   ...&#xA;   fiends(before: String) @relation(name: ""FRIEND"", direction: ""OUT"")&#xA;}&#xA;&#xA;User {&#xA;   ...&#xA;   friends(before: '03.2018')&#xA;}&#xA;</code></pre>&#xA;",860675,,,,2018-06-24 13:13:59,How to filter based on edge's property using GRANDstack,<neo4j><graphql><apollo>,1,0,0,2018-06-22 20:27:58
51010477,2,,50961807,0,,"<p>You can implement cursor based pagination with Prisma like this:</p>&#xA;&#xA;<pre><code>{&#xA;  users{&#xA;    links(first: 10, after:""some-id"") {&#xA;      description&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is possible because the id and the cursor is the same.</p>&#xA;&#xA;<p>Alternatively you can use offset based pagination like this:</p>&#xA;&#xA;<pre><code>{&#xA;  users{&#xA;    links(first: 10, skip: 30) {&#xA;      description&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",386973,,,,2018-06-24 13:40:46,"",,0,2,0,2018-06-24 13:40:46
51043641,2,,50198976,3,,"<p>Miha answered his own question in the comments. The correct way to filter is:</p>&#xA;&#xA;<pre><code>{ &#xA;   contentfulStran(naslov: {eq: ""Ponudba""}) &#xA;   { &#xA;      id &#xA;      naslov&#xA;      zaporedje&#xA;      tekst&#xA;      {&#xA;        tekst &#xA;      } &#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note the <code>{eq: ""param""}</code> object instead of just giving the param.</p>&#xA;",2737021,,,,2018-06-26 13:03:57,"",,0,0,0,2018-06-26 13:03:57
51119287,1,,,1,882,"<p>I have a project in <strong>React</strong> using <strong>Redux</strong> and <strong>Relay</strong>. The client connects to an API Server using GraphQL. I was trying to use the component <strong>QueryRenderer</strong> and I'm getting the following error:</p>&#xA;&#xA;<pre><code>TypeError: this.props.render is not a function&#xA;render&#xA;src/react-landing/node_modules/react-relay/lib/ReactRelayQueryRenderer.js:164&#xA;&#xA;  161 |   if (process.env.NODE_ENV !== 'production') {&#xA;  162 |     deepFreeze(renderProps);&#xA;  163 |   }&#xA;&gt; 164 |   return this.props.render(renderProps);&#xA;  165 | };&#xA;  166 | &#xA;  167 | return ReactRelayQueryRenderer;&#xA;&#xA;View compiled&#xA;finishClassComponent&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:13193&#xA;&#xA;  13190 | } else {&#xA;  13191 |   {&#xA;  13192 |     ReactDebugCurrentFiber.setCurrentPhase('render');&#xA;&gt; 13193 |     nextChildren = instance.render();&#xA;  13194 |     if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode &amp;&amp; workInProgress.mode &amp; StrictMode) {&#xA;  13195 |       instance.render();&#xA;  13196 |     }&#xA;&#xA;View compiled&#xA;updateClassComponent&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:13155&#xA;&#xA;  13152 |   } else {&#xA;  13153 |     shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);&#xA;  13154 |   }&#xA;&gt; 13155 |   return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);&#xA;  13156 | }&#xA;  13157 | &#xA;  13158 | function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime) {&#xA;&#xA;View compiled&#xA;beginWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:13824&#xA;&#xA;  13821 | case FunctionalComponent:&#xA;  13822 |   return updateFunctionalComponent(current, workInProgress);&#xA;  13823 | case ClassComponent:&#xA;&gt; 13824 |   return updateClassComponent(current, workInProgress, renderExpirationTime);&#xA;  13825 | case HostRoot:&#xA;  13826 |   return updateHostRoot(current, workInProgress, renderExpirationTime);&#xA;  13827 | case HostComponent:&#xA;&#xA;View compiled&#xA;performUnitOfWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:15863&#xA;&#xA;  15860 |   startBaseRenderTimer();&#xA;  15861 | }&#xA;  15862 | &#xA;&gt; 15863 | next = beginWork(current, workInProgress, nextRenderExpirationTime);&#xA;  15864 | &#xA;  15865 | if (workInProgress.mode &amp; ProfileMode) {&#xA;  15866 |   // Update ""base"" time if the render wasn't bailed out on.&#xA;&#xA;View compiled&#xA;workLoop&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:15902&#xA;&#xA;  15899 | if (!isAsync) {&#xA;  15900 |   // Flush all expired work.&#xA;  15901 |   while (nextUnitOfWork !== null) {&#xA;&gt; 15902 |     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);&#xA;  15903 |   }&#xA;  15904 | } else {&#xA;  15905 |   // Flush asynchronous work until the deadline runs out of time.&#xA;&#xA;View compiled&#xA;callCallback&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:100&#xA;&#xA;   97 |   // nested call would trigger the fake event handlers of any call higher&#xA;   98 |   // in the stack.&#xA;   99 |   fakeNode.removeEventListener(evtType, callCallback, false);&#xA;&gt; 100 |   func.apply(context, funcArgs);&#xA;  101 |   didError = false;&#xA;  102 | }&#xA;  103 | &#xA;&#xA;View compiled&#xA;invokeGuardedCallbackDev&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:138&#xA;&#xA;  135 | // Synchronously dispatch our fake event. If the user-provided function&#xA;  136 | // errors, it will trigger our global error handler.&#xA;  137 | evt.initEvent(evtType, false, false);&#xA;&gt; 138 | fakeNode.dispatchEvent(evt);&#xA;  139 | &#xA;  140 | if (didError) {&#xA;  141 |   if (!didSetError) {&#xA;&#xA;View compiled&#xA;invokeGuardedCallback&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:187&#xA;&#xA;  184 |  * @param {...*} args Arguments for function&#xA;  185 |  */&#xA;  186 | invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {&#xA;&gt; 187 |   invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);&#xA;  188 | },&#xA;  189 | &#xA;  190 | /**&#xA;&#xA;View compiled&#xA;replayUnitOfWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:15310&#xA;&#xA;  15307 | // Replay the begin phase.&#xA;  15308 | isReplayingFailedUnitOfWork = true;&#xA;  15309 | originalReplayError = thrownValue;&#xA;&gt; 15310 | invokeGuardedCallback$2(null, workLoop, null, isAsync);&#xA;  15311 | isReplayingFailedUnitOfWork = false;&#xA;  15312 | originalReplayError = null;&#xA;  15313 | if (hasCaughtError()) {&#xA;&#xA;View compiled&#xA;renderRoot&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:15962&#xA;&#xA;  15959 | &#xA;  15960 | var failedUnitOfWork = nextUnitOfWork;&#xA;  15961 | if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) {&#xA;&gt; 15962 |   replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);&#xA;  15963 | }&#xA;  15964 | &#xA;  15965 | // TODO: we already know this isn't true in some cases.&#xA;&#xA;View compiled&#xA;performWorkOnRoot&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16560&#xA;&#xA;  16557 |   // This root is already complete. We can commit it.&#xA;  16558 |   completeRoot(root, finishedWork, expirationTime);&#xA;  16559 | } else {&#xA;&gt; 16560 |   finishedWork = renderRoot(root, expirationTime, false);&#xA;  16561 |   if (finishedWork !== null) {&#xA;  16562 |     // We've completed the root. Commit it.&#xA;  16563 |     completeRoot(root, finishedWork, expirationTime);&#xA;&#xA;View compiled&#xA;performWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16482&#xA;&#xA;  16479 |   }&#xA;  16480 | } else {&#xA;  16481 |   while (nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime)) {&#xA;&gt; 16482 |     performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);&#xA;  16483 |     findHighestPriorityRoot();&#xA;  16484 |   }&#xA;  16485 | }&#xA;&#xA;View compiled&#xA;performSyncWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16454&#xA;&#xA;  16451 | }&#xA;  16452 | &#xA;  16453 | function performSyncWork() {&#xA;&gt; 16454 |   performWork(Sync, false, null);&#xA;  16455 | }&#xA;  16456 | &#xA;  16457 | function performWork(minExpirationTime, isAsync, dl) {&#xA;&#xA;View compiled&#xA;requestWork&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16354&#xA;&#xA;  16351 | &#xA;  16352 | // TODO: Get rid of Sync and use current time?&#xA;  16353 | if (expirationTime === Sync) {&#xA;&gt; 16354 |   performSyncWork();&#xA;  16355 | } else {&#xA;  16356 |   scheduleCallbackWithExpiration(expirationTime);&#xA;  16357 | }&#xA;&#xA;View compiled&#xA;scheduleWork$1&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16218&#xA;&#xA;  16215 | !isWorking || isCommitting$1 ||&#xA;  16216 | // ...unless this is a different root than the one we're rendering.&#xA;  16217 | nextRoot !== root) {&#xA;&gt; 16218 |   requestWork(root, nextExpirationTimeToWorkOn);&#xA;  16219 | }&#xA;  16220 | if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {&#xA;  16221 |   invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');&#xA;&#xA;View compiled&#xA;scheduleRootUpdate&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16785&#xA;&#xA;  16782 |   }&#xA;  16783 |   enqueueUpdate(current, update, expirationTime);&#xA;  16784 | &#xA;&gt; 16785 |   scheduleWork$1(current, expirationTime);&#xA;  16786 |   return expirationTime;&#xA;  16787 | }&#xA;  16788 | &#xA;&#xA;View compiled&#xA;updateContainerAtExpirationTime&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16812&#xA;&#xA;  16809 |     container.pendingContext = context;&#xA;  16810 |   }&#xA;  16811 | &#xA;&gt; 16812 |   return scheduleRootUpdate(current, element, expirationTime, callback);&#xA;  16813 | }&#xA;  16814 | &#xA;  16815 | function findHostInstance(component) {&#xA;&#xA;View compiled&#xA;updateContainer&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16839&#xA;&#xA;  16836 |   var current = container.current;&#xA;  16837 |   var currentTime = recalculateCurrentTime();&#xA;  16838 |   var expirationTime = computeExpirationForFiber(currentTime, current);&#xA;&gt; 16839 |   return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);&#xA;  16840 | }&#xA;  16841 | &#xA;  16842 | function getPublicRootInstance(container) {&#xA;&#xA;View compiled&#xA;./node_modules/react-dom/cjs/react-dom.development.js/ReactRoot.prototype.render&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:17122&#xA;&#xA;  17119 |   if (callback !== null) {&#xA;  17120 |     work.then(callback);&#xA;  17121 |   }&#xA;&gt; 17122 |   updateContainer(children, root, null, work._onCommit);&#xA;  17123 |   return work;&#xA;  17124 | };&#xA;  17125 | ReactRoot.prototype.unmount = function (callback) {&#xA;&#xA;View compiled&#xA;legacyRenderSubtreeIntoContainer/&lt;&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:17262&#xA;&#xA;  17259 |     if (parentComponent != null) {&#xA;  17260 |       root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);&#xA;  17261 |     } else {&#xA;&gt; 17262 |       root.render(children, callback);&#xA;  17263 |     }&#xA;  17264 |   });&#xA;  17265 | } else {&#xA;&#xA;View compiled&#xA;unbatchedUpdates&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:16679&#xA;&#xA;  16676 |       isUnbatchingUpdates = false;&#xA;  16677 |     }&#xA;  16678 |   }&#xA;&gt; 16679 |   return fn(a);&#xA;  16680 | }&#xA;  16681 | &#xA;  16682 | // TODO: Batching should be implemented at the renderer level, not within&#xA;&#xA;View compiled&#xA;legacyRenderSubtreeIntoContainer&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:17258&#xA;&#xA;  17255 |   };&#xA;  17256 | }&#xA;  17257 | // Initial mount should not be batched.&#xA;&gt; 17258 | unbatchedUpdates(function () {&#xA;  17259 |   if (parentComponent != null) {&#xA;  17260 |     root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);&#xA;  17261 |   } else {&#xA;&#xA;View compiled&#xA;render&#xA;src/react-landing/node_modules/react-dom/cjs/react-dom.development.js:17317&#xA;&#xA;  17314 |   return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);&#xA;  17315 | },&#xA;  17316 | render: function (element, container, callback) {&#xA;&gt; 17317 |   return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);&#xA;  17318 | },&#xA;  17319 | unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {&#xA;  17320 |   !(parentComponent != null &amp;&amp; has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;&#xA;&#xA;View compiled&#xA;./src/index.js&#xA;src/react-landing/src/index.js:15&#xA;&#xA;  12 | import '../node_modules/font-awesome/css/font-awesome.min.css';&#xA;  13 | &#xA;  14 | &#xA;&gt; 15 | ReactDOM.render(&#xA;  16 |   &lt;Provider store={ store }&gt;&#xA;  17 |     &lt;I18nextProvider i18n={ i18n }&gt;&#xA;  18 |       &lt;App /&gt;&#xA;&#xA;View compiled&#xA;▶ 6 stack frames were collapsed.&#xA;</code></pre>&#xA;&#xA;<p>This are the source files:</p>&#xA;&#xA;<p><strong><em>src/components/HomePage/Header/Header.jsx</em></strong></p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import { connect } from ""react-redux"";&#xA;import { I18n } from 'react-i18next';&#xA;import { QueryRenderer } from 'react-relay';&#xA;&#xA;import environment from '../../../relay/environment';&#xA;import featuredStores from './FeaturedStores';&#xA;import SearchBox from '../../SearchBox/SearchBox';&#xA;&#xA;import './Header.css';&#xA;&#xA;&#xA;const mapStateToProps = state =&gt; {&#xA;  return {&#xA;    query: state.storeService.getAllFeatured()&#xA;  };&#xA;};&#xA;&#xA;const Header = ({ query }) =&gt; (&#xA;  &lt;I18n&gt;&#xA;    {&#xA;      (t) =&gt; (&#xA;        &lt;div className=""background""&gt;&#xA;          &lt;ul className=""cb-slideshow""&gt;&#xA;            &lt;li&gt;&lt;span&gt;Image 01&lt;/span&gt;&lt;/li&gt;&#xA;            &lt;li&gt;&lt;span&gt;Image 02&lt;/span&gt;&lt;/li&gt;&#xA;            &lt;li&gt;&lt;span&gt;Image 03&lt;/span&gt;&lt;/li&gt;&#xA;          &lt;/ul&gt;&#xA;          &lt;div className=""banner""&gt;&#xA;            &lt;div className=""container""&gt;&#xA;              &lt;div className=""banner-info""&gt;&#xA;                &lt;h2&gt;{ t('home-page.header.title') }&lt;/h2&gt;&#xA;                &lt;p&gt;{ t('home-page.header.description') }&lt;/p&gt;&#xA;              &lt;/div&gt;&#xA;              &lt;div className=""banner-grads""&gt;&#xA;                &lt;QueryRenderer environment={ environment } query={ query }&gt; render={ featuredStores }&gt;&lt;/QueryRenderer&gt;&#xA;&#xA;                &lt;div className=""clearfix""&gt;&lt;/div&gt;&#xA;&#xA;                &lt;SearchBox /&gt;&#xA;              &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;          &lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;      )&#xA;    }&#xA;  &lt;/I18n&gt;&#xA;);&#xA;&#xA;export default connect(mapStateToProps)(Header);&#xA;</code></pre>&#xA;&#xA;<p><strong><em>src/components/HomePage/Header/FeaturedStores.jsx</em></strong></p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import Spinner from 'react-spinkit';&#xA;&#xA;/**&#xA; * FeaturedStores component.&#xA; */&#xA;export default ({ error, stores }) =&gt; {&#xA;  if (error) {&#xA;    return &lt;div&gt;Error!&lt;/div&gt;;&#xA;  }&#xA;&#xA;  if (!stores) {&#xA;    return &lt;Spinner name=""line-scale"" color=""blue"" /&gt;;&#xA;  }&#xA;&#xA;  return (&#xA;    &lt;div&gt;&#xA;      {&#xA;        stores.map((store, key) =&gt; {&#xA;          return (&#xA;            &lt;div className=""col-md-4 banner-grad"" key={ key }&gt;&#xA;              &lt;div className=""banner-grad-img""&gt;&#xA;                &lt;img src={ store.image } alt={ store.name } /&gt;&#xA;                &lt;h4&gt;{ store.name }&lt;/h4&gt;&#xA;                &lt;p&gt;&#xA;                  &lt;span className=""storeDescription""&gt;{ store.description }&lt;/span&gt;&#xA;                  &lt;br /&gt; { store.address }, { store.city }&#xA;                &lt;/p&gt;&#xA;              &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;          );&#xA;        })&#xA;      }&#xA;    &lt;/div&gt;&#xA;  );&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong><em>src/relay/services/StoreService.jsx</em></strong></p>&#xA;&#xA;<pre><code>import storesQuery from '../queries/StoresQuery';&#xA;import featuredStoresQuery from '../queries/FeaturedStoresQuery';&#xA;import storeQuery from '../queries/StoreQuery';&#xA;import storesByMenuItemQuery from '../queries/StoresByMenuItemQuery';&#xA;&#xA;&#xA;/** Limit of stores per request. */&#xA;const LIMIT = 24&#xA;&#xA;/**&#xA; * class :: StoreService&#xA; *&#xA; * Service for Store types.&#xA; */&#xA;class StoreService {&#xA;  /**&#xA;   * Constructor.&#xA;   */&#xA;  constructor() {&#xA;    this.storesQuery = storesQuery;&#xA;    this.storeQuery = storeQuery;&#xA;    this.featuredStoresQuery = featuredStoresQuery;&#xA;    this.storesByMenuItemQuery = storesByMenuItemQuery;&#xA;    this.searchFrom404 = false&#xA;    this.skipCounter = 0&#xA;  }&#xA;&#xA;  /**&#xA;   * Resets the skip counter.&#xA;   */&#xA;  resetSkipCounter() {&#xA;    this.skipCounter = 0&#xA;  }&#xA;&#xA;  /**&#xA;   * Gets all the stores using pagination.&#xA;   *&#xA;   * @returns {any} GraphQL query for retrieving the stores from the API server.&#xA;   */&#xA;  getAll() {&#xA;    this.skipCounter += LIMIT&#xA;&#xA;    return this.storesQuery;&#xA;  }&#xA;&#xA;  /**&#xA;   * Gets all the featured stores.&#xA;   *&#xA;   * @returns {any} GraphQL query for retrieving the featured stores from the API server.&#xA;   */&#xA;  getAllFeatured() {&#xA;    return this.featuredStoresQuery;&#xA;  }&#xA;&#xA;  /**&#xA;   * Gets an store from the API server by its URI.&#xA;   *&#xA;   * @returns {any} GraphQL query for retrieving the store from the API server.&#xA;   */&#xA;  getStore() {&#xA;    return this.storeQuery;&#xA;  }&#xA;&#xA;  /**&#xA;   * Gets all the stores from the API server that have the given item in their menues.&#xA;   *&#xA;   * @param {Boolean} searchFrom404 True if the search was performed from the SearchBox component.&#xA;   * @returns {any} GraphQL query for retrieving the stores from the API server.&#xA;   */&#xA;  getAllByMenuItem(searchFrom404) {&#xA;    this.searchFrom404 = searchFrom404 || false&#xA;&#xA;    return this.storesByMenuItemQuery;&#xA;  }&#xA;}&#xA;&#xA;/**&#xA; * Singleton implementation.&#xA; */&#xA;export default (function () {&#xA;  /** StoreService instance reference. */&#xA;  let instance = null&#xA;&#xA;  return {&#xA;    /**&#xA;     * Gets a unique instance of StoreService.&#xA;     *&#xA;     * @returns {StoreService} A unique instance of StoreService.&#xA;     */&#xA;    getInstance: function () {&#xA;      if (!instance) {&#xA;        instance = new StoreService()&#xA;      }&#xA;      return instance&#xA;    }&#xA;  }&#xA;})()&#xA;</code></pre>&#xA;&#xA;<p><strong><em>src/relay/queries/FeaturedStoresQuery.js</em></strong></p>&#xA;&#xA;<pre><code>import { graphql } from 'react-relay';&#xA;&#xA;&#xA;/**&#xA; * Gets all the featured stores.&#xA; */&#xA;export default graphql`&#xA;  query FeaturedStoresQuery {&#xA;    featuredStores {&#xA;      URI&#xA;      name&#xA;      category&#xA;      address&#xA;      city&#xA;      image&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>How can I solve this issue and render my component with <strong>QueryRenderer</strong>?</p>&#xA;",2312335,,2312335,2018-07-01 21:54:15,2020-05-02 21:37:52,SO Relay QueryRenderer - TypeError: this.props.render is not a function,<reactjs><react-redux><graphql><typeerror><react-relay>,3,1,0,2018-06-30 23:27:25
51124034,2,,51119287,0,,<p>The translations was working just fine before adding Redux and Relay. Someone told me that Relay can manage centralized states so I'll try to remove Redux before trying something else. Maybe both together are collapsing the rendering.</p>&#xA;,2312335,,,,2018-07-01 14:08:59,"",,0,0,0,2018-07-01 14:08:59
51169617,1,,,0,1038,"<p>Im trying to get just entrys which have in a specific value in a array (myArray: [String]). </p>&#xA;&#xA;<p>Displaying of this Array is not Problem: </p>&#xA;&#xA;<pre><code>query ($lang: [String!], $filter: String!) {&#xA;  nodes(lang: $lang, filter: {schema: {is: myObj}, fields: {myObj: {name: {regex: $filter}}}}) {&#xA;    elements {&#xA;      uuid&#xA;      language&#xA;      availableLanguages&#xA;      fields {&#xA;        ... on module {&#xA;          name&#xA;          myArray&#xA;        }&#xA;      }&#xA;      node {&#xA;        language&#xA;        fields {&#xA;          ... on module {&#xA;            name&#xA;            myArray&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Result:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""nodes"": {&#xA;      ""elements"": [&#xA;        {&#xA;          ""uuid"": ""xxxxxxxxxxxxxxxxxxxxxxxxxx"",&#xA;          ""language"": ""de"",&#xA;          ""availableLanguages"": [&#xA;            ""de""&#xA;          ],&#xA;          ""fields"": {&#xA;            ""name"": ""ASDF"",&#xA;            ""myArray"": [&#xA;              ""CAT_1"",&#xA;              ""CAT_2""&#xA;            ]&#xA;          },&#xA;          ""node"": null&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I filter on myArray? That I just et elements with the value uf <code>$filter</code> in the array <code>myArray</code>?</p>&#xA;&#xA;<p>In the Graph<em>i</em>QL I can't find the myArray in the docs under the filter - fields.</p>&#xA;",1599881,,,,2018-07-04 11:17:23,How to filter on a array with graphql in Generic Mesh CMS?,<graphql><gentics-mesh>,1,0,0,2018-07-04 08:54:14
51174424,1,51189504,,0,1175,"<p>I was glad to discover graphql-compose, and I started working with it in my projet. Actually I have an issue querying a litte more complex queries than the ones mentioned in the tutorials. For example I'd like to do a LIKE query on a mongoose table. If I modify the tutorial example to filter by name with an <a href=""https://graphql-compose.herokuapp.com/user/?query=%0A%7B%0A%20%20userMany(filter%3A%20%7B%20name%3A%20%22MICHA%22%20%7D%2C%20limit%3A%205%2C%20sort%3A%20_ID_ASC)%20%7B%0A%20%20%20%20name%0A%20%20%20%20languages%20%7B%0A%20%20%20%20%20%20language%0A%20%20%20%20%20%20skill%0A%20%20%20%20%7D%0A%20%20%20%20contacts%20%7B%0A%20%20%20%20%20%20email%0A%20%20%20%20%7D%0A%20%20%20%20gender%0A%20%20%20%20age%0A%20%20%7D%0A%7D%0A%20%20%20%20%20%20"" rel=""nofollow noreferrer"">exact match</a>, everything works fine</p>&#xA;&#xA;<pre><code>{&#xA;  userMany(filter: { name: ""MICHA"" }, limit: 5, sort: _ID_ASC) {&#xA;    name&#xA;    languages {&#xA;      language&#xA;      skill&#xA;    }&#xA;    contacts {&#xA;      email&#xA;    }&#xA;    gender&#xA;    age&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But if I attempt to use a regex, I'm immediately stuck like <a href=""https://graphql-compose.herokuapp.com/user/?query=%0A%7B%0A%20%20userMany(filter%3A%20%7B%20name%3A%20%22%2FMICH%2Fi%22%20%7D%2C%20limit%3A%205%2C%20sort%3A%20_ID_ASC)%20%7B%0A%20%20%20%20name%0A%20%20%20%20languages%20%7B%0A%20%20%20%20%20%20language%0A%20%20%20%20%20%20skill%0A%20%20%20%20%7D%0A%20%20%20%20contacts%20%7B%0A%20%20%20%20%20%20email%0A%20%20%20%20%7D%0A%20%20%20%20gender%0A%20%20%20%20age%0A%20%20%7D%0A%7D%0A%20%20%20%20%20%20"" rel=""nofollow noreferrer"">in this example</a> where my query is </p>&#xA;&#xA;<pre><code>{&#xA;  userMany(filter: { name: ""/MICH/i"" }, limit: 5, sort: _ID_ASC) {&#xA;    name&#xA;    languages {&#xA;      language&#xA;      skill&#xA;    }&#xA;    contacts {&#xA;      email&#xA;    }&#xA;    gender&#xA;    age&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>p.s: sorry, I was obliged to use the graphql tag instead of graphql-compose since the latter still doesn't exist, and I don't have enough credits to create it :-(</p>&#xA;",2033675,,,,2018-07-05 10:53:30,graphql-compose-mongoose doesn't execute like queries,<graphql>,1,2,0,2018-07-04 13:04:36
51188859,2,,51165205,1,,"<p>If you are using githubs graphql api than it seems that there is no way to filter those edges,&#xA;But if you're implementing the graphql server then it's possible to know what the edges nodes are and thus filter it in the edge resolver</p>&#xA;",1368057,,,,2018-07-05 10:20:00,"",,0,0,0,2018-07-05 10:20:00
51230360,1,51232603,,1,457,"<p>I'm generating Flow types for Apollo Client, and I currently have this:</p>&#xA;&#xA;<pre><code>type FetchModuleQuery = {|&#xA;  // Fetch single module&#xA;  module: ?{|&#xA;    // ID&#xA;    id: string,&#xA;    // Name&#xA;    name: string,&#xA;    // Fetch list of assignments for module&#xA;    assignments: ?Array&lt;?{|&#xA;      // Created date&#xA;      createdAt: any,&#xA;      // ID&#xA;      id: string,&#xA;      // Name&#xA;      name: string&#xA;    |}&gt;&#xA;  |}&#xA;|};&#xA;</code></pre>&#xA;&#xA;<p>However, this data is located in my parent component <code>&lt;Component1 /&gt;</code>, and I render its child component like so:</p>&#xA;&#xA;<pre><code>&lt;Component2 assignments={this.props.module.assignments} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>This works fine; I'm doing all the checks I need to do to keep Flow happy. However, I can't figure out the cleanest way of typing my <code>&lt;Component2 /&gt;</code>; ideally, I want to use this existing <code>FetchModuleQuery</code> object type, and not create anything new.</p>&#xA;&#xA;<p>Any ideas?</p>&#xA;",1136709,,2071697,2018-10-30 16:13:47,2018-10-30 16:13:47,Destructure a Flow object type?,<javascript><reactjs><graphql><flowtype><react-apollo>,2,1,0,2018-07-08 08:57:47
51251296,2,,51251065,5,,"<p>GraphQL doesn’t directly allow this.  Input object types have fixed structure, and there’s no conditional validation (built-in; your resolver function could produce errors based on its own checks that are richer than what’s in the schema).</p>&#xA;&#xA;<p>The most common pattern I’ve seen adopts the <a href=""https://facebook.github.io/relay/docs/en/graphql-server-specification.html#mutations"" rel=""noreferrer"">Relay GraphQL mutation conventions</a> (even if you don’t expect your clients to be using Relay).  This has one mutation per possible action (in your case, one mutation per submitted form) and a distinct input object type per mutation.</p>&#xA;&#xA;<p>Also note that the input object types can be nested, so in your example, you could write</p>&#xA;&#xA;<pre><code>input Name {&#xA;  givenName: String!&#xA;  surname: String!&#xA;}&#xA;&#xA;input Fruit {&#xA;  name: String!&#xA;}&#xA;&#xA;input WhatYouEatInput {&#xA;  name: Name!&#xA;  fruit: Fruit!&#xA;}&#xA;&#xA;mutation {&#xA;  whatYouEat(input: WhatYouEatInput!): WhatYouEatPayload!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which would allow reusing the common parts of the schema across different mutation types.</p>&#xA;",10008173,,,,2018-07-09 17:45:46,"",,0,1,0,2018-07-09 17:45:46
51270260,1,,,2,115,"<p>I make a GraphQL query where I get back a lot of data and than I calculate the min and max values. As the calculating is quite time consuming I would like to only do it when I receive the value. Unfortunately the <code>props</code> method is called every time the component is rerendered even there was no new call, and the data comes from the store. How can I limit the calculation to the points where I really get new data</p>&#xA;&#xA;<pre><code>graphql(DataQuery, {&#xA;    options: ({ id }) =&gt; ({&#xA;        variables: {&#xA;            id,&#xA;        },&#xA;    }),&#xA;    props: ({ data: { result} }) =&gt; ({&#xA;        data: result,&#xA;        min: getMin(result),&#xA;        max: getMax(result),&#xA;    }),&#xA;})&#xA;</code></pre>&#xA;",184883,,,,2018-07-12 09:41:14,How to enhance the response in apollo client with react only once,<reactjs><apollo><react-apollo><apollo-client>,1,0,0,2018-07-10 16:32:52
51270607,2,,51270260,3,,"<p>This problem is similar to <a href=""https://redux.js.org/recipes/computing-derived-data"" rel=""nofollow noreferrer"">the problem in redux</a> where <code>mapStateToProps()</code> will be called again every time the store updates repeating costy calculations. </p>&#xA;&#xA;<p>You can solve that by using <a href=""https://github.com/reduxjs/reselect"" rel=""nofollow noreferrer"">memorized selectors</a>:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import { createSelector } from 'reselect'&#xA;&#xA;const getMinMax = createSelector(&#xA;  result =&gt; result,&#xA;  result =&gt; ({&#xA;      min: getMin(result),&#xA;      max: getMax(result),&#xA;  })&#xA;)&#xA;&#xA;graphql(DataQuery, {&#xA;    options: ({ id }) =&gt; ({&#xA;        variables: {&#xA;            id,&#xA;        },&#xA;    }),&#xA;    props: ({ data: {result} }) =&gt; ({&#xA;        data: result,&#xA;        ...getMinMax(result), // will only re-calculate if result changed&#xA;    }),&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Memorized selectors remember the last result of a call and keep returning that on subsequent calls as long as the input does not change.</p>&#xA;",5005177,,5005177,2018-07-12 09:41:14,2018-07-12 09:41:14,"",,0,0,0,2018-07-10 16:54:11
51280890,1,,,0,458,"<p>I'm trying to run the following graphql query but the terminal is saying I have syntax errors in my code:</p>&#xA;&#xA;<pre><code>export const query = graphql`&#xA;&#xA;    query allAirtableLinked(filter: { table: { eq: ""Published"" } }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          data {&#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Terminal declares a syntax error </p>&#xA;&#xA;<pre><code>  Error: BabelPluginGraphQL: GraphQL syntax error in query:&#xA;    query allAirtableLinked(filter: {table: {eq: ""Published""}}) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          data {&#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  message:&#xA;  Syntax Error GraphQL request (4:27) Expected $, found Name ""filter""&#xA;  3:&#xA;  4:   query allAirtableLinked(filter: {table: {eq: ""Published""}}) {&#xA;                               ^&#xA;  5:     edges {&#xA;</code></pre>&#xA;&#xA;<p>Any ideas?</p>&#xA;",482095,,,,2018-07-11 11:44:00,How to resolve graphql syntax erros gatsby.js,<graphql><gatsby>,1,0,0,2018-07-11 08:38:41
51284679,2,,51280890,1,,"<p>You're passing arguments to the GraphQL <code>query</code> object and not the query field.</p>&#xA;&#xA;<p>Try something like this:</p>&#xA;&#xA;<pre><code>query allAirtableLinked($filter: { table: { eq: ""Published"" } }) {&#xA;  allAirtableLinked(filter: $filter) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        data {&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3708153,,,,2018-07-11 11:44:00,"",,0,1,0,2018-07-11 11:44:00
51292522,1,,,0,1529,"<p>I am changing the format of my schema from this:</p>&#xA;&#xA;<pre><code>var OldSchema = new GraphQLSchema({&#xA;  query: queryType,&#xA;  mutation: mutationType&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>to this:</p>&#xA;&#xA;<pre><code>typeDef = `&#xA;type Query {&#xA;  posts: [Post]&#xA;  author: Author&#xA;}&#xA;`;&#xA;&#xA;const NewSchema = makeExecutableSchema({&#xA;  typeDefs: [typeDef],&#xA;  resolvers: resolvers&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Since I have a lot of fields, and I want to transfer them from the old format to the new format one by one, I am using the function <strong>mergeSchemas</strong> from graphql-tools:</p>&#xA;&#xA;<pre><code>export const RootSchema = mergeSchemas({&#xA;  schemas: [NewSchema, OldSchema]&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>When I try to create a query ( which only get fields from the OldSchema ), I get the error **There can be only one fragment named ""duty"".</p>&#xA;&#xA;<p>This is how my query looks:</p>&#xA;&#xA;<pre><code>query {&#xA;  person {&#xA;    ...personFragment&#xA;  }&#xA;}&#xA;fragment conceptFragment on Person {&#xA;  jobs {&#xA;    ... on techJob {&#xA;      ...activities&#xA;    }&#xA;    ... on carpentryJob {&#xA;      ...skillSet&#xA;    }&#xA;  }&#xA;}&#xA;fragment activities on techJob {&#xA;  duties {&#xA;    ...duty&#xA;  }&#xA;}&#xA;fragment duty on Duties {&#xA;  id&#xA;}&#xA;fragment skillSet on carpentryJob {&#xA;  skills {&#xA;    ...dutiesSkill&#xA;  }&#xA;}&#xA;fragment dutiesSkill on Skill {&#xA;  duties {&#xA;    ...duty&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I know the error is happening in the parsing and it seems that the Validation of the query is happening for the OldSchema and for the RootSchema, but the RootSchema is the one that fails.</p>&#xA;",9335323,,,,2018-07-18 02:03:50,"Error: There can be only one fragment named ""fragmentName""",<javascript><apollo><graphql-js><graphql-tools>,2,4,0,2018-07-11 19:01:19
51303530,1,51363068,,15,7937,"<p>I saw <code>clientMutationId</code> field in <a href=""https://developer.github.com/v4/guides/migrating-from-rest/#example-strong-typing"" rel=""nofollow noreferrer"">example-strong-typing</a> documentation.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>mutation {&#xA;  addComment(input:{clientMutationId: 1234, subjectId: &quot;MDA6SXNzdWUyMjcyMDA2MTT=&quot;, body: &quot;Looks good to me!&quot;}) {&#xA;    clientMutationId&#xA;    commentEdge {&#xA;      node {&#xA;        body&#xA;        repository {&#xA;          id&#xA;          name&#xA;          nameWithOwner&#xA;        }&#xA;        issue {&#xA;          number&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>what does <code>clientMutationId</code> mean?  How can I generate it?</p>&#xA;",6463558,,6463558,2021-06-22 02:24:34,2021-06-22 02:24:34,"github graphql api, what does ""clientMutationId"" mean?",<graphql><github-api><relay><github-graphql><graphql-relay>,1,0,0,2018-07-12 10:40:10
51306702,2,,51302462,9,,"<p>Default arguments are currently a known issue and the best way to get around them is to use the <code>$util.defaultIfNull()</code> velocity helper function. For example, you can default arguments for limit and next token doing something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""version"": ""2017-02-28"",&#xA;  ""operation"": ""Scan"",&#xA;  ""limit"": $util.defaultIfNull($ctx.args.first, 20),&#xA;  ""nextToken"": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.after, null)),&#xA;}&#xA;</code></pre>&#xA;",2088684,,1480391,2018-07-12 14:01:31,2018-07-12 14:01:31,"",,0,5,0,2018-07-12 13:15:30
51311768,2,,45509228,9,,"<p>The reason for this is that ApolloClient, like Relay, uses a global store to cache your data on the client.</p>&#xA;&#xA;<p>In order to do this for you, global ids are required. For some reason, global ids are not something people think about, and in fact, it is something people complain about when switching to Relay all the time.</p>&#xA;&#xA;<p>ApolloClient has a clever solution for this! (Apollo team correct me if I am wrong) They allow you to define how your records get keyed in the store! By default, it uses the typename and id to create a the kind of global IDs that Relay suggests you create. This is why they need the typename.</p>&#xA;&#xA;<p>Since you are turning off the typename in the query, Apollo will do some smart stuff to try and figure out the type (and thus the key in the store). This smart stuff can lead to problems for you down the road.</p>&#xA;&#xA;<p>If you want to create your own global ids instead of using all this smart stuff, you can specify it like so:</p>&#xA;&#xA;<pre><code>const cache = new InMemoryCache({&#xA;  dataIdFromObject: object =&gt; object.key || null&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://www.apollographql.com/docs/react/advanced/caching.html#normalization"" rel=""noreferrer"">https://www.apollographql.com/docs/react/advanced/caching.html#normalization</a></p>&#xA;",386294,,,,2018-07-12 17:52:29,"",,0,0,0,2018-07-12 17:52:29
51323297,2,,51322346,5,,"<p>I think you could use <a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">fragments</a> for this! But you still have to write 2 <code>&quot;queries&quot;</code> in this case <code>fragments</code>.</p>&#xA;<p>First let's create a <code>fragment</code> for each <code>timeSeries</code>, please check your timeSeries query type, I'm going to refer to it as <code>timeseriesDataQuery</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>const series1Q = gql`&#xA;  fragment series1 on timeseriesDataQuery {&#xA;    series1: timeseriesData(sourceId: &quot;source1&quot;) {&#xA;      data {&#xA;        time&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;const series2Q = gql`&#xA;  fragment series2 on timeseriesDataQuery {&#xA;    series2: timeseriesData(sourceId: &quot;source2&quot;) {&#xA;      data {&#xA;        time&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And then just stitch them up in the query:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const mainQuery = gql`&#xA;    query fetchData {&#xA;      ...series1 &#xA;      ...series2&#xA;    }&#xA;    ${series1Q}&#xA;    ${series2Q}&#xA;`  &#xA;</code></pre>&#xA;",3708153,,19290081,2022-11-01 15:46:45,2022-11-01 15:46:45,"",,0,2,0,2018-07-13 10:41:34
51335122,2,,51327851,0,,"<p>Found out that using <code>&lt;SimpleSlider data={data} /&gt;</code> on index.js was enough to get the data to the component, without the need for any graphql fragment.</p>&#xA;",1733238,,,,2018-07-14 04:02:25,"",,0,0,0,2018-07-14 04:02:25
51362786,2,,51292522,0,,<p>You can maybe give an <code>alias</code> to one of the fragments? Like:</p>&#xA;&#xA;<pre><code>fragment activities on techJob {&#xA;  activities: duties {&#xA;    ...duty&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And</p>&#xA;&#xA;<pre><code>fragment dutiesSkill on Skill {&#xA;  dutiesSkill: duties {&#xA;    ...duty&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,3708153,,,,2018-07-16 13:18:27,"",,0,1,0,2018-07-16 13:18:27
51363068,2,,51303530,18,,"<p><code>clientMutationId</code> is not directly related with GraphQL but it is with <a href=""https://facebook.github.io/relay/docs/en/mutations.html"" rel=""noreferrer"">graphql-relay</a>.</p>&#xA;&#xA;<p>Check <a href=""https://github.com/chrisbolin/understanding-relay-mutations"" rel=""noreferrer"">Understanding Relay Mutations</a> for a better explanation.</p>&#xA;&#xA;<blockquote>&#xA;  <p><em>clientMutationId. This ID is generated by the Relay client behind the scenes to track the mutation's progress.</em></p>&#xA;</blockquote>&#xA;",3708153,,,,2018-07-16 13:31:18,"",,0,1,0,2018-07-16 13:31:18
51382387,2,,51369726,0,,"<p>I believe <code>apollo-server</code> does not provide cursor pagination out of the box. </p>&#xA;&#xA;<p>You can either implement it yourself. Or you can use(or get inspired) by the one that <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay</a> uses.</p>&#xA;&#xA;<p>And according to <a href=""https://www.apollographql.com/docs/react/features/pagination.html#relay-cursors"" rel=""nofollow noreferrer"">Apollo client</a> if you use Relay style cursor pagination the client has support for it.</p>&#xA;",3708153,,,,2018-07-17 13:16:14,"",,0,0,0,2018-07-17 13:16:14
51385661,1,,,3,305,"<p>I would like to save a birthdate from an (react) input (type = 'date'), send it via GraphQL to node backend and persist it in postgres in a date format.</p>&#xA;&#xA;<ol>&#xA;<li>Input in HTML: <code>09.07.2000</code></li>&#xA;<li>In GraphQL resolver: <code>2000-07-09T00:00:00.000Z</code></li>&#xA;<li>Date format in Postgres (original output in console): <code>09.07.2000</code></li>&#xA;</ol>&#xA;&#xA;<p>Well, that's what i expected. But now, if i request the same field:</p>&#xA;&#xA;<ol>&#xA;<li>Date format in Postgres (original output in console): <code>09.07.2000</code></li>&#xA;<li>Graphql response: <code>08.07.2000</code></li>&#xA;<li>HTML Input: <code>08.07.2000</code></li>&#xA;</ol>&#xA;&#xA;<p>If I change the scalar in graphQl schema to <code>String</code>, the following string returns: <code>Fri Jul 09 2000 00:00:00 GMT+0200 (CEST)</code></p>&#xA;&#xA;<h2>Code</h2>&#xA;&#xA;<h3>schema</h3>&#xA;&#xA;<pre><code>scalar Date&#xA;&#xA;type Child {&#xA;  ...&#xA;  birthDate: Date&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<h3>resolvers</h3>&#xA;&#xA;<pre><code>const { GraphQLDate } = require('graphql-iso-date')&#xA;...&#xA;Date: GraphQLDate,&#xA;</code></pre>&#xA;&#xA;<h2>Problem</h2>&#xA;&#xA;<p>It looks like there is a problem in converting the date format from different timezones. If there is no timezone the scalar resolver guess a timezone. But this is a birthdate, it hast to be the same date on every timezone. How can I fix this? Do I have to use a string instead of date in prostgres?</p>&#xA;&#xA;<p>Thanks for any support  I'm really lost</p>&#xA;&#xA;<p><strong>UPDATE</strong><br>&#xA;It looks like knex.js is the problem.&#xA;A normal SQL query responds the expected date. But a query with knex.js response a datetime.</p>&#xA;",6839130,,6839130,2018-07-23 10:57:41,2018-07-23 10:57:41,Save a birthDate via qraphql in postgres,<postgresql><date><graphql><knex.js>,0,0,0,2018-07-17 15:52:27
51389803,2,,48331103,31,,"<p>The accepted answer didn't solve my issue. Instead, it worked if you remove the initial curly brackets.</p>&#xA;<p>The query should look like this instead:</p>&#xA;<pre><code>const query=gql`&#xA;  user(id: 5) {&#xA;    firstName&#xA;    lastName&#xA;  }&#xA;`&#xA;</code></pre>&#xA;",5623338,,1402846,2020-12-12 04:52:34,2020-12-12 04:52:34,"",,0,1,0,2018-07-17 20:34:47
51487578,2,,51462263,2,,"<p>Before you embark on caching and other energy-intensive 'solutions', let's do some things to speed up the queries themselves.</p>&#xA;&#xA;<p><strong>Query 1</strong> (postmeta problem)</p>&#xA;&#xA;<p>The standard <code>wp_postmeta</code> has an inefficient schema.  This is better:</p>&#xA;&#xA;<pre><code>CREATE TABLE wp_postmeta (&#xA;    post_id BIGINT UNSIGNED NOT NULL,&#xA;    meta_key VARCHAR(255) NOT NULL,&#xA;    meta_value LONGTEXT NOT NULL,&#xA;    PRIMARY KEY(post_id, meta_key),&#xA;    INDEX(meta_key)&#xA;    ) ENGINE=InnoDB;&#xA;</code></pre>&#xA;&#xA;<p>See <a href=""http://mysql.rjweb.org/doc.php/index_cookbook_mysql#speeding_up_wp_postmeta"" rel=""nofollow noreferrer""><em>here</em></a> for explanation, what to do if you have 767 troubles, and how do deal with a requirement for <code>meta_id</code> (which is mostly useless).</p>&#xA;&#xA;<p>Those tips will speed up most queries involving <code>wp_postmeta</code>.</p>&#xA;&#xA;<p><strong>Query 2</strong> (bad formulation)</p>&#xA;&#xA;<ul>&#xA;<li><code>wp_posts.post_name = NULL</code> always fails; instead say <code>wp_posts.post_name IS NULL</code>.</li>&#xA;<li>Without an <code>ORDER BY</code>, <code>LIMIT</code> will deliver an arbitrary row.</li>&#xA;<li><code>OR</code> does not optimize well...</li>&#xA;</ul>&#xA;&#xA;<p>Rewrite thus:</p>&#xA;&#xA;<pre><code>SELECT * FROM &#xA;    ( ( SELECT ...&#xA;            FROM `wp_posts` AS `wp_posts`&#xA;            WHERE `wp_posts`.`id` = 176&#xA;              AND `wp_posts`.`post_status` = 'publish'&#xA;            LIMIT 1 )&#xA;      UNION DISTINCT&#xA;      ( SELECT ...&#xA;            FROM `wp_posts` AS `wp_posts`&#xA;            WHERE `wp_posts`.`post_name` IS NULL&#xA;              AND `wp_posts`.`post_status` = 'publish'&#xA;            LIMIT 1 )&#xA;    ) LIMIT 1&#xA;</code></pre>&#xA;&#xA;<p>And then these would be beneficial:</p>&#xA;&#xA;<pre><code>INDEX(post_status, post_id)&#xA;INDEX(post_status, post_name)&#xA;</code></pre>&#xA;&#xA;<p>If you add <code>ORDER BY</code>, it will need to be added in 3 places; just before each <code>LIMIT</code>.</p>&#xA;&#xA;<p>Before:  A full table scan of <code>wp_posts</code>.  After my suggestions: two very efficient, single-row fetches, plus figuring which of the 2 rows do deliver.</p>&#xA;",1766831,,1766831,2018-07-23 21:56:38,2018-07-23 21:56:38,"",,0,1,0,2018-07-23 21:42:21
51509990,1,51515251,,3,5382,"<p>I have a model <code>Location</code>, the relationship is with itself. </p>&#xA;&#xA;<pre><code>class Location extends Model&lt;Location&gt; {&#xA;    ...&#xA;&#xA;    @BelongsTo(() =&gt; Location, ""countryId"")&#xA;    public country?: Location;&#xA;&#xA;    @BelongsTo(() =&gt; Location, ""stateId"")&#xA;    public state?: Location;&#xA;&#xA;    @HasMany(() =&gt; Location, ""countryId"")&#xA;    public states?: Location[];&#xA;&#xA;    @HasMany(() =&gt; Location, ""stateId"")&#xA;    public regions?: Location[];&#xA;&#xA;    @HasMany(() =&gt; Location, ""regionId"")&#xA;    public places?: Location[];&#xA;&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So basically <code>counties</code> has many <code>states</code> has many <code>regions</code> and etc. <strong>I'd like to implement this as a <code>GraphQLType</code></strong>.</p>&#xA;&#xA;<p><strong>What have I tried:</strong></p>&#xA;&#xA;<pre><code>const LocationType = new GraphQLObjectType({&#xA;    name: ""LocationType"",&#xA;    fields: () =&gt; ({&#xA;        ...&#xA;        states: {type: new GraphQLList(LocationType)},&#xA;        ...&#xA;    }),&#xA;});&#xA;</code></pre>&#xA;&#xA;<p><strong>Error I get</strong></p>&#xA;&#xA;<blockquote>&#xA;  <p>'LocationType' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.</p>&#xA;</blockquote>&#xA;",6680253,,6680253,2018-07-25 02:38:22,2018-07-25 09:18:15,item does not have a type annotation and is referenced directly or indirectly in its own initializer,<typescript><graphql>,1,0,0,2018-07-25 02:28:14
51523319,1,,,2,534,"<p>I have the following resolver settings: </p>&#xA;&#xA;<pre><code>#set($questions = [])&#xA;#foreach($item in ${ctx.args.questions})&#xA;    #set($item.id = $util.dynamodb.toDynamoDBJson($util.autoId()))&#xA;    $util.qr($questions.add($util.dynamodb.toMapValues($item)))&#xA;#end&#xA;{&#xA;    ""version"" : ""2018-05-29"",&#xA;    ""operation"" : ""BatchPutItem"",&#xA;    ""tables"" : {&#xA;        ""QuestionTable"": $utils.toJson($questions)&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the following GraphQL schema: </p>&#xA;&#xA;<pre><code>input CreateQuestionInput {&#xA;    text: String&#xA;    sectionId: ID!&#xA;}&#xA;&#xA;input CreateScoreInput {&#xA;    score: Int!&#xA;    questionId: ID!&#xA;    userId: ID!&#xA;}&#xA;&#xA;input CreateSectionInput {&#xA;    title: String&#xA;    subSection: String&#xA;}&#xA;&#xA;input DeleteQuestionInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;input DeleteScoreInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;input DeleteSectionInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;type Mutation {&#xA;    ...&#xA;    createQuestion(input: CreateQuestionInput!): Question&#xA;    batchCreateQuestion(questions: [CreateQuestionInput]!): [Question]&#xA;&#xA;}&#xA;&#xA;type Query {&#xA;    getSection(id: ID!): Section&#xA;    listSections(filter: TableSectionFilterInput, limit: Int, nextToken: String): SectionConnection&#xA;    getScore(id: ID!): Score&#xA;    listScores(filter: TableScoreFilterInput, limit: Int, nextToken: String): ScoreConnection&#xA;    getQuestion(id: ID!): Question&#xA;    listQuestions(filter: TableQuestionFilterInput, limit: Int, nextToken: String): QuestionConnection&#xA;}&#xA;&#xA;type Question {&#xA;    id: ID!&#xA;    text: String&#xA;    sectionId: ID!&#xA;}&#xA;&#xA;type QuestionConnection {&#xA;    items: [Question]&#xA;    nextToken: String&#xA;}&#xA;&#xA;type Schema {&#xA;    query: Query&#xA;}&#xA;&#xA;type Score {&#xA;    id: ID!&#xA;    score: Int!&#xA;    questionId: ID!&#xA;    userId: ID!&#xA;}&#xA;&#xA;type ScoreConnection {&#xA;    items: [Score]&#xA;    nextToken: String&#xA;}&#xA;&#xA;type Section {&#xA;    id: ID!&#xA;    title: String&#xA;    subSection: String&#xA;    questions: [Question]&#xA;}&#xA;&#xA;type SectionConnection {&#xA;    items: [Section]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input TableQuestionFilterInput {&#xA;    id: TableIDFilterInput&#xA;    text: TableStringFilterInput&#xA;    sectionId: TableIDFilterInput&#xA;}&#xA;&#xA;input UpdateQuestionInput {&#xA;    id: ID!&#xA;    text: String&#xA;    sectionId: ID&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(I've redacted some of the schema as it was fairly large).</p>&#xA;&#xA;<p>When I attempt to run the query: </p>&#xA;&#xA;<pre><code>mutation BatchCreateQuestions($sec: ID!) {&#xA;  batchCreateQuestion(questions: [&#xA;    {&#xA;      text: ""Tester 1""&#xA;      sectionId: $sec&#xA;    },&#xA;    {&#xA;      text: ""Tester 2"",&#xA;      sectionId: $sec&#xA;    }&#xA;  ]) {&#xA;    id&#xA;    text&#xA;    sectionId&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>With the variables:</p>&#xA;&#xA;<pre><code>{ ""sec"": ""abc123"" }&#xA;</code></pre>&#xA;&#xA;<p>I get the response:</p>&#xA;&#xA;<pre><code>{&#xA;""data"": {&#xA;    ""batchCreateQuestion"": [&#xA;      null,&#xA;      null&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And when I check the DynamoDB table, it hasn't saved the values. I've granted full dynamodb permissions for this datasource, but still no joy.</p>&#xA;",1541609,,,,2018-07-25 16:49:46,AppSync batch insert to DynamoDB fails and returns null,<amazon-dynamodb><graphql><aws-appsync>,2,1,0,2018-07-25 16:04:23
51526079,1,51526694,,19,20992,"<p>Just like the post ask I need to be able to search with 3 possible scenarios. I need to have all uppercase, or lowercase, or normal casing. </p>&#xA;&#xA;<p>If that is not possible is there a way to do a case insensitive filter instead?</p>&#xA;&#xA;<pre><code>  allMarkdownRemark(filter: { brand: { eq: $normalBrand } }) { //==&gt; Need more here&#xA;        edges {&#xA;            node {&#xA;                webImages {&#xA;                    url&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>I found some people doing this:</p>&#xA;&#xA;<pre><code>filter: { OR: [&#xA;  {brand: { eq: $normalBrand }}, &#xA;  {brand: { eq: $normalBrand2 }}, &#xA;  {brand: { eq: $normalBrand3 }}&#xA;]}&#xA;</code></pre>&#xA;&#xA;<p>But it does not work for me</p>&#xA;",8551819,,21574,2019-04-19 21:42:34,2022-09-19 13:46:03,How to use OR / AND in graphql query filter or make a case insensitive filter?,<graphql><gatsby>,4,1,0,2018-07-25 19:10:45
51530499,1,,,20,23962,"<p>I'm using Apollo Client's <code>&lt;Query&gt;</code> within a component that is re-rendered when state is changed within a lifecycle method. I wish to have my <code>&lt;Query&gt;</code> component re-run the query because I know that data has changed.&#xA;It appears that Query component is using a cache that needs to be invalidated before query is re-run.</p>&#xA;&#xA;<p>I'm using a wonky workaround that caches the <code>refetch</code> callback from the render prop in the parent component, but it feels wrong. I'll post my approach in the answers if anyone is interested.</p>&#xA;&#xA;<p>My code looks something like this. I removed <code>loading</code> and <code>error</code> handling from query as well as some other detail for brevity.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class ParentComponent extends React.Component {&#xA;  componentDidUpdate(prevProps) {&#xA;    if (this.props.refetchId !== prevProps.refetchId) {&#xA;      const otherData = this.processData() // do something&#xA;      this.setState({otherData}) // this forces component to reload&#xA;    }&#xA;  }&#xA;&#xA;  render() {&#xA;    const { otherData } = this.state&#xA;&#xA;    return (&#xA;      &lt;Query query={MY_QUERY}&gt;&#xA;        {({ data }) =&gt; {&#xA;          return &lt;ChildComponent gqlData={data} stateData={otherData} /&gt;&#xA;        }}&#xA;      &lt;/Query&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>How do I force <code>&lt;Query&gt;</code> to fetch new data to pass to <code>&lt;ChildComponent&gt;</code>?</strong> </p>&#xA;&#xA;<p>Even though <code>ParentComponent</code> re-renders when props or state change, <code>Query</code> doesn't re-run. <code>ChildComponent</code> gets an updated <code>stateData</code> prop, but has a stale <code>gqlData</code> prop. As I understand Apollo's query cache need to be invalidated, but I'm not sure.</p>&#xA;&#xA;<p>Please note that passing <code>refetch</code> to ChildComponent is not the answer because it only displays information from GraphQL and wouldn't know when to refetch. I don't want to introduce timers or otherwise complicate <code>ChildComponent</code> to solve this - it doesn't need to know about this complexity or data fetching concerns.</p>&#xA;",68672,,1573859,2018-07-26 12:23:03,2020-12-01 12:55:13,How to force Apollo Query component to re-run query when parent component re-renders,<reactjs><graphql><react-apollo><apollo-client>,5,1,0,2018-07-26 03:18:59
51538532,2,,51530499,2,,"<p>It seems to me that the Query component doesn't necessarily need to be inside this <code>ParentComponent</code>.</p>&#xA;&#xA;<p>In that case, I would move the Query component up, since I would still be able to render other stuff while I don't have results in the <code>ChildComponent</code>. And then I would have access to the <a href=""https://www.apollographql.com/docs/react/essentials/queries.html#refetching"" rel=""nofollow noreferrer""><code>query.refetch</code></a> method.</p>&#xA;&#xA;<p>Note that in the example I added the <code>graphql</code> hoc, but you can still use Query component around <code>&lt;ParentComponent /&gt;</code>.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class ParentComponent extends React.Component {&#xA;    componentDidUpdate(prevProps) {&#xA;        if (this.props.refetchId !== prevProps.refetchId) {&#xA;            const otherData = this.processData() // do something&#xA;&#xA;            //   won't need this anymore, since refetch will cause the Parent component to rerender)&#xA;            //   this.setState({otherData}) // this forces component to reload &#xA;&#xA;            this.props.myQuery.refetch(); // &gt;&gt;&gt; Refetch here!&#xA;        }&#xA;    }&#xA;&#xA;    render() {&#xA;        const {&#xA;            otherData&#xA;        } = this.state;&#xA;&#xA;        return &lt;ChildComponent gqlData={this.props.myQuery} stateData={otherData} /&gt;;&#xA;    }&#xA;}&#xA;&#xA;export graphql(MY_QUERY, {&#xA;    name: 'myQuery'&#xA;})(ParentComponent);&#xA;</code></pre>&#xA;",1573859,,,,2018-07-26 12:09:37,"",,0,2,0,2018-07-26 12:09:37
51548795,1,,,4,1740,"<p>I have an AppSync api set-up, with a specific mutation set-up. Which works fine when I test that mutation in AppSync. However when I try to use the same query in a react app, I'm getting a null value. However when I look in the network tab in my browser, the correct data is being returned from AppSync. </p>&#xA;&#xA;<p>I have the following mutation in my React app: </p>&#xA;&#xA;<pre><code>import gql from 'graphql-tag';&#xA;&#xA;export default gql`&#xA;mutation CreateUser(&#xA;  $email: String!,&#xA;  $name: String&#xA;) {&#xA;  createUser(input: {&#xA;    email: $email&#xA;    name: $name&#xA;  }) {&#xA;    __typename&#xA;    id&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>My React component (slightly redacted for brevity):</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import MutationCreateUser from '../GraphQL/MutationCreateUser';&#xA;import { graphql } from ""react-apollo"";&#xA;&#xA;class UserForm extends Component {&#xA;&#xA;  state = {&#xA;    name: '',&#xA;    email: '',&#xA;    ... &#xA;    err: null&#xA;  }&#xA;&#xA;  ...&#xA;&#xA;  submit = async () =&gt; {&#xA;    const { createUser, history } = this.props;&#xA;    const user = this.state;&#xA;    try {&#xA;      const result = await createUser({&#xA;        name: user.name,&#xA;        email: user.email&#xA;      });&#xA;      // This shows { ""data"": { ""createUser"": ""null"" } }&#xA;      console.log('RES', result);&#xA;    } catch (e) {&#xA;      this.setState({ err: e.message });&#xA;    }&#xA;    ... &#xA;  }&#xA;  ... &#xA;}&#xA;&#xA;export default graphql(&#xA;  MutationCreateUser,&#xA;  {&#xA;    props: ({ mutate }) =&gt; {&#xA;      return {&#xA;        createUser: (user) =&gt; {          &#xA;          return mutate({&#xA;            variables: user&#xA;          });&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;)(UserForm);&#xA;</code></pre>&#xA;&#xA;<p>When I inspect the query in the network tab, I see:&#xA;<code>&#xA;{""data"":{""createUser"":{""__typename"":""User"",""id"":""860b7cec-e882-4242-aca0-d4865154b640""}}}&#xA;</code></p>&#xA;&#xA;<p>However, in my React component, I see:&#xA;<code>&#xA;{ ""data"": { ""createUser"": ""null"" } }&#xA;</code></p>&#xA;&#xA;<p>I'm not sure if I'm missing something around how the component is set-up with Apollo which means the data isn't being loaded proprely. But the query itself seems to work fine.</p>&#xA;&#xA;<p>The data is also correctly stored in DynamoDB as expected.</p>&#xA;&#xA;<p>Here is my request mapping:</p>&#xA;&#xA;<pre><code>{&#xA;  ""version"": ""2017-02-28"",&#xA;  ""operation"": ""PutItem"",&#xA;  ""key"": {&#xA;    ""id"": $util.dynamodb.toDynamoDBJson($util.autoId()),&#xA;  },&#xA;  ""attributeValues"": $util.dynamodb.toMapValuesJson($ctx.args.input),&#xA;  ""condition"": {&#xA;    ""expression"": ""attribute_not_exists(#id)"",&#xA;    ""expressionNames"": {&#xA;      ""#id"": ""id"",&#xA;    },&#xA;  },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My response mapping:</p>&#xA;&#xA;<pre><code>$util.toJson($ctx.result)&#xA;</code></pre>&#xA;&#xA;<p>And finally my schema:</p>&#xA;&#xA;<pre><code>input CreateQuestionInput {&#xA;    text: String!&#xA;    sectionId: ID!&#xA;}&#xA;&#xA;input CreateScoreInput {&#xA;    score: Int!&#xA;    questionId: ID!&#xA;    userId: ID!&#xA;}&#xA;&#xA;input CreateSectionInput {&#xA;    title: String&#xA;    subSection: String&#xA;}&#xA;&#xA;input CreateUserInput {&#xA;    email: String!&#xA;    name: String&#xA;    jobTitle: String&#xA;    jobTitleShare: Boolean&#xA;    department: String&#xA;    level: Int&#xA;    yearRange: Int&#xA;    industry: String&#xA;    orgSize: Int&#xA;}&#xA;&#xA;input DeleteQuestionInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;input DeleteScoreInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;input DeleteSectionInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;input DeleteUserInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;type Mutation {&#xA;    createSection(input: CreateSectionInput!): Section&#xA;    updateSection(input: UpdateSectionInput!): Section&#xA;    deleteSection(input: DeleteSectionInput!): Section&#xA;    createScore(input: CreateScoreInput!): Score&#xA;    updateScore(input: UpdateScoreInput!): Score&#xA;    deleteScore(input: DeleteScoreInput!): Score&#xA;    createQuestion(input: CreateQuestionInput!): Question&#xA;    updateQuestion(input: UpdateQuestionInput!): Question&#xA;    deleteQuestion(input: DeleteQuestionInput!): Question&#xA;    batchCreateQuestion(questions: [CreateQuestionInput]!): [Question]&#xA;    createUser(input: CreateUserInput!): User&#xA;    updateUser(input: UpdateUserInput!): User&#xA;    deleteUser(input: DeleteUserInput!): User&#xA;}&#xA;&#xA;type Query {&#xA;    getSection(id: ID!): Section&#xA;    listSections(filter: TableSectionFilterInput, limit: Int, nextToken: String): SectionConnection&#xA;    getScore(id: ID!): Score&#xA;    listScores(filter: TableScoreFilterInput, limit: Int, nextToken: String): ScoreConnection&#xA;    getQuestion(id: ID!): Question&#xA;    listQuestions(filter: TableQuestionFilterInput, limit: Int, nextToken: String): QuestionConnection&#xA;    getUser(id: ID!): User&#xA;    listUsers(filter: TableUserFilterInput, limit: Int, nextToken: String): UserConnection&#xA;}&#xA;&#xA;type Question {&#xA;    id: ID!&#xA;    text: String!&#xA;    sectionId: ID!&#xA;}&#xA;&#xA;type QuestionConnection {&#xA;    items: [Question]&#xA;    nextToken: String&#xA;}&#xA;&#xA;type Schema {&#xA;    query: Query&#xA;}&#xA;&#xA;type Score {&#xA;    id: ID!&#xA;    score: Int!&#xA;    questionId: ID!&#xA;    userId: ID!&#xA;}&#xA;&#xA;type ScoreConnection {&#xA;    items: [Score]&#xA;    nextToken: String&#xA;}&#xA;&#xA;type Section {&#xA;    id: ID!&#xA;    title: String&#xA;    subSection: String&#xA;    questions: [Question]&#xA;}&#xA;&#xA;type SectionConnection {&#xA;    items: [Section]&#xA;    nextToken: String&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateSection(id: ID, title: String): Section&#xA;        @aws_subscribe(mutations: [""createSection""])&#xA;    onUpdateSection(id: ID, title: String): Section&#xA;        @aws_subscribe(mutations: [""updateSection""])&#xA;    onDeleteSection(id: ID, title: String): Section&#xA;        @aws_subscribe(mutations: [""deleteSection""])&#xA;    onCreateScore(&#xA;        id: ID,&#xA;        score: Int,&#xA;        questionId: ID,&#xA;        userId: ID&#xA;    ): Score&#xA;        @aws_subscribe(mutations: [""createScore""])&#xA;    onUpdateScore(&#xA;        id: ID,&#xA;        score: Int,&#xA;        questionId: ID,&#xA;        userId: ID&#xA;    ): Score&#xA;        @aws_subscribe(mutations: [""updateScore""])&#xA;    onDeleteScore(&#xA;        id: ID,&#xA;        score: Int,&#xA;        questionId: ID,&#xA;        userId: ID&#xA;    ): Score&#xA;        @aws_subscribe(mutations: [""deleteScore""])&#xA;    onCreateQuestion(id: ID, text: String, sectionId: ID): Question&#xA;        @aws_subscribe(mutations: [""createQuestion""])&#xA;    onUpdateQuestion(id: ID, text: String, sectionId: ID): Question&#xA;        @aws_subscribe(mutations: [""updateQuestion""])&#xA;    onDeleteQuestion(id: ID, text: String, sectionId: ID): Question&#xA;        @aws_subscribe(mutations: [""deleteQuestion""])&#xA;    onCreateUser(&#xA;        id: ID,&#xA;        email: String,&#xA;        jobTitle: String,&#xA;        jobTitleShare: Boolean,&#xA;        department: String&#xA;    ): User&#xA;        @aws_subscribe(mutations: [""createUser""])&#xA;    onUpdateUser(&#xA;        id: ID,&#xA;        email: String,&#xA;        jobTitle: String,&#xA;        jobTitleShare: Boolean,&#xA;        department: String&#xA;    ): User&#xA;        @aws_subscribe(mutations: [""updateUser""])&#xA;    onDeleteUser(&#xA;        id: ID,&#xA;        email: String,&#xA;        jobTitle: String,&#xA;        jobTitleShare: Boolean,&#xA;        department: String&#xA;    ): User&#xA;        @aws_subscribe(mutations: [""deleteUser""])&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableQuestionFilterInput {&#xA;    id: TableIDFilterInput&#xA;    text: TableStringFilterInput&#xA;    sectionId: TableIDFilterInput&#xA;}&#xA;&#xA;input TableScoreFilterInput {&#xA;    id: TableIDFilterInput&#xA;    score: TableIntFilterInput&#xA;    questionId: TableIDFilterInput&#xA;    userId: TableIDFilterInput&#xA;}&#xA;&#xA;input TableSectionFilterInput {&#xA;    id: TableIDFilterInput&#xA;    title: TableStringFilterInput&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input TableUserFilterInput {&#xA;    id: TableIDFilterInput&#xA;    email: TableStringFilterInput&#xA;    jobTitle: TableStringFilterInput&#xA;    jobTitleShare: TableBooleanFilterInput&#xA;    department: TableStringFilterInput&#xA;    level: TableIntFilterInput&#xA;    yearRange: TableIntFilterInput&#xA;    industry: TableStringFilterInput&#xA;    orgSize: TableIntFilterInput&#xA;}&#xA;&#xA;input UpdateQuestionInput {&#xA;    id: ID!&#xA;    text: String&#xA;    sectionId: ID&#xA;}&#xA;&#xA;input UpdateScoreInput {&#xA;    id: ID!&#xA;    score: Int&#xA;    questionId: ID&#xA;    userId: ID&#xA;}&#xA;&#xA;input UpdateSectionInput {&#xA;    id: ID!&#xA;    title: String&#xA;}&#xA;&#xA;input UpdateUserInput {&#xA;    id: ID!&#xA;    email: String&#xA;    jobTitle: String&#xA;    jobTitleShare: Boolean&#xA;    department: String&#xA;    level: Int&#xA;    yearRange: Int&#xA;    industry: String&#xA;    orgSize: Int&#xA;}&#xA;&#xA;type User {&#xA;    id: ID!&#xA;    email: String&#xA;    jobTitle: String&#xA;    jobTitleShare: Boolean&#xA;    department: String&#xA;    level: Int&#xA;    yearRange: Int&#xA;    industry: String&#xA;    orgSize: Int&#xA;}&#xA;&#xA;type UserConnection {&#xA;    items: [User]&#xA;    nextToken: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The request works in AppSync:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/mZQxe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mZQxe.png"" alt=""enter image description here""></a></p>&#xA;",1541609,,640607,2019-07-02 23:20:36,2019-07-02 23:20:36,Graphql apollo client returning null value from AppSync,<reactjs><amazon-web-services><graphql><aws-appsync>,1,0,0,2018-07-26 23:26:39
51586400,2,,51586181,0,,"<p>its cool i got it. just use <code>**update**TestMutate(..)</code> instead of <code>addTestMutate</code> like so:</p>&#xA;&#xA;<pre><code>mutation {&#xA;    updateTestMutate(input: {uuid: ""abc123"", roundType: {id: ""234dfg345dfg345""}}) {&#xA;    uuid&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2409057,,,,2018-07-30 02:48:24,"",,0,0,0,2018-07-30 02:48:24
51602361,2,,51602305,17,,"<p>Subscriptions require the parameter you're filtering on to be in the response of the mutation. Could you try updating your mutation to this?</p>&#xA;&#xA;<pre><code>mutation mut{&#xA;  testSubMutation(param:""123"") {&#xA;    param&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1229845,,,,2018-07-30 21:12:29,"",,0,5,0,2018-07-30 21:12:29
51608768,1,,,2,737,"<p>The routine of working with the graphql apollo is that add file query .graphql</p>&#xA;&#xA;<p>i would create dynamic query with <strong>java</strong> and i do not create file for each query</p>&#xA;&#xA;<p>example querys :</p>&#xA;&#xA;<p>one : </p>&#xA;&#xA;<pre><code>query EntryDetailQuery($repoFullName: String!) {&#xA;  entry(repoFullName: $repoFullName) {&#xA;    id&#xA;    repository {&#xA;      full_name&#xA;      description&#xA;      owner {&#xA;          login&#xA;      }&#xA;    }&#xA;    postedBy {&#xA;      login&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>two : </p>&#xA;&#xA;<p>just request full_name </p>&#xA;&#xA;<pre><code>query EntryDetailQuery($repoFullName: String!) {&#xA;  entry(repoFullName: $repoFullName) {&#xA;    id&#xA;    repository {&#xA;      full_name&#xA;&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>in fact, i would to get dynamic querys with <strong>Java</strong></p>&#xA;</blockquote>&#xA;&#xA;<p>is it possible?</p>&#xA;",6056489,,6056489,2018-07-31 08:31:26,2020-04-20 19:25:05,dynamic query graphql apollo with java,<java><android><graphql><apollo-client>,1,1,0,2018-07-31 08:26:16
51624567,2,,51586881,0,,"<p>Assuming that you have an array with accessible dates you could group them with a little helper function.</p>&#xA;&#xA;<pre><code>const list = ['2018-08-12', '2018-07-12', '2017-08-12'];&#xA;&#xA;const groupedList = list.reduce((acc, item) =&gt; {&#xA;  const year = item.split('-')[0];&#xA;&#xA;  if (!acc[year]) {&#xA;    acc[year] = []&#xA;  }&#xA;&#xA;  acc[year].push(item);&#xA;  return acc;&#xA;}, {});&#xA;</code></pre>&#xA;&#xA;<p>Which would result in an object including keys for every year.</p>&#xA;&#xA;<p>I'm not sure this possible with a GraphQL query.</p>&#xA;&#xA;<p>Also in case you're relying on the publish date in contentful that's a little risky because I think it changes when content is updated to the last publish date (please double check). It might make sense to split it into its own content type so that you can set the date yourself and be sure.</p>&#xA;&#xA;<p>Hope that helps. :)</p>&#xA;",4253183,,,,2018-08-01 02:24:50,"",,0,0,0,2018-08-01 02:24:50
51641949,2,,51622290,0,,"<p>The issue is in the KeySchema of the GlobalSecondaryIndex.</p>&#xA;&#xA;<p>Instead of <code>KeyType: 'SORT'</code> it should be <code>KeyType: 'RANGE'</code></p>&#xA;&#xA;<p>AWS Documentation doesn't help much with this, as they always refer to it as <code>sort key</code> but you must declare the type as <code>range</code>.</p>&#xA;",786704,,,,2018-08-01 20:40:57,"",,0,0,0,2018-08-01 20:40:57
51662479,1,,,1,146,"<p>I have a basic query to obtain information about some issues.</p>&#xA;&#xA;<pre><code>query getIssues($owner: String!, $repo: String!, $milestoneId: Int!, $cursor:String) {&#xA;  repository(owner: $owner, name: $repo) {&#xA;    milestone(number: $milestoneId) {&#xA;      title&#xA;      issues(first: 100, after:$cursor) {&#xA;        totalCount&#xA;        edges {&#xA;          node {&#xA;            title&#xA;            state&#xA;            createdAt&#xA;            closedAt&#xA;          }&#xA;        }&#xA;        pageInfo&#xA;        {&#xA;          hasNextPage&#xA;          endCursor&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When I use the arguments : </p>&#xA;&#xA;<pre><code>{""owner"": ""Me"", ""repo"": ""MyRepo"", ""milestoneId"": 1, ""cursor"": null}&#xA;</code></pre>&#xA;&#xA;<p>I receive information about the first 100 issues. There's a <code>totalCount</code> of 213, the <code>paginationInfo</code> tells me that there's another page and gives me a cursor to go to the next page.</p>&#xA;&#xA;<p>When I do another query with the field <code>$cursor</code> replaced to the value of the cursor that was given by <code>endCursor</code>. I receive this as an answer :</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""repository"": {&#xA;      ""milestone"": {&#xA;        ""title"": ""MilestoneName"",&#xA;        ""issues"": {&#xA;          ""totalCount"": 213,&#xA;          ""edges"": [],&#xA;          ""pageInfo"": {&#xA;            ""hasNextPage"": false,&#xA;            ""endCursor"": null&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there an additional step to get pagination with cursor to work?</p>&#xA;",4048657,,,,2018-08-02 21:35:20,"GitHub GraphQL api says there's another page, but when using a cursor no results are found",<graphql><github-api>,0,0,0,2018-08-02 21:35:20
51702449,2,,51702131,3,,"<p>This did the trick:</p>&#xA;&#xA;<p>sort: { fields: [date], order: DESC }</p>&#xA;&#xA;<p>I found it in a <a href=""https://github.com/contentful-userland/gatsby-contentful-starter"" rel=""nofollow noreferrer"">Gatsby-Contentful-Starter</a>; I had the false impression the syntax needs to be something like fieldName___argumentByWichToSort</p>&#xA;",5288970,,,,2018-08-06 07:21:49,"",,0,2,0,2018-08-06 07:21:49
51790441,2,,51737165,0,,<p>My guess is that the argument <code>email: $email</code> should be wrapped in an input object like this:</p>&#xA;&#xA;<pre><code>input: {&#xA;  email: $email&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I personally don't use relay's mutation helper function.</p>&#xA;,5459695,,,,2018-08-10 16:16:46,"",,0,0,0,2018-08-10 16:16:46
51791799,1,51797211,,1,750,"<p>Recently I was trying to an implementation of a Mutation Request using GoLang as a Graphql Server, Basically this is the query that i send: As you can see its an array of object that contains <strong>name</strong> and an <strong>array of strings</strong></p>&#xA;&#xA;<pre><code>mutation{&#xA;    CellTest(cells:[{name:""lero"",child:[""1"",""2""]},{name:""lero2"",child:[""12"",""22""]}]){&#xA;            querybody&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In my Go code I have a type object that is gonna set the values sent</p>&#xA;&#xA;<pre><code>type Cell struct {&#xA;    name  string   `json:""name""`&#xA;    child []string `json:""child""`&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and a custom array that is gonna be []Cell</p>&#xA;&#xA;<pre><code>type Cells []*Cell&#xA;</code></pre>&#xA;&#xA;<p>However when the request is received by GO I get this:&#xA;Note that this is the print of <strong>cellsInterface</strong></p>&#xA;&#xA;<blockquote>&#xA;  <p>[map[child:[1 2] name:lero] map[child:[12 22] name:lero2]]</p>&#xA;</blockquote>&#xA;&#xA;<p>How can i get each value and assign those in my <strong>Array Cells</strong>&#xA;something like this:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Cells[0] = {name=""first"",child={""1"",""2""}}</p>&#xA;  &#xA;  <p>Cells[1] = {name=""second"",child={""hello"",""good""}}</p>&#xA;</blockquote>&#xA;&#xA;<p>this is my current attempt:</p>&#xA;&#xA;<pre><code>var resolvedCells Cells&#xA;cellsInterface := params.Args[""cells""].([]interface{})&#xA;cellsByte, err := json.Marshal(cellsInterface)&#xA;if err != nil {&#xA;    fmt.Println(""marshal the input json"", err)&#xA;    return resolvedCells, err&#xA;}&#xA;&#xA;if err := json.Unmarshal(cellsByte, &amp;resolvedCells); err != nil {&#xA;    fmt.Println(""unmarshal the input json to Data.Cells"", err)&#xA;    return resolvedCells, err&#xA;}&#xA;&#xA;for cell := range resolvedCells {&#xA;    fmt.Println(cellsInterface[cell].([]interface{}))&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However this only split the cells array into 0 and 1.</p>&#xA;",6582127,,5821354,2018-08-11 19:04:08,2018-08-11 19:04:08,Golang graphql iterate over map with submap,<arrays><json><go><struct><graphql>,1,5,0,2018-08-10 17:58:23
51797211,2,,51791799,1,,"<p>Range through the map values in the result and append those values to Cell slice. If you are getting an object from json. Then you can unmarshall the bytes into Cell.</p>&#xA;&#xA;<p>The result when unmarshalling should be a slice of Cell struct as</p>&#xA;&#xA;<pre><code>var resolvedCells []Cell&#xA;if err := json.Unmarshal(cellsByte, &amp;resolvedCells); err != nil {&#xA;                fmt.Println(""unmarshal the input json to Data.Cells"", err)&#xA;    }&#xA;fmt.Println(resolvedCells)&#xA;</code></pre>&#xA;&#xA;<p>Working Code on <a href=""https://play.golang.org/p/aRXD9FGn1d4"" rel=""nofollow noreferrer"">Go playground</a></p>&#xA;&#xA;<p>Or if you want to use pointers loop over the resolvedCell as</p>&#xA;&#xA;<pre><code>type Cells []*Cell&#xA;&#xA;func main() {&#xA;    var resolvedCells Cells&#xA;    if err := json.Unmarshal(cellsByte, &amp;resolvedCells); err != nil {&#xA;                    fmt.Println(""unmarshal the input json to Data.Cells"", err)&#xA;        }&#xA;    fmt.Println(*resolvedCells[1])&#xA;    for _, value := range resolvedCells{&#xA;        fmt.Println(value)&#xA;        fmt.Printf(""%+v"",value.Child) // access child struct value of array&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://play.golang.org/p/cHJrNy2XrA_f"" rel=""nofollow noreferrer"">Playground example</a></p>&#xA;",5821354,,5821354,2018-08-11 18:58:04,2018-08-11 18:58:04,"",,0,7,0,2018-08-11 06:47:39
51815874,2,,51805890,9,,"<p>GraphQL as a query language on the front-end does not support 'joins' in the classic SQL sense. </p>&#xA;&#xA;<p>Rather, it allows you to pick and choose which fields in a particular model you want to fetch for your component.</p>&#xA;&#xA;<p>To query all phones in your dataset, your query would look like this:</p>&#xA;&#xA;<pre><code>query myComponentQuery {&#xA;  phone {&#xA;    id&#xA;    brand&#xA;    model&#xA;    price&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The GraphQL server that your front-end is querying would then have individual field resolvers - telling GraphQL where to fetch id, brand, model etc.</p>&#xA;&#xA;<p>The server-side resolver would look something like this:</p>&#xA;&#xA;<pre><code>Phone: {&#xA;  id(root, args, context) {&#xA;    pg.query('Select * from Phones where name = ?', ['blah']).then(d =&gt; {/*doStuff*/})&#xA;    //OR&#xA;    fetch(context.upstream_url + '/thing/' + args.id).then(d =&gt; {/*doStuff*/})&#xA;&#xA;    return {/*the result of either of those calls here*/}&#xA;  },&#xA;  price(root, args, context) {&#xA;    return 9001&#xA;  },&#xA;},&#xA;</code></pre>&#xA;",5175932,,,,2018-08-13 05:50:47,"",,0,1,0,2018-08-13 05:50:47
51833587,1,,,1,617,"<p>I want to show the loader only when a certain period of time has elapsed. Apollo does provide a <code>loading</code> property but it'd show the loader instantaneously.</p>&#xA;&#xA;<p>I was thinking of hacking something together using <code>componentWillReceiveProps</code> but if there's a more idiomatic way of doing this, I'd be more than happy to use that.</p>&#xA;",5241520,,,,2018-08-14 06:19:31,"How to implement ""delayed loader"" using apollo-client?",<reactjs><graphql><apollo><react-apollo>,1,0,0,2018-08-14 04:11:04
51834260,2,,51833270,1,,"<p>You need implement your graphql <code>resolver</code> in server-side. It decide what result you will get.</p>&#xA;&#xA;<p>In <code>resolver</code> function, your can get the arguments you passed from client. </p>&#xA;&#xA;<p>For your question, I think you need implement a <code>pagination</code> </p>&#xA;&#xA;<p>See these links:</p>&#xA;&#xA;<p><a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">https://graphql.org/learn/pagination/</a> </p>&#xA;&#xA;<p><a href=""https://www.apollographql.com/docs/react/features/pagination.html"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/features/pagination.html</a></p>&#xA;&#xA;<p><a href=""https://github.com/mrdulin/apollo-server-express-starter/tree/master/src/pagination"" rel=""nofollow noreferrer"">https://github.com/mrdulin/apollo-server-express-starter/tree/master/src/pagination</a></p>&#xA;",6463558,,,,2018-08-14 05:27:43,"",,0,0,0,2018-08-14 05:27:43
51852773,2,,51683790,0,,"<p>While I'm not sure how the hash is calculated exactly (I suspect some combination of the contents of the fragments in the component and the schema definitions) it does use this hash to determine if a warning should be displayed if the compiled Relay files (<code>.graphql.js</code>) are not up to date with the <code>schema.graphql</code>/<code>schema.json</code> definitions.</p>&#xA;&#xA;<p>In summary, not a security risk, it is instead used to display a helpful warning message when developing an application using Relay when files are out of date.</p>&#xA;",151433,,,,2018-08-15 04:02:50,"",,0,0,0,2018-08-15 04:02:50
51863657,1,,,0,2804,"<p>I am trying to perform a query using the in operator where the criteria is based on values in an array.  How can I perform the query below to take an array and base its in criteria off a variable array?  I am using reactjs + gatsby.</p>&#xA;&#xA;<pre><code>... graphql`&#xA;      query pageHeader {&#xA;         .... there is another query in the real code above this line&#xA;         allContentInSites (filter: {slug: {in: ` + JSON.stringify(searchCriteria.map(item =&gt; item.value)) + ` }})  {&#xA;          edges {&#xA;            node {&#xA;              title,&#xA;              link&#xA;            }&#xA;          }&#xA;        }&#xA;      }'&#xA;</code></pre>&#xA;&#xA;<p>I was initially thinking the sample code above would pass a json string object for the in criteria but this seems to break the page.</p>&#xA;",1790300,,,,2018-08-15 21:00:26,graphql: querying with dynamic filtering criteria,<reactjs><graphql><gatsby>,2,0,0,2018-08-15 17:34:08
51889909,1,,,0,504,"<p>I suppose it's because it's relatively new, but it's been such a pain working out what's a bug and what's actually an error in Apollo. </p>&#xA;&#xA;<p>I've created a fragment called 'EventFragment', which I'd like to spread into 2 other fragments. </p>&#xA;&#xA;<p>It works fine provided it's only in one, but as soon as it's in more than one, I get the error ""There can be only one fragment named EventFragment"" which, obviously there isn't.  </p>&#xA;&#xA;<p>Is this a bug, or can I actually only use a fragment in one other context?</p>&#xA;&#xA;<pre><code>    import gql from 'graphql-tag'&#xA;&#xA;    export const EventFragment = gql`&#xA;        fragment EventFragment on Event {&#xA;            id&#xA;            createdAt&#xA;            updatedAt&#xA;            deletedAt&#xA;            title&#xA;            description&#xA;            type&#xA;            date&#xA;            isSystem&#xA;            addedBy {&#xA;                id&#xA;                firstName&#xA;                lastName&#xA;            }&#xA;            liability {&#xA;                id&#xA;                loan {&#xA;                    id&#xA;                    name&#xA;                }&#xA;            }&#xA;            isRepeating&#xA;            repeatNumber&#xA;            repeatUnit&#xA;            files {&#xA;                id&#xA;                createdAt&#xA;                updatedAt&#xA;                deletedAt&#xA;                filename&#xA;            }&#xA;            company {&#xA;                id&#xA;            }&#xA;            person {&#xA;                id&#xA;            }&#xA;        }&#xA;    `&#xA;&#xA;    export const LiabilityFragment = gql`&#xA;        fragment LiabilityFragment on Liability {&#xA;            id&#xA;            createdAt&#xA;            updatedAt&#xA;            deletedAt&#xA;            name&#xA;            isFixed&#xA;            loanTerm&#xA;            interestOnlyTerm&#xA;            startDate&#xA;            financePurpose&#xA;            limit&#xA;            amount&#xA;            initialBalance&#xA;            repaymentAmount&#xA;            repaymentFrequency&#xA;            discountPercent&#xA;            bankAccountName&#xA;            bankAccountBsb&#xA;            bankAccountNumber&#xA;            assets {&#xA;                id&#xA;                deletedAt&#xA;                name&#xA;                address {&#xA;                    id&#xA;                    address&#xA;                }&#xA;            }&#xA;            people {&#xA;                id&#xA;                percent&#xA;                person {&#xA;                    id&#xA;                    firstName&#xA;                    lastName&#xA;                    deletedAt&#xA;                }&#xA;            }&#xA;            companies {&#xA;                id&#xA;                percent&#xA;                company {&#xA;                    id&#xA;                    name&#xA;                    deletedAt&#xA;                }&#xA;            }&#xA;            loan {&#xA;                id&#xA;                name&#xA;            }&#xA;            events {&#xA;                ...EventFragment&#xA;            }&#xA;        }&#xA;        ${EventFragment}&#xA;    `&#xA;&#xA;    export const PersonFragment = gql`&#xA;        fragment PersonFragment on Person {&#xA;            id&#xA;            createdAt&#xA;            updatedAt&#xA;            title&#xA;            firstName&#xA;            middleName&#xA;            lastName&#xA;            preferredName&#xA;            previousName&#xA;            address {&#xA;                id&#xA;                offPlan&#xA;                level&#xA;                building&#xA;                unitNumber&#xA;                address&#xA;            }&#xA;            dateOfBirth&#xA;            gender&#xA;            maritalStatus&#xA;            email&#xA;            phonePreference&#xA;            phoneHome&#xA;            phoneWork&#xA;            phoneMobile&#xA;            phoneFax&#xA;            actingOnTrust&#xA;            trustName&#xA;            dependants {&#xA;                id&#xA;                name&#xA;                age&#xA;            }&#xA;            liabilities {&#xA;                id&#xA;                percent&#xA;                deletedAt&#xA;                personRelation {&#xA;                    ...LiabilityFragment&#xA;                }&#xA;                companyRelation {&#xA;                    ...LiabilityFragment&#xA;                }&#xA;            }&#xA;            assets {&#xA;                id&#xA;                percent&#xA;                deletedAt&#xA;                personRelation {&#xA;                    ...AssetFragment&#xA;                }&#xA;                companyRelation {&#xA;                    ...AssetFragment&#xA;                } &#xA;            }&#xA;            events {&#xA;                ...EventFragment&#xA;            }&#xA;        }&#xA;        ${LiabilityFragment}&#xA;        ${AssetFragment}&#xA;        ${EventFragment}&#xA;    `&#xA;</code></pre>&#xA;",6448335,,,,2018-08-17 06:54:53,Can't use a fragment in more than one other fragment...?,<graphql><apollo><react-apollo><graphql-js>,0,3,0,2018-08-17 06:54:53
51905699,1,,,4,880,"<p>I have two react components the child component uses Apollo client for GraphQL which wraps the child component as higher order component. I want to access the child class method using reference to execute child method in parent class but when I use ref I get Graphql object instead of react child component. My code sample looks like this.  </p>&#xA;&#xA;<p><strong>Note:</strong><br>&#xA;this question is not a duplicate of<br>&#xA;<a href=""https://stackoverflow.com/questions/39041710/react-js-change-child-components-state-from-parent-component"">React js change child component's state from parent component&#xA;</a><br>&#xA;<strong>OR</strong><br>&#xA;<a href=""https://stackoverflow.com/questions/49558824/access-child-state-of-child-from-parent-component-in-react"">Access child state of child from parent component in react&#xA;</a><br>&#xA;<strong>Because</strong><br>&#xA;They don't use GraphQL Apollo Client)</p>&#xA;&#xA;<p><strong>Parent Component</strong>  </p>&#xA;&#xA;<pre><code>import React, {Component} from 'react';&#xA;&#xA;import ""./Child"";&#xA;class Parent extends Component{&#xA;    state={&#xA;&#xA;    };&#xA;    executeSomeChildFunction = () =&gt;{&#xA;        /* console.log(this.myChild); */&#xA;        this.myChild.childFunction();&#xA;    };&#xA;    render(){&#xA;        return(&#xA;            &lt;div&gt;&#xA;                &lt;button onclick={this.executeSomeChildFunction}&gt;&#xA;                     Click To Execute Child Function&#xA;                &lt;/button&gt;&#xA;                &lt;Child ref={el=&gt; this.myChild =el} /&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    };&#xA;}&#xA;&#xA;export default Parent;   &#xA;</code></pre>&#xA;&#xA;<p><strong>Child Component</strong>  </p>&#xA;&#xA;<pre><code>import React, {Component} from 'react';&#xA;&#xA;const myQuery = `query DriversQuery() {&#xA;    drivers: { &#xA;        edges{ &#xA;           node{ &#xA;                   id &#xA;                   pk &#xA;                   firstName &#xA;                   lastName &#xA;               }&#xA;         }&#xA;       }&#xA;    }`;&#xA;&#xA;class Child extends Component{&#xA;    state={&#xA;&#xA;    };&#xA;    childFunction = () =&gt; {&#xA;        alert(""I am a child function"");&#xA;    };&#xA;    render(){&#xA;        return(&#xA;            &lt;div&gt;Replace this div with your code!&lt;/div&gt;&#xA;        );&#xA;    };&#xA;}&#xA;&#xA;export default gql(myQuery, {/*some options*/})(Child);&#xA;</code></pre>&#xA;&#xA;<p><strong>What I Get as Output</strong>&#xA;When I <code>console.log(this.myChild);</code> I get a graphql object like this.<br>&#xA;<a href=""https://i.stack.imgur.com/NDwLK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NDwLK.png"" alt=""Output""></a></p>&#xA;&#xA;<p><strong>Expected Output</strong><br>&#xA;I want to get Child Element Reference. So that When I <code>console.log(this.myChild);</code> I should get Child component object.</p>&#xA;",9967575,,,,2018-08-18 05:51:35,How to get React Js Child Component Reference in Parent Component While Using Apollo Client GraphQL,<javascript><reactjs><graphql><react-apollo><apollo-client>,0,21,0,2018-08-18 05:51:35
51910054,2,,51908632,0,,"<p>Redux comes at hand and prove again its awesomness. </p>&#xA;&#xA;<p>I have simply to pass the property in my Redux's state. Then, I pass the property in the variable option direclty vie the ownProps property. Hence, my state can reach the query. I will appreciate if it allow me to dynamically refetch my data now. </p>&#xA;&#xA;<p>Here my reduxContainer.js: </p>&#xA;&#xA;<pre><code>const mapStateToProps = (state) =&gt; { &#xA;    return {&#xA;    property: state&#xA;    }&#xA;}&#xA;const yourContainer = connect(mapStateToProps)(YourReactComponent)&#xA;export default yourContainer&#xA;</code></pre>&#xA;&#xA;<p>Then, the state's connected query: </p>&#xA;&#xA;<pre><code>export default graphql(YourQuery, &#xA;        {options(ownProps) {&#xA;            return {&#xA;              variables: { property : ownProps.property}&#xA;            }&#xA;}})(YourReactComponent); &#xA;</code></pre>&#xA;",9817602,,,,2018-08-18 15:20:32,"",,0,0,0,2018-08-18 15:20:32
51927420,1,51940067,,4,2182,"<p>Imagine the following GraphQL request:</p>&#xA;&#xA;<pre><code>{&#xA;  books(&#xA;    first:10,&#xA;    filter: [{field: TITLE, contains: ""Potter""}],&#xA;    orderBy: [{sort: PRICE, direction: DESC}, {sort: TITLE}]&#xA;  )&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The result will return a connection with the Relay cursor information.</p>&#xA;&#xA;<p>Should the cursor contain the <code>filter</code> and <code>orderBy</code> details?</p>&#xA;&#xA;<p>Meaning querying the next set of data would only mean:</p>&#xA;&#xA;<pre><code>{&#xA;  books(first:10, after:""opaque-cursor"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Or should the <code>filter</code> and <code>orderBy</code> be repeated? </p>&#xA;&#xA;<p>In the latter case the user can specify different <code>filter</code> and/or <code>orderBy</code> details which would make the opaque cursor invalid.</p>&#xA;&#xA;<p>I can't find anything in the Relay spec about this.</p>&#xA;",1458877,,,,2022-01-24 23:52:44,How to use (opaque) cursors in GraphQL / Relay when using filter arguments and order by,<graphql><relayjs><relay>,3,0,0,2018-08-20 09:07:06
51940067,2,,51927420,4,,"<p>I've seen this done multiple ways, but I've found that with cursor-based pagination, your cursor exists only within your dataset, and to change the filters would change the dataset, making it invalid.</p>&#xA;&#xA;<p>If you're using SQL (or something without cursor-based-pagination), then, you would need to include enough information in your cursor to be able to recover it. Your cursor would need to include all of your filter / order information, and you would need to disallow any additional filtering.</p>&#xA;&#xA;<p>You'd have to throw an error if they sent ""after"" along with ""filter / orderBy"". You could, optionally, check to see if the arguments are the same as the ones in your cursor, in case of user error, but there simply is no use-case to get ""page 2"" of a DIFFERENT set of data.</p>&#xA;",652728,,,,2018-08-21 00:26:31,"",,0,0,0,2018-08-21 00:26:31
51942606,1,51945624,,0,355,"<p>I'm trying to figure out how to query a single user from graphql schema by id. I'm using the graphiql tool and I'm able to get all Users. </p>&#xA;&#xA;<pre><code>{&#xA;    allPrismicUsers {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;        data {&#xA;          name&#xA;        }&#xA;        }&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Outputs :</strong> </p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""allPrismicUsers”: {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Prismic__User__WzKFwywAABmiZk_4"",&#xA;            ""data"": {&#xA;              ""name"": “John Doe”&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Prismic__User__WzKDZywAABmiZkYp"",&#xA;            ""data"": {&#xA;              ""name"": “Jane Doe“&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Prismic__User__WzKGDiwAAJSiZlFL"",&#xA;            ""data"": {&#xA;              ""name"": “Cat Doe”&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I also have prismicUser() on the schema</p>&#xA;&#xA;<pre><code>query {&#xA;  prismicUser {&#xA;    id&#xA;    data {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Output:</strong> </p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""prismicUser"": {&#xA;      ""id"": ""Prismic__User__WzKGDiwAAJSiZlFL"",&#xA;      ""data"": {&#xA;        ""name"": ""Cat Doe""&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm trying to query a user based on a specific id but not sure if I'm querying the wrong way. &#xA;I tried this. </p>&#xA;&#xA;<pre><code>query {&#xA;  prismicLocation(id: ""Prismic__User__WzKDZywAABmiZkYp"") {&#xA;    data {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I get an error </p>&#xA;&#xA;<blockquote>&#xA;  <p>{   ""errors"": [&#xA;      {&#xA;        ""message"": ""Argument \""id\"" has invalid value \""Prismic__User__WzKDZywAABmiZkYp\"".\nExpected&#xA;  \""prismicUserIdQueryString_2\"", found not an object."",&#xA;        ""users"": [&#xA;          {&#xA;            ""line"": 25,&#xA;            ""column"": 23&#xA;          }&#xA;        ]&#xA;      }   ] }</p>&#xA;</blockquote>&#xA;&#xA;<p><strong>How can I call a specific user based on their id ?</strong></p>&#xA;",1096499,,4833285,2018-08-21 15:18:46,2018-08-21 15:18:46,prismic graphql querying single user,<graphql><gatsby><prismic.io>,1,0,0,2018-08-21 06:12:51
51959682,2,,45340126,0,,"<p>In python, if you specify it as a dictionary key, an error may occur.&#xA;For example.</p>&#xA;&#xA;<pre><code>&gt;&gt;&gt; a = dict()&#xA;&gt;&gt;&gt; type(a)&#xA;&lt;class 'dict'&gt;&#xA;&gt;&gt;&gt; a[[0]] = 1&#xA;Traceback (most recent call last):&#xA;  File ""&lt;stdin&gt;"", line 1, in &lt;module&gt;&#xA;TypeError: unhashable type: 'list'&#xA;</code></pre>&#xA;&#xA;<p>In the dictionary, a hash function is used to respond to the requirement of processing at low cost avoiding the whole search by <strong>eq</strong> when setting and acquiring the value.</p>&#xA;&#xA;<p>An example of hashable is built-in int, str, tuple, frozenset.</p>&#xA;&#xA;<p>The dict in this context is a Graphql request.&#xA;So first check if the value of key in query is hashable.&#xA;Also, it is desirable to put the query example I requested at the same time.</p>&#xA;",8363057,,,,2018-08-22 04:02:01,"",,0,1,0,2018-08-22 04:02:01
51979317,1,52002427,,0,455,"<p>So I'm using Apollo for my app's state, and am so far a little taken aback there's no equivalent to <code>mapStateToProps</code> or something. </p>&#xA;&#xA;<p>As far as I understand, to have any data globally accessible in my store, once I get the data, I need a query to write the data to the store, then another query in my other component to go and get it. </p>&#xA;&#xA;<p>By this point, the other component has very much mounted and rendered, so content just sort of flickers in and out. </p>&#xA;&#xA;<p>In Redux, I can just add new data to the store in my reducers, then anything that's connected with mapStateToProps has access to it.</p>&#xA;&#xA;<p>Is there an equivalent? Or does everything need to go through asynchronous queries? Does anyone else kind of find this an enormous pain?</p>&#xA;&#xA;<p>For example, in one component I'm getting some invitation data:</p>&#xA;&#xA;<pre><code>   this.props.client.query({&#xA;        query: REQUEST_ACTION_DATA,&#xA;        variables: {&#xA;            id: actionData.id,&#xA;            type: actionData.type&#xA;        }&#xA;    }).then(data =&gt; {&#xA;        this.props.client.writeQuery({query: GET_ACTION_DATA, data: {&#xA;            action: {&#xA;                type: data.data.actionData.type,&#xA;                object: data.data.actionData.invitation,&#xA;                __typename: 'ActionDataPayload'&#xA;            }&#xA;        }})&#xA;&#xA;        this.props.history.push('/auth/register')&#xA;    })&#xA;</code></pre>&#xA;&#xA;<p>... then in my other component I have this:</p>&#xA;&#xA;<pre><code>componentWillMount() {&#xA;    const authToken = localStorage.getItem(AUTH_TOKEN);&#xA;&#xA;    if (authToken) {&#xA;        this.props.history.push('/')&#xA;    }else{&#xA;        this.props.client.query({&#xA;            query: GET_ACTION_DATA&#xA;        }).then(data =&gt; {&#xA;            if(data.data &amp;&amp; data.data.action &amp;&amp; data.data.action.type == 'invite'){&#xA;                this.setState({&#xA;                    invitation: data.data.action.object&#xA;                })&#xA;            }&#xA;            console.log(data)&#xA;        })&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>ignoring the fact that it's hugely unwieldy to write all this for something so simple, is there just a way to access store data without having to wait around?</p>&#xA;",6448335,,,,2018-08-24 10:23:36,Synchronously read from the store?,<reactjs><graphql><react-apollo>,1,2,0,2018-08-23 06:10:20
51986819,1,,,0,1441,"<p>I am new to <code>AWS App Sync</code>, I want to query which accepts multiple values against one field and return result based on the input. Is this possible?</p>&#xA;&#xA;<p><code>listBookByName(bookID: [String], limit: Int, nextToken: String): listBookByNameConnection</code></p>&#xA;",10264977,,6888763,2018-08-23 15:30:30,2018-09-19 05:46:25,How to filter table with multiple values against one field,<graphql><aws-appsync>,2,0,0,2018-08-23 13:22:40
51989706,2,,51795299,5,,"<p>The <code>Connection</code> spec was originally created for Relay (Facebook's GraphQL client). It later developed a life of its own, and is now considered a <em>best practice</em>, regardless of the client. But (and that's a huge <em>but</em>), it most definitely does not map well to every use-case.</p>&#xA;&#xA;<p>If you see value in implementing the <code>Connection</code> pagination style, you have 2 options:</p>&#xA;&#xA;<p>1) Treat <code>after</code> as the offset (meaning a number would be passed), and <code>first</code> as the limit:</p>&#xA;&#xA;<pre><code>SELECT * FROM ORDER BY timestamp OFFSET $after LIMIT $first&#xA;</code></pre>&#xA;&#xA;<p>The same for <code>before</code> and <code>last</code>, just different direction.</p>&#xA;&#xA;<p>2) Another way is to treat <code>after</code>/<code>before</code> as the last seen value of the sort column (so an actual (obfuscated) value would be passed):</p>&#xA;&#xA;<pre><code>SELECT * FROM ORDER BY timestamp WHERE timestamp &gt; $after LIMIT $first&#xA;</code></pre>&#xA;&#xA;<p>That said, <strong>if you don't benefit from the <code>Connection</code> approach, feel free to ignore it</strong>. Especially if you're not even using Relay as the client. It's a completely optional thing and should not be shoehorned where it doesn't belong.</p>&#xA;",294657,,294657,2019-02-04 17:32:47,2019-02-04 17:32:47,"",,0,0,0,2018-08-23 15:49:15
51997213,2,,49747217,0,,<p>I meant to put this up months ago and it slipped my mind apparently. Problem ended up being unrelated to this and an incomplete refactor I did that resulted in an infinite react tree (child rendered parent)</p>&#xA;,9623208,,,,2018-08-24 03:52:04,"",,0,0,0,2018-08-24 03:52:04
52000568,1,52013499,,0,190,"<p>It is possible to create a typed <code>&lt;Query&gt;</code> <code>&lt;Mutation&gt;</code> or <code>&lt;Subscription&gt;</code> <a href=""https://www.apollographql.com/docs/react/recipes/static-typing.html"" rel=""nofollow noreferrer"">by extending the respective class</a>:</p>&#xA;&#xA;<pre><code>class MyQuery extends Query&lt;TData, TVariables&gt; { }&#xA;</code></pre>&#xA;&#xA;<p>However, in this case I would have to supply the <code>query</code> every time I use <code>&lt;MyQuery&gt;</code>:</p>&#xA;&#xA;<pre><code>&lt;MyQuery query={queries.MyQuery}&gt; // etc.&#xA;</code></pre>&#xA;&#xA;<p>Is there a nice way to ""bake in"" the query, so that <code>&lt;MyQuery&gt;</code> can be reused without having to supply <code>query={...}</code>?</p>&#xA;",2088135,,,,2018-08-25 02:26:07,Reusable typed react-apollo component with query,<typescript><react-apollo>,1,0,0,2018-08-24 08:39:37
52001510,2,,51999721,51,,"<p>The key was <code>input</code> in the <code>updateInput</code> mutation.</p>&#xA;&#xA;<pre><code>updateInput(input: Input!): String&#xA;         // ^^^^^ input key&#xA;</code></pre>&#xA;&#xA;<p>Thus, need to specify correct key in the passed variable.</p>&#xA;&#xA;<pre><code>const variables = {&#xA;  input: someData, // key is ""input"" based on the mutation above&#xA;};&#xA;&#xA;API.graphql(graphqlOperation(UpdateInput, variables)).then(...);&#xA;</code></pre>&#xA;",8012206,,8012206,2019-12-10 02:35:37,2019-12-10 02:35:37,"",,0,1,0,2018-08-24 09:33:03
52003256,1,,,2,144,"<p>I have a GraphQL server using ExpressJS. Want to write a schema using GraphQL-Tools:<br>&#xA;I want to get a Object like this...</p>&#xA;&#xA;<pre><code>User: {  &#xA;    firstName,  &#xA;    lastName,  &#xA;    location: {  &#xA;        city,  &#xA;        state,  &#xA;        lat,  &#xA;        lan  &#xA;    },  &#xA;    phoneNumber  &#xA;} &#xA;</code></pre>&#xA;&#xA;<p>with that design I can maintain details of the user in a single object.  But I canot find the way of doing nested objects with graphql-tools..</p>&#xA;&#xA;<pre><code>type User {&#xA;    id: String&#xA;    name: String&#xA;    location: Location&#xA;}&#xA;&#xA;type Location {&#xA;    city: String&#xA;    country: String&#xA;    zip: String&#xA;}  &#xA;</code></pre>&#xA;&#xA;<p>when I try with the above mentioned type, I am getting console errors:</p>&#xA;&#xA;<pre><code>throw new SchemaError('Resolve function missing for ""' + typeName + '.' + fieldName + '""');  &#xA;    ^&#xA;Error: Resolve function missing for ""User.location""&#xA;</code></pre>&#xA;&#xA;<p>Please anyone can show me the right way or if I did any mistake please correct me.</p>&#xA;",10269224,,2320961,2018-08-24 11:37:01,2018-08-24 11:37:01,how to proceed with nested objects in a single object with graphql-tools,<graphql-tools>,0,1,0,2018-08-24 11:14:02
52045369,1,52047350,,0,768,"<p>So here is my schema:</p>&#xA;&#xA;<pre><code>type Model {&#xA;    PartitionKey: ID!&#xA;    Name: String&#xA;    Version: Int&#xA;    FBX: String&#xA;    # ms since epoch&#xA;    CreatedAt: AWSTimestamp&#xA;    Description: String&#xA;    Tags: [String]&#xA;}&#xA;&#xA;type Query {&#xA;    getAllModels(count: Int, nextToken: String): PaginatedModels!&#xA;}&#xA;&#xA;type PaginatedModels {&#xA;    models: [Model!]!&#xA;    nextToken: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would like to call 'getAllModels' and have all of it's data, and all of it's tags be filled in.</p>&#xA;&#xA;<p>But here is the thing. Tags are stored via sort keys. Like so</p>&#xA;&#xA;<pre><code>PartionKey | SortKey&#xA;Model-0    | Model-0&#xA;Model-0    | Tag-Tree&#xA;Model-0    | Tag-Building&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to transform the 'Tag' sort keys into the <code>Tags: [String]</code> array in the schema via a DynamoDB resolver? Or must I do something extra fancy through a lambda? Or is there a smarter way to do this?</p>&#xA;",1580359,,,,2018-08-27 21:49:10,Map different Sort Key responses to Appsync Schema values,<amazon-web-services><amazon-dynamodb><graphql><aws-appsync>,1,0,0,2018-08-27 18:51:10
52046495,1,52047569,,0,1811,"<p>How do you use this?</p>&#xA;&#xA;<p>From here:&#xA;<a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-util-reference.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/resolver-util-reference.html</a></p>&#xA;&#xA;<p>I am trying to basically do this:</p>&#xA;&#xA;<pre><code>{&#xA;    ""version"": ""2017-02-28"",&#xA;    ""operation"": ""Scan"",&#xA;    ""filter"" : {&#xA;      $util.transform.toDynamoDBFilterExpression({&#xA;        PartitionKey:{&#xA;            begins_with:""Model""&#xA;        }&#xA;      }),&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That isn't working. How exactly do you fit this command into a resolver?</p>&#xA;",1580359,,,,2020-03-11 16:26:42,$util.transform.toDynamoDBFilterExpression,<graphql><aws-appsync>,2,0,0,2018-08-27 20:24:02
52048116,1,52068726,,2,2437,"<p>I have worked out a fairly complex chain of DynamoDB resolvers on a GraphQL AppSync query. What I am curious to know is if I could have possibly designed this in a way to require fewer DynamoDB queries.</p>&#xA;&#xA;<p>Here is my GraphQL Schema:</p>&#xA;&#xA;<pre><code>type Tag {&#xA;    PartitionKey: ID!&#xA;    SortKey: ID!&#xA;    TagName: String!&#xA;    TagType: String&#xA;}&#xA;&#xA;type Model {&#xA;    PartitionKey: ID!&#xA;    Name: String&#xA;    Version: Int&#xA;    FBX: String&#xA;    # ms since epoch&#xA;    CreatedAt: AWSTimestamp&#xA;    Description: String&#xA;    Tags: [String]&#xA;}&#xA;&#xA;type Query {&#xA;    GetAllModels(count: Int, nextToken: String): PaginatedModels!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the query that I am doing:</p>&#xA;&#xA;<pre><code>query GetAllModels{&#xA;  GetAllModels {&#xA;    Models {    &#xA;        PartitionKey        &#xA;        Name&#xA;        Version&#xA;        CreatedAt&#xA;        Description&#xA;        Tags {&#xA;          TagName&#xA;          TagType&#xA;        }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My DynamoDB table is set up as so:</p>&#xA;&#xA;<pre><code>PartionKey | SortKey       | TagName | TagType | ModelName | Description&#xA;Model-0    | Model-0       |                     ModelZero | Blah Blah   &#xA;Model-0    | Tag-Pine      |&#xA;Model-0    | Tag-Apple     |&#xA;Tag-Pine   | Tag-Pine      | Pine    | Tree&#xA;Tag-Apple  | Tag-Apple     | Apple   | Fruit&#xA;</code></pre>&#xA;&#xA;<p>So in my resolvers I am going:</p>&#xA;&#xA;<ol>&#xA;<li><p>GetAllModels will scan with two filters. One filter for PartitionKey beginning with 'Model-' and another filter for SortKey begining with 'Model-'. This is to get all Models.</p></li>&#xA;<li><p>Next there is a resolver attached to 'Tags' in the Model object. This will query with two expressions. One for PartitionKey = source.Parition and a second for SortKey begin_with 'Tag-' this gets me all of the tags on a model.</p></li>&#xA;<li><p>Next there are two resolvers on the Tag object. One on TagName and another on TagType. These do a direct GetItem to get their appropriate value with PartitionKey = source.Sort and SortKey = source.SortKey set as the keys.</p></li>&#xA;</ol>&#xA;&#xA;<p>So each scanned Model ends up firing off 3 more queries to DynamoDB. This just seems a bit excessive to me. But I cannot see any other way to do this. Is there some way to be able to get both TagName and TagType in one query?</p>&#xA;&#xA;<p>Is there a better way to approach this?</p>&#xA;",1580359,,,,2018-08-30 15:53:38,Retrieving arrays of nested information in AppSync schema,<amazon-web-services><amazon-dynamodb><graphql><aws-appsync>,1,0,0,2018-08-27 23:21:13
52101396,1,,,10,4311,"<p>I was wondering if there's a way to share the common fields between Input and Type in GraphQL so that I don't have to define the same set of fields in multiple places.</p>&#xA;&#xA;<p>Example:</p>&#xA;&#xA;<pre><code>input PersonInput {&#xA;    id: String!&#xA;    name: String&#xA;    address: String&#xA;}&#xA;&#xA;type Person {&#xA;    id: String!&#xA;    name: String&#xA;    address: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I know Fragment might be a solution, but if my understanding is correct, using Fragment always requires you to put an ON condition which makes it look like this:</p>&#xA;&#xA;<pre><code>Fragment PersonCommonFields on Person {&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>There seems to be no way to specify ""on Person/PersonInput"".</p>&#xA;",1783403,,1269037,2019-05-19 04:44:02,2019-05-19 04:44:02,Share common fields between Input and Type in GraphQL,<graphql><graphql-js><graphql-tools>,1,1,0,2018-08-30 16:10:14
52113238,2,,52112373,0,,"<p>You need implement pagination. Pass <code>limit</code>(<code>pageSize</code>) argument to <code>graphql</code> server <code>resolver</code>. process the datas in server-side.</p>&#xA;&#xA;<pre><code>query {&#xA;  missions(limit: 1) { &#xA;    missionId { id } ,&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>server-side:</p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    missions: (_, {limit}, ctx) =&gt; {&#xA;      const missions = [];&#xA;&#xA;      for(let i = 0; i &lt; limit; i++) {&#xA;        missions.push(db.missions[i])&#xA;      }&#xA;      return missions;&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That's <code>graphql</code> ideology, front-end developer define the data structure and what data they want to get.</p>&#xA;&#xA;<p>It's bad idea to query the <code>list</code> data through a http request. And <code>filter</code> the data in front-end using <code>directive</code> or other way of <code>graphql</code>. Waste bandwidth.</p>&#xA;",6463558,,6463558,2018-08-31 10:20:44,2018-08-31 10:20:44,"",,0,2,0,2018-08-31 10:13:50
52145338,1,,,0,220,"<p>I've got a bunch of graphQL fragments set up in my React/Apollo app, but I really need to access them on my Node server. </p>&#xA;&#xA;<p>For example, in my client I'm attempting to do this query, to get all relevant <code>Person</code> and <code>Company</code> entities:</p>&#xA;&#xA;<pre><code>query GET_REPORTING_CLIENTS{&#xA;    reportingClients{&#xA;        people {&#xA;            ...PersonFragment&#xA;        }&#xA;        companies {&#xA;            ...CompanyFragment&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, I can't just pass <code>info</code> into the queries on my server, cause <code>context.db.query.person</code> obviously won't have a key for 'people'.</p>&#xA;&#xA;<p>Ideally, I'd be able to go:</p>&#xA;&#xA;<pre><code>context.db.query.person({&#xA;     where: (query details)&#xA;}, PersonFragment)&#xA;</code></pre>&#xA;&#xA;<p>...but that doesn't work cause the server doesn't have the fragment. At the moment I'm getting around that by copy-pasting huge blocks of graphQL from the client to the app, but it's a really poor solution. </p>&#xA;&#xA;<p>Is there an answer, or does everything  just need to double up?</p>&#xA;",6448335,,,,2018-09-04 13:45:05,Share fragments between client and server,<graphql><react-apollo><graphql-js><prisma><prisma-graphql>,1,0,0,2018-09-03 07:49:41
52145389,1,52166213,,1,1165,"<p>I'm attempting to use a QueryRenderer with an accompanying fragment that I intend to use for pagination, in combination with Relay's <code>createPaginationContainer</code> higher-order component.</p>&#xA;&#xA;<p>I am using a fragment within the query I'm passing to QueryRenderer. E.g</p>&#xA;&#xA;<pre><code>  &lt;QueryRenderer&#xA;    environment={environment}&#xA;    query={&#xA;      graphql`&#xA;        query MyComponentQuery($count: Int!, $cursor: String) {&#xA;          ...MyComponent_students @arguments(count: $count, cursor: $cursor)&#xA;        }&#xA;      `&#xA;    }&#xA;    variables={{count: 10}}&#xA;    render={(p) =&gt; {&#xA;      console.log('render of QueryRenderer');&#xA;      console.log(p);&#xA;      return (&lt;MyComponent {...p.props} error={p.error} /&gt;);&#xA;    }}/&gt;&#xA;</code></pre>&#xA;&#xA;<p>This query is performed successfully - I can see in the network tab that the expected JSON is returned from the server as a result of executing this GraphQL query.</p>&#xA;&#xA;<p>However, I am entirely unable to see the result of the query within the context of the QueryRenderer's <code>query</code> prop (note the logging in the snippet above). Here's the output of <code>console.log(p)</code>.</p>&#xA;&#xA;<pre><code>{…}​&#xA;  error: null​&#xA;  props: {…}​​&#xA;    __fragments: {…}​​​&#xA;      MyComponent_students: {…}​​​​&#xA;        count: 10​​​​&#xA;        cursor: null​​​​&#xA;        &lt;prototype&gt;: Object { … }​​​&#xA;      &lt;prototype&gt;: Object { … }&#xA;  ​​  __id: ""client:root""&#xA;​​    &lt;prototype&gt;: Object { … }​&#xA;  retry: function retry()​&#xA;  &lt;prototype&gt;: Object { … }&#xA;</code></pre>&#xA;&#xA;<p>This then prevents me from passing the result of the query down to the paginationContainer (in this instance it's <code>MyComponent</code>).</p>&#xA;&#xA;<p>Why is this happening, and how can it be fixed?</p>&#xA;&#xA;<p>For reference, the fragment <code>MyComponent_students</code> is defined as:</p>&#xA;&#xA;<p><code>&#xA;      fragment MyComponent_students on Query&#xA;        @argumentDefinitions(&#xA;            count: {type: ""Int"", defaultValue: 10}&#xA;            cursor: {type: ""String""}&#xA;        ) {&#xA;        students(&#xA;            first: $count&#xA;            after: $cursor&#xA;        ) @connection(key: ""MyComponent_students"") {&#xA;            edges {&#xA;                node {&#xA;                    id&#xA;                    createdAt&#xA;                }&#xA;            }&#xA;        }&#xA;      }&#xA;</code></p>&#xA;",908041,,,,2018-09-04 12:19:50,Relay QueryRenderer does not return expected props from query,<reactjs><graphql><relayjs><relay>,1,0,0,2018-09-03 07:53:05
52188179,2,,52187999,10,,"<p>Notice that you are doing <code>import  graphql  from 'graphql-tag'</code> at the top of the Form component file. I'd imagine that you are actually trying to do <code>import { graphql } from 'react-apollo';</code> based on the way that you are using <code>graphql</code> as a HOC in the code you posted.</p>&#xA;&#xA;<p>Your import/export is also incorrect. You shouldn't have a default export but rather put the <code>export</code> keyword in front of each query definition. Then you need to change <code>import createStory from '../../Queries/Queries'</code> to <code>import {createStory} from '../../Queries/Queries'</code>. Currently you are setting <code>createStory</code> equal to <code>{ getStories, updateStory, createStory }</code>.</p>&#xA;",10315025,,10315025,2018-09-05 15:01:49,2018-09-05 15:01:49,"",,0,2,0,2018-09-05 14:56:03
52192589,2,,52173791,4,,"<p>Ok so after quite a bit of work trying out different strategies, I finally attempted changing the name of the field from <code>createdAt</code> to <code>createdDate</code> and it works now.</p>&#xA;&#xA;<p>As I look through the Playground I found that <code>createdAt</code> is a semi-hidden protected field used by Prisma itself for when requesting sorting on queries. It can be found under the <code>orderBy</code> selection in the Arguments list for a single data entry.</p>&#xA;&#xA;<p>The error message <code>Reason: 'createdAt' Field 'createdAt' is not defined in the input type 'PostingCreateInput'.</code> certainly did not in any way point me in the right direction though.</p>&#xA;&#xA;<p>TLDR; The problem was I was naming my field <code>createdAt</code> which is a protected field name.</p>&#xA;",8779395,,,,2018-09-05 19:57:53,"",,0,2,0,2018-09-05 19:57:53
52194316,2,,52178900,1,,"<p>Instead of do a query, you can call DDB scan from the VTL. &#xA;The scan operation does not guarantee any ordering on the result</p>&#xA;",1043698,,,,2018-09-05 22:47:51,"",,0,0,0,2018-09-05 22:47:51
52212362,1,,,0,526,"<p>I am migrating from redux to graphQL and using Apollo 2.1 with React. I would like to convert query result from json format into an array.</p>&#xA;&#xA;<p>If my Query return is something like this {x: x, y:y, z:z}, can I modify the return to look something like this [x,y,z]? This is obviously easy to do in a separate function but trying to come up to speed on graphQL.</p>&#xA;",8648711,,,,2018-09-06 21:25:27,How do I convert graphQL query result into data array,<reactjs><graphql>,0,2,0,2018-09-06 21:25:27
52220475,2,,44746923,36,,"<p>Some time ago I came up with another solution, which is the same approach like @WuDo suggested.</p>&#xA;<p>The idea is to flatten the tree on data level using IDs to reference them (each child with it's parent) and marking the roots of the tree, then on client side build up the tree again recursively.</p>&#xA;<p>This way you should not worry about limiting the depth of your query like in @samcorcos's answer.</p>&#xA;<p>schema:</p>&#xA;<pre><code>type Query {&#xA;    tags: [Tag]&#xA;}&#xA;&#xA;type Tag {&#xA;    id: ID!&#xA;    children: [ID]&#xA;    root: Boolean&#xA;}&#xA;</code></pre>&#xA;<p>response:</p>&#xA;<pre><code>{ &#xA;    &quot;tags&quot;: [&#xA;        {&quot;id&quot;: &quot;1&quot;, &quot;children&quot;: [&quot;2&quot;], &quot;root&quot;: true}, &#xA;        {&quot;id&quot;: &quot;2&quot;, &quot;children&quot;: [], &quot;root&quot;: false}&#xA;    ] &#xA;}&#xA;</code></pre>&#xA;<p>client tree buildup:</p>&#xA;<pre><code>import find from 'lodash/find';&#xA;import isArray from 'lodash/isArray';&#xA;&#xA;const rootTags = [...tags.map(obj =&gt; ({...obj})).filter(tag =&gt; tag.root === true)];&#xA;const mapChildren = childId =&gt; {&#xA;    const tag = find(tags, tag =&gt; tag.id === childId) || null;&#xA;&#xA;    if (isArray(tag.children) &amp;&amp; tag.children.length &gt; 0) {&#xA;        tag.children = tag.children.map(mapChildren).filter(tag =&gt; tag !== null);&#xA;    }&#xA;}&#xA;const tagTree = rootTags.map(tag =&gt; {&#xA;    tag.children = tag.children.map(mapChildren).filter(tag =&gt; tag !== null);&#xA;    return tag;&#xA;});&#xA;</code></pre>&#xA;<p>//  Update 2022-08-16 Fixed typo</p>&#xA;",970718,,970718,2022-08-26 10:47:45,2022-08-26 10:47:45,"",,0,5,0,2018-09-07 10:20:58
52229016,1,,,2,268,"<p>Is it possible to update the props of a component by calling <code>refetch</code> from a sibling component?</p>&#xA;&#xA;<p>Consider components with the following structure:</p>&#xA;&#xA;<pre><code>&lt;Home&gt; # wrapped in a QueryRenderer&#xA;    &lt;List /&gt; # wrapped in a Fragment Container&#xA;    &lt;Map /&gt; # wrapped in a Refetch Container&#xA;&lt;/Home&gt;&#xA;</code></pre>&#xA;&#xA;<p><code>List</code> and <code>Map</code> use the same query endpoint: <code>allItems</code>. </p>&#xA;&#xA;<p>When <code>Map</code> calls <code>refetch</code>, it's own data updates, <code>List</code>'s data does not update, however. </p>&#xA;&#xA;<p>The refetch query is identical to the <code>Home</code>'s <code>QueryRenderer</code> query. It appears that Relay does not map the result of the refetch to the parts of the store that hold the data for <code>List</code>, as <code>List</code>'s props do not change. </p>&#xA;&#xA;<p>Is it possible for a refetch to update props outside of component the Refetch Container contains? If not, how can changes in one component fire a refetch and update the props of a sibling component without moving the refetch container to a higher level - unless this is the only way?</p>&#xA;&#xA;<p>For some more context, I've included some code to illustrate the structure and queries more clearly. </p>&#xA;&#xA;<p>Using Relay, suppose we have a parent component wrapped in a <code>QueryRenderer</code> to perform an initial data fetch.</p>&#xA;&#xA;<pre><code>        &lt;QueryRenderer&#xA;            environment={environment}&#xA;            query={graphql`&#xA;                query HomeQuery {&#xA;                    ...List_query&#xA;                    ...Map_query&#xA;                }&#xA;            `}&#xA;            render={({ error, props }) =&gt; {&#xA;                if (error) {&#xA;                    console.log(error)&#xA;                    return &lt;div&gt;Error!&lt;/div&gt;&#xA;                }&#xA;                if (!props) {&#xA;                    return &lt;div&gt;Loading...&lt;/div&gt;&#xA;                }&#xA;&#xA;                return (&#xA;                    &lt;div&gt;&#xA;                        &lt;List query={props} /&gt;&#xA;                        &lt;Map query={props} /&gt;&#xA;                    &lt;/div&gt;&#xA;                )&#xA;            }}&#xA;        /&gt;&#xA;</code></pre>&#xA;&#xA;<p>Both <code>List</code> and <code>Map</code> contain fragments. <code>List</code> is wrapped with a Fragment Container: </p>&#xA;&#xA;<pre><code>createFragmentContainer(List, {&#xA;    query: graphql`&#xA;        fragment List_query on Query {&#xA;            allItems(first: 10) @connection(key: ""Map_allItems"") {&#xA;                edges {&#xA;                    node {&#xA;                        id&#xA;                        name&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    `&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>Whereas the <code>Map</code> is wrapped in a Refetch Container: </p>&#xA;&#xA;<pre><code>createRefetchContainer(&#xA;    Map,&#xA;    {&#xA;        query: graphql`&#xA;            fragment Map_query on Query {&#xA;                allItems(first: 10) @connection( key: ""Map_allItems"") {&#xA;                    edges {&#xA;                        node {&#xA;                            id&#xA;                            name&#xA;                            created&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        `&#xA;    },&#xA;    graphql`&#xA;        query MapRefetchQuery {&#xA;            ...Map_query&#xA;            ...List_query&#xA;        }&#xA;    `&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>The code has been reduced, so may have a typo in it! Let me know if this is the case, and I'll update it.</p>&#xA;",3084316,,,,2018-09-07 20:05:58,Can Relay's RefetchContainer update sibling components with a refetch?,<reactjs><graphql><relayjs><relaymodern>,0,1,0,2018-09-07 20:05:58
52273954,2,,52271313,1,,"<p>This kind of functionality can be achieved using <code>apollo-link-state</code>.</p>&#xA;&#xA;<p><a href=""https://stackoverflow.com/questions/52087275/apollo-link-state-defaults-derived-from-query-data"">example</a> - 'internal' query can be forced to be <code>cache-only</code> by <a href=""https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-config-options-fetchPolicy"" rel=""nofollow noreferrer"">fetchPolicy</a></p>&#xA;&#xA;<p>Also consider simple filtering in component state (or <a href=""https://stackoverflow.com/a/52028445/6124657"">other options</a> - it all depends on (sharing filtered result) requirements.</p>&#xA;",6124657,,,,2018-09-11 10:33:03,"",,0,2,0,2018-09-11 10:33:03
52306969,1,52307077,,0,289,"<p>How can I pass an array of custom type in a mutation when declaring typeDefs in GraphQL?</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>type Itinerary {&#xD;&#xA;  name: String!&#xD;&#xA;  itinerary: [Location]!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;input Location {&#xD;&#xA;  name: String!&#xD;&#xA;  country: String&#xD;&#xA;  region: String&#xD;&#xA;  city: String&#xD;&#xA;  duration: Int!&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type Mutation {&#xD;&#xA;  addItinerary(&#xD;&#xA;    name: String!,&#xD;&#xA;    itinerary: [Location]!,&#xD;&#xA;  ): Itinerary&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>I get the error in graphiql <strong>""The type of Itinerary.itinerary must be Output Type but got: [Location]!""</strong></p>&#xA;&#xA;<p>It seems to be such a trivial task but I could not find anything specific to this case</p>&#xA;",9588683,,5052733,2019-07-30 13:32:20,2019-07-30 13:32:20,GraphQL typedef mutation need to accept an Array,<javascript><types><graphql><mutation>,1,0,0,2018-09-13 05:06:40
52307077,2,,52306969,0,,"<p>You're returning a type of <code>Itinerary</code>, which itself contains a nested <code>Location</code>, however you've stated that <code>Location</code> is an <strong>input type</strong>, which can't be returned as the result of a mutation. You need to define separate input types and can't return them.</p>&#xA;",743464,,,,2018-09-13 05:17:56,"",,0,4,0,2018-09-13 05:17:56
52328299,1,,,0,286,"<p>I'm migrating to dock a slightly old python application, not maintained.... I made a <code>pip freeze</code> to see what's going into production. &#xA;I am confronted with a problem that I have difficulty solving. I have this mistake: &#xA;So I wonder if it's not a problem related to a version that's not respected. The project runs on python 3.6.2.</p>&#xA;&#xA;<p>Do you have any idea how I can solve the problem? </p>&#xA;&#xA;<p><strong><em>stacktrace</em></strong></p>&#xA;&#xA;<pre><code>raphql_1  |   File ""/usr/local/bin/gunicorn"", line 11, in &lt;module&gt;&#xA;graphql_1  |     sys.exit(run())&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/wsgiapp.py"", line 74, in run&#xA;graphql_1  |     WSGIApplication(""%(prog)s [OPTIONS] [APP_MODULE]"").run()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/base.py"", line 203, in run&#xA;graphql_1  |     super(Application, self).run()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/base.py"", line 72, in run&#xA;graphql_1  |     Arbiter(self).run()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/arbiter.py"", line 60, in __init__&#xA;graphql_1  |     self.setup(app)&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/arbiter.py"", line 120, in setup&#xA;graphql_1  |     self.app.wsgi()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/base.py"", line 67, in wsgi&#xA;graphql_1  |     self.callable = self.load()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/wsgiapp.py"", line 65, in load&#xA;graphql_1  |     return self.load_wsgiapp()&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/app/wsgiapp.py"", line 52, in load_wsgiapp&#xA;graphql_1  |     return util.import_app(self.app_uri)&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/gunicorn/util.py"", line 352, in import_app&#xA;graphql_1  |     __import__(module)&#xA;graphql_1  |   File ""/workspace/src/server/main.py"", line 15, in &lt;module&gt;&#xA;graphql_1  |     from api import root&#xA;graphql_1  |   File ""/workspace/src/api/root.py"", line 6, in &lt;module&gt;&#xA;graphql_1  |     from api import mutation, query&#xA;graphql_1  |   File ""/workspace/src/api/mutation.py"", line 4, in &lt;module&gt;&#xA;graphql_1  |     from api.object_types import (availability, home, home_feature,&#xA;graphql_1  |   File ""/workspace/src/api/object_types/availability.py"", line 6, in &lt;module&gt;&#xA;graphql_1  |     from api.helpers.objecttype import QueryProvidingObjectType&#xA;graphql_1  |   File ""/workspace/src/api/helpers/objecttype.py"", line 49, in &lt;module&gt;&#xA;graphql_1  |     class QueryProvidingObjectType(SQLAlchemyObjectType):&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/graphene_sqlalchemy/types.py"", line 85, in __new__&#xA;graphql_1  |     registry=None&#xA;graphql_1  |   File ""/usr/local/lib/python3.6/site-packages/graphene/types/options.py"", line 29, in __init__&#xA;graphql_1  |     ', '.join(sorted(meta_attrs.keys()))&#xA;graphql_1  | TypeError: Invalid attributes: abstract&#xA;</code></pre>&#xA;&#xA;<p><strong><em>requirement.txt</em></strong> </p>&#xA;&#xA;<pre><code>alembic==0.9.7&#xA;backports.csv==1.0.5&#xA;certifi==2017.11.5&#xA;chardet==3.0.4&#xA;cli-helpers==0.2.2&#xA;click==6.7&#xA;configobj==5.0.6&#xA;decorator==4.2.1&#xA;fin==2.1.8&#xA;flake8==3.4.1&#xA;Flask==0.12.2&#xA;Flask-Cors==3.0.3&#xA;Flask-GraphQL==1.4.1&#xA;Flask-SSLify==0.1.5&#xA;graphene==1.4.1&#xA;graphene-sqlalchemy==1.1.1&#xA;graphql-core==1.1&#xA;graphql-relay==0.4.5&#xA;graypy==0.2.14&#xA;gunicorn==19.7.1&#xA;httplib2==0.10.3&#xA;humanize==0.5.1&#xA;idna==2.6&#xA;ipython==6.2.1&#xA;ipython-genutils==0.2.0&#xA;iso8601==0.1.12&#xA;itsdangerous==0.24&#xA;jedi==0.11.1&#xA;Jinja2==2.9.6&#xA;Mako==1.0.7&#xA;MarkupSafe==1.0&#xA;mccabe==0.6.1&#xA;mock==2.0.0&#xA;oauth2client==4.1.2&#xA;parso==0.1.1&#xA;pbr==3.1.1&#xA;pexpect==4.3.1&#xA;pgcli==1.7.0&#xA;pgspecial==1.8.0&#xA;pickleshare==0.7.4&#xA;promise==2.1&#xA;prompt-toolkit==1.0.15&#xA;psycopg2==2.7.1&#xA;ptyprocess==0.5.2&#xA;py==1.4.34&#xA;pyasn1==0.4.2&#xA;pyasn1-modules==0.2.1&#xA;pycodestyle==2.3.1&#xA;pyflakes==1.5.0&#xA;Pygments==2.2.0&#xA;pytest==3.1.3&#xA;python-dateutil==2.6.1&#xA;python-editor==1.0.3&#xA;PyYAML==3.12&#xA;requests==2.18.4&#xA;rsa==3.4.2&#xA;setproctitle==1.1.10&#xA;simplegeneric==0.8.1&#xA;singledispatch==3.4.0.3&#xA;six==1.10.0&#xA;SQLAlchemy==1.1.12&#xA;sqlalchemy-citext==1.3.post0&#xA;SQLAlchemy-Utils==0.32.14&#xA;sqlparse==0.2.4&#xA;terminaltables==3.1.0&#xA;testfixtures==5.3.1&#xA;traitlets==4.3.2&#xA;typing==3.6.2&#xA;typing-inspect==0.1.1&#xA;Unidecode==0.4.21&#xA;urllib3==1.22&#xA;wcwidth==0.1.7&#xA;Werkzeug==0.12.2&#xA;</code></pre>&#xA;&#xA;<p>the class in question that is related to the error: </p>&#xA;&#xA;<pre><code>class QueryProvidingObjectType(SQLAlchemyObjectType):&#xA;    class Meta:&#xA;        abstract = True&#xA;&#xA;    # TODO: copy-pasta duplication here:&#xA;    @classmethod&#xA;    def QueryOne(cls, filter_fields):&#xA;        def resolver(self, args, context, info):&#xA;            query = cls.get_query(context)&#xA;            query = apply_filter(query, cls._meta.model, args)&#xA;            return query.first()&#xA;        all_fields = cls._meta.fields&#xA;        fields = {name: field_to_argument(cls, name, all_fields[name])&#xA;                  for name in filter_fields}&#xA;        return graphene.Field(&#xA;            cls,&#xA;            resolver=resolver,&#xA;            args=fields,&#xA;            description=f""Return the first {cls} that matches the filters""&#xA;            )&#xA;&#xA;    @classmethod&#xA;    def QueryList(cls, filter_fields=(), sort_by=None):&#xA;        def resolver(self, args, context, info):&#xA;            query = cls.get_query(context)&#xA;            if sort_by:&#xA;                query = apply_sort(query, cls._meta.model, sort_by)&#xA;            query = apply_filter(query, cls._meta.model, args)&#xA;            return query.all()&#xA;&#xA;        all_fields = cls._meta.fields&#xA;        model_fields = {name: field_to_argument(cls, name, all_fields[name])&#xA;                        for name in filter_fields}&#xA;        model_fields.update({&#xA;            ""first"": graphene.Int(),&#xA;            ""after"": graphene.Int()&#xA;        })&#xA;        description = f""Query for all {cls}s""&#xA;        if filter_fields:&#xA;            description += "" (optionally filtered using provided arguments)""&#xA;        return graphene.List(&#xA;            cls,&#xA;            resolver=resolver,&#xA;            args=model_fields,&#xA;            description=description)&#xA;&#xA;    @classmethod&#xA;    def FuzzySearch(cls, match_field):&#xA;        mapper = MapperFactory.get_mapper(FuzzySearchResult[cls])&#xA;        result_type = mapper.graphene_output_type()&#xA;&#xA;        def resolver(self, args, context, info):&#xA;            first = args.pop('first', 5)&#xA;            attr_name, search_query = list(args.items())[0]&#xA;&#xA;            query = cls.get_query(context).all()&#xA;            return fuzzy_search(search_query, query, key=attrgetter(attr_name), limit=first)&#xA;&#xA;        all_fields = cls._meta.fields&#xA;        fields = {&#xA;            match_field: field_to_argument(cls, match_field, all_fields[match_field]),&#xA;            'first': graphene.Argument(&#xA;                graphene.Int,&#xA;                description=""[optional] limit the number of results""&#xA;            ),&#xA;        }&#xA;        return graphene.List(result_type, resolver=resolver, args=fields)&#xA;</code></pre>&#xA;",2667201,,,,2018-09-14 08:51:17,Graphene - SqlAlchemy - Abstract Attribute,<python><sqlalchemy><graphql><flask-sqlalchemy><graphene-python>,0,2,0,2018-09-14 08:51:17
52358303,1,,,2,587,"<p>Say I have two GraphQL queries.</p>&#xA;&#xA;<p>Query A:</p>&#xA;&#xA;<pre><code>{&#xA;  entry(section: [privacyStatement]) {&#xA;    ... on PrivacyStatement {&#xA;      title&#xA;      slug&#xA;      pageTitle&#xA;      metaDescription&#xA;      metaImage {&#xA;        id&#xA;        title&#xA;        url&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Query B:</p>&#xA;&#xA;<pre><code>{&#xA;  entry(section: [contact]) {&#xA;    ... on Contact {&#xA;      title&#xA;      slug&#xA;      pageTitle&#xA;      metaDescription&#xA;      metaImage {&#xA;        id&#xA;        title&#xA;        url&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I want both queries to contain another query:</p>&#xA;&#xA;<p>Query C:</p>&#xA;&#xA;<pre><code>  {&#xA;    services: categories(groupId: 1, level: 1) {&#xA;      id&#xA;      title&#xA;      slug&#xA;      children {&#xA;        id&#xA;        title&#xA;        slug&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>How do I do that without duplicating query C in both query A and B (which would not be very DRY)? You can only use fragments for pieces within one query if I understand correctly.</p>&#xA;&#xA;<p>Update:</p>&#xA;&#xA;<p>So I mean something like this:</p>&#xA;&#xA;<pre><code>Query A {&#xA;  entry(section: [privacyStatement]) {&#xA;    ... on PrivacyStatement {&#xA;      title&#xA;      slug&#xA;      pageTitle&#xA;      metaDescription&#xA;      metaImage {&#xA;        id&#xA;        title&#xA;        url&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;QueryC&#xA;</code></pre>&#xA;&#xA;<p>and:</p>&#xA;&#xA;<pre><code>Query B {&#xA;  entry(section: [contact]) {&#xA;    ... on Contact {&#xA;      title&#xA;      slug&#xA;      pageTitle&#xA;      metaDescription&#xA;      metaImage {&#xA;        id&#xA;        title&#xA;        url&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;QueryC&#xA;</code></pre>&#xA;",453746,,453746,2018-09-17 09:45:29,2018-09-17 11:05:08,Reusing a GraphQL query in another query without duplicating,<graphql>,1,0,0,2018-09-16 20:55:33
52370862,2,,52369302,1,,"<p>I know your struggle with react and component updating, but I guess there's no bullet proof to get rid of it;  80% I guess you should try any of the different life cycle methods. Back in the day there was <strong>componentWillReceiveProps</strong> for async calls but since it's been marked unsafe (I guess) you should try <strong>getDerivedStateFromProps(props, state)</strong></p>&#xA;&#xA;<pre><code>getDerivedStateFromProps(props, state) {&#xA;  console.log(""*************** PROPS:"",  props);&#xA;&#xA;  let { openCorporates: { getEntityAttribute  } } = props;&#xA;&#xA;  if (getEntityAttribute  &amp;&amp;  getEntityAttribute.value) {&#xA;      let openCorporatesCompany = JSON.parse(getEntityAttribute.value);&#xA;      let company = _.cloneDeep(this.state.company);&#xA;&#xA;      company.legalName = openCorporatesCompany.name;&#xA;      this.setState({&#xA;          openCorporatesCompany,&#xA;          company&#xA;      })&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Take into account I haven't run the snippet.</p>&#xA;",1326811,,,,2018-09-17 15:12:22,"",,0,12,0,2018-09-17 15:12:22
52371932,2,,52369302,1,,"<p>This ended up doing the trick, thanks to @Charlie's answer:</p>&#xA;&#xA;<pre><code>static getDerivedStateFromProps(props, state) {&#xA;    let newState = _.cloneDeep(state);&#xA;    let { openCorporates: { getEntityAttribute  } } = props;&#xA;&#xA;    if (getEntityAttribute  &amp;&amp;  getEntityAttribute.value) {&#xA;        let openCorporatesCompany = JSON.parse(getEntityAttribute.value);&#xA;        let company = _.cloneDeep(newState.company);&#xA;        company.legalName = openCorporatesCompany.name;&#xA;        newState.openCorporatesCompany = openCorporatesCompany;&#xA;        newState.company = company;&#xA;    }&#xA;&#xA;    return newState;&#xA;}&#xA;</code></pre>&#xA;",4178182,,,,2018-09-17 16:13:44,"",,0,0,0,2018-09-17 16:13:44
52413744,2,,52398927,3,,"<p>What type of sorting are you looking to do? If it's ascending/descending using a DynamoDB resolver then you can set that on the <code>ScanIndexForward</code> argument for this on the request template: <a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html</a> </p>&#xA;",2733539,,,,2018-09-19 20:28:55,"",,0,0,0,2018-09-19 20:28:55
52435925,2,,50164822,2,,"<p>You're just missing the id for the default location object at the defaultState, just tried like this and worked:</p>&#xA;&#xA;<pre><code>export default {&#xA;  location: {&#xA;    __typename: 'Location',&#xA;    id: 0,&#xA;    coords: [36, 23],&#xA;  },&#xA;}&#xA;</code></pre>&#xA;",5239847,,,,2018-09-21 02:47:34,"",,0,0,0,2018-09-21 02:47:34
52452982,1,52453108,,7,7395,"<p>A very common use case in GraphQL is creating an object with a mutation, and receiving the exact same fields back, plus and ID returned by the database. Here's a related <a href=""https://stackoverflow.com/questions/45911490/why-does-graphql-choose-to-use-an-input-type"">question</a> asking about this.</p>&#xA;&#xA;<p>My question is, how can this pattern be simplified to avoid repeated fields? I've tried reusing the input type as a fragment,</p>&#xA;&#xA;<pre><code>input ClientInput {&#xA;  short_name: String&#xA;  full_name: String&#xA;  address: String&#xA;  email: String&#xA;  location: String  &#xA;}&#xA;&#xA;type Client {&#xA;  id: String&#xA;  ...ClientInput&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>...but that failed with</p>&#xA;&#xA;<blockquote>&#xA;  <p>Syntax Error: Expected Name, found ...</p>&#xA;</blockquote>&#xA;&#xA;<p>All the <a href=""https://graphql.org/learn/queries/#fragments"" rel=""noreferrer"">documentation</a> and blog posts I've seen on Fragments always creates them <code>on</code> an existing type. That means still repeating all but the ID field:</p>&#xA;&#xA;<pre><code>type Client {&#xA;  _id: String&#xA;  short_name: String&#xA;  full_name: String&#xA;  address: String&#xA;  email: String&#xA;  location: String&#xA;}&#xA;&#xA;fragment ClientFields on Client {&#xA;  short_name: String&#xA;  full_name: String&#xA;  address: String&#xA;  email: String&#xA;  location: String&#xA;}&#xA;&#xA;input ClientInput {&#xA;  ...ClientFields&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How is that any better?</p>&#xA;",1269037,,,,2019-08-13 23:36:26,Reusing input type as fragment in GraphQL,<types><graphql>,1,0,0,2018-09-22 02:27:07
52453108,2,,52452982,12,,"<p><strong>TL;DR:</strong> A mechanism for allowing fields to be shared between an object type and an input object type just does not exist. Fragments can only be used client-side when composing queries.</p>&#xA;&#xA;<p>From the specification:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the document.</p>&#xA;</blockquote>&#xA;&#xA;<p>The intent behind fragments is that you may have any number of saved queries that query the same type -- you don't want to have to update 20 different queries if the schema changes or you decide you don't need a certain field anymore.</p>&#xA;&#xA;<p>A similar mechanism for allowing fields to be shared between a Type and an Input Type server-side just does not exist. This is likely largely by design because even though a Type field and an Input Type field both have some kind of <code>type</code>, they may have other properties. For example, Input Type fields can have a default value, while that property does not exist for a Type field. Similarly, Type fields have resolvers and arguments, which Input Type fields do not.</p>&#xA;&#xA;<p>If you really want to keep things DRY, there may be workarounds available, depending on what kind of GraphQL server you're running. If it's a GraphQL.js server that uses a schema created from one or more SDL strings, for example, you can just use template literals:</p>&#xA;&#xA;<pre><code>const sharedClientFields = `&#xA;    short_name: String&#xA;    full_name: String&#xA;    address: String&#xA;    email: String&#xA;    location: String &#xA;`&#xA;const schema = `&#xA;  type Client {&#xA;    _id: String&#xA;    ${sharedClientFields}&#xA;  }&#xA;&#xA;  type ClientInput {&#xA;    ${sharedClientFields}&#xA;  }&#xA;`&#xA;</code></pre>&#xA;",6024220,,6024220,2019-08-13 23:36:26,2019-08-13 23:36:26,"",,0,1,0,2018-09-22 02:57:41
52454251,2,,52453455,1,,"<p>You might need to have <code>bookID</code> as parent's ID inside <code>Author</code>:<br></p>&#xA;&#xA;<pre><code>type Author {&#xA;    # parent's id&#xA;    bookID: ID!&#xA;    # author id&#xA;    id: ID!&#xA;    name: String!&#xA;}&#xA;&#xA;type Book {&#xA;    id: ID!&#xA;    title: String!&#xA;    author: Author!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When <code>Create Resource</code>, just make:<br>&#xA; - <code>Book.id</code> as <code>primary key</code> of <code>BookTable</code><br>&#xA; - <code>Author.bookID</code> as <code>primary key</code> and <code>Author.id</code> as <code>sort key</code> of&#xA;   <code>AuthorTable</code><br></p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/uOI6l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uOI6l.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>You also need to attach resolver for <code>Book.author</code> using <code>$ctx.source.id</code><br></p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/xOeOw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xOeOw.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>After you attach <code>Book.author</code> resolver, you are good to go. You can get result something like below:<br></p>&#xA;&#xA;<pre><code>getBook(title: ""xx"") {&#xA;  id&#xA;  title&#xA;  author {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",9270631,,9270631,2018-09-22 06:56:24,2018-09-22 06:56:24,"",,0,0,0,2018-09-22 06:49:29
52472160,1,,,0,90,"<p>Im trying to use pagination with Mongo. My issue is if I limit my find results, my count is equal to the .limit value.&#xA;Is there some sort of meta value total_count in mongo/mongoose?</p>&#xA;&#xA;<p>UPDATE:&#xA;I was able to use mongoose-paginate from npm to accomplish this.</p>&#xA;",7644474,,7644474,2018-09-25 04:05:27,2018-09-25 04:05:27,Is it possible to get a total_count on a find from Mongo while using limit,<node.js><mongodb><mongoose><graphql>,1,2,0,2018-09-24 03:00:42
52483155,1,,,0,107,"<pre><code>const MoreCommentsQuery = gql`&#xA;  query MoreComments($cursor: String) {&#xA;    moreComments(cursor: $cursor) {&#xA;      cursor&#xA;      comments {&#xA;        author&#xA;        text&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const CommentsWithData = () =&gt; (&#xA;  &lt;Query query={CommentsQuery}&gt;&#xA;    {({ data: { comments, cursor }, loading, fetchMore }) =&gt; (&#xA;      &lt;Comments&#xA;        entries={comments || []}&#xA;        onLoadMore={() =&gt;&#xA;          fetchMore({&#xA;            // note this is a different query than the one used in the&#xA;            // Query component&#xA;            query: MoreCommentsQuery,&#xA;            variables: { cursor: cursor },&#xA;            updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;              const previousEntry = previousResult.entry;&#xA;              const newComments = fetchMoreResult.moreComments.comments;&#xA;              const newCursor = fetchMoreResult.moreComments.cursor;&#xA;&#xA;              return {&#xA;                // By returning `cursor` here, we update the `fetchMore` function&#xA;                // to the new cursor.&#xA;                cursor: newCursor,&#xA;                entry: {&#xA;                  // Put the new comments in the front of the list&#xA;                  comments: [...newComments, ...previousEntry.comments]&#xA;                }&#xA;              };&#xA;            }&#xA;          })&#xA;        }&#xA;      /&gt;&#xA;    )}&#xA;  &lt;/Query&gt;&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>This is from the documentation so i cant show the code for the comments query but when executing the CommentsQuery, where does this cursor come from, is it literally just returning the argument we passed in or does the cursor field have to exist on MoreComments Query?</p>&#xA;",10302794,,,,2018-09-24 15:58:37,Infinite scroll fetchmore,<javascript><graphql><apollo>,0,3,0,2018-09-24 15:58:37
52511018,1,,,7,629,"<p>I currently have a GraphQL API that uses connection based pagination as defined in <a href=""https://graphql.org/learn/pagination/"" rel=""noreferrer"">https://graphql.org/learn/pagination/</a> which is what the Relay client uses.</p>&#xA;&#xA;<p>I have looked at ra-data-graphql-simple but that expects the GraphQL server to return certain queries.</p>&#xA;&#xA;<p>Are there any other examples of clients that would work with this format? If not is my best option to build on top of ra-data-graphql?</p>&#xA;&#xA;<p>Thank you,&#xA;Owen</p>&#xA;",2282963,,,,2019-02-24 07:27:31,react-admin and connection pagination,<graphql><apollo><relay><react-admin>,1,2,0,2018-09-26 06:08:23
52544319,1,,,0,218,"<p>I want to store a file structure similar to Google Drive. I can create files of several types (doc, spreadsheet, ..). Details of each file are stored in their table.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>File [id, name, file_id]&#xA;Doc [file_id, title, a, b, c]&#xA;Spreadsheet [file_id, title, d, e]&#xA;</code></pre>&#xA;&#xA;<p>How to do it right?</p>&#xA;",8780677,,8780677,2018-09-27 21:04:15,2018-09-28 00:00:02,How to create a foreign key to multiple tables?,<sql><database><graphql>,2,4,0,2018-09-27 20:00:54
52547916,2,,52459761,2,,"<p>Inspect the schema in GraphiQL. It should show a root query similar to this one:</p>&#xA;&#xA;<pre><code>allAnimals(&#xA;  before:String,&#xA;  after:String,&#xA;  firts:Int,&#xA;  last:Int,&#xA;  name:String,&#xA;  genus:String,&#xA;  isDomesticated:Boolean&#xA;):AnimalNodeConnection&#xA;</code></pre>&#xA;&#xA;<p>The three filter criteria are exposed as query parameters, so you can use them with a query like this one:</p>&#xA;&#xA;<pre><code>query filteredAnimals{&#xA;  allAnimals(&#xA;    name:""Big Foot"",&#xA;    genus:""Unknown"",&#xA;    isDomesticated:false&#xA;  ) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;        genus&#xA;        isDomesticated&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which will give you a connection with undomesticated animals named ""Big Foot"" (""big FOOT"", ""Big foot"", etc.) with genus equal to ""Unknown"".</p>&#xA;&#xA;<p><strong>Note:</strong> Filters declared on the <code>FilterSet</code> Meta class are named after the type of filtering they do, like <code>name_Icontains</code>, <code>name_Iexact</code>. Filters declared as <code>FilterSet</code> fields (name filter in your case) keep their names unmodified, and extend or <strong>OVERRIDE</strong> filters declared in the <code>FilterSet</code> Meta class.</p>&#xA;",2636418,,,,2018-09-28 03:36:18,"",,0,1,0,2018-09-28 03:36:18
52608910,2,,52601436,1,,"<p>@Junchao, what Vincent said is correct. Also, you must have a re-fetch query and send <code>refetchVariables</code> with your <code>first</code> value updated. I will try to provide you an example:</p>&#xA;&#xA;<pre><code>export default createRefetchContainer(&#xA;  TeamsComponent,&#xA;  {&#xA;    query: graphql`&#xA;      fragment TeamsComponent_query on Query&#xA;        @argumentDefinitions(&#xA;          first: { type: Int }&#xA;          last: { type: Int }&#xA;          before: { type: String }&#xA;          after: { type: String }&#xA;        ) {&#xA;        teams(&#xA;          id: { type: ""ID!"" }&#xA;          first: { type: Int }&#xA;          last: { type: Int }&#xA;          before: { type: String }&#xA;          after: { type: String }&#xA;        ) @connection(key: ""TeamsComponent_teams"", filters: []) {&#xA;          count&#xA;          pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;          }&#xA;          edges {&#xA;            node {&#xA;              id&#xA;               name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;  graphql`&#xA;    query TeamsComponent(&#xA;      $after: String&#xA;      $before: String&#xA;      $first: Int&#xA;      $last: Int&#xA;    ) {&#xA;        ...TeamsComponent_query&#xA;          @arguments(&#xA;            first: $first&#xA;            last: $last&#xA;            after: $after&#xA;            before: $before&#xA;          )&#xA;    }&#xA;  `,&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>I tried to build an example based on your code. This is basically the idea. The bottom query is the re-fetch one. Alongside with that, you must trigger this re-fetch somehow by calling <code>this.props.relay.refetch</code> passing your <code>renderVaribles</code>. Take a deep looker into the docs about this.&#xA;Hope is helps :)</p>&#xA;&#xA;<p>UPDATE:</p>&#xA;&#xA;<p>Just to add something, you could have a <code>handleLoadMore</code> function with something like this:</p>&#xA;&#xA;<pre><code>  handleLoadMore = () =&gt; {&#xA;    const { relay, connection } = this.props;&#xA;    const { isFetching } = this.state;&#xA;&#xA;    if (!connection) return;&#xA;&#xA;    const { edges, pageInfo } = connection;&#xA;&#xA;    if (!pageInfo.hasNextPage) return;&#xA;&#xA;    const total = edges.length + TOTAL_REFETCH_ITEMS;&#xA;&#xA;    const fragmentRenderVariables = this.getRenderVariables() || {};&#xA;    const renderVariables = { first: total, ...fragmentRenderVariables };&#xA;&#xA;    if (isFetching) {&#xA;      // do not loadMore if it is still loading more or searching&#xA;      return;&#xA;    }&#xA;&#xA;    this.setState({&#xA;      isFetching: true,&#xA;    });&#xA;    const refetchVariables = fragmentVariables =&gt; ({&#xA;      first: TOTAL_REFETCH_ITEMS,&#xA;      after: pageInfo.endCursor,&#xA;    });&#xA;&#xA;    relay.refetch(&#xA;      refetchVariables,&#xA;      null,&#xA;      () =&gt; {&#xA;        this.setState({ isFetching: false });&#xA;      },&#xA;      {&#xA;        force: false,&#xA;      },&#xA;    );&#xA;  };&#xA;</code></pre>&#xA;&#xA;<p>UPDATE 2:</p>&#xA;&#xA;<p>For going backwards, you could have something like:</p>&#xA;&#xA;<pre><code>  loadPageBackwardsVars = () =&gt; {&#xA;    const { connection, quantityPerPage } = this.props;&#xA;    const { quantity } = getFormatedQuery(location);&#xA;&#xA;    const { endCursorOffset, startCursorOffset } = connection;&#xA;&#xA;    const firstItem = connection.edges.slice(startCursorOffset, endCursorOffset)[0].cursor;&#xA;&#xA;    const refetchVariables = fragmentVariables =&gt; ({&#xA;      ...fragmentVariables,&#xA;      ...this.getFragmentVariables(),&#xA;      last: parseInt(quantity || quantityPerPage, 10) || 10,&#xA;      first: null,&#xA;      before: firstItem,&#xA;    });&#xA;&#xA;    return refetchVariables;&#xA;  };&#xA;</code></pre>&#xA;",6768607,,6768607,2018-10-03 12:02:37,2018-10-03 12:02:37,"",,0,4,0,2018-10-02 13:02:51
52611086,1,,,1,942,"<p>In GraphQL the recommended way for pagination is to use connections as described <a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">here</a>. I understand the reasons and advantages of this usage but I need an advice how to implement it.</p>&#xA;&#xA;<p>The server side of the application works on top of a SQL database (Postgres in my case). Some of the GraphQL connection fields have optional argument to specify sorting. Now with knowing the sorting columns and a cursor from the GraphQL query, how can I build an SQL query? Of course it should be efficient - if there is a SQL index index for the combination of sorting columns it should be used.</p>&#xA;&#xA;<p>The problem is that SQL doesn't know anything like GraphQL cursors - we can't tell it to select all rows after certain row. There is just WHERE, OFFSET and LIMIT. From my point of view it seems I need to firstly select a single row based on the cursor and then build a second SQL query using the values of the sorting columns in that row to specify a complicated WHERE clause - not sure if the database would use index in that case.</p>&#xA;&#xA;<p><em>What bothers me is that I could not find any article on this topic. Does it mean that SQL database is not usually used when implementing a GraphQL server? What database should be used then? How are GraphQL queries to connection fields usually transformed to queries for the underlying database?</em></p>&#xA;&#xA;<p>EDIT: <a href=""https://github.com/graphql/graphql-relay-js/issues/94#issuecomment-232410564"" rel=""nofollow noreferrer"">This</a> is more or less what I came up with myself. The problem is how to extend it to support sorting as well and how to implement it efficiently using database indexes.</p>&#xA;",512485,,512485,2018-10-02 15:23:59,2018-10-02 23:46:35,How to implement a backend for GraphQL connections?,<sql><sorting><pagination><graphql>,1,0,0,2018-10-02 15:00:49
52617870,2,,52611086,-1,,"<p>The trick here is that, as the server implementer, the cursor can be literally any value you want encoded as a string.  Most examples I've seen have been base64-encoded for a bit of opacity, but it doesn't have to be.  (Try base64-decoding the cursors from the Star Wars examples in your link, for example.)</p>&#xA;&#xA;<p>Let's say your GraphQL schema looks like</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>enum ThingColumn { FOO BAR }&#xA;input ThingFilter {&#xA;  foo: Int&#xA;  bar: Int&#xA;}&#xA;type Query {&#xA;  things(&#xA;    filter: ThingFilter,&#xA;    sort: ThingColumn,&#xA;    first: Int,&#xA;    after: String&#xA;  ): ThingConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Your first query might be</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>query {&#xA;  things(filter: { foo: 1 }, sort: BAR, first: 2) {&#xA;    edges {&#xA;      node { bar }&#xA;    }&#xA;    pageInfo {&#xA;      endCursor&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This on its own could fairly directly translate into an SQL query like</p>&#xA;&#xA;<pre class=""lang-sql prettyprint-override""><code>SELECT bar FROM things WHERE foo=1 ORDER BY bar ASC LIMIT 2;&#xA;</code></pre>&#xA;&#xA;<p>Now as you iterate through each item you can just use a string version of its offset as its cursor; that's totally allowed by the spec.</p>&#xA;&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  ""data"": {&#xA;    ""things"": {&#xA;      ""edges"": [&#xA;        { ""node"": { ""bar"": 17 } },&#xA;        { ""node"": { ""bar"": 42 } }&#xA;      ],&#xA;      ""pageInfo"": {&#xA;        ""endCursor"": ""2"",&#xA;        ""hasNextPage"": true&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then when the next query says <code>after: ""2""</code>, you can turn that back into an SQL <code>OFFSET</code> and repeat the query.</p>&#xA;&#xA;<p>If you're trying to build a generic GraphQL interface that gets translated to reasonably generic SQL queries, it's impossible to create indexes such that every query is ""fast"".  Like other cases, you need to figure out what your common and/or slow queries are and <code>CREATE INDEX</code> as needed.  You might be able to limit the options in your schema to things you know you can index:</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>type Other {&#xA;  things(first: Int, after: String): ThingConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>query OtherThings($id: ID!, $cursor: String) {&#xA;  node(id: $id) {&#xA;    ... on Other {&#xA;      things(first: 100, after: $cursor) { ... FromAbove }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-sql prettyprint-override""><code>SELECT * FROM things WHERE other_id=? ORDER BY id LIMIT ?;&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-sql prettyprint-override""><code>CREATE INDEX things_other ON things(other_id);&#xA;</code></pre>&#xA;",10008173,,,,2018-10-02 23:46:35,"",,0,4,0,2018-10-02 23:46:35
52663530,1,,,1,1673,"<p>A Client needs a specific JSON structure which I wanted to provide by an GraphQL Response.</p>&#xA;&#xA;<p>Unfortunately I have to get rid of the top level ""data"" field and flatten the response for that client.</p>&#xA;&#xA;<p>Is there a way to do this by a resolver?</p>&#xA;&#xA;<p>From:</p>&#xA;&#xA;<pre><code>{ &#xA;   ""data"" : {&#xA;      ""myKey"": &#xA;         {...}&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>To:</p>&#xA;&#xA;<pre><code>{ &#xA;   ""myKey"": &#xA;      {...}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Thanks!</p>&#xA;",3099894,,,,2018-10-05 15:56:32,Flatten Apollo GraphQL Response (Data Field),<graphql><graphql-js><apollo-client><apollo-server>,1,0,0,2018-10-05 10:26:33
52665875,2,,52665452,0,,"<p>Mongo and GraphQL are only source of structured data. Data is fetched (as logged) properly, you have a problem with rendering tree structured data.</p>&#xA;&#xA;<p>Just read <code>react-table</code> docs, look at examples, f.e. <a href=""https://react-table.js.org/#/story/sub-components"" rel=""nofollow noreferrer"">this one</a> ... you should use <code>accessor</code> to get access to the right parts of data.</p>&#xA;",6124657,,,,2018-10-05 12:40:27,"",,0,7,0,2018-10-05 12:40:27
52727119,2,,52722552,2,,"<p>Another thing that may be useful to avoid having to copy paste query code all over the place is to use query fragments .</p>&#xA;&#xA;<p>for example: </p>&#xA;&#xA;<pre><code># Query that contains a fragment&#xA;query myQuery1($_key: ID!) {&#xA;  myQuery1(_key: $_key) {&#xA;    field1,&#xA;    ...myFragmentFields&#xA;    }&#xA;  }&#xA;&#xA;# Fragment to be used in queries&#xA;fragment myFragmentFields on myQueryType {&#xA;    _key,&#xA;    name,&#xA;    formula,&#xA;    type&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Here is the <a href=""https://graphql.github.io/learn/queries/#fragments"" rel=""nofollow noreferrer"">documentation</a>:</p>&#xA;",3571016,,,,2018-10-09 18:18:33,"",,0,1,0,2018-10-09 18:18:33
52749578,2,,52748713,2,,"<p>Fragments are used client-side, not server-side. According to the spec:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the document... Fragments are consumed by using the spread operator (...). All fields selected by the fragment will be added to the query field selection at the same level as the fragment invocation. This happens through multiple levels of fragment spreads.</p>&#xA;</blockquote>&#xA;&#xA;<p>So a client request might include a query like this:</p>&#xA;&#xA;<pre><code>query {&#xA;    paintInputsUser{&#xA;        ...paintInputUserFields&#xA;    }&#xA;}&#xA;&#xA;fragment paintInputUserFields on PaintInputUser {&#xA;  username&#xA;  country&#xA;  views&#xA;  rol&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>There's nothing special you need to do server-side to enable this behavior. All spec-compliant implementations of GraphQL support fragments out of the box.</p>&#xA;",6024220,,,,2018-10-10 22:23:42,"",,0,1,0,2018-10-10 22:23:42
52812471,1,,,0,54,"<p>I have the following:</p>&#xA;&#xA;<pre><code>class PeopleByNameQueryComponent extends Query&lt;FindPeopleByNameQuery, FindPeopleByNameQueryVariables&gt; { }&#xA;&#xA;&#xA;export const PeopleByNameQuery = (props: any) =&gt; {&#xA;    const { children, ...otherProps } = props;&#xA;    return &lt;PeopleByNameQueryComponent query={FIND_PEOPLE_QUERY} variables={props.variables} {...otherProps}&gt;&#xA;...&#xA;    &lt;/PeopleByNameQueryComponent&gt;;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'd like to reduce the code to something like:</p>&#xA;&#xA;<pre><code>export const PeopleByNameQuery = (props: any) =&gt; {&#xA;    const { children, ...otherProps } = props;&#xA;&#xA;    const ClassToUse = GenericQueryClass extends Query&lt;props.FindQuery, props.QueryVariables&gt; { }&#xA;&#xA;    return &lt;ClassToUse query={FIND_PEOPLE_QUERY} variables={props.variables} {...otherProps}&gt;&#xA;    &lt;/ClassToUse&gt;;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm not too sure if this is possible, the end goal is to reduce the amount of code being written to accomplish the same thing, there will be a lot of queries.</p>&#xA;",79891,,79891,2018-10-15 08:24:28,2018-10-15 08:24:28,Create a class extending another class at runtime in typescript,<javascript><reactjs><typescript><generics><react-apollo>,0,4,0,2018-10-15 08:21:00
52833294,1,52886339,,0,454,"<p>The following graphene query of mine where I pass parameters to my query returns all the results, even when my front end gives correct parameters it gives all results. Even with data where no result should return it still returns all results.</p>&#xA;&#xA;<p>I have a graphene type:</p>&#xA;&#xA;<pre><code>class TimeStampType(DjangoObjectType):&#xA;    rowid=graphene.Int()&#xA;    class Meta:&#xA;        model = TimeStamp &#xA;        interfaces = (Node, )&#xA;        filter_fields = {&#xA;            'year': ['exact'],&#xA;            'week': ['exact'],&#xA;            'weekDay': ['exact'],&#xA;            'shift': ['exact'],&#xA;            'time': ['exact'],&#xA;            'shortDate': ['exact'],&#xA;        }&#xA;    def resolve_rowid(self, context, **kwargs):&#xA;        return self.id&#xA;</code></pre>&#xA;&#xA;<p>with query: </p>&#xA;&#xA;<pre><code>node_timestamp = DjangoFilterConnectionField(TimeStampType)&#xA;</code></pre>&#xA;&#xA;<p>My query looks like the following: </p>&#xA;&#xA;<pre><code>query nodeTimeStamp($year:Float, $week:Float, $weekDay:Float){&#xA;  nodeTimestamp(year:$year, week:$week, weekDay:$weekDay) {&#xA;    edges{&#xA;      node{&#xA;        id&#xA;        rowid&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5996109,,,,2018-10-19 05:30:16,Django Graphene node interface with arguments returns all fields,<django><graphql><graphene-python>,1,1,0,2018-10-16 10:23:10
52844535,1,,,3,1880,"<p>I am new to gatsby and graphQL and am trying to build a website with this stack that will display a list of concerts/events. </p>&#xA;&#xA;<p>My question is:  </p>&#xA;&#xA;<p>Is it possible to pass data from my app state down to my query variables. Where do I connect my state and my graphQL query ?  </p>&#xA;&#xA;<p>Here is my code: </p>&#xA;&#xA;<pre><code>class IndexPage extends Component {&#xA;&#xA;state = {&#xA;  term: '',&#xA;  date: null,&#xA;}&#xA;&#xA;&#xA;onTermChange(term) {&#xA;  this.setState({ term });&#xA;}&#xA;&#xA;render() {&#xA;  return (&#xA;  &lt;Layout&gt;&#xA;    &lt;SearchForm&#xA;      onTermChange={this.onTermChange.bind(this)}&#xA;      value={this.state.term}&#xA;    /&gt;&#xA;&#xA;    &lt;Calendar&#xA;      onChange={date =&gt; this.setState({ date })}&#xA;      value={this.state.date}&#xA;&#xA;    /&gt;&#xA;&#xA;    &lt;StaticQuery&#xA;      query={graphql`&#xA;      query ComingEvents {&#xA;        allEvent(sort: {fields: [dateAndTime], order: ASC}) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              name&#xA;              dateAndTime&#xA;              venue&#xA;              ticketsLink&#xA;              city&#xA;              thumbnail {&#xA;                id&#xA;                url&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }`&#xA;      }&#xA;      render={ data =&gt; (&#xA;        &lt;EventsList&#xA;        events={data.allEvent.edges}&#xA;         /&gt;&#xA;      )}&#xA;     /&gt;&#xA;&lt;/Layout&gt;&#xA;&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>}&#xA;}</p>&#xA;&#xA;<p>Basically this is what I want to do:</p>&#xA;&#xA;<ol>&#xA;<li>When the value of the search field form <code>this.state.term</code> changes, I want to pass this as $name parameter and query new results. </li>&#xA;<li>When the value of the date picked out in the calendar <code>this.state.date</code> changes, I want to pass this as $dateAndTime parameter and query new results.</li>&#xA;</ol>&#xA;",8045609,,8045609,2018-10-16 22:17:57,2021-10-01 23:10:37,Gatsby - Pass state property to GraphQL query variables/parameter?,<reactjs><graphql><gatsby>,1,5,0,2018-10-16 21:54:52
52854703,1,52854927,,0,327,"<p>Here's the graph I'm working on.</p>&#xA;&#xA;<pre><code>g = TinkerGraph.open().traversal()&#xA;first_generation = g.addV('person').property('id', '1').next()&#xA;second_generation = g.addV('person').property('id', '2').next()&#xA;third_generation = g.addV('person').property('id', '3').next()&#xA;third_generation_1 = g.addV('person').property('id', '4').next()&#xA;fourth_generation = g.addV('person').property('id', '5').next()&#xA;g.addE('child').from(first_generation).to(second_generation)&#xA;g.addE('child').from(second_generation).to(third_generation)&#xA;g.addE('child').from(second_generation).to(third_generation_1)&#xA;g.addE('child').from(third_generation).to(fourth_generation)&#xA;</code></pre>&#xA;&#xA;<p>Here, I want to fetch the list of all people with the number of children they have. </p>&#xA;&#xA;<pre><code>[{'id': 1, 'children': 1}, {'id': 2, 'children': 2}]&#xA;</code></pre>&#xA;&#xA;<p>I read about <code>sideEffect</code> but can't seem to append the result of sideEffect to the output. </p>&#xA;&#xA;<p>Any suggestions on how we can achieve the desired output ?</p>&#xA;",3708849,,,,2018-10-17 12:30:53,How to append the count of child vertices in Gremlin?,<graphql><gremlin><tinkerpop><tinkerpop3><gremlin-server>,1,0,0,2018-10-17 12:17:01
52867379,2,,52867124,4,,"<p>You need to make the <code>ShopLocation</code> with <code>input</code> keyword instead of <code>type</code>,</p>&#xA;&#xA;<pre><code>input ShopLocationInput {&#xA;  lane1: String&#xA;  lane2: String&#xA;  city: String&#xA;  postalCode: String&#xA;  country: String&#xA;}&#xA;&#xA;type ShopResponse {&#xA;  statusCode: Int&#xA;  messageCode: String&#xA;  data: String&#xA;}&#xA;&#xA;type Mutation {&#xA;  createShop(&#xA;    name: String&#xA;    email: String&#xA;    location: ShopLocationInput&#xA;  ): ShopResponse&#xA;}&#xA;</code></pre>&#xA;",6673165,,,,2018-10-18 05:13:35,"",,0,0,0,2018-10-18 05:13:35
52911340,2,,52820680,3,,"<p>From <a href=""https://developer.github.com/v3/pulls/comments/"" rel=""nofollow noreferrer"">Github API comment doc</a> : </p>&#xA;&#xA;<blockquote>&#xA;  <p>The position value equals the number of lines down from <strong>the first ""@@"" hunk header in the file</strong> you want to add a comment. The line just below the ""@@"" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.</p>&#xA;</blockquote>&#xA;&#xA;<p>Here <code>diffHunk</code> gives you the current diff hunk which is not necessary the first in the file</p>&#xA;&#xA;<p>If you get the full diff file it's more clear : </p>&#xA;&#xA;<pre class=""lang-curl prettyprint-override""><code>curl ""https://api.github.com/repos/Kmaschta/comfygure/pulls/1"" \&#xA;     -H ""Accept: application/vnd.github.v3.diff""&#xA;</code></pre>&#xA;&#xA;<p>The comment is in <code>env.js</code> whose first hunk starts at line 77, your comment is in line 148 while the <code>diffHunk</code> in your request starts at line 114</p>&#xA;&#xA;<p>I don't think it's possible to request the full PR diff using GraphQL at the moment but you can use Rest v3 as above</p>&#xA;",2614364,,,,2018-10-21 01:10:38,"",,0,3,0,2018-10-21 01:10:38
53051660,2,,53029549,0,,"<p>Without a sample graph I'm really just trying to make a good guess:</p>&#xA;&#xA;<pre><code>g.V().has(""id"", ""17892"").&#xA;  bothE(""nextStop"").as(""e"").outV().&#xA;  until(__.not(inE(""nextStop"").&#xA;                 where(eq(""e"")).by(""route"").&#xA;                 where(lt(""e"")).by(""stopSeq""))).&#xA;    repeat(inE(""nextStop"").&#xA;             where(eq(""e"")).by(""route"").&#xA;             where(lt(""e"")).by(""stopSeq"").as(""e"").outV()).as(""origin"").&#xA;  outE(""nextStop"").as(""e"").inV().&#xA;  until(__.not(outE(""nextStop"").&#xA;                 where(eq(""e"")).by(""route"").&#xA;                 where(gt(""e"")).by(""stopSeq""))).&#xA;    repeat(outE(""nextStop"").&#xA;             where(eq(""e"")).by(""route"").&#xA;             where(gt(""e"")).by(""stopSeq"").as(""e"").inV()).&#xA;  path().&#xA;    from(""origin"").&#xA;    by(""stop_id"").&#xA;    by(""distance"")&#xA;</code></pre>&#xA;&#xA;<p>This traversal is supposed to find all the origins and from there traverse to the final destination stops and emit those paths.</p>&#xA;",612000,,,,2018-10-29 18:26:39,"",,0,0,0,2018-10-29 18:26:39
53074038,1,53109455,,6,264,"<p>I'm using GraphQL + Relay in my app and find myself wrapping almost every component with <code>createFragmentContainer</code>, including those very low in the DOM hierarchy (usually functional components). </p>&#xA;&#xA;<p>Is that the right way to use fragments? I'm wondering what are the guidelines for when to wrap components in fragment containers? Seems redundant to wrap a component when it only needs one field and I can pass that data from the parent via props.</p>&#xA;&#xA;<p>I'm using Relay but I think the concepts are similar to Apollo as well.</p>&#xA;",1751946,,1751946,2018-10-30 23:01:59,2018-11-01 23:27:10,How granular should Relay/Apollo fragments be?,<reactjs><graphql><apollo><relayjs><relay>,2,0,0,2018-10-30 22:56:27
53109455,2,,53074038,4,,"<p>Yes, it is. Instead of querying all the data on root component and pass to others as props, you should create fragment containers and each of this component query its own data. And due to relay data masking, these data from fragments can only be seen inside the component that required it.</p>&#xA;&#xA;<p>Maybe this is a good reading: <a href=""https://medium.com/entria/relay-apollo-anti-pattern-d9f4dea47738"" rel=""nofollow noreferrer"">https://medium.com/entria/relay-apollo-anti-pattern-d9f4dea47738</a></p>&#xA;&#xA;<p>And this on <code>Data Masking</code>: <a href=""https://facebook.github.io/relay/docs/en/thinking-in-relay.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/en/thinking-in-relay.html</a></p>&#xA;&#xA;<p>Hope it helps :)</p>&#xA;",6768607,,,,2018-11-01 21:15:41,"",,0,1,0,2018-11-01 21:15:41
53137317,1,53137511,,3,3906,"<p>I am looking for a solution to <strong>randomly</strong> <code>sort</code> a <strong><a href=""https://graphql.org/learn/"" rel=""nofollow noreferrer"">GraphQL</a></strong> query. I have looked through the documentation and it appears that their is no options. </p>&#xA;&#xA;<p>Does anyone know of one or a workaround to randomising the following query?</p>&#xA;&#xA;<pre><code>query {&#xA;  allContentfulAttraction(&#xA;    limit: 4&#xA;    filter: { location: { eq: ""AttractionLocation1"" } }&#xA;  ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8450582,,,,2020-06-13 14:41:25,Sort GraphQL query randomly,<javascript><reactjs><graphql><gatsby>,2,0,0,2018-11-04 02:43:45
53139135,2,,53097025,2,,"<p>ended up using this </p>&#xA;&#xA;<pre><code>@GraphQLQuery(name = ""projects"", description = ""Return a paginated Projects results"")&#xA;public List&lt;Project&gt; getAll(&#xA;        @GraphQLArgument(name = ""offset"",defaultValue = ""0"", description = ""Offset item from beginning of data"") int offset,&#xA;        @GraphQLArgument(name = ""limit"", defaultValue = ""10"", description = ""Limit the size of fetched results"") int limit&#xA;) { ... }&#xA;</code></pre>&#xA;&#xA;<p>if anyone can comment or add a different solution...</p>&#xA;&#xA;<p>G.</p>&#xA;",148397,,,,2018-11-04 08:49:54,"",,0,1,0,2018-11-04 08:49:54
53177346,1,53201520,,3,10264,"<p>I have a React project with a GraphQL server using Apollo client. I am trying to figure out how to change the query result based on search text and filtering selections. If someone could look at my code and give me some help, I would greatly appreciate it. Sorry about all the code, I thought maybe it all might be relevant.</p>&#xA;&#xA;<p><strong>server/index.js</strong></p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    getClasses: () =&gt; classes,&#xA;    searchClasses: () =&gt; classes&#xA;  },&#xA;};&#xA;&#xA;const server = new ApolloServer({ typeDefs, resolvers });&#xA;&#xA;const app = express();&#xA;app.use(cors());&#xA;app.use(bodyParser.text({ type: 'application/graphql' }));&#xA;server.applyMiddleware({ app });&#xA;&#xA;app.listen({ port: 4000 }, () =&gt;&#xA;  console.log(` Server ready at http://localhost:4000${server.graphqlPath}`)&#xA;);&#xA;</code></pre>&#xA;&#xA;<p><strong>server/schema.js</strong></p>&#xA;&#xA;<pre><code>const typeDefs = `&#xA;  type Class {&#xA;    entry_id: ID!&#xA;    title: String&#xA;    url: String&#xA;    thumb: String&#xA;    duration: [String]&#xA;    style: [String]&#xA;    intensity: [String]&#xA;    anatomical_focus: [String]&#xA;    level: [String]&#xA;    teacher: [String]&#xA;    authorId: Int&#xA;    live_start: Int&#xA;    live_end: Int&#xA;    type: String&#xA;    logged_in_member_id: Int&#xA;    favorite: Boolean&#xA;    favorite_order: Int&#xA;    favorited_on: Int&#xA;    body_snippet: String&#xA;  }&#xA;&#xA;  input Filters {&#xA;    teacher: String&#xA;    duration: String&#xA;    level: String&#xA;    style: String&#xA;    anatomy: String&#xA;  }&#xA;&#xA;  type Query {&#xA;    getClasses: [Class]!&#xA;    searchClasses(search: String, filters: Filters): [Class]!&#xA;  }&#xA;`;&#xA;&#xA;module.exports = typeDefs;&#xA;</code></pre>&#xA;&#xA;<p><strong>client/src/index.js</strong></p>&#xA;&#xA;<pre><code>const client = new ApolloClient({&#xA;  uri: 'http://localhost:4000/graphql',&#xA;  cache: new InMemoryCache()&#xA;});&#xA;&#xA;ReactDOM.render(&#xA;  &lt;ApolloProvider client={client}&gt;&#xA;    &lt;Header /&gt;&#xA;    &lt;Router&gt;&#xA;      &lt;Route exact path='/' component={App}/&gt;&#xA;    &lt;/Router&gt;&#xA;  &lt;/ApolloProvider&gt;, &#xA;  document.getElementById('root')&#xA;);&#xA;serviceWorker.unregister();&#xA;</code></pre>&#xA;&#xA;<p><strong>queries/search</strong></p>&#xA;&#xA;<pre><code>const SEARCH_CLASSES = gql`&#xA;  query SearchClasses($search: String, $filters: Filters) {&#xA;    searchClasses(search: $search, filters: $filters) {&#xA;      entry_id&#xA;      title&#xA;      url&#xA;      thumb&#xA;      duration&#xA;      style&#xA;      intensity&#xA;      level&#xA;      teacher&#xA;      body_snippet&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p><strong>client/src/pages/Classes.js</strong></p>&#xA;&#xA;<pre><code>class Classes extends Component {&#xA;    constructor(props) {&#xA;        super(props);&#xA;        this.state = { keyword: '', filters: { teacher: '', duration: '', level: '', style: '', anatomy: '' } };&#xA;        this.setSearch = this.setSearch.bind(this);&#xA;        this.setFilters = this.setFilters.bind(this);&#xA;    }&#xA;    setSearch(e) {&#xA;        this.setState({&#xA;            keyword: e.target.value&#xA;        });&#xA;    }&#xA;    setFilters(e) {&#xA;        this.setState({&#xA;            filters: e.target.value&#xA;        })&#xA;    }&#xA;    componentDidMount() {&#xA;        var ddToggle = document.querySelectorAll('.dropdown-toggle');&#xA;        ddToggle.forEach(function (dd) {&#xA;            dd.addEventListener(""click"", function(ev) {&#xA;                dd.nextSibling.classList.toggle('show');&#xA;            });&#xA;        });&#xA;    }&#xA;&#xA;    render() {&#xA;        let text = this.state.keyword;&#xA;        let teacher = this.state.filters.teacher;&#xA;        let duration = this.state.filters.duration;&#xA;        let level = this.state.filters.level;&#xA;        let style = this.state.filters.style;&#xA;        let anatomy = this.state.filters.anatomy;&#xA;        return (&#xA;            &lt;Query&#xA;                query={Queries.Search}&#xA;                variables={{&#xA;                    search: text,&#xA;                    filters: {&#xA;                        teacher: '',&#xA;                        duration: '',&#xA;                        level: '',&#xA;                        style: '',&#xA;                        anatomy: ''&#xA;                    }&#xA;                }}&gt;&#xA;                {({ loading, error, data }) =&gt; {&#xA;                    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;&#xA;                    if (error) return &lt;p&gt;Error: ${error}&lt;/p&gt;;&#xA;                    return (&#xA;                        &lt;div&gt;&#xA;                            &lt;section className=""ygi-search""&gt;&#xA;                            &lt;div className=""container px-3""&gt;&#xA;                                &lt;div className=""ygi-search__wrapper""&gt;&#xA;                                    &lt;SearchBar handleSearch={this.setSearch} search={ text } /&gt;&#xA;                                    &lt;button className=""ygi-search__filter-btn mx-auto mb-2 "" aria-label=""Shows Filters""&gt;Show Filters&lt;/button&gt;&#xA;                                    &lt;div className=""yi-dropdowns__wrapper-visibility col-lg-10 ""&gt;&#xA;                                        &lt;div className=""row""&gt;&#xA;                                            &lt;TeachersDD handleSelect={this.setFilters} selection={ teacher } /&gt;&#xA;                                            &lt;DurationDD  handleSelect={this.setFilters} selection={ duration } /&gt;&#xA;                                            &lt;LevelDD handleSelect={this.setFilters} selection={ level } /&gt;&#xA;                                            &lt;StyleDD handleSelect={this.setFilters} selection={ style } /&gt;&#xA;                                            &lt;AnatomyDD handleSelect={this.setFilters} selection={ anatomy } /&gt;&#xA;                                        &lt;/div&gt;&#xA;                                    &lt;/div&gt;&#xA;                                &lt;/div&gt;&#xA;                            &lt;/div&gt;&#xA;                        &lt;/section&gt;&#xA;                            &lt;div className=""flex""&gt;&#xA;                                {data.searchClasses.map(single =&gt; (&#xA;                                    &lt;Class class={single} key={single.entry_id} /&gt;&#xA;                                ))}&#xA;                            &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    )&#xA;                }}&#xA;            &lt;/Query&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;export default Classes;&#xA;</code></pre>&#xA;&#xA;<p><strong>client/src/components/Search.js</strong></p>&#xA;&#xA;<pre><code>class SearchBar extends Component {&#xA;&#xA;    render() {&#xA;        return (&#xA;            &lt;div className=""ygi-search-bar col col-12 col-lg-2""&gt;&#xA;                &lt;div className=""ygi-search-bar__wrapper mt-2""&gt;&#xA;                    &lt;input onChange={this.props.handleSearch} placeholder=""Search"" value={this.props.search} type=""text"" className=""ygi-search-bar__input"" /&gt;&#xA;                    &lt;a href=""true"" className=""icon-wrapper ygi-search-bar__icon-wrapper"" style={{ bottom: ""calc(50%)"" }}&gt;&#xA;                        &lt;svg role=""presentation"" className=""icon-search-grey""&gt;&#xA;                            &lt;use xlinkHref=""#icon-search-grey""&gt;&lt;/use&gt;&#xA;                        &lt;/svg&gt;&#xA;                    &lt;/a&gt;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;SearchBar.propTypes = {&#xA;    handleSearch: PropTypes.func,&#xA;    text: PropTypes.string&#xA;};&#xA;&#xA;export default SearchBar;&#xA;</code></pre>&#xA;",10614567,,10614567,2018-11-07 13:26:32,2018-11-08 04:21:01,React Apollo GraphQL Search/Filter,<reactjs><graphql><apollo>,1,1,0,2018-11-06 17:53:28
53267388,1,,,2,241,"<p>I'm trying to find a way to create an engine that translates GraphQL query filters to MongoDB aggregations while keeping the performance. Our application has the requisite of limiting the results from collection A by applying filters to collection B, C and even D sometimes.</p>&#xA;&#xA;<p>For better understanding, here's a sample about how a filter is translated to MongoDB.</p>&#xA;&#xA;<p>This:</p>&#xA;&#xA;<pre><code>{&#xA;  ""filter"": {&#xA;    ""return"": null,&#xA;    ""AND"": [{&#xA;      ""customer_WITH"": {&#xA;        ""OR"": [{&#xA;          ""code"": ""CUSTOMER NAME""&#xA;        }, {&#xA;          ""commercialName_LIKE"": ""CUSTOMER NAME""&#xA;        }, {&#xA;          ""corporateName_LIKE"": ""CUSTOMER NAME""&#xA;        }]&#xA;      }&#xA;    }],&#xA;    ""OR"": [{&#xA;      ""dispatcher_WITH"": {&#xA;        ""company_WITH"": {&#xA;          ""corporateName_LIKE"": ""COMPANY NAME""&#xA;        }&#xA;      }&#xA;    }, {&#xA;      ""redispatcher_WITH"": {&#xA;        ""company_WITH"": {&#xA;          ""corporateName_LIKE"": ""COMPANY NAME""&#xA;        }&#xA;      }&#xA;    }],&#xA;    ""reversal"": null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Gets translated to this:</p>&#xA;&#xA;<pre><code>[{&#xA;  ""$match"": {&#xA;    ""return"": {&#xA;      ""$eq"": null&#xA;    },&#xA;    ""reversal"": {&#xA;      ""$eq"": null&#xA;    },&#xA;    ""company"": {&#xA;      ""$eq"": ObjectId(""xxxxxxxxxxxxxxxxxxxxxxxx"")&#xA;    }&#xA;  }&#xA;}, {&#xA;  ""$lookup"": {&#xA;    ""as"": ""dispatcher"",&#xA;    ""from"": ""shippers"",&#xA;    ""localField"": ""dispatcher"",&#xA;    ""foreignField"": ""_id""&#xA;  }&#xA;}, {&#xA;  ""$unwind"": {&#xA;    ""path"": ""$dispatcher"",&#xA;    ""preserveNullAndEmptyArrays"": true&#xA;  }&#xA;}, {&#xA;  ""$lookup"": {&#xA;    ""as"": ""dispatcher.company"",&#xA;    ""from"": ""companies"",&#xA;    ""localField"": ""dispatcher.company"",&#xA;    ""foreignField"": ""_id""&#xA;  }&#xA;}, {&#xA;  ""$unwind"": {&#xA;    ""path"": ""$dispatcher.company"",&#xA;    ""preserveNullAndEmptyArrays"": true&#xA;  }&#xA;}, {&#xA;  ""$lookup"": {&#xA;    ""as"": ""redispatcher"",&#xA;    ""from"": ""shippers"",&#xA;    ""localField"": ""redispatcher"",&#xA;    ""foreignField"": ""_id""&#xA;  }&#xA;}, {&#xA;  ""$unwind"": {&#xA;    ""path"": ""$redispatcher"",&#xA;    ""preserveNullAndEmptyArrays"": true&#xA;  }&#xA;}, {&#xA;  ""$lookup"": {&#xA;    ""as"": ""redispatcher.company"",&#xA;    ""from"": ""companies"",&#xA;    ""localField"": ""redispatcher.company"",&#xA;    ""foreignField"": ""_id""&#xA;  }&#xA;}, {&#xA;  ""$unwind"": {&#xA;    ""path"": ""$redispatcher.company"",&#xA;    ""preserveNullAndEmptyArrays"": true&#xA;  }&#xA;}, {&#xA;  ""$lookup"": {&#xA;    ""as"": ""customer"",&#xA;    ""from"": ""customers"",&#xA;    ""localField"": ""customer"",&#xA;    ""foreignField"": ""_id""&#xA;  }&#xA;}, {&#xA;  ""$match"": {&#xA;    ""$or"": [{&#xA;      ""dispatcher.company.corporateName"": {&#xA;        ""$regex"": /\sCOMPANY\sNAME/&#xA;      }&#xA;    }, {&#xA;      ""redispatcher.company.corporateName"": {&#xA;        ""$regex"": /\sCOMPANY\sNAME/&#xA;      }&#xA;    }],&#xA;    ""$and"": [{&#xA;      ""$or"": [{&#xA;        ""customer.code"": {&#xA;          ""$eq"": ""CUSTOMER NAME""&#xA;        }&#xA;      }, {&#xA;        ""customer.commercialName"": {&#xA;          ""$regex"": /CUSTOMER\sNAME/&#xA;        }&#xA;      }, {&#xA;        ""customer.corporateName"": {&#xA;          ""$regex"": /CUSTOMER\sNAME/&#xA;        }&#xA;      }]&#xA;    }]&#xA;  }&#xA;}, {&#xA;  ""$unwind"": {&#xA;    ""path"": ""$customer"",&#xA;    ""preserveNullAndEmptyArrays"": true&#xA;  }&#xA;}, {&#xA;  ""$group"": {&#xA;    ""_id"": ""$invoiceNo"",&#xA;    ""__rootId"": {&#xA;      ""$first"": ""$_id""&#xA;    },&#xA;    ""company"": {&#xA;      ""$first"": ""$company""&#xA;    },&#xA;    ""customer"": {&#xA;      ""$first"": ""$customer._id""&#xA;    },&#xA;    ""dispatcher"": {&#xA;      ""$first"": ""$dispatcher._id""&#xA;    },&#xA;    ""redispatcher"": {&#xA;      ""$first"": ""$redispatcher._id""&#xA;    },&#xA;    ""driverPlate"": {&#xA;      ""$first"": ""$driverPlate""&#xA;    },&#xA;    ""key"": {&#xA;      ""$first"": ""$key""&#xA;    },&#xA;    ""activities"": {&#xA;      ""$first"": ""$activities""&#xA;    },&#xA;    ""serialNo"": {&#xA;      ""$first"": ""$serialNo""&#xA;    },&#xA;    ""invoiceNo"": {&#xA;      ""$first"": ""$invoiceNo""&#xA;    },&#xA;    ""incidents"": {&#xA;      ""$first"": ""$incidents""&#xA;    },&#xA;    ""deliveries"": {&#xA;      ""$first"": ""$deliveries""&#xA;    },&#xA;    ""return"": {&#xA;      ""$first"": ""$return""&#xA;    }&#xA;  }&#xA;}, {&#xA;  ""$project"": {&#xA;    ""_id"": ""$__rootId"",&#xA;    ""company"": ""$company"",&#xA;    ""customer"": ""$customer"",&#xA;    ""dispatcher"": ""$dispatcher"",&#xA;    ""redispatcher"": ""$redispatcher"",&#xA;    ""driverPlate"": ""$driverPlate"",&#xA;    ""key"": ""$key"",&#xA;    ""activities"": ""$activities"",&#xA;    ""serialNo"": ""$serialNo"",&#xA;    ""invoiceNo"": ""$invoiceNo"",&#xA;    ""incidents"": ""$incidents"",&#xA;    ""deliveries"": ""$deliveries"",&#xA;    ""return"": ""$return""&#xA;  }&#xA;}, {&#xA;  ""$sort"": {&#xA;    ""invoiceNo"": -1&#xA;  }&#xA;}, {&#xA;  ""$limit"": 51&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>The engine is smart enough to reallocate to the first position $match properties that don't require $lookups and right after $lookups if they do, however if they are within a $and/$or condition block, then they are reallocated after the last $lookup, regardless of what properties are there.</p>&#xA;&#xA;<p>I could scan for what is used inside the $and and deconstruct it into new reallocated $match phases, but I need to figure how to handle the $or operator: I can't apply the same desconstruction idea on it because this would invalidate the condition.</p>&#xA;&#xA;<p>So my question is: Is there an alternative way to use the phase $lookup along with $and/$or and improve the performance drastically? </p>&#xA;&#xA;<p>Creating more indexes won't help because they're not used for the $lookup. Moving up $match phases, as the MongoDB team would suggest is also not possible because it would break the conditions. So I'm out of ideas now.</p>&#xA;&#xA;<p>Best regards.</p>&#xA;",6041744,,3708153,2019-02-28 19:05:51,2019-02-28 19:05:51,Slow query performance: MongoDB with $lookup and $and/$or,<javascript><mongodb><performance><graphql><graphql-tag>,0,4,0,2018-11-12 17:40:04
53276607,1,,,3,1032,"<p>I am trying to connect my existing react-native project to GrapghQl using relay. <code>__generated__</code> folder not creating AppQuery.graphql.js  </p>&#xA;&#xA;<p><a href=""http://facebook.github.io/relay/docs/en/installation-and-setup.html%20https://codeburst.io/how-to-setup-a-react-native-graphql-relay-modern-a6a5f6c18353"" rel=""nofollow noreferrer"">Reference link</a>.  </p>&#xA;&#xA;<p>error-&#xA;<a href=""https://i.stack.imgur.com/mBHoG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mBHoG.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>package.json</p>&#xA;&#xA;<pre><code>{&#xA;  ""name"": ""farmcom"",&#xA;  ""version"": ""0.0.1"",&#xA;  ""private"": true,&#xA;  ""scripts"": {&#xA;    ""start"": ""node node_modules/react-native/local-cli/cli.js start"",&#xA;    ""relay"": ""relay-compiler --src ./src --schema ./schema.graphql"",&#xA;    ""relayw"": ""relay-compiler --src ./src --schema ./schema.graphql --watch"",&#xA;    ""test"": ""jest""&#xA;  },&#xA;  ""dependencies"": {&#xA;    ""graphql"": ""^14.0.2"",&#xA;    ""prop-types"": ""^15.6.2"",&#xA;    ""react"": ""16.5.0"",&#xA;    ""react-native"": ""^0.57.2"",&#xA;    ""react-native-collapsible"": ""^1.2.0"",&#xA;    ""react-native-splash-screen"": ""^3.0.6"",&#xA;    ""react-native-vector-icons"": ""^6.0.2"",&#xA;    ""react-navigation"": ""^2.17.0"",&#xA;    ""react-relay"": ""^1.7.0"",&#xA;    ""relay"": ""^0.8.0-1""&#xA;  },&#xA;  ""devDependencies"": {&#xA;    ""babel-jest"": ""23.6.0"",&#xA;    ""babel-plugin-relay"": ""^1.7.0"",&#xA;    ""jest"": ""23.6.0"",&#xA;    ""metro-react-native-babel-preset"": ""0.48.0"",&#xA;    ""react-test-renderer"": ""16.5.0"",&#xA;    ""relay-compiler"": ""^1.7.0"",&#xA;    ""schedule"": ""^0.4.0""&#xA;  },&#xA;  ""jest"": {&#xA;    ""preset"": ""react-native""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>.babelrc</p>&#xA;&#xA;<pre><code>{&#xA;  ""presets"": [""module:metro-react-native-babel-preset""],&#xA;  ""plugins"": [""relay""]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>relay-environment.js</p>&#xA;&#xA;<pre><code>const { Environment, Network, RecordSource, Store } = require(""relay-runtime"");&#xA;&#xA;const source = new RecordSource();&#xA;const store = new Store(source);&#xA;&#xA;var myHeaders = new Headers();&#xA;// myHeaders.append('Access-Control-Allow-Headers', 'Content-Type');&#xA;// myHeaders.append(""Content-Type"", ""multipart/form-data"");&#xA;myHeaders.append(""Content-Type"", ""application/json"");&#xA;&#xA;//'https://us-west-2.api.scaphold.io/graphql/narrow-pigs'&#xA;//'https://api.graph.cool/relay/v1/cj9z8yz7ig1zb0121dl0uwk2n&#xA;&#xA;// Define a function that fetches the results of an operation (query/mutation/etc)&#xA;// and returns its results as a Promise:&#xA;function fetchQuery(operation, variables, cacheConfig, uploadables) {&#xA;  return fetch(""https://api.graph.cool/relay/v1/cjd4f6t7c35vn0159xw0lfij1"", {&#xA;    method: ""POST"",&#xA;    headers: myHeaders,&#xA;    mode: ""cors"",&#xA;    body: JSON.stringify({&#xA;      query: operation.text, // GraphQL text from input&#xA;      variables&#xA;    })&#xA;  }).then(response =&gt; {&#xA;    return response.json();&#xA;  });&#xA;}&#xA;&#xA;// Create a network layer from the fetch function&#xA;const network = Network.create(fetchQuery);&#xA;&#xA;const environment = new Environment({&#xA;  network,&#xA;  store&#xA;});&#xA;&#xA;export default environment;&#xA;</code></pre>&#xA;&#xA;<p>App.js</p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import { StyleSheet, Text } from ""react-native"";&#xA;import SplashScreen from ""react-native-splash-screen"";&#xA;import { graphql, QueryRenderer } from ""react-relay"";&#xA;import ListAccount from ""./src/listAccount"";&#xA;import environment from ""./src/relay.environment"";&#xA;&#xA;&#xA;const AppQuery = graphql`&#xA;  query AppQuery($count: Int!, $after: String) {&#xA;    viewer {&#xA;      ...listAccount_viewer&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default class App extends Component {&#xA;  constructor(props) {&#xA;    super(props);&#xA;    this.state = {&#xA;      authentic: false&#xA;    };&#xA;  }&#xA;&#xA;  isAuthentic = authentic =&gt; {&#xA;    this.setState({ authentic });&#xA;  };&#xA;&#xA;  componentDidMount() {&#xA;    SplashScreen.hide();&#xA;  }&#xA;&#xA;  renderCard(item) {&#xA;    return &lt;Text&gt;{item.text}&lt;/Text&gt;;&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;QueryRenderer&#xA;        environment={environment}&#xA;        query={AppQuery}&#xA;        variables={{&#xA;          count: 1&#xA;        }}&#xA;        render={({ error, props }) =&gt; {&#xA;          if (error) {&#xA;            return &lt;Text&gt;{error.message}&lt;/Text&gt;;&#xA;          } else if (props) {&#xA;            return (&#xA;              &lt;View&gt;&#xA;                &lt;ListAccount viewer={props.viewer} /&gt;&#xA;              &lt;/View&gt;&#xA;            );&#xA;          }&#xA;          return &lt;Text&gt;App Loading&lt;/Text&gt;;&#xA;        }}&#xA;      /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;const styles = StyleSheet.create({&#xA;  container: {&#xA;    flex: 1,&#xA;    alignItems: ""center""&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>listAccount.js</p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import {&#xA;  Text,&#xA;  View,&#xA;  Button,&#xA;  Checkbox,&#xA;  TextInput,&#xA;  TouchableOpacity&#xA;} from ""react-native"";&#xA;import { graphql, createPaginationContainer } from ""react-relay"";&#xA;import Account from ""./account"";&#xA;&#xA;class ListAccount extends Component {&#xA;  _loadMore() {&#xA;    if (!this.props.relay.hasMore()) {&#xA;      console.log(`Nothing more to load`);&#xA;      return;&#xA;    } else if (this.props.relay.isLoading()) {&#xA;      console.log(`Request is already pending`);&#xA;      return;&#xA;    }&#xA;    this.props.relay.loadMore(1);&#xA;  }&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;View&gt;&#xA;        &lt;Text&gt;&#xA;          {this.props.viewer.allAccounts.edges.map(({ node }, i) =&gt; (&#xA;            &lt;Account key={i} account={node} /&gt;&#xA;          ))}&#xA;        &lt;/Text&gt;&#xA;        &lt;Button onPress={() =&gt; this._loadMore()} title=""more..."" /&gt;&#xA;      &lt;/View&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default createPaginationContainer(&#xA;  ListAccount,&#xA;  {&#xA;    viewer: graphql`&#xA;      fragment listAccount_viewer on Viewer {&#xA;        allAccounts(first: $count, after: $after, orderBy: createdAt_DESC)&#xA;          @connection(key: ""ListAccount_allAccounts"") {&#xA;          edges {&#xA;            node {&#xA;              ...account_account&#xA;            }&#xA;          }&#xA;          pageInfo {&#xA;            hasNextPage&#xA;            endCursor&#xA;          }&#xA;        }&#xA;      }&#xA;    `&#xA;  },&#xA;&#xA;  {&#xA;    direction: ""forward"",&#xA;    query: graphql`&#xA;      query listAccountForwardQuery($count: Int!, $after: String) {&#xA;        viewer {&#xA;          ...listAccount_viewer&#xA;        }&#xA;      }&#xA;    `,&#xA;    getConnectionFromProps(props) {&#xA;      return props.viewer &amp;&amp; props.viewer.allAccounts;&#xA;    },&#xA;    getFragmentVariables(previousVariables, totalCount) {&#xA;      return {&#xA;        ...previousVariables,&#xA;        count: totalCount&#xA;      };&#xA;    },&#xA;    getVariables(props, paginationInfo, fragmentVariables) {&#xA;      return {&#xA;        count: paginationInfo.count,&#xA;        after: paginationInfo.cursor&#xA;      };&#xA;    }&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>account.js</p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import { Text } from ""react-native"";&#xA;import { graphql, createFragmentContainer } from ""react-relay"";&#xA;&#xA;class Account extends Component {&#xA;  render() {&#xA;    return &lt;Text&gt;{this.props.account.acno}&lt;/Text&gt;;&#xA;  }&#xA;}&#xA;&#xA;export default createFragmentContainer(&#xA;  Account,&#xA;  graphql`&#xA;    fragment account_account on Account {&#xA;      acno&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;",6769668,,3329664,2018-11-13 09:22:02,2018-11-13 09:22:02,Unable to resolve module `./__generated__/AppQuery.graphq,<react-native><graphql><relayjs>,0,5,0,2018-11-13 08:17:57
53287893,1,,,1,404,"<p>I've been reading that it is important to secure your applications with the a Maximum Query Depth. Meaning, to limit the number of ""levels"" that the query has. Example of a very deep query:</p>&#xA;&#xA;<pre><code>query IAmEvil {&#xA;  author(id: ""abc"") {&#xA;    posts {&#xA;      author {&#xA;        posts {&#xA;          author {&#xA;            posts {&#xA;              author {&#xA;                # that could go on as deep as the client wants!&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I know the level of depth of my query? and ultimately not allowed queries with more that a depth of 4 to perform.&#xA;Can I get the full query to count the deepness manually? Or is their already an implementation?</p>&#xA;&#xA;<p>This problem is also described here: <a href=""https://www.howtographql.com/advanced/4-security/"" rel=""nofollow noreferrer"">https://www.howtographql.com/advanced/4-security/</a></p>&#xA;",9942045,,,,2019-10-07 10:36:14,Absinthe Graphql nested queries security,<graphql><absinthe>,2,0,0,2018-11-13 19:05:06
53318805,1,53320140,,0,259,"<p>I am working with Apollo GraphQL and have to call nested query .But while call the Query in <code>.graphql</code> file it showing</p>&#xA;&#xA;<blockquote>&#xA;  <p>Syntax error : Expected Name, found {</p>&#xA;</blockquote>&#xA;&#xA;<p>Let me know how to call Nested query of GraphQL.&#xA;<a href=""https://i.stack.imgur.com/Hojb0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Hojb0.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>I have to call <strong>getAllproduct{....}</strong> query with the specified parameters.Here the <strong><em>FilterInput</em></strong> having the parameter as <strong><em>location</em></strong> with another pattern of query , so I don't know how to call this nested query.Anyone please help me to find out the solution.Thanks...</p>&#xA;",9600234,,,,2018-11-15 13:05:12,Nested query GraphQL : Syntax error - iOS,<ios><graphql><apollo>,1,0,0,2018-11-15 11:47:36
53321463,1,53322466,,0,232,"<p>Suppose I have a query that looks like this</p>&#xA;&#xA;<pre><code>{&#xA;    items {&#xA;        id&#xA;        name&#xA;        price&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<ul>&#xA;<li>items resolver is returning an array.</li>&#xA;<li><code>price</code> is having its own resolver</li>&#xA;</ul>&#xA;&#xA;<p>How can I say, apply a sorting logic on items array based on price? after all the prices are resolved.</p>&#xA;",2688699,,,,2018-11-15 15:12:45,How to sort graphql array by a property that having its own resolver,<graphql>,1,0,0,2018-11-15 14:18:27
53352739,1,53424277,,5,1942,"<p>I am using <strong>Apollo server 2.0</strong> as graphql aggregation layer over my rest apis ( different microservices).</p>&#xA;&#xA;<p>I want to generate <strong>graphql schema</strong> directly from the api response of microservices instead of manually writing them by hand which could be error prone.</p>&#xA;&#xA;<p>e.g If my api response is </p>&#xA;&#xA;<pre><code>const restApiResponse = {&#xA;  ""id"": 512,&#xA;  ""personName"": ""Caribbean T20 2016"",&#xA;  ""personShortName"": ""caribbean-t20 2016"",&#xA;  ""startDate"": ""2016-06-29T19:30:00.000Z"",&#xA;  ""endDate"": ""2016-08-08T18:29:59.000Z"",&#xA;  ""status"": 0,&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>Then I want to generate below schema based on the <strong>typeName</strong> supplied e.g <code>Person</code>&#xA; -</p>&#xA;&#xA;<pre><code>type Person {&#xA;  id: Float&#xA;  personName: String&#xA;  personShortName: String&#xA;  startDate: String&#xA;  endDate: String&#xA;  status: Float&#xA;}&#xA;</code></pre>&#xA;",1745409,,1745409,2018-11-17 15:48:29,2018-11-22 05:15:29,Generate Graphql schema from json api response,<schema><graphql><apollo-server>,2,5,0,2018-11-17 15:40:22
53372134,1,,,0,72,"<p>I have the Base Component which will have a QueryRenderer to fetch data for header, food items list, filtering options. In the render method, i would like to display the Header, FoodList and a FilterSidebar . Now when on click of a item in FilterSidebar, i am changing the state in redux , which in turn is used as variables for the QueryRender. The QueryRender refetches the data again with the new filters. The problem is since Header and Filtersidebar is also inside renderer method of queryrender, All the components get refreshed. Is there any way to handle this situation where only the listing changes based on new variables.</p>&#xA;",5861784,,5861784,2018-11-20 11:41:55,2018-11-20 11:41:55,Refetch Graphql data,<reactjs><react-redux><graphql><graphql-js><relayjs>,0,3,0,2018-11-19 09:57:06
53424277,2,,53352739,3,,"<p>Finally after lots of searches and look up I wrote a script to do that for me -</p>&#xA;&#xA;<p>There are some minor issues with this such as ints are parsed as Floats but thats fine as I can replace them with int if required.</p>&#xA;&#xA;<pre><code>const { composeWithJson } = require('graphql-compose-json');&#xA;const { GQC } = require('graphql-compose');&#xA;const { printSchema } = require('graphql'); // CommonJS&#xA;&#xA;&#xA;const restApiResponse = {&#xA;    ""id"": 399,&#xA;    ""templateId"": 115,&#xA;    ""amount"": 100000,&#xA;    ""amountINR"": 100000,&#xA;    ""amountUSD"": 0,&#xA;    ""currencyCode"": ""INR"",&#xA;    ""createdAt"": ""2018-06-07T00:08:28.000Z"",&#xA;    ""createdBy"": 36,&#xA;};&#xA;&#xA;const GqlType = composeWithJson('Template', restApiResponse);&#xA;const PersonGraphQLType = GqlType.getType();&#xA;&#xA;GqlType.addResolver({&#xA;    name: 'findById',&#xA;    type: GqlType,&#xA;    args: {&#xA;      id: 'Int!',&#xA;    },&#xA;    resolve: rp =&gt; {&#xA;    },&#xA;  });&#xA;&#xA;  GQC.rootQuery().addFields({&#xA;    person: GqlType.getResolver('findById'),&#xA;  });&#xA;&#xA;const schema = GQC.buildSchema();&#xA;&#xA;console.log(printSchema(schema));&#xA;</code></pre>&#xA;&#xA;<p><strong>It generates output like this -</strong></p>&#xA;&#xA;<pre><code>type Template {&#xA;  id: Float&#xA;  templateId: Float&#xA;  amount: Float&#xA;  amountINR: Float&#xA;  amountUSD: Float&#xA;  currencyCode: String&#xA;  createdAt: String&#xA;  createdBy: Float&#xA;}&#xA;</code></pre>&#xA;",1745409,,,,2018-11-22 05:15:29,"",,0,0,0,2018-11-22 05:15:29
53440474,2,,53440377,0,,"<p>Managed to pass the limit variable using Apollo HOC pattern...</p>&#xA;&#xA;<pre><code>export default graphql(PICTURES_QUERY, {&#xA;  options: () =&gt; ({&#xA;    variables: {&#xA;      limit: limitAmt&#xA;    }&#xA;  })&#xA;})(HomeScreen);&#xA;</code></pre>&#xA;",7285771,,,,2018-11-23 03:54:21,"",,0,0,0,2018-11-23 03:54:21
53472352,2,,53472309,0,,"<p>dumb question, but in case other making the same mistake. In network tab, make sure to select <code>all</code> instead of <code>xhr</code>.</p>&#xA;",6680253,,,,2018-11-25 21:52:02,"",,0,0,0,2018-11-25 21:52:02
53489920,2,,52702134,8,,"<p>If you are using Hasura.io then you can use the customized API queries to <code>ORDER BY</code> and <code>LIMIT</code> for the <code>MIN</code> and <code>MAX</code> result.</p>&#xA;&#xA;<p>Example for <code>MAX</code> value:</p>&#xA;&#xA;<pre><code>query {&#xA;  table_name(limit: 1, order_by: {time: desc}) { &#xA;      data &#xA;      time&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example for <code>MIN</code> value:</p>&#xA;&#xA;<pre><code>query {&#xA;  table_name(limit: 1, order_by: {time: asc}) { &#xA;      data &#xA;      time&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",9558219,,,,2018-11-26 22:13:14,"",,0,0,0,2018-11-26 22:13:14
53495730,1,53496777,,2,5393,"<p>I have a column <code>updatedAt</code> in my table <code>User</code> which is of <code>Date</code> type, it stores date along with time. I want to query using only date and not datetime. I am using sequelize <code>Sequelize.Op.gt</code> and <code>Sequelize.Op.lt</code> operators to get <code>Users</code> updated on that exact date regardless of time by adding <code>24 * 60 * 60 * 1000</code>. But the date is not incrementing one day. When I try to subtract, it is working flawlessly. I could add one day only after using getTime() method.</p>&#xA;&#xA;<p>I'm confused as to why it works when subtracting without using <code>getTime()</code> but doesn't work when adding. Could anyone explain?</p>&#xA;&#xA;<p><strong>TL;DR</strong></p>&#xA;&#xA;<p>This <strong>works:</strong></p>&#xA;&#xA;<pre><code>[Sequelize.Op.gt]: new Date(new Date(updatedAt) - 24 * 60 * 60 * 1000)&#xA;//updateAt: 2018-11-27&#xA;//output: 2018-11-26&#xA;</code></pre>&#xA;&#xA;<p>This <strong>doesn't</strong> work:</p>&#xA;&#xA;<pre><code>[Sequelize.Op.gt]: new Date(new Date(updatedAt) + 24 * 60 * 60 * 1000)&#xA;//updateAt: 2018-11-27&#xA;//output: 2018-11-27&#xA;</code></pre>&#xA;&#xA;<p>And this <strong>works:</strong></p>&#xA;&#xA;<pre><code>[Sequelize.Op.lt]: new Date(new Date(updatedAt).getTime() + 24 * 60 * 60 * 1000)&#xA;//updateAt: 2018-11-27&#xA;//output: 2018-11-28&#xA;</code></pre>&#xA;",7093656,,,,2020-10-22 20:12:47,Sequelize: Adding a day to the date doesn't work,<node.js><sequelize.js><graphql><sequelize-cli>,2,0,0,2018-11-27 08:46:29
53527851,1,,,0,327,"<p>Reading through the Relay docs I am confused about the concept of Cache mentioned in the network layer (<a href=""https://facebook.github.io/relay/docs/en/network-layer.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/en/network-layer.html</a>) vs the Relay Store (<a href=""https://facebook.github.io/relay/docs/en/relay-store.html"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/docs/en/relay-store.html</a>).</p>&#xA;&#xA;<p>Are these two different caches? Which one does automatically get garbage collected by Relay? </p>&#xA;",118386,,,,2018-11-30 11:02:47,Relay Modern Cache Vs Store,<graphql><relay><relaymodern>,1,0,0,2018-11-28 20:47:25
53528466,1,,,0,440,"<p>I installed <a href=""https://github.com/overblog/GraphQLBundle"" rel=""nofollow noreferrer"">GraphQLBundle</a> on my existing Symfony 3.4 project and tried to create next type:</p>&#xA;&#xA;<pre><code>type RootQuery {&#xA;    post(limit: Int, offset: Int): [Post]&#xA;}&#xA;&#xA;type Post {&#xA;        id: ID&#xA;        title(sort: String, search: String): String&#xA;        href: String&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Then I created ResolverMap: </p>&#xA;&#xA;<pre><code>&lt;?php&#xA;&#xA;class PostMap extends ResolverMap&#xA;{&#xA;&#xA;    /**&#xA;     * @return array|callable[]&#xA;     */&#xA;    public function map()&#xA;    {&#xA;        return [&#xA;            'RootQuery' =&gt; [&#xA;                self::RESOLVE_FIELD =&gt; function ($value, Argument $argument, \ArrayObject $context, ResolveInfo $info) {&#xA;                    $limit = $argument['limit'] ?? 10;&#xA;                    $offset = $argument['offset'] ?? 0;&#xA;&#xA;                    $paginator = new Paginator((int)$limit, (int)$offset);&#xA;&#xA;                    return $this-&gt;getData($paginator);&#xA;                },&#xA;            ],&#xA;        ];&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>everything works pretty good, but I don't understood one moment:</p>&#xA;&#xA;<pre><code>{&#xA;  post(limit:10) {&#xA;    id&#xA;    title(sort: ""ASC"")&#xA;    href&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>limit</code> from post I can get, but parameters <code>sort</code> I can't get. </p>&#xA;&#xA;<p>How can I resolve that query?</p>&#xA;",5686668,,7852833,2018-11-28 22:41:49,2018-11-28 22:41:49,Symfony 3.4 Overblog Graphql dont understood how resolve query,<php><symfony><graphql><symfony-3.4>,0,4,0,2018-11-28 21:34:22
53536541,2,,53427037,0,,"<p>A fragment is used to <strong>always</strong> retrieve <strong>given fields</strong> on a <strong>given type</strong>.</p>&#xA;&#xA;<p>It follows the following format:</p>&#xA;&#xA;<pre><code>fragment NameOfYourFragment on YourType { ... }&#xA;</code></pre>&#xA;&#xA;<p>You currently can't apply a given fragment conditionally as it is always applied.&#xA;Moreover, you specified a fragment on <code>Jobs</code>, but the type name used by Prisma is <code>Job</code> (even if you have the <code>job</code> and <code>jobs</code> resolvers)</p>&#xA;&#xA;<p>You probably only need the following resolver:</p>&#xA;&#xA;<pre><code>const job = {&#xA;  fragment: `fragment JobId on Job { id }`,&#xA;  resolve: jobsResolver&#xA;}&#xA;</code></pre>&#xA;",10721492,,,,2018-11-29 10:12:06,"",,0,0,0,2018-11-29 10:12:06
53545076,1,,,1,3919,"<p>I need to show different data based on the selected option from the dropdown. I'm querying the value using <code>Query</code> component and that value is different for each option.&#xA;Here's the sample code for it.</p>&#xA;&#xA;<pre><code> &lt;Query query={CURRENT_USER}&gt;&#xA;     {({loading, error, data}) =&gt; {&#xA;         if (loading) &#xA;             return ""loading..."";&#xA;         if (error) &#xA;             return `Error! ${error.message}`;&#xA;         return  &lt;h1&gt;{data.month === Date().slice(4,7).toLowerCase() ? data.amount : 0}&lt;/h1&gt;&#xA;      }}&#xA; &lt;/Query&gt;&#xA; &lt;div&gt;&#xA;     &lt;select defaultValue={Date().slice(4,7).toLowerCase()}&gt;&#xA;         &lt;option value=""jan""&gt;JAN&lt;/option&gt;&#xA;         &lt;option value=""feb""&gt;FEB&lt;/option&gt;&#xA;         &lt;option value=""mar""&gt;MAR&lt;/option&gt;&#xA;         &lt;option value=""apr""&gt;APR&lt;/option&gt;&#xA;         &lt;option value=""jun""&gt;JUN&lt;/option&gt;&#xA;         &lt;option value=""jul""&gt;JUL&lt;/option&gt;&#xA;         &lt;option value=""aug""&gt;AUG&lt;/option&gt;&#xA;         &lt;option value=""sep""&gt;SEPT&lt;/option&gt;&#xA;         &lt;option value=""oct""&gt;OCT&lt;/option&gt;&#xA;         &lt;option value=""nov""&gt;NOV&lt;/option&gt;&#xA;         &lt;option value=""dec""&gt;DEC&lt;/option&gt;&#xA;     &lt;/select&gt;&#xA; &lt;/div&gt;&#xA;</code></pre>&#xA;",5845711,,,,2018-12-01 16:31:45,Apollo React: How to refetch query when a different option is selected from select dropdown?,<reactjs><graphql><react-apollo><apollo-client>,2,0,0,2018-11-29 18:05:02
53546542,2,,53545076,2,,"<p>The Query component returns <code>refetch</code> which can be passed to the <code>onChange</code> function in your form. It accepts variables just like the original query.</p>&#xA;&#xA;<p>It would look something like this:</p>&#xA;&#xA;<pre><code>&lt;Query query={CURRENT_USER} variables={{month: this.state.month}}&gt;&#xA;  {({loading, error, data, refetch}) =&gt; {&#xA;    if (loading) return 'loading...'&#xA;    if (error) return `Error! ${error.message}`&#xA;      return (&#xA;       &lt;h1&gt;&#xA;         {data.month ===&#xA;           Date().slice(4, 7).toLowerCase()&#xA;             ? data.amount&#xA;             : 0&#xA;         }&#xA;       &lt;/h1&gt;&#xA;     )&#xA;   }}&#xA; &lt;/Query&gt;&#xA; &lt;div&gt;&#xA;   &lt;select &#xA;     value={this.state.month}&#xA;     onChange={(event) =&gt; refetch({variables: {month: event.target.value}}&#xA;   &gt;&#xA;     &lt;option value=""jan""&gt;JAN&lt;/option&gt;&#xA;     &lt;option value=""feb""&gt;FEB&lt;/option&gt;&#xA;     &lt;option value=""mar""&gt;MAR&lt;/option&gt;&#xA;     &lt;option value=""apr""&gt;APR&lt;/option&gt;&#xA;     &lt;option value=""jun""&gt;JUN&lt;/option&gt;&#xA;     &lt;option value=""jul""&gt;JUL&lt;/option&gt;&#xA;     &lt;option value=""aug""&gt;AUG&lt;/option&gt;&#xA;     &lt;option value=""sep""&gt;SEPT&lt;/option&gt;&#xA;     &lt;option value=""oct""&gt;OCT&lt;/option&gt;&#xA;     &lt;option value=""nov""&gt;NOV&lt;/option&gt;&#xA;     &lt;option value=""dec""&gt;DEC&lt;/option&gt;&#xA;   &lt;/select&gt;&#xA; &lt;/div&gt;&#xA;</code></pre>&#xA;",10145728,,10145728,2018-11-30 19:57:36,2018-11-30 19:57:36,"",,0,3,0,2018-11-29 19:50:26
53548069,2,,51922779,0,,"<p>I believe your problem may be that you're just passing your props in as variables. They need to be set to specific property names in order for your graphql resolvers to accept them. </p>&#xA;&#xA;<pre><code>variables={{start: props.startTime, end: props.endTime}}&#xA;</code></pre>&#xA;",8585548,,4477364,2018-11-29 22:09:56,2018-11-29 22:09:56,"",,0,0,0,2018-11-29 21:45:43
53582219,2,,46513476,6,,<p>I had the same problem. I was using find instead filter.</p>&#xA;,7557079,,,,2018-12-02 16:22:39,"",,0,0,0,2018-12-02 16:22:39
53623336,2,,53620146,1,,"<p>You could run or skip the fragments conditionally. Take a look at this: &#xA;<a href=""https://facebook.github.io/relay/docs/en/classic/classic-api-reference-relay-ql.html#conditional-fields"" rel=""nofollow noreferrer"">Relay Conditional Fields</a></p>&#xA;&#xA;<p>So, you could pass extra arguments to your mutation (maybe a new type of object?), and then, use this values to run or not the fragments. For example:</p>&#xA;&#xA;<pre><code>mutation UserProfile_Mutation($input: !UserProfileInput, $extraArg: Boolean!) {&#xA; updateProfile(input: $input) {&#xA;   profile {&#xA;     ...Page1_profile  @include(if: $extraArg)&#xA;     ...Page2_profile  @include(if: $extraArg) // or any other arg&#xA;     ...etc&#xA;   }     &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Hope it helps! :)</p>&#xA;",6768607,,,,2018-12-05 00:15:25,"",,0,0,0,2018-12-05 00:15:25
53624172,1,,,1,1172,<p>I have 2 types:</p>&#xA;&#xA;<pre><code>type Location {&#xA;    id: ID!&#xA;    room: Int&#xA;    title: String&#xA;}&#xA;&#xA;type Populate {&#xA;    id: ID!&#xA;    locationID: ID!&#xA;    location: Location&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I need to populate the <code>location</code> field when I call the GraphQL api. Locations are stored in DynamoDB. I know that a resolver is necessary but I haven't been a exactly how to write it. Thanks for the help!</p>&#xA;,7977034,,,,2018-12-05 05:30:46,Joining DynamoDB tables with AppSync,<amazon-web-services><amazon-dynamodb><graphql><aws-appsync>,1,0,0,2018-12-05 02:12:34
53631447,1,,,1,182,"<pre><code>subscription userSubscription($filter: UserSubscriptionFilter!) {&#xA;  User(filter: $filter) {&#xA;      mutation&#xA;      node {&#xA;          name&#xA;          addresses {&#xA;              id&#xA;              pincode&#xA;          }&#xA;      }&#xA;  }}&#xA;</code></pre>&#xA;&#xA;<p>in this subscription query i need to pass filter variable with value </p>&#xA;&#xA;<pre><code>const subscriptionConfig = {&#xA;    subscription: updateQPListSubscription,&#xA;    variables: {filter:{mutation_in: [""CREATED""]}},&#xA;</code></pre>&#xA;&#xA;<p>However CREATED is an enum, how do i pass it as filter variable</p>&#xA;&#xA;<p>If i hard-code in query itself then its working .... for example below query is working</p>&#xA;&#xA;<pre><code>subscription userSubscription {&#xA;  User(filter: {mutation_in: [CREATED] node:{name_contains:""ankit""}}) {&#xA;      mutation&#xA;      node {&#xA;          name&#xA;          addresses {&#xA;              id&#xA;              pincode&#xA;          }&#xA;      }&#xA;  }}&#xA;</code></pre>&#xA;&#xA;<p>i want to pass the whole filter variable dynamically using the variables field when setting up the subscription</p>&#xA;&#xA;<p>In graphcool playground also it does not work, however it accept the query variable i passed</p>&#xA;",5861784,,,,2018-12-05 11:39:01,Passing Enum as variable to Relay Qraphql query,<relayjs><relay><graphcool><relaymodern><prisma-graphql>,0,1,0,2018-12-05 11:39:01
53663038,1,,,1,92,"<p>I'm trying to create a component that fetches data using Apollo. And the component has the search/filter feature. And the filter could be done with the local(current) data or in the server. I'm not sure how to handle both features with Apollo. With Redux I could dispatch two separate actions where both would in the end update the data in the Redux store. But I'm not sure how to access the data in Apollo to do filter locally(in client). </p>&#xA;&#xA;<p>Here is simplified version of my component</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import { Query } from 'react-apollo';&#xA;import AnotherComponent from './AnotherComponent';&#xA;&#xA;class MyComponent extends Component {&#xA;    state = {&#xA;        searchTerm: '',&#xA;        data: [],&#xA;    }&#xA;&#xA;    filterData = () =&gt; {&#xA;        // some sort of filtering. No issue with this.&#xA;    }&#xA;&#xA;    handleSearchTermChangeLocal = searchTerm =&gt; {&#xA;        const data = this.filterData([howToGetDataFromApollo], searchTerm);&#xA;        this.setState({ data, searchTerm });&#xA;    }&#xA;&#xA;    render() {&#xA;        const { query, variables } = this.props;&#xA;&#xA;        return (&#xA;            &lt;Query query={query} variables={variables}&gt;&#xA;                {({ loading, data, error }) =&gt; (&#xA;                    &lt;AnotherComponent&#xA;                        {...this.props}&#xA;                        isLoading={loading}&#xA;                        data={data}&#xA;                        error={error}&#xA;                        onSearchTermChange={handleSearchTermChange}&#xA;                    /&gt;&#xA;                )}&#xA;            &lt;/Query&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;export default MyComponent;&#xA;</code></pre>&#xA;",1983439,,,,2018-12-08 09:59:52,Working with data fetched by Apollo React,<reactjs><react-apollo>,1,3,0,2018-12-07 03:59:33
53674792,2,,53661830,1,,"<p>If <code>query</code> is the parent, the <code>parentID</code> will be <code>client:root</code>. </p>&#xA;&#xA;<p>Take a look at this: <a href=""https://github.com/facebook/relay/blob/1d72862fa620a9db69d6219d5aa562054d9b93c7/packages/react-relay/classic/store/RelayStoreConstants.js#L18"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/blob/1d72862fa620a9db69d6219d5aa562054d9b93c7/packages/react-relay/classic/store/RelayStoreConstants.js#L18</a></p>&#xA;&#xA;<p>Also at this issue: <a href=""https://github.com/facebook/relay/issues/2157#issuecomment-385009482"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/issues/2157#issuecomment-385009482</a></p>&#xA;&#xA;<p>create a <code>const ROOT_ID = 'client:root';</code> and pass <code>ROOT_ID</code> as your <code>parentID</code>. Also, check the name of your connection on the updater, it has to be exactly equal to the name where you declared the query.</p>&#xA;&#xA;<p><strong>UPDATE</strong>:&#xA;Actually, you can import <code>ROOT_ID</code> of <code>relay-runtime</code></p>&#xA;&#xA;<p><code>import { ROOT_ID } from 'relay-runtime';</code></p>&#xA;&#xA;<p><strong>UPDATE 2</strong>:</p>&#xA;&#xA;<p>Your edit was not very clear for me, but I will provide you an example of it should work ok? After your mutation is run, you first access its data by using <code>getRootField</code> just like you are doing. So, if I have a mutation like:</p>&#xA;&#xA;<pre><code>  mutation UserAddMutation($input: UserAddInput!) {&#xA;    UserAdd(input: $input) {&#xA;      userEdge {&#xA;        node {&#xA;          name&#xA;          id&#xA;          age&#xA;        }&#xA;      }&#xA;      error&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>You will do: </p>&#xA;&#xA;<pre><code>const newEdge = store.getRootField('UserAdd').getLinkedRecord('userEdge');&#xA;      connectionUpdater({&#xA;        store,&#xA;        parentId: ROOT_ID,&#xA;        connectionName: 'UserAdd_users',&#xA;        edge: newEdge,&#xA;        before: true,&#xA;      });&#xA;</code></pre>&#xA;&#xA;<p>This <code>connectionUpdater</code> is a helper function that looks likes this:</p>&#xA;&#xA;<pre><code>export function connectionUpdater({ store, parentId, connectionName, edge, before, filters }) {&#xA;  if (edge) {&#xA;    if (!parentId) {&#xA;      // eslint-disable-next-line&#xA;      console.log('maybe you forgot to pass a parentId: ');&#xA;      return;&#xA;    }&#xA;&#xA;    const parentProxy = store.get(parentId);&#xA;&#xA;    const connection = ConnectionHandler.getConnection(parentProxy, connectionName, filters);&#xA;&#xA;    if (!connection) {&#xA;      // eslint-disable-next-line&#xA;      console.log('maybe this connection is not in relay store yet:', connectionName);&#xA;      return;&#xA;    }&#xA;&#xA;    const newEndCursorOffset = connection.getValue('endCursorOffset');&#xA;    connection.setValue(newEndCursorOffset + 1, 'endCursorOffset');&#xA;&#xA;    const newCount = connection.getValue('count');&#xA;    connection.setValue(newCount + 1, 'count');&#xA;&#xA;    if (before) {&#xA;      ConnectionHandler.insertEdgeBefore(connection, edge);&#xA;    } else {&#xA;      ConnectionHandler.insertEdgeAfter(connection, edge);&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Hope it helps :)</p>&#xA;",6768607,,6768607,2018-12-07 21:57:06,2018-12-07 21:57:06,"",,0,5,0,2018-12-07 18:05:55
53681377,2,,53663038,0,,"<p>I did not understand this: </p>&#xA;&#xA;<blockquote>&#xA;  <p>And the filter could be done with the local(current) data or in the server.</p>&#xA;</blockquote>&#xA;&#xA;<p>In your example you are only making the filter on the client side.</p>&#xA;&#xA;<p>In my opinion, the best option for your is to split the code in two components.</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import { Query } from 'react-apollo';&#xA;import Filter from './Filter';&#xA;&#xA;function MyComponent() {&#xA;    render() {&#xA;        const { query, variables } = this.props;&#xA;&#xA;        return (&#xA;            &lt;Query query={query} variables={variables}&gt;&#xA;                {({ loading, data, error }) =&gt; (&#xA;                    &lt;Filter&#xA;                        {...this.props}&#xA;                        isLoading={loading}&#xA;                        data={data}&#xA;                        error={error}&#xA;                    /&gt;&#xA;                )}&#xA;            &lt;/Query&gt;&#xA;        );&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Filter Component:</p>&#xA;&#xA;<pre><code>import AnotherComponent from './AnotherComponent';&#xA;&#xA;filterData = () =&gt; {&#xA;    // some sort of filtering. No issue with this.&#xA;}&#xA;&#xA;class Filter extends Component {&#xA;    state = {&#xA;        searchTerm: '',&#xA;        data&#xA;    }&#xA;&#xA;    static getDerivedStateFromProps(props, state) {&#xA;        return { data: filterData(props.data, state.searchTerm };&#xA;    }&#xA;&#xA;    handleSearchTermChangeLocal = searchTerm =&gt; {&#xA;        const data = filterData(this.state.data, searchTerm);&#xA;        this.setState({ data, searchTerm });&#xA;    }&#xA;&#xA;    render() {&#xA;        return (&#xA;            &lt;AnotherComponent&#xA;                 {...this.props}&#xA;                 data={this.state.data}&#xA;                 onSearchTermChange={handleSearchTermChange}&#xA;            /&gt;&#xA;        );&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I wrote the code here in stack overflow directly, that are problem spelling problems and you can improve the logic, my idea here was just to write the code to answer your question</p>&#xA;",1167714,,,,2018-12-08 09:59:52,"",,0,0,0,2018-12-08 09:59:52
53696522,2,,53684290,4,,"<p>Prisma generates a GraphQL schema based on your datamodel. Doing so, it generates <strong>plural types</strong> based on your types.</p>&#xA;&#xA;<p>However, because the plural of <code>Species</code> is <code>Species</code>, Prisma now has two types with the same name, therefore, throws an error. (See the same <a href=""https://github.com/prisma/prisma/issues/3437"" rel=""nofollow noreferrer"">issue</a> with <code>News</code>)</p>&#xA;&#xA;<p>You currently can't choose the pluralized name for a type or field (See <a href=""https://github.com/prisma/prisma/issues/253"" rel=""nofollow noreferrer"">issue</a>).</p>&#xA;&#xA;<p>It's a generally good advice to only have <strong>singular</strong> names for your types.</p>&#xA;",10721492,,10721492,2018-12-10 08:27:19,2018-12-10 08:27:19,"",,0,0,0,2018-12-09 20:45:58
53703072,1,,,0,43,"<p>I have compound fragments:</p>&#xA;&#xA;<pre><code>const FragmentA = `fragment FragmentA {&#xA;  b {&#xA;    ...FragmentB&#xA;  }&#xA;}&#xA;`&#xA;const FragmentB = `fragment FragmentB {&#xA;  field&#xA;  field1&#xA;  field2&#xA;}&#xA;`&#xA;&#xA;const Fragments = `&#xA;  ${FragmentA}&#xA;  ${FragmentB}&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Is there a way to unit-test, if this <code>FragmentB</code> was added to <code>Fragments</code> and if the whole <code>Fragments</code> is valid?</p>&#xA;",4083045,,4083045,2018-12-11 05:28:42,2018-12-11 05:28:42,How to test a GraphQL query if its fragment is defined?,<graphql>,0,2,0,2018-12-10 09:49:27
53742841,1,,,0,198,"<p>Currently we are using the variables to pass the props which are required in the child. </p>&#xA;&#xA;<pre><code>&lt;Query&#xA;        variables={{&#xA;          queryVar1: 'a',&#xA;          queryVar3: 'a',&#xA;          props1: this.props.prop1,&#xA;          props2: this.props.prop1,&#xA;        }}&#xA;        query={SOMEQUERY}&#xA;        fetchPolicy=""network-only""&#xA;      &gt;&#xA;        { myComp }&#xA;      &lt;/Query&gt;&#xA;</code></pre>&#xA;&#xA;<p>But this is making the code cluttered. how else we can pass the props from parent to child.</p>&#xA;",9382810,,,,2018-12-12 12:18:59,React apollo - How to pass props to Query and access it in child,<reactjs><apollo><react-apollo><apollo-client>,1,0,0,2018-12-12 12:15:44
53753784,1,53754474,,1,1349,"<p>I have some struggles with writing an API in graphql.</p>&#xA;&#xA;<p>Every response in my api should look somewhat the same.&#xA;So ideally this would be the graphql type:</p>&#xA;&#xA;<pre><code>type Response {&#xA;  success&#xA;  data {&#xA;    ... always different&#xA;  }&#xA;  errors {&#xA;    path&#xA;    message&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But because the data field in here is always different. Every Mutation/Query should have it's own response type (if i'm understanding graphql correctly).</p>&#xA;&#xA;<p>So for Login this is the type I'm creating with a transformer function:</p>&#xA;&#xA;<pre><code>type LoginResponse {&#xA;  success&#xA;  data {&#xA;    user&#xA;    token&#xA;  }&#xA;  errors {&#xA;    path&#xA;    message&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now in my front-end, I want to use the following fragment, because these properties are always present in every response.</p>&#xA;&#xA;<pre><code>fragment Response on LoginResponse {&#xA;  success&#xA;  errors {&#xA;    path&#xA;    message&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So the problem I have with this is already shown here, with a fragment you also define it's parent type. So I have to create as many seperate fragments as seperate response types.</p>&#xA;&#xA;<p>Has someone maybe already struggled with this or is there a best practice for this I'm not seeing</p>&#xA;",4084315,,3708153,2019-02-26 10:39:34,2019-02-26 10:39:34,GraphQL response type / fragment struggle,<graphql><apollo><graphql-js><graphql-tag>,1,0,0,2018-12-13 01:29:28
53788200,1,,,0,461,"<p>I have a page with infinite loading enabled. I pull and skip thru a list of notices. Trouble Im facing is, I get a console error.</p>&#xA;&#xA;<p>I've tried providing the skip number and no luck. It doesn't break anything but it's an annoying error.</p>&#xA;&#xA;<p>What could be causing this?</p>&#xA;&#xA;<p>Error: Error writing result to  store for query:</p>&#xA;&#xA;<pre><code> query ($limit: Int, $skip: Int) {&#xA;  getNotifications(limit: $limit, skip: $skip) {&#xA;    notifications {&#xA;      id&#xA;      seen&#xA;      read&#xA;      type&#xA;      text&#xA;      topicID&#xA;      date&#xA;      fromProfile {&#xA;        profilePic&#xA;        profileName&#xA;        __typename&#xA;      }&#xA;      __typename&#xA;    }&#xA;    total&#xA;    unseen&#xA;    __typename&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of NotficationListType for the object of id $ROOT_QUERY.getNotifications({""limit"":5}). The selectionSet that was trying to be written is:</p>&#xA;&#xA;<pre><code>getNotifications(limit: $limit, skip: $skip) {&#xA;  notifications {&#xA;    id&#xA;    seen&#xA;    read&#xA;    type&#xA;    text&#xA;    topicID&#xA;    date&#xA;    fromProfile {&#xA;      profilePic&#xA;      profileName&#xA;      __typename&#xA;    }&#xA;    __typename&#xA;  }&#xA;  total&#xA;  unseen&#xA;  __typename&#xA;}&#xA;</code></pre>&#xA;",7644474,,,,2018-12-14 23:33:33,Fix Error writing to store for query QUERYNAME,<node.js><graphql><apollo>,0,4,0,2018-12-14 23:33:33
53800743,1,53800998,,0,440,"<p>I've been following <a href=""https://www.howtographql.com/react-apollo/3-mutations-creating-links/"" rel=""nofollow noreferrer"">this tutorial</a> to get a React app running with Apollo.</p>&#xA;&#xA;<p>Right now I'm in the step of running a mutation, which I have successfully done but I'm trying to perform a more complex one.</p>&#xA;&#xA;<p>So, one of the fields expected in this mutation is a relation one, expecting a <strong>connect</strong> dataset, which has to be something like:</p>&#xA;&#xA;<pre><code>tags: {&#xA;  connect: [{&#xA;   id: ""cjoo9e0eq004d0824nibmtzl2""&#xA;  },&#xA;  {&#xA;   id: ""cjoopece2000a0899n8jsjkr4""&#xA;  },&#xA;  {&#xA;   id: ""cjozmqfal00040878t7huvb2s""&#xA;  },&#xA;  {&#xA;   id: ""cjozmsquv000l0878y7t2zccm""&#xA;  }],&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>For this tags field, on the frontend I'm showing a select multiselect, so the value is going to be an array of ids: [""cjoo9e0eq004d0824nibmtzl2"", ""cjoopece2000a0899n8jsjkr4""...].</p>&#xA;&#xA;<p>Since the mutation is expecting that field to be an array of objects with ids I'm trying to somehow map that string to transform it into the expected format, but I haven't had any luck. I don't know where can I transform that variable before the mutation gets executed.</p>&#xA;&#xA;<p>Seems like a tricky issue to explain, I hope the explanation is clear enough.</p>&#xA;&#xA;<p>Any help will be highly appreciated!</p>&#xA;&#xA;<p>Edit to add some code:</p>&#xA;&#xA;<pre><code>const CREATE_VIDEO_MUTATION = gql`&#xA;  mutation CreateVideoMutation($title: String!, $tags: [TagWhereUniqueInput!]) {&#xA;    createVideo(&#xA;      data: {&#xA;        title: $title, &#xA;        tags: {&#xA;          connect: $tags&#xA;        }&#xA;      }&#xA;    ) {&#xA;      id&#xA;      title&#xA;    }&#xA;  }&#xA;`&#xA;&#xA;class CreateVideo extends Component {&#xA;  state = {&#xA;    title: '',&#xA;    tags: [],&#xA;  }&#xA;&#xA;  render() {&#xA;    const { title, tags } = this.state;&#xA;    return (&#xA;        .....&#xA;&#xA;      &lt;select multiple &#xA;        className=""mb2"" &#xA;        value={tags}&#xA;        onChange={e =&gt; {&#xA;          this.setState({ tags: [...e.target.options]&#xA;            .filter(({selected}) =&gt; selected)&#xA;            .map(({value}) =&gt; value) })&#xA;        }}&gt;&#xA;        {tagsToRender.map(tag =&gt; {&#xA;          return (&#xA;            &lt;option key={tag.id} value={tag.id}&gt;&#xA;              {tag.name}&#xA;            &lt;/option&gt;&#xA;          )&#xA;        })}&#xA;      &lt;/select&gt;&#xA;&#xA;      &lt;Mutation &#xA;        mutation={CREATE_VIDEO_MUTATION} &#xA;        variables={{ title, tags }}&#xA;        onCompleted={() =&gt; this.props.history.push('/')}&gt;&#xA;        {createVideoMutation =&gt; &lt;button onClick={createVideoMutation}&gt;Submit&lt;/button&gt;}&#xA;      &lt;/Mutation&gt;&#xA;</code></pre>&#xA;",1522176,,1522176,2018-12-16 09:30:01,2018-12-16 09:37:30,Map variable before executing Apollo mutation,<reactjs><graphql><apollo><react-apollo>,1,7,0,2018-12-16 08:54:07
53806301,1,53817312,,0,1201,<p>I would like to use graphql fragments in my nestjs project but i cant find any documentation on the official site.&#xA;I have tried to add a fragment to my *.graphql file:</p>&#xA;&#xA;<pre><code>fragment fragmenName on MyType {&#xA;    attribute&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>on server start the file is transpiled(?) to the qraphql.ts with all types/interfaces and queries except the fragment. The appolo server does not find the fragment also...</p>&#xA;&#xA;<p>Do i miss something?</p>&#xA;,4932576,,,,2018-12-17 14:31:56,Does nestjs supports graphql fragments?,<graphql><nestjs>,1,0,0,2018-12-16 20:42:46
53885584,2,,52022174,0,,<p>Try with this:</p>&#xA;&#xA;<pre><code>const TICKET_FRAGMENT = gql`&#xA;      fragment ticketfragment on TicketNode {&#xA;        id&#xA;        title&#xA;        description&#xA;        ticketId&#xA;        created&#xA;        // Some other fields&#xA;      }&#xA;   `;&#xA;</code></pre>&#xA;,10820405,,,,2018-12-21 13:27:33,"",,0,0,0,2018-12-21 13:27:33
53930324,2,,53870249,2,,"<p>You can use <a href=""https://www.apollographql.com/docs/apollo-server/schema/schema/#input-types"" rel=""nofollow noreferrer"">input types</a> to achieve that. You need to edit your schema</p>&#xA;&#xA;<pre><code>type Query {&#xA;    building(location: Location): Building&#xA;}&#xA;&#xA;input Location {&#xA;    lon: String&#xA;    lat: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then you can post your query like this</p>&#xA;&#xA;<pre><code>query {&#xA;  building(location: {lon:""100.332680"",lat:""5.416393""}) {&#xA;    name,...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",846053,,846053,2020-01-15 16:16:18,2020-01-15 16:16:18,"",,0,0,0,2018-12-26 09:52:15
53935209,1,,,3,328,"<p>I'd like to specify a nested argument as the <code>filter</code> for my <code>@connection</code> directive. Is it possible to do something like this:</p>&#xA;&#xA;<pre><code>input CommentsInput {&#xA;  postId: String!&#xA;  cursors: CommentsCursorInput&#xA;}&#xA;&#xA;query getComments($input: CommentInput) {&#xA;    getComments(input: $input)&#xA;    @connection(key: ""comments"", filter: [""input.postId""]) {&#xA;        comments {&#xA;            id&#xA;            commentBody&#xA;            createdDate&#xA;            liked&#xA;            likeCount&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>postId</code> is passed in <code>input</code>. This is a contrived example and I know I can structure this differently, but my main questions is can I use nested arguments as a filter, or can I only use top-level arguments in that <code>filter</code> array? I didn't see any discussion of this in the <a href=""https://www.apollographql.com/docs/react/features/pagination.html#connection-directive"" rel=""nofollow noreferrer"">docs</a>.</p>&#xA;",428928,,428928,2018-12-28 22:21:42,2018-12-28 22:21:42,Filter Apollo connection with nested variables,<graphql><apollo><react-apollo>,0,0,0,2018-12-26 17:33:09
53963709,2,,53960809,2,,"<p>It doesn't look like it.</p>&#xA;&#xA;<p>The GitHub developer documentation has a complete listing of all GraphQL object types, their fields, and their associated parameters.  A <a href=""https://developer.github.com/v4/object/repository/"" rel=""nofollow noreferrer"">Repository</a> in particular documents its <a href=""https://developer.github.com/v4/object/repository/#releases"" rel=""nofollow noreferrer"">releases field</a>; that has the Relay connection parameters and an ordering, but the only supported <a href=""https://developer.github.com/v4/enum/releaseorderfield/"" rel=""nofollow noreferrer"">ReleaseOrderField</a> values are <code>CREATED_AT</code> and <code>NAME</code>.</p>&#xA;&#xA;<p>That means you need to repeat calls to page through the releases until you find one that meets your criteria.</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>query GetRelease($owner: String!, $name: String!, $cursor: String) {&#xA;  repository(owner: $owner, name: $name) {&#xA;    releases(before: $cursor,&#xA;             last: 1,&#xA;             orderBy: {field: CREATED_AT, order: DESC}) {&#xA;      pageInfo { hasPreviousPage, startCursor }&#xA;      nodes {&#xA;        isPrerelease&#xA;        ...OtherReleaseData&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you hit a release where <code>isPrerelease</code> is true (which you don't want), and <code>hasPreviousPage</code> is also true, re-run the query passing the previous <code>startCursor</code> value as the <code>cursor</code> argument.</p>&#xA;",10008173,,,,2018-12-28 19:57:13,"",,0,0,0,2018-12-28 19:57:13
53973304,1,,,0,371,"<p>I am building a graphQL api with schema and annotations to use AWS Amplify's GraphQL transform. How can I control what kind of ES index it produces behind the scene? </p>&#xA;&#xA;<p>This is a simple API that provides search functionality based on the, lets say, ""5 km radius from the current location"", timestamp and other keywords. The keywords search work absolutely fine but not the geospatial search. As per my research, for doing geospatial search, one needs to have a specific type of schema in ES. Here is my schema: </p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  deviceID: [String!]&#xA;  posts: [Post] @connection(name: ""UserPosts"")&#xA;  comments: [Comment] @connection(name: ""UserComments"")&#xA;}&#xA;&#xA;type Post @model @searchable {&#xA;  id: ID!&#xA;  items: String!&#xA;  latitude: Float&#xA;  longitude: Float&#xA;  user: User @connection(name: ""UserPosts"")&#xA;  comments: [Comment] @connection(name: ""PostComments"")&#xA;}&#xA;&#xA;type Comment @model {&#xA;  id: ID!&#xA;  content: String&#xA;  timestamp: AWSDateTime&#xA;  location: String&#xA;  post: Post @connection(name: ""PostComments"")&#xA;  user: User @connection(name: ""UserComments"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The query with lat, lon and distance to find ""Posts"" should return valid results.</p>&#xA;",1601705,,,,2019-02-12 14:07:04,Is there a way to control auto generated Elastic Search Index with amplify GraphQL transform @searchable annotation?,<annotations><graphql><geospatial><aws-amplify><aws-elasticsearch>,1,0,0,2018-12-29 21:01:17
53984180,2,,53947508,21,,"<p>I think I have an answer to your question, but I also have a similar question regarding the AWS Amplify <code>codegen</code> queries, mutations, etc. If you look at the code that was generated inside of <code>~/graphql</code> folder, you'll find a declaration file similar to this:</p>&#xA;&#xA;<pre><code>export const listOrganizations = `query ListOrganizations(&#xA;  $filter: ModelOrganizationFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listOrganizations(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      address&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>You can see here that the first parameter to the <code>ListOrganizations</code> query (in your case, <code>ListTodos</code> query) takes a first argument of <code>filter: $filter</code>. I have figured out so far that you can modify this query by doing the following...</p>&#xA;&#xA;<pre><code>API.graphql(graphqlOperation(queries.listTodos, {&#xA;    filter: {&#xA;        status: {&#xA;            eq: ""completed""&#xA;        }&#xA;    }&#xA;})));&#xA;</code></pre>&#xA;&#xA;<p>This should filter out all Todos except the ones where their <code>status</code> is equal to <code>completed</code>. The problem that I am having is that I want to enable different levels of access control such that anyone with a Cognito User Pool Group of <code>Admin</code> may view <code>@model</code> as well as the <code>@owner</code>. And I was able to get this all working using the <code>@auth</code> transformer, but now my problem is that on some screens, I only want to display certain entities that are the <code>owner</code> of that entity and because I am also an <code>Admin</code>, the API defaults to getting me everything. I want to use this <code>@filter</code> or <code>ModelOrganizationFilterInput</code> to only give me the data where I am the owner. The only way I have found to do this was to add the <code>owner</code> field to my Schema, but then the API always provides the owner field and I want to filter that field out. </p>&#xA;&#xA;<p>The only documentation that I can find on how the <code>aws-amplify</code> <code>API</code> and <code>graphqlOperation</code> methods is here: <a href=""https://aws-amplify.github.io/docs/js/api"" rel=""noreferrer"">https://aws-amplify.github.io/docs/js/api</a> but there are not many examples and they don't show much of how the API works on the client. I'm stuck.</p>&#xA;",3989221,,,,2018-12-31 06:13:37,"",,0,5,0,2018-12-31 06:13:37
54003825,1,54031031,,6,9004,"<p>I'm trying to query my items (which have fields of AWS DateTime of CreatedAt and UpdatedAt) for all within a certain date range. For example, the past 48 hours.</p>&#xA;&#xA;<p>For example, using this schema:</p>&#xA;&#xA;<pre><code>type Note @model @searchable @auth(rules: [{ allow: owner }]) {&#xA;  id: ID!&#xA;  note: String&#xA;  createdAt: AWSDateTime&#xA;</code></pre>&#xA;&#xA;<p>I'm able to search for dates using, for example:</p>&#xA;&#xA;<pre><code>query {&#xA;  searchNotes(filter:{createdAt: { matchPhrasePrefix: ""2018-12-27""}}) {&#xA;    items{&#xA;      id&#xA;        title&#xA;      createdAt&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which returns all notes that match the UTC time with that string prefix. </p>&#xA;&#xA;<p>From which, I have to sort myself using moment.diff(), or some other method.</p>&#xA;&#xA;<p>I'm not sure there is a better/more efficient way of doing searching/filtering by dates and time using AppSync and GraphQl?</p>&#xA;&#xA;<p>Thank you.</p>&#xA;",10070034,,,,2020-05-24 06:01:06,AppSync - query for all items created within a date range?,<elasticsearch><graphql><aws-appsync><aws-amplify><amplifyjs>,2,0,0,2019-01-02 09:20:05
54021302,2,,53822545,1,,"<p>You could filter once all your posts have been queried by GraphQL: </p>&#xA;&#xA;<pre><code>const Posts = edges&#xA;    .filter( edgeItem =&gt; edgeItem.node.frontmatter.date &gt; Date.now())&#xA;    .map(({ node }) =&gt; &lt;PostItem key={node.id} node={node} /&gt; )&#xA;</code></pre>&#xA;&#xA;<p>If your date is stored as a string, convert it first to make the comparison. &#xA;<a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date</a></p>&#xA;",1111233,,,,2019-01-03 11:20:18,"",,0,0,0,2019-01-03 11:20:18
54022373,2,,54019778,0,,"<p>Ah, stupid me. If anyone's stuck in a similar situation, the following line:</p>&#xA;&#xA;<pre><code>$topic_meta = get_term_meta( $term-&gt;id, '_topic_image', true );&#xA;</code></pre>&#xA;&#xA;<p>should instead be:</p>&#xA;&#xA;<pre><code>$topic_meta = get_term_meta( $term-&gt;term_id, '_topic_image', true );&#xA;</code></pre>&#xA;&#xA;<p>Now it all works fine. This has happened to me before when working with custom fields in <code>comment_meta</code>, <code>user_meta</code>, etc. Not sure why only <code>$post-&gt;id</code> seems to resolve properly? Whereas to select the id for any other object, <em>objectname</em>_id is required.</p>&#xA;",9761787,,5346438,2019-01-03 13:11:43,2019-01-03 13:11:43,"",,0,1,0,2019-01-03 12:33:02
54031031,2,,54003825,10,,"<p>As of writing (Jan 3, 2019), the easiest way to do this would be to store the date as an integer (e.g. seconds since epoch) which would open up the <code>gt, lt, gte, ...</code> filter fields on the auto-generated search resolvers filter input.</p>&#xA;&#xA;<p>Another solution is to write your own resolver using the AWS AppSync console or your own CloudFormation stack. When writing your own resolver you can leverage the entire Elasticsearch DSL to implement all kinds of queries (see <a href=""https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html"" rel=""noreferrer"">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html</a>). To go down this route, you can add your own search field to the Query type in your schema and write a custom resolver.</p>&#xA;&#xA;<pre><code>type Query {&#xA;  searchNotesByCreatedAt(start: String!, end: String!): NotesConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then via the console or via your own CloudFormation stack you can write a resolver like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""version"": ""2017-02-28"",&#xA;  ""operation"": ""GET"",&#xA;  ""path"": ""/note-&lt;your-api-id&gt;/doc/_search"", // created by amplify&#xA;  ""params"": {&#xA;    ""body"": {&#xA;      ""sort"": [{ ""createdAt"" : {""order"" : ""desc""}}],&#xA;      ""query"": {&#xA;        ""range"" : {&#xA;            ""createdAt"" : {&#xA;                ""gte"": $ctx.args.start, &#xA;                ""lte"": $ctx.args.end&#xA;            }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You will only need to deploy this resolver using the console or your own CF stack temporarily. Work is being done to allow you to write your own resolvers from within the amplify CLI. For more information on how this will work see <a href=""https://github.com/aws-amplify/amplify-cli/issues/574"" rel=""noreferrer"">https://github.com/aws-amplify/amplify-cli/issues/574</a>.</p>&#xA;&#xA;<p>Let me know if this works for you.</p>&#xA;",2088684,,,,2019-01-03 23:06:56,"",,0,2,0,2019-01-03 23:06:56
54035786,1,,,0,364,"<p>I have a very simple Schema Structure in my AWS AppSync using DynamoDB as backend.</p>&#xA;&#xA;<pre><code>    type Demo {&#xA;        id: ID!&#xA;        name: String!&#xA;        date: String!&#xA;    }&#xA;&#xA;    type DemoConnection {&#xA;        items: [Demo]&#xA;        nextToken: String&#xA;    }&#xA;input ListFilter {&#xA;    limit: Int&#xA;    nextToken: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And i have this query to list all Demos</p>&#xA;&#xA;<pre><code>listAllDemo(input: ListFilter): DemoConnection&#xA;</code></pre>&#xA;&#xA;<p>For which the resolvers looks as - </p>&#xA;&#xA;<pre><code>{&#xA;    ""version"" : ""2017-02-28"",&#xA;    ""operation"" : ""Scan"",&#xA;    ""limit"": #if($context.arguments.limit) $context.arguments.limit #else 10 #end,&#xA;    ""nextToken"": #if($context.arguments.input.nextToken) ""$context.arguments.input.nextToken"" #else null #end&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And Response Mapping Template as</p>&#xA;&#xA;<pre><code>{&#xA;    ""items"": $util.toJson($context.result.items),&#xA;    ""nextToken"": $util.toJson($context.result.nextToken)&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I created some 13 records to test the ""nextToken"". It returned a token along with 10 results and i used it to fetch the other results.&#xA;There is some other API which deletes these records from DB. WHat happens is even when i am now having 7 records in DB, ""<code>listAll</code>"" returns the nextToken , which it should not, though using this nextToken the next resultset is blank.</p>&#xA;&#xA;<p>I am unable to understand why i am getting this nextToken even when records are not there.</p>&#xA;",8341137,,,,2019-01-04 09:00:39,"nextToken in ""queryAll"" Query type",<graphql><aws-appsync>,0,4,0,2019-01-04 09:00:39
54043070,2,,52113166,0,,"<p>This error indicates that your query doesn't return any fields.  Make sure that under graphql/queries/user/user.js you have at least one field defined like this:</p>&#xA;&#xA;<p><code>const UserListType = new GraphQLObjectType({&#xA;  name: 'UserList',&#xA;  fields() {&#xA;    return {&#xA;      id: {&#xA;        type: GraphQLInt,&#xA;        description: ""Unique identifier of the User""&#xA;      }&#xA;    }&#xA;  }&#xA;})</code></p>&#xA;&#xA;<p>The other piece to check is that you have properly exported the query in graphql/queries/index.js like this:</p>&#xA;&#xA;<pre><code>// Users&#xA;const listUsers = require('./user/listUsers')&#xA;&#xA;module.exports = {&#xA;&#xA;  // Users&#xA;  listUsers&#xA;} &#xA;</code></pre>&#xA;",1626020,,,,2019-01-04 16:52:11,"",,0,0,0,2019-01-04 16:52:11
54068404,2,,47064987,1,,"<p>I came across this same issue as I was trying to sort posts from a category tag that I was using in Contentful. Like @chmac said, you can sort the data from GraphQL with Javascript.</p>&#xA;&#xA;<p>I had to search for a good example, but I finally found one in this Gatsby starter: </p>&#xA;&#xA;<p>Github: <a href=""https://github.com/ryanwiemer/gatsby-starter-gcn/blob/master/src/templates/tag.js"" rel=""nofollow noreferrer"">https://github.com/ryanwiemer/gatsby-starter-gcn/blob/master/src/templates/tag.js</a></p>&#xA;&#xA;<p>Live Example: <a href=""https://gcn.netlify.com/tag/fancy/"" rel=""nofollow noreferrer"">https://gcn.netlify.com/tag/fancy/</a></p>&#xA;&#xA;<p>You can see in the source file that they sorted the data in a new constant called <code>posts</code> using <code>moment</code> (<a href=""https://www.npmjs.com/package/moment"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/moment</a>) and <code>lodash</code>. In my personal example I had to tweak my constant like so:</p>&#xA;&#xA;<pre><code>const courses = orderBy(&#xA;            this.props.data.contentfulCategory.course,&#xA;            // eslint-disable-next-line&#xA;            [object =&gt; new moment(object.createdAt)],&#xA;            ['desc']&#xA;          )&#xA;</code></pre>&#xA;&#xA;<p>Then I just used a map function like so in the component return:</p>&#xA;&#xA;<pre><code>{/* Courses */}&#xA;{courses.map(course =&gt; (&#xA;    &lt;div className=""hero__profile"" key={course.id}&gt;&#xA;        &lt;h2&gt;{course.title}&lt;/h2&gt;&#xA;    &lt;/div&gt;&#xA;))}&#xA;</code></pre>&#xA;&#xA;<p>I hope this helps!</p>&#xA;",4991267,,,,2019-01-07 03:58:44,"",,0,0,0,2019-01-07 03:58:44
54124303,1,,,0,558,"<p>Ok, I have a table with primary partition key (Employee ID) and Sort Key (Poject ID). Now I want a list of all projects an employee works on. Also I want list of all employees working on a project. The relationship is many to many. I have created schema in AppSync (GraphQL). Appsync created the required queries and mutations for the type (EmployeeProjects). Now the ListEmployeeProjects takes a filter input with different attributes. My question is when I do the two searches on Employee ID or Project ID only, will it be a complete table scan? How efficient will that be. If it is a table scan, can I reduce the time complexity by creating indexes (GSI or LSI). The end product will have huge amount of data, so I cannot test the app with such data before hand. My project works fine, but I am worried about the problems that might arise later on with a lot of data. Can someone please help.</p>&#xA;",2261287,,,,2019-03-23 02:14:53,"How best to perform a query on primary partition key only, for a table which has both partition key and sort key?",<amazon-dynamodb><graphql><aws-appsync>,1,0,0,2019-01-10 08:10:23
54150946,2,,52398927,2,,"<p>( if you found a solution I hope this will help someone else )</p>&#xA;&#xA;<p>It depends on how you designed GSI or LSI to your DynamoDB table.</p>&#xA;&#xA;<p>As stated <a href=""https://docs.aws.amazon.com/mobile/sdkforxamarin/developerguide/dynamodb.html"" rel=""nofollow noreferrer"">here</a> ""DynamoDB builds an <b>unordered hash</b> index on the hash primary key attribute, and a <b>sorted range</b> index on the range primary key attribute.""</p>&#xA;&#xA;<p>Here hash index is same as partition key, and range index is same as sort key (old and new terms).</p>&#xA;&#xA;<p>Similar text is stated <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html"" rel=""nofollow noreferrer"">here</a> - ""All items with the <b>same</b> partition key value are stored together, <b>in sorted order by sort key value</b>.""</p>&#xA;&#xA;<p>So if you added a GSI or LSI to your DynamoDB table in a way stated above (e.g. all your Products IDs are hash / partition keys and creation times are range / sort keys and you need to sort Products by creation time) you can use something similar to <a href=""https://stackoverflow.com/a/54205431/6332774"">example defined in this page of StackOverflow</a>.</p>&#xA;",6332774,,6332774,2019-01-15 19:27:41,2019-01-15 19:27:41,"",,0,0,0,2019-01-11 16:58:05
54158024,2,,54157988,0,,"<p>You just use props.posts.reverse() before map function.</p>&#xA;&#xA;<p>Refer following link.&#xA; <a href=""https://stackoverflow.com/questions/37664041/react-given-an-array-render-the-elements-in-reverse-order-efficiently"">React: Given an array, render the elements in reverse order efficiently</a></p>&#xA;",9667814,,,,2019-01-12 08:48:13,"",,0,1,0,2019-01-12 08:48:13
54176403,1,,,0,71,"<p>I'm trying to complete a paypal transaction using paypal-rest-sdk, everything is set up and working, however, I need to get the clientId back from paypal in the success route in order to save it in my client_feature_payment model. I found that we can set a ""custom"" field where we can set anything and that'll be sent back by paypal but this feautre is available in classic paypal sdk only and not available in rest-sdk one.&#xA;Is there any workaround for this?</p>&#xA;&#xA;<p>/<strong>/Paypal objects and methods from rest-sdk:</strong></p>&#xA;&#xA;<pre><code>client_page: {&#xA;      args: {&#xA;        clientId: {&#xA;          type: GraphQLString&#xA;        }&#xA;      },&#xA;      type: ClientType,&#xA;      resolve: async (_, args) =&gt; {&#xA;        if (args.clientId) {&#xA;          let clientMongoId = fromGlobalId(args.clientId).id;&#xA;          let client = await Client.queryOne(""id"")&#xA;            .eq(clientMongoId)&#xA;            .exec();&#xA;          let clientName = client.name;&#xA;          let clientSecret = client.secret;&#xA;      let company = await Company.queryOne(""id"")&#xA;        .eq(client.companyId)&#xA;        .exec();&#xA;      let companyName = company.name;&#xA;&#xA;      let service = await Service.queryOne(""id"")&#xA;        .eq(client.serviceId)&#xA;        .exec();&#xA;      let serviceName = service.name;&#xA;&#xA;      let clientFeature = await ClientFeature.query(""clientId"")&#xA;        .eq(clientMongoId)&#xA;        .exec();&#xA;&#xA;      let totalFeatures = [];&#xA;      let clientFeatureId = [];&#xA;      for (let i = 0; i &lt; clientFeature.length; i++) {&#xA;        clientFeatureId.unshift(clientFeature[i].id);&#xA;&#xA;        let feature = await Feature.query(""id"")&#xA;          .eq(clientFeature[i].featureId)&#xA;          .exec();&#xA;        let newFeature;&#xA;        feature.map(&#xA;          feature =&gt;&#xA;            (newFeature = [&#xA;              feature.name,&#xA;              feature.cost,&#xA;              feature.trial,&#xA;              feature.frequency&#xA;            ])&#xA;        );&#xA;        totalFeatures.unshift(newFeature);&#xA;      }&#xA;&#xA;      let trial, freq;&#xA;      let cost = [];&#xA;      totalFeatures.map(item =&gt; {&#xA;        if (item[2] &amp;&amp; item[3]) {&#xA;          trial = item[2];&#xA;          freq = item[3];&#xA;        }&#xA;        cost.unshift(item[1]);&#xA;      });&#xA;&#xA;      const finalCost = cost.reduce((accumulator, currentValue) =&gt; {&#xA;        return accumulator + currentValue;&#xA;      }, 0);&#xA;      let paypalFreq;&#xA;      let frequencyInterval;&#xA;      var isoDate = new Date(Date.now() + 1 * 60 * 1000);&#xA;&#xA;      switch (freq) {&#xA;        case ""bi-weekly"":&#xA;          paypalFreq = ""DAY"";&#xA;          frequencyInterval = ""7"";&#xA;          break;&#xA;        case ""monthly"":&#xA;          paypalFreq = ""MONTH"";&#xA;          frequencyInterval = ""1"";&#xA;          break;&#xA;        case ""3 months"":&#xA;          paypalFreq = ""MONTH"";&#xA;          frequencyInterval = ""3"";&#xA;          break;&#xA;        case ""6 months"":&#xA;          paypalFreq = ""MONTH"";&#xA;          frequencyInterval = ""6"";&#xA;          break;&#xA;        case ""1 year"":&#xA;          paypalFreq = ""YEAR"";&#xA;          frequencyInterval = ""1"";&#xA;          break;&#xA;        default:&#xA;          break;&#xA;      }&#xA;&#xA;      var billingPlanAttributes = {&#xA;        description:&#xA;          ""Create Plan for Trial &amp; Frequency based payment for features and services used by customer"",&#xA;        merchant_preferences: {&#xA;          auto_bill_amount: ""yes"",&#xA;          cancel_url: ""http://localhost:3000/cancel"",&#xA;          initial_fail_amount_action: ""continue"",&#xA;          max_fail_attempts: ""1"",&#xA;          return_url: ""http://localhost:3000/success"",&#xA;          setup_fee: {&#xA;            currency: ""USD"",&#xA;            value: ""0""&#xA;          }&#xA;        },&#xA;        name: ""Client Services &amp; Features Charge"",&#xA;        payment_definitions: [&#xA;          {&#xA;            amount: {&#xA;              currency: ""USD"",&#xA;              value: finalCost&#xA;            },&#xA;            cycles: ""0"",&#xA;            frequency: paypalFreq,&#xA;            frequency_interval: frequencyInterval,&#xA;            name: ""Regular 1"",&#xA;            type: ""REGULAR""&#xA;          },&#xA;          {&#xA;            amount: {&#xA;              currency: ""USD"",&#xA;              value: ""0""&#xA;            },&#xA;            cycles: ""1"",&#xA;            frequency: ""DAY"",&#xA;            frequency_interval: trial,&#xA;            name: ""Trial 1"",&#xA;            type: ""TRIAL""&#xA;          }&#xA;        ],&#xA;        type: ""INFINITE""&#xA;      };&#xA;&#xA;      var billingPlanUpdateAttributes = [&#xA;        {&#xA;          op: ""replace"",&#xA;          path: ""/"",&#xA;          value: {&#xA;            state: ""ACTIVE""&#xA;          }&#xA;        }&#xA;      ];&#xA;&#xA;      var billingAgreementAttr = {&#xA;        name: ""Fast Speed Agreement"",&#xA;        description: ""Agreement for Fast Speed Plan"",&#xA;        start_date: isoDate,&#xA;        plan: {&#xA;          id: ""P-0NJ10521L3680291SOAQIVTQ""&#xA;        },&#xA;        payer: {&#xA;          payment_method: ""paypal"",&#xA;          payer_info: {&#xA;            payer_id: clientMongoId&#xA;          }&#xA;        },&#xA;        shipping_address: {&#xA;          line1: ""StayBr111idge Suites"",&#xA;          line2: ""Cro12ok Street"",&#xA;          city: ""San Jose"",&#xA;          state: ""CA"",&#xA;          postal_code: ""95112"",&#xA;          country_code: ""US""&#xA;        }&#xA;      };&#xA;&#xA;      // Create the billing plan&#xA;      let billingPlan = await new Promise((resolve, reject) =&gt; {&#xA;        paypal.billingPlan.create(&#xA;          billingPlanAttributes,&#xA;          (error, billingPlan) =&gt; {&#xA;            if (error) {&#xA;              throw error;&#xA;            } else {&#xA;              resolve(billingPlan);&#xA;            }&#xA;          }&#xA;        );&#xA;      });&#xA;&#xA;      // let billingPlan = await billingPlanPromise;&#xA;&#xA;      // Activate the plan by changing status to Active&#xA;      let billingAgreementAttributes = await new Promise(&#xA;        (resolve, reject) =&gt; {&#xA;          paypal.billingPlan.update(&#xA;            billingPlan.id,&#xA;            billingPlanUpdateAttributes,&#xA;            (error, response) =&gt; {&#xA;              if (error) {&#xA;                throw error;&#xA;              } else {&#xA;                billingAgreementAttr.plan.id = billingPlan.id;&#xA;                resolve(billingAgreementAttr);&#xA;              }&#xA;            }&#xA;          );&#xA;        }&#xA;      );&#xA;&#xA;      // Use activated billing plan to create agreement&#xA;      let approval_url = await new Promise((resolve, reject) =&gt; {&#xA;        paypal.billingAgreement.create(&#xA;          billingAgreementAttributes,&#xA;          (error, billingAgreement) =&gt; {&#xA;            if (error) {&#xA;              throw error;&#xA;            } else {&#xA;              for (&#xA;                var index = 0;&#xA;                index &lt; billingAgreement.links.length;&#xA;                index++&#xA;              ) {&#xA;                if (billingAgreement.links[index].rel === ""approval_url"") {&#xA;                  var approval_url = billingAgreement.links[index].href;&#xA;                  let newApprovalUrl =&#xA;                    approval_url + `&amp;custom=${clientFeatureId}`;&#xA;                  resolve(newApprovalUrl);&#xA;&#xA;                  // See billing_agreements/execute.js to see example for executing agreement&#xA;                  // after you have payment token&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        );&#xA;      });&#xA;&#xA;      let data = {&#xA;        companyId: companyName,&#xA;        serviceId: serviceName,&#xA;        name: clientName,&#xA;        secret: clientSecret,&#xA;        features: totalFeatures,&#xA;        endpoint: approval_url&#xA;      };&#xA;&#xA;      return Object.assign(data);&#xA;    }&#xA;  }&#xA;},&#xA;</code></pre>&#xA;&#xA;<p><strong>The success route:</strong></p>&#xA;&#xA;<pre><code>app.get(""/success"", (req, res) =&gt; {&#xA;    console.log(""This is response"", res);&#xA;    let paymentToken = req.query.token;&#xA;    paypal.billingAgreement.execute(paymentToken, {}, function(&#xA;      error,&#xA;      billingAgreement&#xA;    ) {&#xA;      if (error) {&#xA;        throw error;&#xA;      } else {&#xA;        console.log(""Billing agreement"", billingAgreement);&#xA;        let date = billingAgreement.start_date;&#xA;        let amountString =&#xA;          billingAgreement.plan.payment_definitions[1].amount.value;&#xA;        let trial =&#xA;          billingAgreement.plan.payment_definitions[0].frequency_interval;&#xA;        let frequencyInterval =&#xA;          billingAgreement.plan.payment_definitions[1].frequency_interval;&#xA;        let frequency = billingAgreement.plan.payment_definitions[1].frequency;&#xA;        let totalFrequency = frequencyInterval + "" "" + frequency;&#xA;        let period = [trial, totalFrequency];&#xA;        let amount = parseInt(amountString);&#xA;        try {&#xA;          Payment.create({&#xA;            id: uuidv1(),&#xA;            date: date,&#xA;            amount: amount,&#xA;            period: period&#xA;          });&#xA;        } catch (err) {&#xA;          throw new Error(err);&#xA;        }&#xA;        res.render(""index"");&#xA;      }&#xA;    });&#xA;  });&#xA;</code></pre>&#xA;",3762961,,,,2019-01-14 17:30:30,Paypal not returning custom variable,<node.js><express><paypal><graphql><paypal-rest-sdk>,1,0,0,2019-01-14 06:00:23
54176648,2,,54176521,1,,"<p>It depends on where are places you want to share them, I mean if you want to share data in the same branch of the component tree, you can have a <strong>Container Component</strong> at the top ( Which holds your state and pass the data has <strong>props</strong> to the levels below).</p>&#xA;&#xA;<p>If your components branch is very <strong>complex</strong> and it needs to travel <strong>down many levels</strong> then its a pain and not recommended too, in this case, consider using Context API &#xA;<a href=""https://reactjs.org/docs/context.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/context.html</a></p>&#xA;&#xA;<p>I would not recommend a <strong>HOC</strong> for this, HOC is not meant to share data, its meant to share re-useable <strong>functionalities</strong>.</p>&#xA;&#xA;<p>Please check this, this has a bunch of best practices <a href=""https://www.toptal.com/react/tips-and-practices"" rel=""nofollow noreferrer"">https://www.toptal.com/react/tips-and-practices</a></p>&#xA;&#xA;<p>Well <strong>REDUX</strong> is another way but I would not recommend using REDUX looking at your need.</p>&#xA;&#xA;<p><strong>When to use REDUX?</strong></p>&#xA;&#xA;<p>Basically, you need to be using REDUX, when keeping the state in a top-level root component is no longer sufficient, like for example : ( you have two branches out from root component, one of the child components in branch <strong>A</strong> wants to access some state in branch <strong>B</strong>'s child, then you need to move it to the root component and again pass it down, such cases are apt for <strong>REDUX</strong> ).</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/DG0q7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DG0q7.png"" alt=""enter image description here""></a></p>&#xA;",1635825,,1635825,2019-01-14 06:33:31,2019-01-14 06:33:31,"",,0,0,0,2019-01-14 06:28:18
54223810,2,,54222787,3,,"<p>The mutation to create the task has the following shape: </p>&#xA;&#xA;<pre><code>mutation b {&#xA;  createTask(&#xA;    data: {&#xA;      content: ""Task1""&#xA;      completed: false&#xA;      dateToDo: { connect: { id: ""cjqzjvk6w000e0999a75mzwpx"" } }&#xA;    }&#xA;  ) {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The type <code>DayCreateOneWithoutTasksInput</code> Prisma is asking for is autogenerated and is the one expected for the field <code>dataToDo</code>. The name means that Prisma would accept a type that creates one <code>Day</code> node but does not have the field tasks or a type that specifies a connection. The <code>WithoutTasksInput</code> part states is there because the type can only be used nested in a mutation where you start from a task, Prisma therefore already has the value to fill in for the tasks field on the nested <code>Day</code> node and you do not need to specify it if you create the day instead of connecting an existing one.  </p>&#xA;&#xA;<p>If you use the Playground you can explore the schema that contains all the types on the right side.</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/IGfxA.png"" rel=""nofollow noreferrer"">schema explorer in the playground</a></p>&#xA;&#xA;<p>Hope that helps! </p>&#xA;",9941706,,,,2019-01-16 19:13:23,"",,0,1,0,2019-01-16 19:13:23
54236458,1,54236657,,1,390,"<p>How to add User in this example? I try to use mutation in all ways but doesn't work. </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>type User {&#xA;  masterId: Int&#xA;  name: String&#xA;  surname: String&#xA;  address: Address &#xA;}&#xA;&#xA;type Address {&#xA;  street: String&#xA;  flat: Int&#xA;  city: String&#xA;  country: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I try something like this:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>type Mutation {&#xA;  user(&#xA;    masterId: Int&#xA;    name: String&#xA;    surname: String&#xA;    address: Address&#xA;  ): User&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and next</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>mutation {&#xA;  user(&#xA;    masterId: 4,&#xA;      name: ""Kevin"",&#xA;      surname: ""Key"",&#xA;        address: {&#xA;        street: ""Clark Street"",&#xA;        flat: 19,&#xA;        city: ""Brentwood"",&#xA;        country: ""United Kingdom""&#xA;      }&#xA;  ) &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I try different versions, but I really can not find a solution</p>&#xA;",10927939,,846053,2019-01-17 15:24:19,2019-01-17 15:25:23,"Mutation doesn't work GraphQL, Prisma, Yoga",<graphql><prisma-graphql><plumatic-schema>,1,0,0,2019-01-17 12:56:26
54236657,2,,54236458,1,,"<p>Try this in the playground after creating datamodel in prisma </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>mutation {&#xA;  createUser(&#xA;    data: {&#xA;      name: ""Kevin"",&#xA;      surname: ""Key""&#xA;      address: {&#xA;        create: {&#xA;          street: ""Clark Street"",&#xA;          flat: 19,&#xA;          city: ""Brentwood"",&#xA;          country: ""United Kingdom""&#xA;        }&#xA;      }&#xA;    }&#xA;  ) {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Note</strong>&#xA;You also use connect if address object is already created, for connect just pass the Address id(Primary Key/ObjectId)</p>&#xA;",8630769,,846053,2019-01-17 15:25:23,2019-01-17 15:25:23,"",,0,2,0,2019-01-17 13:07:29
54251722,1,,,0,3454,"<p>I am working on apollo client library for integrating graphql with angular.&#xA;I am able to do simple queries like findAll without any arguments</p>&#xA;&#xA;<pre><code>const allData = &#xA;        gql`&#xA;        query allData {&#xA;          allData {&#xA;            id&#xA;            fromDate&#xA;            toDate&#xA;            name&#xA;            ...&#xA;          }&#xA;        }&#xA;      `&#xA;</code></pre>&#xA;&#xA;<p>I am able to fetch result with this query using watchQuery</p>&#xA;&#xA;<pre><code>this.data = this.apollo.watchQuery&lt;Query&gt;({query: allData}).valueChanges&#xA;      .pipe(&#xA;        map(result =&gt; result.data.allData)&#xA;      );&#xA;</code></pre>&#xA;&#xA;<p>but I am not able to create a complex query with arguments like </p>&#xA;&#xA;<pre><code>{&#xA;  allDataWithFilter(&#xA;    date: {from: ""2010-01-16T10:20:10"", to: ""2019-01-16T11:16:10""}, &#xA;    name: ""ABC"" {&#xA;    allDataWithFilter {&#xA;      id&#xA;      fromDate&#xA;      toDate&#xA;      name&#xA;            ...      &#xA;    }&#xA;    totalPages&#xA;    totalElements&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How do I pass date and other arguments in the query?</p>&#xA;",1298426,,,,2019-01-18 12:04:56,How to create a graphql query with arguments in angular using apollo client library,<angular><apollo-client>,2,0,0,2019-01-18 10:09:26
54253682,2,,54251722,1,,"<p>You should read your schema in order to understand what the server needs and should pass the appropriate data with types. &#xA;I hope it will be something like this in your case.</p>&#xA;&#xA;<pre><code>{&#xA;  allDataWithFilter(&#xA;    date: {$from: DateTime, $to: DateTime}, &#xA;    name: String {&#xA;    allDataWithFilter(from: $from, to: $to) {&#xA;      id&#xA;      fromDate&#xA;      toDate&#xA;      name&#xA;            ...      &#xA;    }&#xA;    totalPages&#xA;    totalElements&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When you are calling this query just pass this data in variables like this</p>&#xA;&#xA;<pre><code>this.apollo.query({&#xA;  query: YourQuery,&#xA;  variables: {&#xA;   from: new Date(),&#xA;   to: someDate&#xA;}&#xA;})&#xA;</code></pre>&#xA;",6883002,,,,2019-01-18 12:04:56,"",,0,1,0,2019-01-18 12:04:56
54257039,2,,54094760,0,,"<p>Just for reference, we were able to solve the problem with the following line:</p>&#xA;&#xA;<pre><code>GraphQLAnnotations.getInstance()&#xA;    .getObjectHandler()&#xA;    .getTypeRetriever()&#xA;    .getGraphQLFieldRetriever()&#xA;    .setAlwaysPrettify(true);&#xA;</code></pre>&#xA;",2777981,,,,2019-01-18 15:32:29,"",,0,0,0,2019-01-18 15:32:29
54259453,1,,,1,3814,"<p>I'm trying to use Graphene to model the following data: a <code>MessageFrequency</code> object, which represents the number of messages sent on a given date for a particular chat, and a <code>MessageFrequencyRange</code> object which represents the number of messages sent per day for a range of dates, all for a given chat. </p>&#xA;&#xA;<p>I've tried creating custom classes and have been able to get the <code>MessageFrequency</code> object queryable by following <a href=""https://stackoverflow.com/a/45407521/6587177"">this</a> stackoverflow post, but I'm confused on how to get a nested custom object working. Below is my current code.</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>class MessageFrequency(graphene.ObjectType):&#xA;&#xA;    chat_id   = graphene.Int()&#xA;    date      = graphene.Date()&#xA;    frequency = graphene.Int()&#xA;&#xA;&#xA;class MessageFrequencyRange(graphene.ObjectType):&#xA;&#xA;    chat_id     = graphene.Int()&#xA;    start_date  = graphene.Date()&#xA;    end_date    = graphene.Date()&#xA;    frequencies = graphene.NonNull(graphene.List(graphene.NonNull(MessageFrequency)))&#xA;&#xA;    def resolve_frequencies(self, info):&#xA;        return [&#xA;            # some method to instantiate a MessageFrequency object...&#xA;            # Query.resolve_message_frequency ?&#xA;        ]&#xA;&#xA;class Query(graphene.ObjectType):&#xA;&#xA;    message_frequency = graphene.Field(&#xA;        MessageFrequency,&#xA;        chat_id=graphene.Int(required=True),&#xA;        date=graphene.Date(required=True),&#xA;    )&#xA;    message_frequency_range = graphene.Field(&#xA;        MessageFrequencyRange,&#xA;        chat_id=graphene.Int(required=True),&#xA;    )&#xA;&#xA;    def resolve_message_frequency(self, info, chat_id, date):&#xA;        # test data for now&#xA;        return MessageFrequency(&#xA;            chat_id=9000,&#xA;            date=date,&#xA;            frequency=1&#xA;        )&#xA;&#xA;    def resolve_message_frequency_range(self, info):&#xA;        # Should be creating a MessageFrequencyRange object, but not sure how to fill&#xA;        # in the frequencies attribute which isn't a scalar&#xA;        return None&#xA;</code></pre>&#xA;&#xA;<p>I'm not sure how I should be resolving the <code>MessageFrequencyRange</code> object inside <code>Query</code>, because it's more complicated than resolving a <code>MessageFrequency</code> object (as it has non scalar fields). I'm also not sure how to resolve the <code>frequencies</code> attribute of <code>MessageFrequencyRange</code>, I would think I should use the previously written resolver but I'm unsure on how exactly to call it. </p>&#xA;&#xA;<p>Any help would be appreciated!</p>&#xA;",6587177,,,,2019-01-22 20:46:39,Graphene resolver for nested custom object,<python><graphql><graphene-python>,1,0,0,2019-01-18 18:14:13
54262737,2,,50660045,9,,"<p>This looks like an interesting library, I would suggest checking it out:</p>&#xA;&#xA;<p><a href=""https://www.npmjs.com/package/json-to-graphql-query"" rel=""noreferrer"">https://www.npmjs.com/package/json-to-graphql-query</a></p>&#xA;&#xA;<p>But basically all we need to do is to convert the object to a string while ensuring the keys do not adopt double quotes and integers are not converted into strings, as that might not play well with the graphql schemas we're working with. </p>&#xA;&#xA;<p>Since JSON.stringify() won't accomplish this, I came up with this little function to help with interpolating arguments into my queries:</p>&#xA;&#xA;<pre><code>/**&#xA; * Queryfy.&#xA; *&#xA; * Prep javascript objects for interpolation within graphql queries.&#xA; *&#xA; * @param {mixed} obj&#xA; * @return template string.&#xA; */&#xA;const queryfy = obj =&gt; {&#xA;&#xA;  // Make sure we don't alter integers.&#xA;  if( typeof obj === 'number' ) {&#xA;    return obj;&#xA;  }&#xA;&#xA;  // Stringify everything other than objects.&#xA;  if( typeof obj !== 'object' || Array.isArray( obj ) ) {&#xA;    return JSON.stringify( obj );&#xA;  }&#xA;&#xA;  // Iterate through object keys to convert into a string&#xA;  // to be interpolated into the query.&#xA;  let props = Object.keys( obj ).map( key =&gt;&#xA;    `${key}:${queryfy( obj[key] )}`&#xA;  ).join( ',' );&#xA;&#xA;  return `{${props}}`;&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is a reduced portion of my code where I am using this successfully:</p>&#xA;&#xA;<pre><code>const dateQuery = {};&#xA;&#xA;if( !! date1 ) {&#xA;&#xA;  dateQuery.after = {&#xA;    year: parseInt( date1.format( 'YYYY' ) ),&#xA;    month: parseInt( date1.format( 'M' ) ),&#xA;    day: date1.format( 'D' ) - 1,&#xA;  }&#xA;&#xA;}&#xA;if( !! date2 ) {&#xA;&#xA;  dateQuery.before = {&#xA;    year: parseInt( date2.format( 'YYYY' ) ),&#xA;    month: parseInt( date2.format( 'M' ) ),&#xA;    day: date2.format( 'D' ) - 1,&#xA;  }&#xA;&#xA;}&#xA;&#xA;const query = await client.query( {&#xA;  query: gql `{&#xA;    apiResponses( where: {&#xA;      dateQuery: ${queryfy( dateQuery )}&#xA;    } ) {&#xA;      edges {&#xA;        node {&#xA;          apiResponseId&#xA;          title&#xA;          date&#xA;          json&#xA;        }&#xA;      }&#xA;    }&#xA;  }`&#xA;} );&#xA;&#xA;</code></pre>&#xA;&#xA;<p>That being said, I am going to check out the library mentioned and probably use that moving forward.</p>&#xA;",3381136,,3381136,2019-01-18 23:42:07,2019-01-18 23:42:07,"",,0,1,0,2019-01-18 23:34:22
54289250,1,,,4,607,"<p>I'm writing a facebook wall like function for my webapp with amplify-cli and vue, and I need to do a simple serverside orderby/sort in my query. It seems impossible.. </p>&#xA;&#xA;<p>I have tried the standard graphql way, with adding sort, it does not work...</p>&#xA;&#xA;<p>The query generated by amplify-cli:</p>&#xA;&#xA;<pre><code>query ListWallposts(&#xA;  $filter: ModelWallpostFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;  ) {&#xA;  listWallposts(filter: $filter, limit: $limit, nextToken: $nextToken&#xA;  ) {&#xA;  items {&#xA;    id&#xA;    content&#xA;    createdAt&#xA;    comments {&#xA;      nextToken&#xA;    }&#xA;    user {&#xA;      id&#xA;      firstname&#xA;      lastname&#xA;&#xA;    }&#xA;  }&#xA;  nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My addition:</p>&#xA;&#xA;<pre><code>query ListWallposts(&#xA;   $filter: ModelWallpostFilterInput&#xA;   $limit: Int&#xA;   $nextToken: String&#xA;  ) {&#xA;  listWallposts(filter: $filter, limit: $limit, nextToken: $nextToken,sort:{ field:createdAt, order:ASC }&#xA;  ) {&#xA;  items {&#xA;    id&#xA;    content&#xA;    createdAt&#xA;    comments {&#xA;      nextToken&#xA;    }&#xA;    user {&#xA;      id&#xA;      firstname&#xA;    lastname&#xA;    }&#xA;  }&#xA;  nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I can not add primary sortkey to dynamoDB, after amplify-cli table creation.&#xA;I have spent days trying to figure this simple thing out... Any help would be very welcome. </p>&#xA;",2329258,,13302,2019-01-21 21:19:00,2019-12-03 05:21:29,How to serverside order/sort query results in amplify-cli,<amazon-web-services><graphql><aws-amplify>,1,0,0,2019-01-21 11:42:41
54313691,2,,54311300,2,,"<p>Its not in build, you need to add input parameters into your api endpoint and then use them to implement pagination. ex- sequelize accepts these parameters as it is and generates query.</p>&#xA;&#xA;<pre><code>yourAPI(filters:yourInputFilters,limit:Int,offset:Int)&#xA;</code></pre>&#xA;&#xA;<p>Sample with sequelize :</p>&#xA;&#xA;<pre><code>model.findAndCountAll({&#xA;            where: filters,&#xA;            limit: limit,&#xA;            offset: offset&#xA;})&#xA;</code></pre>&#xA;",10554174,,,,2019-01-22 17:39:40,"",,0,0,0,2019-01-22 17:39:40
54316196,2,,54259453,-1,,"<p>I've done a nested object yesterday. I will try to answer. Would be good If you post your models.  </p>&#xA;&#xA;<pre><code> class MessageFrequencyType(DjangoObjectType):&#xA;     class Meta:&#xA;        model = MessageFrequency # Not sure about the name of your model&#xA;&#xA;&#xA; class MessageFrequencyRangeType(DjangoObjectType):&#xA;    class Meta:&#xA;       model = MessageFrequencyRange # Not sure about the name of your model&#xA;&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    message_frequency = graphene.List(MessageFrequencyType)&#xA;    message_frequency_range = graphene.List(MessageFrequencyRangeType)&#xA;&#xA;    def resolve_message_frequency(self, info, **kwargs):&#xA;        return MessageFrequency.objects.all()&#xA;&#xA;    def resolve_message_frequency_range(self, info, **kwargs):&#xA;        return MessageFrequencyRange.objects.all()&#xA;&#xA;&#xA;class CreateMessageFrequency(graphene.Mutation):&#xA;    chat_id = graphene.Int()&#xA;    date = graphene.Date()&#xA;    frequency = graphene.Int()&#xA;&#xA;   class Arguments:&#xA;       chat_id = graphene.Int()&#xA;       date = graphene.Date()&#xA;       frequency = graphene.Int()&#xA;&#xA;   def mutate(self, info, chat_id, date, frequency):&#xA;       message_frequency = MessageFrequency(&#xA;           chat_id=chat_id,&#xA;           date=date,&#xA;           frequency=frequency,&#xA;       )&#xA;       message_frequency.save()&#xA;&#xA;   return CreateMessageFrequency(&#xA;       chat_id=message_frequency.chat_id,&#xA;       date=message_frequency.date,&#xA;       frequency=message_frequency.frequency&#xA;   )&#xA;&#xA;&#xA;class CreateMessageFrequencyRange(graphene.Mutation):&#xA;    chat_id = graphene.Int()&#xA;    start_date = graphene.Date()&#xA;    end_date = graphene.Date()&#xA;    frequencies = graphene.Field(MessageFrequencyType)&#xA;&#xA;   class Arguments:&#xA;       chat_id = graphene.Int()&#xA;       start_date = graphene.Date()&#xA;       end_date = graphene.Date()&#xA;       frequencies = graphene.Int()&#xA;&#xA;   def mutate(self, info, chat_id, start_date, end_date, frequencies):&#xA;       chat_id=chat_id&#xA;       start_date=start_date&#xA;       end_date=end_date&#xA;       frequencies = MessageFrequency.objects.filter(id=frequencies).first()&#xA;       if not frequencies:&#xA;          raise Exception('Message Frequency not found')&#xA;&#xA;   MessageFrequencyRange.objects.create(&#xA;       chat_id=chat_id,&#xA;       start_date=start_date,&#xA;       end_date=end_date,&#xA;       frequencies=frequencies&#xA;   )&#xA;&#xA;   return CreateMessageFrequencyRange(&#xA;       chat_id=chat_id,&#xA;       start_date=start_date,&#xA;       end_date=end_date,&#xA;       frequencies=frequencies&#xA;   )&#xA;&#xA;&#xA;class Mutation(graphene.ObjectType):&#xA;    create_message_frequency = CreateMessageFrequency.Field()&#xA;    create_message_frequency_range = CreateMessageFrequencyRange.Field()&#xA;</code></pre>&#xA;",8522675,,,,2019-01-22 20:46:39,"",,0,2,0,2019-01-22 20:46:39
54327966,2,,54197840,0,,"<p>It seem there is no way I can make it now with Apollo Client. So I had to save the parameters of all GET_ITEMS calls from all pages, and then transfer the saved parameters to the refetchQueries mutation method. The code turned out like this:</p>&#xA;&#xA;<p>ItemsContext.js</p>&#xA;&#xA;<pre><code>const ItemsContext = React.createContext({&#xA;  cachedQueryVars: [],&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>ItemsList.js</p>&#xA;&#xA;<pre><code>...&#xA;render() {&#xA;...&#xA;return &lt;ItemsContext.Consumer&gt;{({cachedQueryVars}) =&gt; {&#xA;       cachedQueryVars.push(variables);&#xA;       return &lt;Query query={GET_ITEMS} variables={variables} &gt;&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>ItemEdit.js</p>&#xA;&#xA;<pre><code>...&#xA;render() {&#xA;...&#xA;return &lt;ItemsContext.Consumer&gt;{({cachedQueryVars}) =&gt; &#xA;              &lt;Mutation mutation={UPDATE_ITEM_MUTATION}&#xA;                  refetchQueries={({data}) =&gt; this.handleRefetchQueries(data.updateItem, cachedQueryVars)}&#xA;...&#xA;}&#xA;&#xA;handleRefetchQueries(newItem, cachedItemsQueryVars) {&#xA;  let result = [];&#xA;  let filtered = null;&#xA;&#xA;  if(this.state.oldCategoryId != newItem.category.id) {&#xA;    filtered = cachedItemsQueryVars.filter(v =&gt; v.categoryId == this.state.oldCategoryId);&#xA;    result = this.concatItemQueryVars(result, filtered);&#xA;    filtered = cachedItemsQueryVars.filter(v =&gt; v.categoryId == newItem.category.id);&#xA;    result = this.concatItemQueryVars(result, filtered);&#xA;  }&#xA;  if(this.state.oldCompanyId != newItem.company.id) {&#xA;    filtered = cachedItemsQueryVars.filter(v =&gt; v.companyId == this.state.oldCompanyId);&#xA;    result = this.concatItemQueryVars(result, filtered);&#xA;    filtered = cachedItemsQueryVars.filter(v =&gt; v.companyId == newItem.company.id);&#xA;    result = this.concatItemQueryVars(result, filtered);&#xA;  }&#xA;  ...&#xA;&#xA;  return result;&#xA;}&#xA;&#xA;concatItemQueryVars(result, filtered) {&#xA;  return result.concat(filtered.map(v =&gt; ({&#xA;    query: GET_ITEMS,&#xA;    variables: v&#xA;  })));&#xA;}&#xA;</code></pre>&#xA;",4173951,,,,2019-01-23 13:05:18,"",,0,0,0,2019-01-23 13:05:18
54328681,1,,,18,3490,"<h1>Problem</h1>&#xA;&#xA;<p>I am using django-graphene with Relay on our GraphQL Server. The implementation imposes a <a href=""https://facebook.github.io/relay/graphql/objectidentification.htm"" rel=""noreferrer"">Global ID requirement</a> in the <code>graphene.relay.Node</code> class that <strong>overrides and hides Django's ID field</strong>.</p>&#xA;&#xA;<p>As a result, I can query like this:</p>&#xA;&#xA;<pre><code>{&#xA;    allBatches(id:""QmF0Y2hOb2RlOjE="") {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        pk&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And get this response:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""allBatches"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""QmF0Y2hOb2RlOjE="",&#xA;            ""pk"": 1&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, what I lose is the ability to filter by the original ID (or PK) field of the Object itself:</p>&#xA;&#xA;<pre><code>{&#xA;    allBatches(id:1) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        pk&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In fact, I <strong>simply cannot filter objects by ID</strong>. &#xA;I can think of two possible work-arounds to this:&#xA;1. Prevent django-graphene-relay from hijacking and shadowing the <code>id</code> field, perhaps force it to use a different field name such as <code>gid</code>&#xA;2. Find a way to include <code>pk</code> as a special field that is available both as a property and in filter</p>&#xA;&#xA;<h1>Solution 1</h1>&#xA;&#xA;<p>I have made no progress on 1 since it appears as though <code>django-graphene</code> (and perhaps the relay standard) imposes a limitation that this field be called <code>id</code>. I see that <code>id</code> has been used as a Magic String in multiple places and there does not appear to be a standard way to change the field name.</p>&#xA;&#xA;<h1>Solution 2</h1>&#xA;&#xA;<p>On 2, I can get the property to work with a <code>Mixin</code> like this:</p>&#xA;&#xA;<pre><code>class PKMixin(object):&#xA;    pk = graphene.Field(type=graphene.Int, source='pk')&#xA;</code></pre>&#xA;&#xA;<p>However, I am unable to get the filtering via <code>django-filter</code> to work, since the <code>FilterSet</code> does not have the field <code>pk</code> declared and breaks with the following error</p>&#xA;&#xA;<blockquote>&#xA;  <p>'Meta.fields' contains fields that are not defined on this FilterSet:&#xA;  pk</p>&#xA;</blockquote>&#xA;&#xA;<h2>Update on 2</h2>&#xA;&#xA;<p>I tried the following:</p>&#xA;&#xA;<pre><code>class PKFilteringNode(Node):&#xA;&#xA;    @classmethod&#xA;    def get_node_from_global_id(cls, info, global_id, only_type=None):&#xA;        # So long as only_type is set; if we detect that the global_id is a pk and not a global ID;&#xA;        # then coerce it to be a proper global ID before fetching&#xA;        if only_type:&#xA;            try:&#xA;                int(global_id)&#xA;                global_id = cls.to_global_id(only_type._meta.name, global_id)&#xA;                return super(PKFilteringNode, cls).get_node_from_global_id(info, global_id, only_type)&#xA;            except ValueError:&#xA;                pass&#xA;        return super(PKFilteringNode, cls).get_node_from_global_id(info, global_id, only_type)&#xA;</code></pre>&#xA;&#xA;<p>And now I can get GraphQL to do this:</p>&#xA;&#xA;<pre><code>{&#xA;  batchA: batch(id: ""QmF0Y2hOb2RlOjE="") {&#xA;    id&#xA;    name&#xA;  }&#xA;  batchB: batch(id: 1) {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;{&#xA;  ""data"": {&#xA;    ""batchA"": {&#xA;      ""id"": ""QmF0Y2hOb2RlOjE="",&#xA;      ""name"": ""Default Batch""&#xA;    },&#xA;    ""batchB"": {&#xA;      ""id"": ""QmF0Y2hOb2RlOjE="",&#xA;      ""name"": ""Default Batch""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>But I have a fairly strong fear this will break something downstream,&#xA;  at the level of caching perhaps?&#xA;  Also this does not allow filtering by ID still since filtering depends on&#xA;  <code>DjangoFilterConnectionField</code></p>&#xA;</blockquote>&#xA;&#xA;<h1>Request</h1>&#xA;&#xA;<p>I am stuck at the moment. I have a few questions:</p>&#xA;&#xA;<ol>&#xA;<li>Is this an unusual requirement to begin with? Am I asking the wrong&#xA;question when I wish to retain the <strong>ability to filter by pk</strong> </li>&#xA;<li>Is there a standard pattern to solve this problem?</li>&#xA;</ol>&#xA;&#xA;<h2>Related Issue on Github</h2>&#xA;&#xA;<blockquote>&#xA;  <p><a href=""https://github.com/graphql-python/graphene-django/issues/349"" rel=""noreferrer"">https://github.com/graphql-python/graphene-django/issues/349</a></p>&#xA;</blockquote>&#xA;&#xA;<h2>Versions</h2>&#xA;&#xA;<ul>&#xA;<li>graphene-django==2.1.0 </li>&#xA;<li>django==1.9.12 </li>&#xA;<li>django-filter==1.0.1</li>&#xA;<li>python==2.7.13</li>&#xA;</ul>&#xA;",1410277,,1410277,2019-01-24 10:27:26,2020-09-14 11:18:13,Enable PK based filtering in Django Graphene Relay while retaining Global IDs,<python><django><graphql><relay><graphene-python>,2,5,0,2019-01-23 13:43:06
54344308,2,,54328681,0,,"<p>Have you tried solution 2 but with using id as the source instead?</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>class PKMixin(object):&#xA;    pk = graphene.Field(type=graphene.Int, source='id')&#xA;</code></pre>&#xA;&#xA;<p>Also, if you're only looking to fetch a single record, you shouldn't go via a connection field anyway. You should define something like a <code>batchByPk</code> field on your schema instead.</p>&#xA;&#xA;<p>A final thing to be aware of, is that at the current time graphene-django's <code>DjangoFilterConnectionField</code> isn't implemented in an efficient way, so you may not even want to use it anyway.</p>&#xA;",15687,,,,2019-01-24 10:21:30,"",,0,3,0,2019-01-24 10:21:30
54414395,1,54414626,,4,7086,"<p>I'm having trouble understanding how to write filters for GraphQL queries in GatsbyJS.</p>&#xA;&#xA;<p>This works:</p>&#xA;&#xA;<pre><code>filter: { contentType: { in: [""post"", ""page""] }&#xA;</code></pre>&#xA;&#xA;<p>I basically need the reverse of that, like:</p>&#xA;&#xA;<pre><code>filter: { ""post"" in: { contentTypes } } // where contentTypes is array&#xA;</code></pre>&#xA;&#xA;<p>That doesn't work because ""NAME is expected"" (where ""post"" is in my example).</p>&#xA;&#xA;<p>After going through GatsbyJS <a href=""https://www.gatsbyjs.org/docs/graphql-reference/"" rel=""nofollow noreferrer"">docs</a> I found this:</p>&#xA;&#xA;<pre><code>elemMatch: short for element match, this indicates that the field you are filtering will return an array of elements, on which you can apply a filter using the previous operators&#xA;&#xA;filter:{&#xA;  packageJson:{&#xA;    dependencies:{&#xA;      elemMatch:{&#xA;        name:{&#xA;          eq:""chokidar""&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Great! That's what I need! So I try that, and I get:</p>&#xA;&#xA;<pre><code>error GraphQL Error Field ""elemMatch"" is not defined by type markdownRemarkConnectionFrontmatterTagsQueryList_2.&#xA;</code></pre>&#xA;&#xA;<p>Keywords defined in <a href=""https://github.com/fabien0102/gatsby-starter/blob/master/src/graphql-types.d.ts#L3602"" rel=""nofollow noreferrer"">markdownRemarkConnectionFrontmatterTagsQueryList_2</a> are:</p>&#xA;&#xA;<ul>&#xA;<li>eq: string | null;</li>&#xA;<li>ne: string | null;</li>&#xA;<li>regex: string | null;</li>&#xA;<li>glob: string | null;</li>&#xA;<li>in: Array | null;</li>&#xA;</ul>&#xA;&#xA;<p>Why am I limited to these keywords when more keywords such as <code>elemMatch</code> are mentioned in docs? Why am I not allowed to use the filter structure ""element in: { array }""?</p>&#xA;&#xA;<p>How can I create this filter?</p>&#xA;",4490400,,,,2019-01-29 07:05:54,GraphQL filters in GatsbyJS,<graphql><gatsby>,1,0,0,2019-01-29 05:31:08
54424224,1,,,1,1694,"<p>Is it possible in AWS appsync / amplify to combine filter operators, like: </p>&#xA;&#xA;<pre><code>const filterInput = {&#xA;        or:[&#xA;          {&#xA;          and: [&#xA;                  {createdById: { eq: userID }},&#xA;                  {chatWithId: { eq: chatWithUser.id }}&#xA;                ]&#xA;          },&#xA;          {&#xA;          and:  [&#xA;                  {createdById: { eq: chatWithUser.id }},&#xA;                  {chatWithId: { eq: userID }}&#xA;                ]&#xA;          }&#xA;        ]&#xA;      }&#xA;</code></pre>&#xA;&#xA;<p>Because for me this is not filtering / working as expected.</p>&#xA;",9491785,,,,2019-02-01 21:09:54,aws appsync combine filter operators,<amazon-web-services><graphql><aws-appsync><aws-amplify><amplifyjs>,1,4,0,2019-01-29 15:19:12
54427574,2,,54414649,1,,"<p>For same scenario i have implemented LRU cache in which I stored query as a key and response as value. </p>&#xA;&#xA;<pre><code>const LRU = require(""lru-cache"")&#xA;&#xA;const lruCache = new LRU({&#xA;    maxElements: 1000,&#xA;    length: (n, key) =&gt; {&#xA;        return n * 2 + key.length&#xA;    },&#xA;    dispose: function (key, n) {&#xA;        // n.close()&#xA;    },&#xA;    maxAge: 1000 * 60 * 60&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>To set value <code>lruCache.set(key, value)</code> and to get <code>const data = lruCache.get(key);</code></p>&#xA;&#xA;<p>""key"" is your request.</p>&#xA;&#xA;<p>There are other options also but this is most popular(thats what i believe)</p>&#xA;&#xA;<p>URL - <a href=""https://www.npmjs.com/package/lru-cache"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/lru-cache</a></p>&#xA;",10554174,,,,2019-01-29 18:36:09,"",,0,3,0,2019-01-29 18:36:09
54437547,2,,54425838,1,,"<p>Sorry I misread your example in my first reply. This is what you tried in the playground correct?</p>&#xA;&#xA;<pre><code>getAuditLogsForUser(&#xA;   before: ""2019-01-28T19:31:08.382Z"",&#xA;   after: ""2019-01-28T17:14:30.047Z""&#xA;  ){ &#xA;  id &#xA;  code { action }&#xA;  createdAt &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This will not work since before and after do not refer to time, but are cursors used for pagination. They expect an id. Since id's are also strings this query does not throw an error but will not find anything. Here is how pagination is used: <a href=""https://www.prisma.io/docs/prisma-graphql-api/reference/queries-qwe1/#pagination"" rel=""nofollow noreferrer"">https://www.prisma.io/docs/prisma-graphql-api/reference/queries-qwe1/#pagination</a></p>&#xA;&#xA;<p>What I think you want to do is use a filter in the query. For this you can use the where argument. The query would look like this:</p>&#xA;&#xA;<pre><code>getAuditLogsForUser(&#xA;      where:{AND:[&#xA;           {createdAt_lte: ""2019-01-28T19:31:08.382Z""},&#xA;           {createdAt_gte: ""2019-01-28T17:14:30.047Z""}&#xA;         ]}&#xA;   ) {&#xA;     id &#xA;     code { action } &#xA;     createdAt &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here are the docs for filtering: <a href=""https://www.prisma.io/docs/prisma-graphql-api/reference/queries-qwe1/#filtering"" rel=""nofollow noreferrer"">https://www.prisma.io/docs/prisma-graphql-api/reference/queries-qwe1/#filtering</a></p>&#xA;",9941706,,,,2019-01-30 09:46:09,"",,0,1,0,2019-01-30 09:46:09
54448994,1,,,1,569,"<p>Using graphql-go how do we handle nested objects as in given api returns the following in resolver</p>&#xA;&#xA;<p>{&#xA;id:""34"",&#xA;name:""something"",&#xA;region:{&#xA;    id:34,&#xA;    name: ""San jose""&#xA;   }&#xA;}</p>&#xA;&#xA;<p>how do we implement for region:&#xA;            ""region"": &amp;graphql.Field{&#xA;                Type: graphql.??,&#xA;            },</p>&#xA;",4629500,,,,2020-04-02 11:54:11,graphql-go define field type as object,<go><graphql><graphql-go>,1,1,0,2019-01-30 20:26:11
54457878,1,,,10,7640,"<p>I am doing my queries exactly as in the documentation (<a href=""https://aws-amplify.github.io/docs/js/api#amplify-graphql-client"" rel=""noreferrer"">https://aws-amplify.github.io/docs/js/api#amplify-graphql-client</a>) but I keep receiving the following error:</p>&#xA;&#xA;<pre><code>TypeError: Must provide Source. Received: undefined&#xA;</code></pre>&#xA;&#xA;<p>The query is as follows: </p>&#xA;&#xA;<pre><code>export const listUsers = `query ListUsers(&#xA;  $filter: ModelUserFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listUsers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      firstName&#xA;      prefix&#xA;      lastName&#xA;      phone&#xA;      cigarettesDay&#xA;      enableNotifications&#xA;      age&#xA;      coach {&#xA;        id&#xA;        name&#xA;      }&#xA;      stopDate {&#xA;        nextToken&#xA;      }&#xA;      notifications {&#xA;        nextToken&#xA;      }&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Using <code>API.graphql</code> I call the query as follows:</p>&#xA;&#xA;<pre><code>  async componentDidMount() {&#xA;    try {&#xA;      const result = await API.graphql(graphqlOperation(listUsers));&#xA;      console.log(result);&#xA;    } catch (err) {&#xA;      console.log(err);&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>According to this issue <a href=""https://github.com/graphql/graphql-js/issues/1038"" rel=""noreferrer"">https://github.com/graphql/graphql-js/issues/1038</a> I need to add a <code>source</code>, but I cannot find any example or documentation on how to do that. Any help is much appreciated!</p>&#xA;&#xA;<p><strong>Edit</strong></p>&#xA;&#xA;<p>It worked when I did it as follows:</p>&#xA;&#xA;<pre><code> async componentDidMount() {&#xA;   try {&#xA;     const result = await API.graphql(graphqlOperation(queries.listUsers));&#xA;     console.log(result);&#xA;   } catch (err) {&#xA;     console.log(err);&#xA;   }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>And imported it as <code>import * as queries from '../../../graphql/queries';</code></p>&#xA;&#xA;<p>Why?</p>&#xA;&#xA;<p><strong>Solution</strong></p>&#xA;&#xA;<p>It was because I imported the query as </p>&#xA;&#xA;<pre><code>import listUsers from '../../../graphql/queries';&#xA;</code></pre>&#xA;&#xA;<p>Instead of</p>&#xA;&#xA;<pre><code>import { listUsers } from '../../../graphql/queries';&#xA;</code></pre>&#xA;",9061403,,9061403,2019-01-31 13:58:09,2019-05-16 19:56:32,AWS Amplify Graphql - TypeError: Must provide Source. Received: undefined,<amazon-web-services><api><graphql><aws-amplify>,0,8,0,2019-01-31 09:57:12
54459167,2,,54453539,0,,<p>Hi the issue is in this line.</p>&#xA;&#xA;<pre><code>addBrand({ variables: { type: input.value } });&#xA;</code></pre>&#xA;&#xA;<p>Here you are passing the variable type where as the mutation needs description. Therefore changing to the following should solve your issue.</p>&#xA;&#xA;<pre><code>addBrand({ variables: { description: input.value } });&#xA;</code></pre>&#xA;&#xA;<p>Good luck and let me know how you get on.</p>&#xA;,942997,,,,2019-01-31 11:04:59,"",,0,2,0,2019-01-31 11:04:59
54462952,1,,,0,40,"<p>I am continuing to try and understand how to use GraphQL. I have a nice enough approach to returning by name, but would now like to only show results where an order made more than one purchase of an item. e.g. in the example below I would like to only return people that have more than one ""orderline""</p>&#xA;&#xA;<pre><code>query {&#xA;  persons(firstname: ""Andrew"")&#xA;  {&#xA;    firstname&#xA;    surname&#xA;    orders {&#xA;      id&#xA;      totalcost&#xA;      orderlines {&#xA;        quantity&#xA;        product {&#xA;          name&#xA;          description&#xA;          price&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Below is my current query</p>&#xA;&#xA;<pre><code>public class PersonQuery : ObjectGraphType&lt;Person&gt;&#xA;{&#xA;    public PersonQuery(ShoppingData data)&#xA;    {&#xA;        Field&lt;PersonType&gt;(&#xA;            name: ""person"",&#xA;            description: ""A Person"",&#xA;            arguments: new QueryArguments(&#xA;                new QueryArgument&lt;IdGraphType&gt;&#xA;                {&#xA;                    Name = ""id"",&#xA;                    Description = ""The id of the person""&#xA;                }),&#xA;            resolve: ctx =&gt;&#xA;            {&#xA;                 return data.GetById(ctx.GetArgument&lt;Guid&gt;(""id""));&#xA;            });&#xA;&#xA;        Field&lt;ListGraphType&lt;PersonType&gt;&gt;(&#xA;            name : ""persons"",&#xA;            description: ""Persons"",&#xA;            arguments: new QueryArguments(&#xA;                new QueryArgument&lt;StringGraphType&gt;&#xA;                {&#xA;                    Name = ""firstname"",&#xA;                    Description = ""The firstname of the person""&#xA;                },&#xA;                new QueryArgument&lt;StringGraphType&gt;&#xA;                {&#xA;                    Name = ""surname"",&#xA;                    Description = ""The surname of the person""&#xA;                }),&#xA;            resolve: ctx =&gt;&#xA;            {&#xA;                var firstName = ctx.GetArgument&lt;String&gt;(""firstname"");&#xA;                var surname = ctx.GetArgument&lt;String&gt;(""surname"");&#xA;                return data.Filter(firstName, surname);&#xA;            });&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<ol>&#xA;<li><p>So my question is how would I write a query to on only returning persons who have ordered more than item e.g. > 1 order lines.</p></li>&#xA;<li><p>How would I write a query to show all the people base on my filter, but then only show orders with more than 1 order line? e.g. so people who only made one order line would be shown, but their order would not be show below that? yet people with more than one order line would see them.</p></li>&#xA;</ol>&#xA;&#xA;<p>Many thanks</p>&#xA;",4027438,,13302,2019-12-07 21:09:30,2019-12-07 21:09:30,Graphql Filter on sub item,<c#><.net><graphql>,0,3,0,2019-01-31 14:39:03
54465752,1,,,0,415,"<p>How to do an authentication flow through a GraphQL API in a ngx-admin/Nebular app?</p>&#xA;&#xA;<p>I find the available <code>AuthStrategy</code> classes are limited and there's no straightforward way to change their behaviour. The closest is <code>NbPasswordAuthStrategy</code>, that does an HTTP request, but I haven't figured out how to use it with a GraphQL API.</p>&#xA;",5497859,,,,2019-02-07 13:02:40,Nebular (ngx-admin) authentication flow through a GraphQL API,<graphql><nebular><ngx-admin>,2,0,0,2019-01-31 17:04:40
54473828,1,54495972,,4,9616,"<p>So i have this query in graphql. But greater than(gt) and less than(lt) is not a defined field.</p>&#xA;&#xA;<pre><code>query Test {&#xA;  allStrapiEvent(filter:{date:{gt:""02/13/2019""}}){&#xA;    edges{&#xA;      node{&#xA;        name&#xA;        date(formatString:""MM/DD/YYYY"")&#xA;      }&#xA;    }&#xA;  } &#xA;}&#xA;</code></pre>&#xA;",4918717,,958529,2019-02-01 07:04:13,2019-02-04 03:03:22,How to query date range in gatsby graphql?,<graphql><gatsby>,1,0,0,2019-02-01 06:12:24
54495972,2,,54473828,5,,"<p>It looks like <code>date</code> is of <code>String</code> type, and therefore doesn't get the comparison operators (gt, lt, gte, lte); which is a shame, because this is really useful.</p>&#xA;&#xA;<p>I think as a workaround, you can add an additional field like <code>timestamp</code> and store the date in number (if not already provided by your CMS). Then you can use comparison operators on them.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>// moment.js comes with gatsby&#xA;const moment = require('moment');&#xA;&#xA;exports.onCreateNode = ({ node, actions }) =&gt; {&#xA;  const { createNodeField } = actions&#xA;&#xA;  // I'm guessing your type is StrapiEvent, but it could be st else&#xA;  if (node.internal.type === `StrapiEvent`) {&#xA;    const date = node.date;&#xA;&#xA;    createNodeField({&#xA;      name: 'timestamp',&#xA;      node,&#xA;      // convert date to unix timestamp &amp; convert to number&#xA;      value: +moment(date).format('X'),&#xA;    })&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then say you want to get events starting from yesterday. You can get the unix timestamp like <code>moment().subtract(1, 'day').format('X')</code> // 1549044285</p>&#xA;&#xA;<pre><code>query Test {&#xA;  allStrapiEvent(filter: {&#xA;    fields: {&#xA;      timestamp: {&#xA;        gt: 1549044285&#xA;      }&#xA;    }&#xA;  }) {&#xA;    edges{&#xA;      node{&#xA;        name&#xA;        date(formatString:""MM/DD/YYYY"")&#xA;      }&#xA;    }&#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Not ideal, but will work.</p>&#xA;",10340970,,10340970,2019-02-04 03:03:22,2019-02-04 03:03:22,"",,0,1,0,2019-02-02 18:09:42
54523768,2,,54522503,2,,"<p>This is a known Apollo issue and the team is working on it. The current options you have can be found <a href=""https://medium.com/@martinseanhunt/how-to-invalidate-cached-data-in-apollo-and-handle-updating-paginated-queries-379e4b9e4698"" rel=""nofollow noreferrer"">in this medium post</a>. </p>&#xA;&#xA;<p>It is also an issue with deleting/updating an item when you have it in a list with filters or pagination.</p>&#xA;&#xA;<p>Here is a reference of <a href=""https://github.com/apollographql/apollo-feature-requests/issues/4"" rel=""nofollow noreferrer"">an opened issue on Github about it</a></p>&#xA;",8331783,,,,2019-02-04 20:21:16,"",,0,0,0,2019-02-04 20:21:16
54542807,1,,,2,1423,"<p>I am trying to define my createRefetchContainer with fragment. However, I am getting an error about defaultValue of array of object type. I checked the documentation yet I couldn't figure out how to handle default value attribute for array of object type parameter.</p>&#xA;&#xA;<p>I tried to put empty array ""<strong>[]</strong>"" or ""<strong>[{ key: ""status"", value: ""active"" }]</strong>"" but none of them worked.</p>&#xA;&#xA;<pre><code>export default createRefetchContainer(&#xA;  translate('admin')(UserList),&#xA;  graphql`&#xA;    fragment UserList_usersWithPage on Query&#xA;      @argumentDefinitions(&#xA;        filters: { type: [UserFilterInput], defaultValue: [] }&#xA;        pageNumber: { type: Int, defaultValue: 0 }&#xA;        pageSize: { type: Int, defaultValue: 25 }&#xA;      ) {&#xA;      page: findUsersWithPage(filters: $filters, pageNumber: $pageNumber, pageSize: $pageSize) {&#xA;        totalPages&#xA;        totalElements&#xA;        users {&#xA;          ...MiniProfile_user @relay(mask: false)&#xA;        }&#xA;      }&#xA;    }&#xA;&#xA;    fragment UserList_filterFields on Query {&#xA;      accounts: findDistinctUserAccounts&#xA;      departments: findDistinctUserDepartments&#xA;      expertises: findDistinctUserExpertises&#xA;      ranks: findAllUserRankCodes&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    query UserListRefetchQuery($userFilterInput: [UserFilterInput], $pageNumber: Int, $pageSize: Int) {&#xA;      ...UserList_usersWithPage&#xA;        @arguments(userFilterInput: $userFilterInput, pageNumber: $pageNumber, pageSize: $pageSize)&#xA;    }&#xA;  `,&#xA;);&#xA;&#xA;&#xA;ERROR:&#xA;GraphQLParser: Expected definition for variable `filters` to be an object &#xA;with the following shape: `{type: string, defaultValue?: mixed, nonNull?: &#xA;boolean, list?: boolean}`, got `[object Object]`. Source: document &#xA;`UserList_usersWithPage` file: `scenes/admin/pages/UserList.js`. &#xA;</code></pre>&#xA;",6654419,,,,2020-12-15 15:30:15,GraphQL Relay defaultValue for array of object in fragment argument definitions,<graphql><relay>,1,1,0,2019-02-05 20:48:32
54543277,1,54608587,,2,1466,"<p>I've been learning GraphQL for a little while. I understood concept of simple queries and mutations. Now I'm trying to implement a Relay style cursor based pagination. I can create the results like  edges, totalCount, hasNextPage, hasPreviousPage etc. But I feel like I'm querying the database too much. I mean one ""find"" for edges, one for totalCount (countDocuments() in mongoose), and one for hasNextPage and hasPreviousPage each.</p>&#xA;&#xA;<p>I have a structure that if the client not asking for the totalCount, that query doesn't execute for example. Thanks to field resolvers.</p>&#xA;&#xA;<p>I've tried things like keeping the limit ""first + 1"", so if the client asks for 5 records and the query finds 6, then ""hasNextPage"" is true etc.</p>&#xA;&#xA;<p>But I'm still trying to find a solid example. I want to know the best practices but nearly all of the examples has <strong>mock data</strong>. No real database, just some object arrays. They just slice it and return.</p>&#xA;&#xA;<p>How can I find an example or learn the best practices. I've been reading Facebook's Paging Specification. I've even looked into source codes of mongoose relay pagination packages but they feel like a mess when you're trying to learn something.</p>&#xA;&#xA;<p>I'll be grateful for any good example.&#xA;Thanks</p>&#xA;",10876256,,10876256,2020-02-16 01:44:50,2020-02-16 01:44:50,GraphQL Cursor Based Pagination with Mongoose,<mongoose><graphql><apollo><relay><apollo-server>,1,0,0,2019-02-05 21:25:42
54608393,2,,51927420,2,,"<p>I came across the same question / problem, and came to the same conclusion as @Dan Crews. The cursor must contain everything you need to execute the database query, except for <code>LIMIT</code>.</p>&#xA;<p>When your initial query is something like</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>SELECT *&#xA;FROM DataTable&#xA;WHERE filterField = 42&#xA;ORDER BY sortingField,ASC&#xA;LIMIT 10&#xA;-- with implicit OFFSET 0&#xA;</code></pre>&#xA;<p>then you could basically <em>(<strong>don't</strong> do this in a real app, because of SQL Injections!)</em> use exactly this query as your cursor. You just have to remove <code>LIMIT x</code> and append <code>OFFSET y</code> for every node.</p>&#xA;<p>Response:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  edges: [&#xA;    {&#xA;      cursor: &quot;SELECT ... WHERE ... ORDER BY ... OFFSET 0&quot;,&#xA;      node: { ... }&#xA;    },&#xA;    {&#xA;      cursor: &quot;SELECT ... WHERE ... ORDER BY ... OFFSET 1&quot;,&#xA;      node: { ... }&#xA;    },&#xA;    ...,&#xA;    {&#xA;      cursor: &quot;SELECT ... WHERE ... ORDER BY ... OFFSET 9&quot;,&#xA;      node: { ... }&#xA;    }&#xA;  ]&#xA;  pageInfo: {&#xA;    startCursor: &quot;SELECT ... WHERE ... ORDER BY ... OFFSET 0&quot;&#xA;    endCursor: &quot;SELECT ... WHERE ... ORDER BY ... OFFSET 9&quot;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The next request will then use <code>after: CURSOR, first: 10</code>. Then you'll take the <code>after</code> argument and set the <code>LIMIT</code> and <code>OFFSET</code>:</p>&#xA;<ul>&#xA;<li><code>LIMIT = first</code></li>&#xA;<li><code>OFFSET = OFFSET + 1</code></li>&#xA;</ul>&#xA;<p>Then the resulting database query would be this when using <code>after = endCursor</code>:</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>SELECT *&#xA;FROM DataTable&#xA;WHERE filterField = 42&#xA;ORDER BY sortingField,ASC&#xA;LIMIT 10&#xA;OFFSET 10&#xA;</code></pre>&#xA;<hr />&#xA;<p>As already mentioned above: <strong>This is only an example, and it's highly vulnerable to SQL Injections!</strong></p>&#xA;<hr />&#xA;<p>In a real world app, you could simply encode the provided <code>filter</code> and <code>orderBy</code> arguments within the cursor, and add <code>offset</code> as well:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>function handleGraphQLRequest(first, after, filter, orderBy) {&#xA;  let offset = 0; // initial offset, if after isn't provided&#xA;&#xA;  if(after != null) {&#xA;    // combination of after + filter/orderBy is not allowed!&#xA;    if(filter != null || orderBy != null) {&#xA;      throw new Error(&quot;You can't combine after with filter and/or orderBy&quot;);&#xA;    }&#xA;&#xA;    // parse filter, orderBy, offset from after cursor&#xA;    cursorData = fromBase64String(after);&#xA;    filter = cursorData.filter;&#xA;    orderBy = cursorData.orderBy;&#xA;    offset = cursorData.offset;&#xA;  }&#xA;&#xA;  const databaseResult = executeDatabaseQuery(&#xA;    filter,  // = WHERE ...&#xA;    orderBy, // = ORDER BY ...&#xA;    first,   // = LIMIT ...&#xA;    offset   // = OFFSET ...&#xA;  );&#xA;&#xA;  const edges = []; // this is the resulting edges array&#xA;  let currentOffset = offset; // this is used to calc the offset for each node&#xA;  for(let node of databaseResult.nodes) { // iterate over the database results&#xA;    currentOffset++;&#xA;    const currentCursor = createCursorForNode(filter, orderBy, currentOffset);&#xA;    edges.push({&#xA;      cursor = currentCursor,&#xA;      node = node&#xA;    });&#xA;  }&#xA;&#xA;  return {&#xA;    edges: edges,&#xA;    pageInfo: buildPageInfo(edges, totalCount, offset) // instead of&#xA;        // of providing totalCount, you could also fetch (limit+1) from&#xA;        // database to check if there is a next page available&#xA;  }&#xA;}&#xA;&#xA;// this function returns the cursor string&#xA;function createCursorForNode(filter, orderBy, offset) {&#xA;  return toBase64String({&#xA;    filter: filter,&#xA;    orderBy: orderBy,&#xA;    offset: offset&#xA;  });&#xA;}&#xA;&#xA;// function to build pageInfo object&#xA;function buildPageInfo(edges, totalCount, offset) {&#xA;  return {&#xA;    startCursor: edges.length ? edges[0].cursor : null,&#xA;    endCursor: edges.length ? edges[edges.length - 1].cursor : null,&#xA;    hasPreviousPage: offset &gt; 0 &amp;&amp; totalCount &gt; 0,&#xA;    hasNextPage: offset + edges.length &lt; totalCount&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The content of <code>cursor</code> depends mainly on your database and you database layout.</p>&#xA;<p>The code above emulates a simple pagination with limit and offset. But you could (if supported by your database) of course use something else.</p>&#xA;",1321564,,1480391,2022-01-24 23:52:44,2022-01-24 23:52:44,"",,0,0,0,2019-02-09 16:50:03
54614430,2,,54574000,1,,"<p>You can safely use either method of passing variables to the mutation.</p>&#xA;&#xA;<p>Most of the time I would use the variables prop to set the variables since this is pretty clear and neat.</p>&#xA;&#xA;<p>An instance where you might want to use the other method is when calling the mutation method from a child component - where the variables are also contained in that child component. </p>&#xA;&#xA;<p>To follow on from the example code you gave above: Imagine an array of components on a ToDo list where each has an input but calls a single mutation (located in the parent component). It would be easier to call the mutation from inside each child components eg: </p>&#xA;&#xA;<p><code>updateToDoItem({variables: {id: this.props.id, text: this.state.text}})</code></p>&#xA;",2804256,,,,2019-02-10 07:48:18,"",,0,0,0,2019-02-10 07:48:18
54616553,2,,54616114,4,,"<p>Fundamentally, you want your Snackbar to be a sibling of your Mutation, and let their common parent (i.e. your component) handle the Snackbar open/closed state.</p>&#xA;&#xA;<p>Class-style component</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>class FormWithMutationAndSnackbar extends React.Component {&#xA;  state = {&#xA;    open: false&#xA;  }&#xA;&#xA;  handleOpen = () =&gt; this.setState({ open: true })&#xA;&#xA;  handleClose = () =&gt; this.setState({ open: false })&#xA;&#xA;  render() {&#xA;    const { open } = this.state&#xA;    return(&#xA;      &lt;React.Fragment&gt;&#xA;        &lt;Mutation&#xA;          mutation={this.mutationQuery}&#xA;          onError={(err) =&gt; {&#xA;            // use err to set Snackbar contents for example&#xA;            this.handleOpen()&#xA;          }&#xA;          onCompleted={data =&gt; { console.log(data); }}&#xA;        &gt;&#xA;          {mutation =&gt; (&#xA;            //here is the form&#xA;          )}&#xA;        &lt;/Mutation&gt;&#xA;        &lt;Snackbar&#xA;          open={open}&#xA;          onClose={this.handleClose}&#xA;          // other Snackbar props&#xA;        &gt;&#xA;          // Snackbar contents&#xA;        &lt;/Snackbar&gt;&#xA;      &lt;/React.Fragment&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Functional component with Hooks</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const FormWithMutationAndSnackbar = () =&gt; {&#xA;  const [open, setOpen] = useState(false)&#xA;&#xA;  return(&#xA;    &lt;React.Fragment&gt;&#xA;      &lt;Mutation&#xA;        mutation={this.mutationQuery}&#xA;        onError={(err) =&gt; {&#xA;          // use err to set Snackbar contents for example&#xA;          setOpen(true)&#xA;        }&#xA;        onCompleted={data =&gt; { console.log(data); }}&#xA;      &gt;&#xA;        {mutation =&gt; (&#xA;          //here is the form&#xA;        )}&#xA;      &lt;/Mutation&gt;&#xA;      &lt;Snackbar&#xA;        open={open}&#xA;        onClose={() =&gt; setOpen(false)}&#xA;        // other Snackbar props&#xA;      &gt;&#xA;        // Snackbar contents       &#xA;      &lt;/Snackbar&gt;&#xA;    &lt;/React.Fragment&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;",5438616,,5438616,2019-02-10 16:48:16,2019-02-10 16:48:16,"",,0,1,0,2019-02-10 12:48:24
54639497,1,,,1,45,"<p>I want to be able to add parameters to subqueries, but I can't figure out how to get it to work.</p>&#xA;&#xA;<p>I'm trying to write a schema with a viewer object which contains the queries I have so that I can return edges/nodes. I think I'm missing something fundamental about resolvers but, after a lot of googling, I still don't get it.</p>&#xA;&#xA;<p>My schema looks like this (just the relevant bits):</p>&#xA;&#xA;<pre><code>type Query {&#xA;    viewer: Viewer!&#xA;}&#xA;&#xA;type Viewer {&#xA;  allLinks(skip: Int, first: Int, last: Int, orderBy: &#xA;    LinkOrderByInput): LinkConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>LinkConnection is how you would expect, it has an edges attribute which is a list of nodes etc.</p>&#xA;&#xA;<p>I'm using Prisma, and the resolvers look like this:</p>&#xA;&#xA;<pre><code>const allLinks = async (parent, args, context, info) =&gt; {&#xA;  const links = await context.prisma.linksConnection({&#xA;    first: args.first,&#xA;    orderBy: args.orderBy,&#xA;  })&#xA;  const count = await context.prisma&#xA;    .linksConnection()&#xA;    .aggregate()&#xA;    .count()&#xA;  return {&#xA;    pageInfo: links.pageInfo,&#xA;    edges: links.edges,&#xA;    count,&#xA;  }&#xA;}&#xA;&#xA;export const viewer = async (parent, args, context, info) =&gt; {&#xA;  const links = await allLinks(parent, args, context, info)&#xA;  return { allLinks: links }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then if I do this query: </p>&#xA;&#xA;<pre><code>query {&#xA;  viewer {&#xA;    allLinks(first: 1, orderBy:createdAt_DESC) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;        }&#xA;      }&#xA;      count&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then it runs without actually errorring, but it returns all of the links rather than just one, and I've played around with console.logging and it seems like the first and orderBy parameters aren't actually doing anything.</p>&#xA;&#xA;<p>Can anyone help explain how I can structure my resolvers so that the arguments actually do something? It seems like this should be obvious!</p>&#xA;",10548774,,,,2019-02-11 21:34:02,How to access variables passed to child queries,<graphql>,0,0,0,2019-02-11 21:34:02
54682450,2,,51228270,0,,"<p>You can't change the data type after the index field is created.   I used this code in kabana to declare the data type as ""geo_point"".  Then uploaded an item with the geopoint field and it worked.  </p>&#xA;&#xA;<p><a href=""https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html"" rel=""nofollow noreferrer"">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html</a>&#xA;<a href=""https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-distance-query.html"" rel=""nofollow noreferrer"">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-distance-query.html</a>&#xA;<a href=""https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-point.html"" rel=""nofollow noreferrer"">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-point.html</a></p>&#xA;&#xA;<pre><code> POST yourProjectName/_mappings/yourProjectType&#xA;{&#xA;  ""properties"":{&#xA;    ""geopoint or whatever field you're storing the geo data"": {&#xA;      ""type"": ""geo_point""&#xA;      } &#xA;    }&#xA;  }&#xA;}&#xA;&#xA;POST _search&#xA;{&#xA;  ""query"": {&#xA;    ""bool"" : {&#xA;      ""must"" : {&#xA;        ""match"":{&#xA;          ""summary"": ""something""&#xA;        }&#xA;      },&#xA;      ""filter"" : {&#xA;          ""geo_distance"" : {&#xA;              ""distance"" : ""12km"",&#xA;              ""geopoint"" : ""40.054447974637476,-82.92002800852062""&#xA;&#xA;          }&#xA;      }&#xA;  }&#xA;}&#xA;}&#xA;</code></pre>&#xA;",8917223,,8917223,2019-05-24 02:30:32,2019-05-24 02:30:32,"",,0,0,0,2019-02-14 02:41:09
54685743,2,,54685611,-1,,"<p>First error I see is that you can not set the state directly as <code>this.state.sortItem = e.target.innerHTML</code>Instead you have to use <code>this.setState({ sortItem: e.targetinnerHTML })</code></p>&#xA;&#xA;<p>Y por favor, intenta no usar Spanglish xD es una mala práctica.</p>&#xA;",9027629,,9027629,2019-02-14 08:51:51,2019-02-14 08:51:51,"",,0,4,0,2019-02-14 08:09:48
54782808,1,54782809,,4,2308,"<p>How can you filter by dates in Gatsby? The docs allude to <code>lt</code> and <code>gt</code> operators, I get errors when I try to use them.</p>&#xA;",702072,,,,2019-02-20 09:23:02,Filtering by dates in Gatsby and Contentful,<graphql><gatsby><contentful>,1,0,0,2019-02-20 09:23:02
54782809,2,,54782808,6,,"<p>Filtering by date in Gatsby is potentially tricky. Many API's send dates in JSON as strings - in the ISO8601 format. That means that GraphQL will treat the dates as strings too. This is fine if you are happy filtering on string equality, but that's not usually how you want to filter on dates. </p>&#xA;&#xA;<p>A common use case is to filter to dates that are in the past or future. In most situations, we would do some kind of <code>less than</code> or <code>more than</code> comparison with todays date. Unfortunately, this won't work for dates strings in GraphQL. The <code>lt</code> and <code>gt</code> operators only apply to <em>numbers</em> and won't work for strings.</p>&#xA;&#xA;<p>Fortunately, there is an escape hatch - <code>setFieldsOnGraphQLNodeType</code>. This allows us to take a content node, and add our own fields with derived data in. We can take a datestring, and parse it to a timestamp - a number. With the date as a timestamp, graphql can do its thing and allow <code>lt</code> and <code>gt</code> filters.</p>&#xA;&#xA;<p>Lets say we are writing a blog, and what to filter posts that are published in the past. We can add a <code>publishedAt</code> datetime field in our ContentModel, which will help our content authors publish things in the future. We can filter out the future posts until we transform <code>publishedAt</code> from a date string into a number. </p>&#xA;&#xA;<p>Here's how that looks:</p>&#xA;&#xA;<pre><code>exports.setFieldsOnGraphQLNodeType = ({ type }) =&gt; {&#xA;  if (type.name === `ContentfulBlogPost`) {&#xA;    return {&#xA;      publishAtTimestamp: {&#xA;        type: GraphQLFloat,&#xA;        resolve: source =&gt; {&#xA;          return new Date(source.publishAt).getTime(); &#xA;        }&#xA;     }&#xA;   };&#xA;  }&#xA;&#xA;  // by default return empty object&#xA;  return {};&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>ContentfulBlogPost 's now have a new field <code>publishedAtTimestamp</code> which is a number, that means you can now filter on it with <code>lt</code> or <code>gt</code></p>&#xA;&#xA;<pre><code>  query {&#xA;    allContentfulBlogPost(&#xA;      filter: { publishedAtTimestamp: { lt: $SOME_TIMESTAMP } }&#xA;    ) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          ...otherFields&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",702072,,,,2019-02-20 09:23:02,"",,0,1,0,2019-02-20 09:23:02
54800600,2,,54800422,0,,"<p>No. You cannot query <code>data.items</code> without specifying atleast one subfield of items. If you want to share that type across multiple queries, you can define it as a fragment and share that fragment across multiple queries to avoid duplication of type.</p>&#xA;&#xA;<p>For example you can create and reuse a fragment as follows</p>&#xA;&#xA;<pre><code>const itemFragment = gql`&#xA;  fragment item on items {&#xA;    a: String&#xA;    b: String&#xA;  }&#xA;`&#xA;&#xA;export const data = gql`&#xA;  query data {&#xA;    data {&#xA;      ...itemFragment&#xA;    }&#xA;  }&#xA;  ${itemFragment}&#xA;`;&#xA;</code></pre>&#xA;",2041906,,,,2019-02-21 06:27:06,"",,0,0,0,2019-02-21 06:27:06
54806515,1,54808655,,0,3271,"<h1>Requirement:</h1>&#xA;&#xA;<p>I need recommendation in writing resolver function for handling graphql filters. The filter supports eq, ne, like, contains and not like operators. </p>&#xA;&#xA;<h2>Schema:</h2>&#xA;&#xA;<pre><code>import { gql } from 'apollo-server-express';&#xA;&#xA;export default gql`&#xA;   extend type Query {&#xA;       authGroups(filter: AuthGroupFilterInput): AuthGroupConnection!&#xA;    }&#xA;&#xA;    type AuthGroup implements Node {&#xA;       id: ID!&#xA;       name: String&#xA;    }&#xA;&#xA;    input AuthGroupFilterInput {&#xA;       name: StringFilterInput&#xA;    }&#xA;&#xA;    type AuthGroupConnection {&#xA;       edges: [AuthGroup!]!&#xA;       pageInfo: PageInfo&#xA;    }&#xA;&#xA;    input StringFilterInput {&#xA;      lt: String,&#xA;      gt: String,&#xA;      eq: String,&#xA;      ne: String,&#xA;      contains: String,&#xA;      like: String,&#xA;      notLike: String,&#xA;    }  &#xA;&#xA;`;&#xA;</code></pre>&#xA;&#xA;<h2>GraphQL Query:</h2>&#xA;&#xA;<pre><code> Query {&#xA;    authGroups(filter: {  &#xA;          name: {&#xA;             like: '%AD'&#xA;          }&#xA;       }&#xA;      )&#xA;    {&#xA;       edges {&#xA;         id&#xA;         name&#xA;       }&#xA;    }&#xA; }&#xA;</code></pre>&#xA;&#xA;<h2>Resolvers:</h2>&#xA;&#xA;<pre><code>authGroups: async (parent, args, { models }) =&gt; {&#xA;        const filter = args.filter;&#xA;        const filters = filter &#xA;                        ? {&#xA;                            where: filter,&#xA;                        } &#xA;                        : {};&#xA;&#xA;        const authGroups = await models.authGroup.findAll({&#xA;           ...filters&#xA;        //    where : {&#xA;        //        name: {&#xA;        //            [Sequelize.Op.like] : 'AD%'&#xA;        //        }&#xA;        //    }&#xA;        });  &#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>Technologies Used:</h2>&#xA;&#xA;<ul>&#xA;<li>Apollo Server</li>&#xA;<li>express</li>&#xA;<li>Sequelize</li>&#xA;<li>PostgreSQL</li>&#xA;</ul>&#xA;&#xA;<p>How to replace the operators in filter with [Sequelize.Op.operator]? I tried using operatorsAliases in config.json but it didn't have any effect. Your help is much appreciated.</p>&#xA;",6559242,,,,2019-02-21 21:42:54,How to write resolve graphql filters in apollo graphql server,<sequelize.js><graphql><apollo-server>,2,0,0,2019-02-21 11:56:43
54915412,1,,,6,392,"<p>My application looks something like what's included in the snippets below.</p>&#xA;&#xA;<p>(I've left out a lot of the implementation details in the hopes that the code below is sufficient to get my question across). </p>&#xA;&#xA;<p><strong>SampleApp.js</strong></p>&#xA;&#xA;<pre><code>const SampleAppQuery = graphql`&#xA;  list SampleAppQuery {&#xA;    ...ItemComponent_item&#xA;  }&#xA;`&#xA;&#xA;function SampleApp() {&#xA;  return (&#xA;    &lt;QueryRenderer&#xA;      environment={environment}&#xA;      query={SampleAppQuery}&#xA;      render={(error, props) =&gt; {&#xA;        if (props) {&#xA;          return &lt;AppRefetchContainer list={props} /&gt;&#xA;        }&#xA;      }}&#xA;    /&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>AppRefetchContainer.js</strong></p>&#xA;&#xA;<pre><code>class AppRefetchContainer extends Component {&#xA;  render() {&#xA;    &lt;div&gt;&#xA;      &lt;HeaderComponent refetchList={this._refetchList} /&gt;&#xA;      {list.map(item =&gt; &lt;ItemComponent item={item} /&gt;)}&#xA;    &lt;/div&gt;&#xA;  }&#xA;&#xA;  _refetchList(params) {&#xA;    this.props.relay.refetch(params)&#xA;  }&#xA;}&#xA;&#xA;export default createRefetchContainer(&#xA;  AppRefetchContainer,&#xA;  graphql`&#xA;    fragment AppRefetchContainer_list on Item {&#xA;      ...ItemComponent_item&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    query AppRefetchContainerQuery($sortBy: String!)&#xA;    list SampleAppQuery(sortBy: $sortBy) {&#xA;      ...ItemComponent_item&#xA;    }&#xA;  `&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>The initial application load is just fine. Clicking on one of the headers should trigger a refetch so that the list data can be sorted on the passed inparams. When I trigger a refetch, the server responds with the correct data, <em>however</em>, the component does not rerender.</p>&#xA;&#xA;<p>I suspect that my issue is with the way I've defined the fragments here. The console error I get on initial page load is:</p>&#xA;&#xA;<pre><code>RelayModernSelector: Expected object to contain data for fragment&#xA;`AppRefetchContainer_list`, got `{""list"":[{""__fragments"":&#xA;{""ItemComponent_item"":{}},""__id"":""[some_valid_id]"",""__fragmentOwner"":null},{...&#xA;</code></pre>&#xA;&#xA;<p>Question(s):</p>&#xA;&#xA;<ol>&#xA;<li><p>I'm not entirely sure how to interpret that error. Is it the reason why I'm unable to rerender the UI?</p></li>&#xA;<li><p>I know this approach may not be ideal, but how do I <code>refetch</code> from a component that isn't necessarily a fragment of the query?</p></li>&#xA;</ol>&#xA;&#xA;<p>Happy to provide any clarification or missing context :)</p>&#xA;",4111393,,4111393,2019-02-27 23:40:30,2019-02-27 23:40:30,"Refetch container refetches, but does not update the view",<reactjs><graphql><relay><relaymodern>,0,0,0,2019-02-27 22:19:52
54936088,2,,54918291,0,,"<p>As of 1st of March 2019 it is not possible to dynamically create the graphql queries. The solution for this problem is to have a ""dummy"" page with all your content layouts and ignoring it in your graphql query. Although you are ignoring it, your graphql schema will contain all the layout structures.</p>&#xA;&#xA;<pre><code>allWordpress(Page|Post)(filter:{slug:{ne:""dummy-page""}}) {&#xA;    edges {&#xA;        node {&#xA;            ...&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",3584674,,,,2019-02-28 23:58:41,"",,0,0,0,2019-02-28 23:58:41
54937238,1,54937674,,0,464,"<p>I am having issue with react.js with apollo to query graphql endpoint. Here is the code that having issue. </p>&#xA;&#xA;<pre><code>class ChecklistSummaryTime extends Component {&#xA;constructor(props) {&#xA;    super(props);&#xA;    this.state = {&#xA;       data: [],&#xA;       sitePath: window.location.pathname&#xA;    }&#xA; }&#xA;&#xA; render() {&#xA;     return(&#xA;        &lt;ApolloProvider client={getGraphqlClient()}&gt;&#xA;            &lt;Query query={gql`&#xA;                {&#xA;                    all_checklist_time (checklist_type: ""backup"", order_by: ""check_year check_month"", &#xA;                            sort_order: ""desc desc"", group_by: ""check_month check_year"") {&#xA;                            quarter,&#xA;                            month,&#xA;                            year&#xA;                    }&#xA;                }&#xA;            `}&gt;&#xA;            {({ loading, error, data }) =&gt; {&#xA;                if (loading) return ""Loading..."";&#xA;                if (error) return `Error! ${error.message}`;&#xA;                console.log(data);&#xA;                return data;&#xA;            }}&#xA;            &lt;/Query&gt;&#xA;        &lt;/ApolloProvider&gt;&#xA;     );&#xA; }}&#xA;</code></pre>&#xA;&#xA;<p>It has error of ""Error: Objects are not valid as a React child (found: object with keys {all_checklist_time}). If you meant to render a collection of children, use an array instead.""</p>&#xA;&#xA;<p>Please help me out to figure out what is wrong with the gql portion? </p>&#xA;&#xA;<p>Thanks</p>&#xA;",5438688,,,,2019-03-01 03:49:12,react.js with apollo to query graphql - Error: Objects are not valid as a React child,<javascript><reactjs><graphql>,1,0,0,2019-03-01 02:45:08
54947174,1,,,0,639,"<p>I'm building a new <code>createRefetchContainer()</code> off a working implementation in the same project, but getting this error on running <code>yarn relay</code>:</p>&#xA;&#xA;<pre><code>ERROR:&#xA;GraphQLParser: Unknown field `usersByName` on type `Viewer`. &#xA;Source: document `AutocompleteUsersContainer_UsersRefetchQuery` file:&#xA; `client/components/Autocomplete/Users/AutocompleteUsersContainer.js`.&#xA;</code></pre>&#xA;&#xA;<p>The erroring relay function:</p>&#xA;&#xA;<pre><code>export default createRefetchContainer(&#xA;  AutocompleteUsers,&#xA;  graphql`&#xA;    fragment AutocompleteUsersContainer_viewer on Viewer&#xA;      @argumentDefinitions(name: { type: ""String"", defaultValue: """" }) {&#xA;      usersByName(name: $name)&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    query AutocompleteUsersContainer_UsersRefetchQuery(&#xA;      $name: String!&#xA;    ) {&#xA;      viewer {&#xA;        usersByName(name: $name){&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>The working implementation:</p>&#xA;&#xA;<pre><code>export default createRefetchContainer(&#xA;  AutocompleteLocations,&#xA;  graphql`&#xA;    fragment AutocompleteLocationsContainer_viewer on Viewer&#xA;      @argumentDefinitions(searchValue: { type: ""String"", defaultValue: """" }) {&#xA;      locations(searchValue: $searchValue)&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    query AutocompleteLocationsContainer_LocationsRefetchQuery(&#xA;      $searchValue: String!&#xA;    ) {&#xA;      viewer {&#xA;        locations(searchValue: $searchValue)&#xA;      }&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>The <code>usersByName</code> query below returns results directly in graphql, which is why I'm not sure why <code>relay</code> says <code>Unknown field 'usersByname'</code>:</p>&#xA;&#xA;<pre><code>query getViewer{&#xA;  viewer {&#xA;    usersByName(&#xA;      name: ""Test Name""&#xA;    ) {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",665082,,,,2019-03-01 16:06:28,GraphQL parser returns unknown field error for known field,<reactjs><graphql><relayjs>,1,2,0,2019-03-01 14:59:38
54947891,1,54948666,,4,1242,"<p>I'm playing around with GraphQL, and I've run across the concept of connections and edges.</p>&#xA;&#xA;<p>From what I understand it's not uncommon to see metadata on the connection, like the <code>totalCount</code> property in the following snippet.</p>&#xA;&#xA;<pre><code>type UserFriendsConnection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [UserFriendsEdge]&#xA;  totalCount: Int&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My questions is whether it's OK to put arbitrary metadata on the edge also, and if the following would be a decent way to do that.</p>&#xA;&#xA;<p>I felt like a query and a response would best illustrate what I'm looking for. It's the <code>role</code> property I want to place somewhere that makes sense.</p>&#xA;&#xA;<p>I feel like it doesn't belong in the <code>User</code> type since the role describes the type of connection/relationship the <code>User</code> has with a <code>Group</code>.</p>&#xA;&#xA;<pre><code># Query&#xA;&#xA;{&#xA;  me {&#xA;    id&#xA;    name&#xA;    groupsConnection {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          name&#xA;          membersConnection {&#xA;            edges {&#xA;                node {&#xA;                id&#xA;                name&#xA;              }&#xA;              role                             &lt;--- HERE&#xA;            }&#xA;          }&#xA;        }&#xA;        role                                   &lt;--- HERE&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code># Response&#xA;&#xA;{&#xA;  ""data"": {&#xA;    ""me"": {&#xA;      ""id"": ""1Edj3hZFg"",&#xA;      ""name"": ""John Doe"",&#xA;      ""groupsConnection"": {&#xA;        ""edges"": [&#xA;          {&#xA;            ""node"": {&#xA;              ""id"": ""bpQgdZweQE"",&#xA;              ""name"": ""Fishing Team"",&#xA;              ""membersConnection"": {&#xA;                ""edges"": [&#xA;                  {&#xA;                    ""node"": {&#xA;                      ""id"": ""1Edj3hZFg"",&#xA;                      ""name"": ""John Doe""&#xA;                    },&#xA;                    ""role"": ""ADMINISTRATOR""    &lt;--- HERE&#xA;                  },&#xA;                  {&#xA;                    ""node"": {&#xA;                      ""id"": ""7dj37dH2d"",&#xA;                      ""name"": ""Rebecca Anderson""&#xA;                    },&#xA;                    ""role"": ""MEMBER""           &lt;--- HERE&#xA;                  }&#xA;                ]&#xA;              }&#xA;            },&#xA;            ""role"": ""ADMINISTRATOR""            &lt;--- HERE&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1331179,,,,2019-03-01 16:28:23,Can I add data to a GraphQL edge?,<graphql>,1,0,0,2019-03-01 15:40:41
54948666,2,,54947891,7,,"<p>Connections are part of the <a href=""https://facebook.github.io/relay/docs/en/graphql-server-specification.html"" rel=""noreferrer"">Relay specification</a>. Relay itself is a GraphQL client, although you can have a Relay-compliant GraphQL server without actually using Relay on the front end. According to the spec:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Edge types must have fields named node and cursor. They may have additional fields related to the edge, as the schema designer sees fit.</p>&#xA;</blockquote>&#xA;&#xA;<p>It's common enough to see additional fields on these types and it certainly makes sense. One word of caution though. If we have a <code>User</code> type, we may create a <code>UserConnection</code> and a <code>UserEdge</code>:</p>&#xA;&#xA;<pre><code>type UserConnection {&#xA;  pageInfo: PageInfo!&#xA;  egdes: [UserEdge!]!&#xA;}&#xA;&#xA;type UserEdge {&#xA;  cursor: String!&#xA;  edge: User!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>We can then use that connection type in all sorts of places...</p>&#xA;&#xA;<pre><code>type Query {&#xA;  allUsers: UserConnection!&#xA;  # other fields&#xA;}&#xA;&#xA;type Group {&#xA;  members: UserConnection!&#xA;  # other fields&#xA;}&#xA;&#xA;type User {&#xA;  coworkers: UserConnection!&#xA;  # other fields&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, if you add a field like <code>role</code> to <code>UserEdge</code>, that field will only make sense in the context of the <code>members</code> field on the <code>Group</code> type. It would have to return null or some dummy value in all other contexts, which can introduce unnecessary confusion.</p>&#xA;&#xA;<p>That means, if you're going to introduce extra fields on your edge type that are relationship-dependent, you should probably create connection and edge types that are specific to that relationship:</p>&#xA;&#xA;<pre><code>type GroupUserConnection {&#xA;  pageInfo: PageInfo!&#xA;  egdes: [GroupUserEdge!]!&#xA;}&#xA;&#xA;type GroupUserEdge {&#xA;  cursor: String!&#xA;  edge: User!&#xA;  role: Role!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This way, you can still use a regular <code>UserConnection</code> for other fields and avoid clients unnecessarily requesting a <code>role</code> where there isn't one.</p>&#xA;",6024220,,,,2019-03-01 16:28:23,"",,0,1,0,2019-03-01 16:28:23
54975949,2,,51530499,0,,"<p>As promised, here's my hacky workaround</p>&#xA;&#xA;<pre><code>class ParentComponent extends React.Component {&#xA;  componentDidUpdate(prevProps) {&#xA;    if (this.props.refetchId !== prevProps.refetchId) {&#xA;      const otherData = this.processData() // do something&#xA;      this.setState({otherData})&#xA;      if (this.refetch) {&#xA;        this.refetch()&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  render() {&#xA;    const { otherData } = this.state&#xA;    const setRefetch = refetch =&gt; {this.refetch = refetch}&#xA;    return (&#xA;      &lt;Query query={MY_QUERY}&gt;&#xA;        {({ data, refetch }) =&gt; {&#xA;          setRefetch(refetch)&#xA;          return &lt;ChildComponent gqlData={data} stateData={otherData} /&gt;&#xA;        }}&#xA;      &lt;/Query&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",68672,,,,2019-03-04 02:42:20,"",,0,0,0,2019-03-04 02:42:20
54984035,1,54988767,,14,5431,<p>I have written a GraphQL query which like the one below:</p>&#xA;&#xA;<pre><code>{&#xA;  posts {&#xA;    author {&#xA;      comments&#xA;    }&#xA;    comments&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to know how can I get the details about the requested child fields inside the <code>posts</code> resolver.</p>&#xA;&#xA;<p>I want to do it to avoid nested calls of resolvers. I am using ApolloServer's <code>DataSource</code> API.</p>&#xA;&#xA;<p>I can change the API server to get all the data at once.</p>&#xA;&#xA;<p>I am using ApolloServer 2.0 and any other ways of avoiding nested calls are also welcome.</p>&#xA;,1745409,,6024220,2019-10-08 02:01:42,2019-10-08 02:01:42,How to know which fields were requested in a GraphQL query?,<graphql><apollo><apollo-server><resolver>,2,1,0,2019-03-04 13:11:46
54994334,1,55181462,,1,184,"<p>I presently have a page with a dynamically created form. I am having trouble understanding how to manipulate the state and GraphQL query to handle nested queries.</p>&#xA;&#xA;<p>With my present implementation it does not seem to be able to create any new entries. I want to create 1 ""target"" with several sub ""addr"" tied to it in one mutation.</p>&#xA;&#xA;<p>This is the state definitions:</p>&#xA;&#xA;<pre><code>state = {&#xA;    name:'',&#xA;    addr:[{&#xA;    mobilepkg:'',&#xA;    target_url:'',  &#xA;    target_ip: '',&#xA;    idCars:[]&#xA;    }],&#xA;    category:'',&#xA;    date: '',&#xA;    location:''&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Handler for Graph:</p>&#xA;&#xA;<pre><code>   handleTarget = async e =&gt; {&#xA;        e.preventDefault()&#xA;        const { name,&#xA;        target_url,&#xA;        target_ip,category,&#xA;        mobilepkg,date,location } = this.state&#xA;        let idCars = this.state.idCars&#xA;        let adras = this.state.addr&#xA;        await this.props.createTargetMutation({&#xA;          variables: {&#xA;            data: {&#xA;&#xA;          name,&#xA;        addr:{&#xA;        create:&#xA;        [{&#xA;          target_url,&#xA;          target_ip,&#xA;          mobilepkg,&#xA;         cars: {&#xA;                connect: idCars&#xA;              },&#xA;&#xA;        }]&#xA;        },&#xA;        date,&#xA;        location,&#xA;&#xA;              category&#xA;            }&#xA;          }&#xA;        })&#xA;&#xA;        this.props.history.replace('/targets')&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>My create mutation</p>&#xA;&#xA;<pre><code>const CREATE_DRAFT_MUTATION = gql`&#xA; mutation CreateTargetMutation($data: TargetCreateInput!) {&#xA;    createTarget(data: $data) {&#xA;    id&#xA;    name&#xA;    addr&#xA;    category&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>GraphQL datamodel</p>&#xA;&#xA;<pre><code> type Target {&#xA;      id: ID! @unique&#xA;      name: String!&#xA;      addr: [Addr!]! &#xA;&#xA;      category: String!&#xA;      date:String!&#xA;      location:String!&#xA;    }&#xA;&#xA;    type Addr {&#xA;      id: ID! @unique&#xA;      target_url:String!&#xA;      target_ip:String!&#xA;      mobilepkg:String!&#xA;      cars: [Car!]!&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>How do I put my ReactJS state which has a nested array into GraphQL?&#xA;PS:I am new to GraphQL and ReactJS.</p>&#xA;&#xA;<p>EDIT: In playground im able to create my items but its not working in my actual application.</p>&#xA;&#xA;<pre><code>mutation CreateTargetMutation($data: TargetCreateInput!) {&#xA;    createTarget(data: $data) {&#xA;    id&#xA;    name&#xA;    addr{&#xA;        target_ip&#xA;        target_url&#xA;        mobilepkg&#xA;    cars{&#xA;     id&#xA;    }&#xA;    }&#xA;    category&#xA;    date&#xA;    location&#xA;    }&#xA;  }&#xA;&#xA;{&#xA;  ""data"": {&#xA;    ""name"":""testerquery"",&#xA;    ""addr"":  {&#xA;      ""create"": {&#xA;      ""target_ip"":""123"",&#xA;        ""target_url"":""123"",&#xA;        ""mobilepkg"":""asd"",&#xA;    ""cars"":{""connect"":{""id"":""cjs3yd83u004a0781jffzaqqr""}}&#xA;    }&#xA;    },&#xA;    ""category"":""simple"",&#xA;    ""date"":""2019-03-12"",&#xA;    ""location"":""kl""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",11151265,,11151265,2019-03-11 02:45:27,2019-03-15 11:19:45,Put Nested ReactJS values into GraphQL create mutation,<javascript><reactjs><graphql>,1,0,0,2019-03-05 01:55:17
54999206,1,55150080,,0,1585,"<p>I have the need to query all incomplete projects, wherein upon completion a project will be given a status change (<code>Completed</code>) plus a boolean <code>isComplete==true</code>.</p>&#xA;&#xA;<p>I'm working through AWS Appsync to test the queries before I hard-code them into my app, but this one doesn't seem to be effective. I want all projects where <code>isComplete==false</code> or <code>isComplete==null</code>: boolean logic doesn't work with the <code>input1</code> variable below (0 results). </p>&#xA;&#xA;<pre><code>{""__typename"":{""S"":""Project""},""addressLine1"":{""S"":""321 Faith Cir""},""city"":{""S"":""Perris""},""createdAt"":{""S"":""2019-03-05T01:01:39.513Z""},""currentOwner"":{""S"":""pgres52""},""dateRequired"":{""S"":""2019-03-13-07:00""},""id"":{""S"":""89a5-42ef7efef8fb""},""status"":{""S"":""Created""},""statusLastChangedAt"":{""S"":""2019-03-05T01:01:39.513Z""}}&#xA;&#xA;{&#xA;  ""input1"":{&#xA;    ""isComplete"": {&#xA;      ""ne"": true&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;query listNonCompleteProjects($input1: ModelProjectFilterInput) {&#xA;  listProjects(filter: $input1, limit: 20) {&#xA;    items {&#xA;      id&#xA;      currentOwner&#xA;      addressLine1&#xA;      city&#xA;      dateRequired&#xA;      isComplete&#xA;      statusLastChangedAt&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}```&#xA;</code></pre>&#xA;",11025422,,,,2019-03-13 19:44:40,graphql appsync query with boolean filter,<amazon-web-services><amazon-dynamodb><graphql><aws-appsync>,1,2,0,2019-03-05 09:14:51
55018327,2,,53060987,0,,"<p>I made a super cool extension method that returns whether the selection is included in a GraphQL query. &#xA;Include the navigation property to your query if it exists in the selections.</p>&#xA;&#xA;<hr>&#xA;&#xA;<h2>Extension Method</h2>&#xA;&#xA;<pre class=""lang-cs prettyprint-override""><code>using System;&#xA;using System.Linq;&#xA;using GraphQL.Language.AST;&#xA;using GraphQL.Types;    &#xA;&#xA;public static class ContextExtensions&#xA;{&#xA;    /// &lt;summary&gt;&#xA;    /// Returns true if the given fieldSelector exists in the selection of the query.&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;param name=""context""&gt;The working context&lt;/param&gt;&#xA;    /// &lt;param name=""fieldSelector""&gt;The query of the field selector. For example items:organizationUnits:displayName&lt;/param&gt;&#xA;    /// &lt;param name=""namespaceSeperator""&gt;The seperator character of the fieldSelector. Default is :&lt;/param&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    public static bool HasSelectionField(this ResolveFieldContext&lt;object&gt; context, string fieldSelector, char namespaceSeperator = ':')&#xA;    {&#xA;        if (string.IsNullOrWhiteSpace(fieldSelector))&#xA;        {&#xA;            return false;&#xA;        }&#xA;&#xA;        if (context.SubFields == null)&#xA;        {&#xA;            return false;&#xA;        }&#xA;&#xA;        var fragments = fieldSelector.Split(new[] { namespaceSeperator }, StringSplitOptions.RemoveEmptyEntries);&#xA;&#xA;        if (fragments.Length == 1)&#xA;        {&#xA;            return context.SubFields.ContainsKey(fragments[0]);&#xA;        }&#xA;&#xA;        if (context.SubFields[fragments[0]] == null)&#xA;        {&#xA;            return false;&#xA;        }&#xA;&#xA;        if (context.SubFields[fragments[0]].SelectionSet == null)&#xA;        {&#xA;            return false;&#xA;        }&#xA;&#xA;        if (context.SubFields[fragments[0]].SelectionSet.Selections == null)&#xA;        {&#xA;            return false;&#xA;        }&#xA;&#xA;&#xA;        var selections = context.SubFields[fragments[0]].SelectionSet.Selections;&#xA;&#xA;        for (var i = 1; i &lt; fragments.Length; i++)&#xA;        {&#xA;            if (selections == null)&#xA;            {&#xA;                return false;&#xA;            }&#xA;&#xA;            var field = selections.Select(selection =&gt; (Field)selection).FirstOrDefault(f =&gt; f.Name == fragments[i]);&#xA;            if (field == null)&#xA;            {&#xA;                return false;&#xA;            }&#xA;&#xA;            if (i == fragments.Length - 1)&#xA;            {&#xA;                return true;&#xA;            }&#xA;&#xA;            selections = field.SelectionSet?.Selections;&#xA;        }&#xA;&#xA;        return true;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<h2>Usage</h2>&#xA;&#xA;<pre class=""lang-cs prettyprint-override""><code>protected override async Task&lt;PagedResultDto&lt;UserDto&gt;&gt; Resolve(ResolveFieldContext&lt;object&gt; context)&#xA;{&#xA;    var total_count_exists = context.HasSelectionField(""totalCount""); //true&#xA;    var items_name_exists = context.HasSelectionField(""items:name""); //true&#xA;    var items_roles_name_exists = context.HasSelectionField(""items:roles:name""); //true&#xA;    var items_organizationUnits_displayName_exists = context.HasSelectionField(""items:organizationUnits:displayName""); //true&#xA;    var items_organizationUnits_xyz_exists = context.HasSelectionField(""items:organizationUnits:xyz""); //false&#xA;}&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<h2>Sample Query</h2>&#xA;&#xA;<pre><code>query MyQuery {&#xA;  users(id: 1) {&#xA;    totalCount&#xA;    items {&#xA;      name&#xA;      surname&#xA;&#xA;      roles {&#xA;        id&#xA;        name&#xA;        displayName&#xA;      }&#xA;&#xA;      organizationUnits {&#xA;        id&#xA;        code&#xA;        displayName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1767482,,1767482,2019-03-06 08:41:25,2019-03-06 08:41:25,"",,0,0,0,2019-03-06 08:09:55
55052455,2,,55046370,8,,"<p><a href=""https://www.gatsbyjs.org/docs/actions/#createNode"" rel=""noreferrer""><code>children</code></a> is used <a href=""https://github.com/gatsbyjs/gatsby/blob/1eb1c39bff0edbf043491fd5da0a785c70c88ef2/packages/gatsby-transformer-json/src/gatsby-node.js#L22"" rel=""noreferrer"">internally</a> for creating hierarchy between <code>Node</code>s.</p>&#xA;&#xA;<p>Just rename <code>children</code> to something else and it will be fine:</p>&#xA;&#xA;<pre><code>{&#xA;    ""name"": ""first"",&#xA;    ""age"": 34,&#xA;    ""test"": ""test1"",&#xA;    ""foos"": [&#xA;      {&#xA;        ""id"": 1,&#xA;        ""child"": ""child1""&#xA;      },&#xA;      {&#xA;        ""id"": 2,&#xA;        ""child"": ""child2""&#xA;      }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now run the corresponding query:</p>&#xA;&#xA;<pre><code>{&#xA;  testJson {&#xA;    name,&#xA;    foos {&#xA;      id,&#xA;      child&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The result will be as expected:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""testJson"": {&#xA;      ""name"": ""first"",&#xA;      ""foos"": [&#xA;        {&#xA;          ""id"": 1,&#xA;          ""child"": ""child1""&#xA;        },&#xA;        {&#xA;          ""id"": 2,&#xA;          ""child"": ""child2""&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4135289,,4135289,2019-03-07 21:16:08,2019-03-07 21:16:08,"",,0,1,0,2019-03-07 20:40:02
55072013,1,,,0,50,"<p>principal</p>&#xA;&#xA;<pre><code>interface Community {&#xA;  uuid: String&#xA;  name: String&#xA;  tagline: String&#xA;  desc: String&#xA;  location: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>his children</p>&#xA;&#xA;<pre><code>type CommunityWithOwnerUser implements Community {&#xA;  uuid: String&#xA;  name: String&#xA;  tagline: String&#xA;  desc: String&#xA;  location: String&#xA;  //....owner details&#xA;  ownerUuid:String&#xA;  ownerName:String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>other child</p>&#xA;&#xA;<pre><code>type CommunityWithAnyMember implements Community {&#xA;  uuid: String&#xA;  name: String&#xA;  tagline: String&#xA;  desc: String&#xA;  location: String&#xA;  //....member details&#xA;  memberUuid:String&#xA;  memberName:String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I know that these types are unreasonable.it is example</p>&#xA;&#xA;<p>my question</p>&#xA;&#xA;<p>I've rewritten the details of the <code>Community</code> type in all type definitions. instead it would be great if I could use something like <code>extend</code></p>&#xA;&#xA;<pre><code>type CommunityWithAnyMember extend Community {&#xA;  memberUuid:String&#xA;  memberName:String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>its output</p>&#xA;&#xA;<pre><code>type CommunityWithAnyMember {&#xA;  uuid: String&#xA;  name: String&#xA;  tagline: String&#xA;  desc: String&#xA;  location: String&#xA;  memberUuid:String&#xA;  memberName:String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've been doing research for a long time.&#xA;I found <a href=""https://github.com/Sydsvenskan/node-graphql-partials"" rel=""nofollow noreferrer"">https://github.com/Sydsvenskan/node-graphql-partials</a> but it didn't help.Thank you for your answer</p>&#xA;",10039122,,9325419,2019-03-09 08:06:45,2019-03-09 08:06:45,I dont want to redefine properties when defining a GraphQL type. Is there a way to get past it?,<graphql><react-apollo>,0,3,0,2019-03-08 22:43:24
55089046,1,55089302,,2,1365,"<p>I am learning Relay library for GraphQL in React app.&#xA;I did everything as in official docs.&#xA;My <code>/project/resources/js/schema.graphql</code> has:</p>&#xA;&#xA;<pre><code>type usersPagination {&#xA;  """"""List of items on the current page""""""&#xA;  data: [Users]&#xA;&#xA;  """"""Number of total items selected by the query""""""&#xA;  total: Int!&#xA;&#xA;  """"""Number of items returned per page""""""&#xA;  per_page: Int!&#xA;&#xA;  """"""Current page of the cursor""""""&#xA;  current_page: Int!&#xA;&#xA;  """"""Number of the first item returned""""""&#xA;  from: Int&#xA;&#xA;  """"""Number of the last item returned""""""&#xA;  to: Int&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In my React <code>/project/resources/js/components/main/Table.js</code> I try to make query:</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;    environment={environment}&#xA;    query={graphql`&#xA;        query usersPaginationQuery {&#xA;            data {&#xA;                Users&#xA;            }&#xA;        }&#xA;    `}&#xA;    render={({error, props}) =&gt; {&#xA;        if(error) {&#xA;            return &lt;div&gt;Error!&lt;/div&gt;&#xA;        }&#xA;        if(!props) {&#xA;            return &lt;div&gt;Loading...&lt;/div&gt;&#xA;        }&#xA;&#xA;        return &lt;div&gt;User: {props.users.data.id}&lt;/div&gt;;&#xA;    }}&#xA;/&gt;&#xA;</code></pre>&#xA;&#xA;<p>Then I run <code>npm run relay</code> to compile it but it throws me an error:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Parse error: Error: RelayFindGraphQLTags: Operation names in graphql&#xA;  tags must be prefixed with the module name and end in ""Mutation"",&#xA;  ""Query"", or ""Subscription"". Got <code>usersPaginationQuery</code> in module&#xA;  <code>Table</code>. in ""components/main/Table.js""</p>&#xA;</blockquote>&#xA;&#xA;<p>For me it's nonsense, bcz my query name is exact as <code>module name + ""Query""</code> keyword.&#xA;Thanks for any help.</p>&#xA;",10712836,,10712836,2019-03-10 15:19:34,2019-03-11 10:08:15,What's Relay operation name?,<javascript><reactjs><graphql><relayjs><relay>,2,2,0,2019-03-10 15:06:24
55104266,2,,55103347,4,,"<p>Okay, so for anyone as stupid as me, here's basically what I was doing wrong:</p>&#xA;&#xA;<ul>&#xA;<li>Instead of <code>addPlayer</code> in <code>update: (store, { data: { addPlayer } })</code>, it should be whatever the name of the mutation is, so in this case <code>insert_players</code>.</li>&#xA;<li>By default a mutation response from Hasura has a <code>returning</code> field, which is a list, and so the added player is the first element in the list, so you can get it like so: <code>const addedPlayer = insert_players.returning[0];</code></li>&#xA;</ul>&#xA;&#xA;<p>I didn't want to just delete my question after realising what was wrong shortly after posting it, in case this is useful to other people like me, and so I'll leave it up. </p>&#xA;",4255859,,,,2019-03-11 14:36:41,"",,0,0,0,2019-03-11 14:36:41
55133140,2,,55081682,3,,"<p>OK, i am gonna answer another one of my questions in case anyone lands here equally as upsidedown as i was when i asked it...  I simply didn't realize what some of the behind the scenes magic was doing therefore i was using this wrong... And i find the docs confusing</p>&#xA;&#xA;<p>In my example above... my ProductRealBenefits in the reference was a one to many relationship represented in my schema with realbenefits: [ProductRealBenefits]... Therefore i needed the following components.</p>&#xA;&#xA;<pre><code>&lt;ReferenceArrayInput label=""Real Benefit Tags"" source=""realbenefitsIds"" reference=""ProductRealBenefit""&gt;&#xA;    &lt;CheckboxGroupInput  optionValue=""id"" optionText=""name"" allowEmpty /&gt;&#xA;&lt;/ReferenceArrayInput&gt;&#xA;</code></pre>&#xA;&#xA;<p>There is a little magic in the ra_data_graphql_simple dataProvider that creates an item for you in state called realbenefitsIds, which is what you use as the source for the ReferenceArrayInput, i was trying to use the actual realbenefits array object, and that was not gonna work.  I could not find any good examples out there or any decent explanations on how to get this to work... So ultimately it was Redux Dev Tools that saved my bacon here.  I had to jump through some hoops in the graph server to get all this working with the dataprovider sending back diff things for GET_MANY and GET_REFERENCE_MANY filter values, but that was just a matter of parsing the filter args to match what sequelize was expecting.  I'll end up writing a dataProvider eventually but this fit the bill for now..</p>&#xA;&#xA;<p>PS.. i was seeing some strange behaviour in my CheckboxGroupInput, when i clicked something it duplicated whatever box was clicked... The reason for that was an error in object type in my schema... There was an <strong>Int</strong> mixed in with <strong>ID</strong>, and luckily that showed up in Redux Dev Tools and led me to the problem.</p>&#xA;&#xA;<p>Lastly.. I'm putting together a sample project in Github that will use React-Admin, GraphQL, RA_DATA_GRAPHQL_SIMPLE, Sequelize, and a Postgres Database and i will comment it alot to take some of the confusion out of it for anyone like myself... Cheers!!  </p>&#xA;",9876522,,,,2019-03-13 01:43:23,"",,0,2,0,2019-03-13 01:43:23
55150080,2,,54999206,1,,"<p>Solved! Partially helped with this post: <a href=""https://www.prisma.io/forum/t/how-do-i-filter-items-with-certain-fields-being-null/553/7"" rel=""nofollow noreferrer"">Prisma.io: How do I filter items with certain fields being null?</a></p>&#xA;&#xA;<p>I was able to get it to work with an additional parameter <code>status</code> (string):</p>&#xA;&#xA;<pre><code>query listNonCompleteProjects($input1: ModelProjectFilterInput) {&#xA;  listProjects(filter: $input1, limit: 20) {&#xA;    items {&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;  ""input1"":{&#xA;    ""and"": [&#xA;      {""status"": {""notContains"": ""Complete""}},&#xA;      {""isComplete"": {&#xA;        ""ne"": true&#xA;      }}&#xA;    ]&#xA;  },&#xA;</code></pre>&#xA;",11025422,,,,2019-03-13 19:44:40,"",,0,0,0,2019-03-13 19:44:40
55163011,2,,55143573,2,,"<p>You need an ID to retrieve an item with any get query. getPatient(id:""YOUR ID HERE""){}`</p>&#xA;&#xA;<p>Something like...</p>&#xA;&#xA;<pre><code>query Get_Patient_By_Id{&#xA;  getPatient(id:""2dbcb870-e302-4ed5-a419-68751597129c""){&#xA;     id        &#xA;     name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For React, you'll add in the id to the variables list argument:</p>&#xA;&#xA;<pre><code>const getPatient = await API.graphql(&#xA;  graphqlOperation(&#xA;    queries.getPatient, &#xA;    {id: ""2dbcb870-e302-4ed5-a419-68751597129c""}&#xA;  )&#xA;);&#xA;console.log(getPatient.data.getPatient);&#xA;</code></pre>&#xA;&#xA;<p>docs: <a href=""https://aws-amplify.github.io/docs/js/api#simple-query"" rel=""nofollow noreferrer"">https://aws-amplify.github.io/docs/js/api#simple-query</a></p>&#xA;",3979495,,3979495,2019-03-14 16:36:37,2019-03-14 16:36:37,"",,0,0,0,2019-03-14 12:50:09
55165772,1,,,2,4120,"<p>I've recently started learning how to use python and i'm having some trouble with a graphQL api call. </p>&#xA;&#xA;<p>I'm trying to set up a loop to grab all the information using pagination, and my first request is working just fine.</p>&#xA;&#xA;<pre><code>values = """"""&#xA;      {""query"" : ""{organizations(ids:) {pipes {id name phases {id name cards_count cards(first:30){pageInfo{endCursor hasNextPage} edges {node {id title current_phase{name} assignees {name} due_date createdAt finished_at fields{name value filled_at updated_at} } } } } }}}""}&#xA;    """"""&#xA;</code></pre>&#xA;&#xA;<p>but the second call using the end cursor as a variable isn't working for me. I assume that it's because i'm not understanding how to properly escape the string of the variable. But for the life of me I'm unable to understand how it should be done.</p>&#xA;&#xA;<p>Here's what I've got for it so far...</p>&#xA;&#xA;<pre><code>values = """"""&#xA;      {""query"" : ""{phase(id: """""" + phaseID+ """""" ){id name cards_count cards(first:30, after:""""""\"" + pointer + ""\""""""){pageInfo{endCursor hasNextPage} edges {node {id title assignees {name} due_date createdAt finished_at fields{name value datetime_value updated_at phase_field { id label }  } } } } } }""}&#xA;        """""" &#xA;</code></pre>&#xA;&#xA;<p>the second one as it loops just returns a 400 bad request.</p>&#xA;&#xA;<p>Any help would be greatly appreciated.</p>&#xA;",7594159,,482717,2021-05-27 10:09:49,2021-05-27 10:09:49,Python GraphQL API call composition,<python><graphql>,2,0,0,2019-03-14 15:00:28
55174835,1,,,1,125,"<p>I recently started grokking Relay Modern. I understand that QueryRenderer is used to fetch data using GraphQL query, your root component will have query renderer and all the child components define the data they need in terms of GraphQL fragments.&#xA;But is having just one QueryRenderer a good way to go ahead, wouldn't it be difficult pass the query and fragment parameters way upto the root?&#xA;If we are having multiple QueryRenderer we are not really making use of Relay caching mechanism as each QueryRenderer creates it's own store tree.</p>&#xA;&#xA;<p>Any thoughts or best practices on how to use QueryRenderer is much appreciated.</p>&#xA;",7152046,,,,2019-03-15 02:46:11,Best way to use QueryRenderer in Relay Modern,<graphql><relay><relaymodern>,0,0,0,2019-03-15 02:46:11
55181462,2,,54994334,0,,"<p>Bro, you are one the right path. You just need to iterate your values in order to solve this problem. Once you iterate through the values you simply  need to make a call to the new array which contains everything and it will work. As your values are nested you will need to add  ""{}"" to your car variable and within that contain your connect since you wish to create new ""addr"" whilst connecting to existing ""car"".</p>&#xA;&#xA;<pre><code> let create = []&#xA;        for(let i=0; i &lt; this.state.addr.length; i++){&#xA;                create.push({&#xA;                    'mobilepkg':this.state.addr[i].mobilepkg,&#xA;                    'target_url':this.state.addr[i].target_url,&#xA;                    'target_ip':this.state.addr[i].target_ip,&#xA;                    'cars': {&#xA;                    'connect':  this.state.addr[i].cars}&#xA;                })&#xA;    }&#xA;&#xA;      await this.props.createTargetMutation({&#xA;          variables: {&#xA;            data: {&#xA;         name,&#xA;         addr:  {&#xA;        create&#xA;        },&#xA;        category,&#xA;        date,&#xA;        location&#xA;            }&#xA;          }&#xA;        })&#xA;        this.props.history.replace('/targets')&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Your values should now successfully pass into GraphQL and create targets with many ""addr"" whilst connecting to many ""car""</p>&#xA;",9850717,,,,2019-03-15 11:19:45,"",,0,0,0,2019-03-15 11:19:45
55211609,1,,,7,547,"<p>Is it possible to return data for a query in apollo that is based on a filter for a nested field? For example: </p>&#xA;&#xA;<p>Query:</p>&#xA;&#xA;<pre><code>Users($filter: String!) {&#xA;  user(filter: $filter) { &#xA;    id, &#xA;    name, &#xA;    address(filter: $filter) { &#xA;       street, &#xA;       city, &#xA;       country&#xA;    } &#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>TypeDefs:</p>&#xA;&#xA;<pre><code>Query: {&#xA;   users(filter: String): [User]!&#xA;}&#xA;&#xA;User: {&#xA;    id: ID!,&#xA;    name: String!,&#xA;    address: Address&#xA;}&#xA;&#xA;Address: {&#xA;    street: String!,&#xA;    city: String!,&#xA;    country: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Apollo resolvers: </p>&#xA;&#xA;<pre><code>const resolverMap = {&#xA;  Query: {&#xA;    User(obj, args, context, info) {&#xA;      // query api for User info (not including address)&#xA;      // the final results of the query should only return users with the &#xA;      // specific address (for example if the filter is country: England, only &#xA;      // return users that live in England.&#xA;    },&#xA;  },&#xA;  Address: {&#xA;    address: (obj, args, context, info) {&#xA;      // query another api for address based on parent (User) Id&#xA;    },&#xA;  },&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Using that query, I only want results returned for users that reside in a specific country, say England.  Since this filter is for a nested type [address], would it be possible using this query and not having to query address's first?</p>&#xA;",6183605,,6183605,2019-03-18 01:52:32,2022-04-14 02:38:04,Returning data from apollo-server based on a filter for a nested field,<reactjs><graphql><apollo><apollo-server>,1,4,0,2019-03-17 20:30:23
55238174,2,,46244375,-1,,"<p>graphene relay you can use if you want objects by ID. In this case ID will be relay node ID, which you can change as per your ID need.</p>&#xA;&#xA;<p>You can get a godd example in below link:</p>&#xA;&#xA;<p><a href=""https://github.com/alexisrolland/flask-graphene-sqlalchemy"" rel=""nofollow noreferrer"">https://github.com/alexisrolland/flask-graphene-sqlalchemy</a> </p>&#xA;",6873191,,,,2019-03-19 09:58:55,"",,0,1,0,2019-03-19 09:58:55
55259184,1,,,2,2031,"<p>I use Hasura and a PostGres DB. Here is the GraphQL mutation</p>&#xA;&#xA;<pre><code>mutation submitBeacon($thing_uid: Int, $x: Int, $y: Int, $z: Int){&#xA;            insert_conf_thing(objects:&#xA;              [{thing_uid: $thing_uid, my_coordinates: {type: ""Point"", coordinates: [$x, $y, $z]}}]) {&#xA;            returning {&#xA;              thing_uid&#xA;              my_coordinates&#xA;            }   } }&#xA;</code></pre>&#xA;&#xA;<p>Query variables</p>&#xA;&#xA;<pre><code>{&#xA;  ""thing_uid"": 1744,&#xA;  ""x"": 2,&#xA;  ""y"": 3,&#xA;  ""z"": 4&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And here is the query response</p>&#xA;&#xA;<pre><code>{&#xA;  ""errors"": [&#xA;    {&#xA;      ""extensions"": {&#xA;        ""path"": ""$.selectionSet.insert_conf_thing.args.objects[0].my_coordinates"",&#xA;        ""code"": ""validation-failed""&#xA;      },&#xA;      ""message"": ""variables are not allowed in scalars""&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Postgres DB types :&#xA;<strong>thing_uid</strong> is a BigInt&#xA;<strong>my_coordinates</strong> is a <a href=""https://www.postgresql.org/docs/9.4/datatype-geometric.html"" rel=""nofollow noreferrer"">Geometric type</a></p>&#xA;&#xA;<p>If I replace the variables $x, $y and $z by 1, 2 and 3 in the query, everything works fine.</p>&#xA;&#xA;<p>Why the query returns an error when I'm using parameters ?</p>&#xA;",2313688,,2313688,2019-03-20 13:44:55,2019-03-22 16:42:18,graphQL mutation with parameters gives error : validation failed variables are not allowed in scalars,<postgresql><graphql><graphiql><hasura>,1,2,0,2019-03-20 11:00:59
55278750,1,,,0,262,"<p>I have a relay subscription setup in which I am getting the data in the updater which looks like this <a href=""https://gist.github.com/ydvsailendar/6b9569bbcbc269246e299eb5cce18a80#file-gistfile1-txt-L10"" rel=""nofollow noreferrer"">https://gist.github.com/ydvsailendar/6b9569bbcbc269246e299eb5cce18a80#file-gistfile1-txt-L10</a></p>&#xA;&#xA;<p>I want to update my connection for a query so that I can get the updated messages via the query when the subscription gets new messages.</p>&#xA;&#xA;<p>here is my subscription:</p>&#xA;&#xA;<pre><code>import { ConnectionHandler } from 'relay-runtime';&#xA;import {&#xA;    graphql,&#xA;    requestSubscription&#xA;} from 'react-relay'&#xA;import environment from '../network';&#xA;&#xA;const subscription = graphql`&#xA;    subscription chatWithSubscription($id: String){&#xA;        chatWith(id: $id){&#xA;            textMessage&#xA;            id&#xA;            chatId&#xA;            date&#xA;            userType&#xA;            translatedMessage&#xA;        }&#xA;    }&#xA;`;&#xA;&#xA;function chatWith(id) {&#xA;    const variables = { id: id };&#xA;    requestSubscription(environment, {&#xA;        subscription,&#xA;        variables,&#xA;        onError: (error) =&gt; {&#xA;            console.log(error, ""error"");&#xA;        },&#xA;        updater: (store) =&gt; {&#xA;            console.log(store, ""store""); &#xA;        }&#xA;    });&#xA;}&#xA;&#xA;module.exports = chatWith;&#xA;</code></pre>&#xA;&#xA;<p>and here is my query which i want to update via the updater:</p>&#xA;&#xA;<pre><code>module.exports = createPaginationContainer(&#xA;  ChatMessages,&#xA;  graphql`&#xA;    fragment ChatMessages_query on Query&#xA;      @argumentDefinitions(&#xA;        count: { type: ""Int"", defaultValue: 10 }&#xA;        cursor: { type: ""String"" }&#xA;        chatId: { type: ""ID"" }&#xA;      ) {&#xA;      messages(&#xA;        first: $count&#xA;        after: $cursor&#xA;        chatId: $chatId&#xA;      ) @connection(key: ""ChatMessages_messages"") {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            chatId&#xA;            userType&#xA;            date&#xA;            textMessage&#xA;            translatedMessage&#xA;          }&#xA;          cursor&#xA;        }&#xA;        totalCount&#xA;        pageInfo {&#xA;          endCursor&#xA;          hasNextPage&#xA;        }&#xA;      }&#xA;    }&#xA;  `,&#xA;  {&#xA;    direction: ""forward"" | ""backward"",&#xA;    getConnectionFromProps(props) {&#xA;      return props.query &amp;&amp; props.query.messages;&#xA;    },&#xA;    // This is also the default implementation of `getFragmentVariables` if it isn't provided.&#xA;    getFragmentVariables(prevVars, totalCount) {&#xA;      return {&#xA;        ...prevVars,&#xA;        count: totalCount&#xA;      };&#xA;    },&#xA;    getVariables(props, { count, cursor }, fragmentVariables) {&#xA;      return {&#xA;        count,&#xA;        cursor,&#xA;        chatId: fragmentVariables.chatId&#xA;      };&#xA;    },&#xA;    query: graphql`&#xA;      query ChatMessagesPaginationQuery(&#xA;        $count: Int!&#xA;        $cursor: String&#xA;        $chatId: ID!&#xA;      ) {&#xA;        ...ChatMessages_query&#xA;          @arguments(&#xA;            count: $count&#xA;            cursor: $cursor&#xA;            chatId: $chatId&#xA;          )&#xA;      }&#xA;    `&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>I am new to using updater via subscription and the docs were really confusing i couldn't understand the viewers' prop and other mentioned in the docs. please help me with the implementation.</p>&#xA;",10206624,,10160112,2019-03-21 11:00:32,2019-03-21 11:00:32,update connection using relay subscription updater,<react-native><relay><relaymodern><react-relay><graphql-relay>,0,3,0,2019-03-21 10:50:26
55283254,1,,,2,273,"<p>I'm trying to sort the content of my YAML file by date with GraphQL. I'm publishing the notifications through Netlify CMS and using React(Gatsby) as a front end. The notifications are being written to the notifications.yml file but I can't get them sorted by date; latest first. I'm rendering the contents out fine to the site but I can't find a way to sort them by date.</p>&#xA;&#xA;<p>I have tried using ""sort: { field: date, order: DESC }"" in the GraphQL query but I get the error: </p>&#xA;&#xA;<blockquote>&#xA;  <p>Unknown argument ""sort"" on field ""file"" of type ""Query"". Did you mean ""root""?  graphql/template-strings</p>&#xA;</blockquote>&#xA;&#xA;<p>Here's my notifications.yml:</p>&#xA;&#xA;<pre><code>notifications:&#xA;  - date: '2019-03-16'&#xA;    message: 'First notification'&#xA;    title: 'One'&#xA;  - date: '2019-03-17'&#xA;    message: 'Second notification'&#xA;    title: 'Two'&#xA;  - date: 2019-03-20'&#xA;    message: 'Third notification'&#xA;    title: 'Three'&#xA;</code></pre>&#xA;&#xA;<p>GraphQL query:</p>&#xA;&#xA;<pre><code>query={graphql`&#xA;  query NotificationQuery {&#xA;    notifications: file(&#xA;      relativePath: { regex: ""/notifications/"" }&#xA;    ) {&#xA;      childDataYaml {&#xA;        notifications {&#xA;          date(formatString: ""MMMM D, YYYY"")&#xA;          message&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Could you guys please help me out?</p>&#xA;",3775810,,13302,2019-03-21 20:00:34,2019-03-21 20:00:34,Sort YAML file content by date with GraphQL?,<reactjs><yaml><graphql><gatsby><netlify-cms>,0,1,0,2019-03-21 14:52:45
55297505,1,55432328,,0,38,"<p>We are using graphql and relay, and recompose. </p>&#xA;&#xA;<p>I am getting some data from a <code>Unit</code>, but I also need some data from its <code>Project</code>.(A unit belongs to a project)</p>&#xA;&#xA;<p>And I have figured out how to, get some images i need from the project like so: </p>&#xA;&#xA;<pre><code>project {&#xA;  images {&#xA;    fileKey&#xA;    aspectRatio&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>but i get many images.. like 20.. and i just need the first one.. How do i tell relay or graphQl to give me just one?</p>&#xA;&#xA;<p>Thanks, here is my whole fragment:</p>&#xA;&#xA;<pre><code>const enhance = compose(&#xA;  fragment(graphql`&#xA;      fragment DetailsSectionContainer_unit on Unit {&#xA;        tourIdArchilogic&#xA;        tourIdMatterport&#xA;        images {&#xA;          fileKey&#xA;          aspectRatio&#xA;        }&#xA;        ...TitleRowContainer_unit&#xA;        ...UnitSummaryContainer_unit&#xA;        ...ContactFormColumnContainer_unit&#xA;        project {&#xA;          images {&#xA;            fileKey&#xA;            aspectRatio&#xA;          }&#xA;          ...ContactFormColumnContainer_project&#xA;        }&#xA;        company {&#xA;          ...ContactFormColumnContainer_company&#xA;        }&#xA;        ...TourContainer_unit&#xA;      }&#xA;      fragment DetailsSectionContainer_rentedUnit on RentedUnit {&#xA;        ...UnitSummaryContainer_rentedUnit&#xA;      }&#xA;      fragment DetailsSectionContainer_vacantUnit on VacantUnit {&#xA;        ...UnitSummaryContainer_vacantUnit&#xA;      }&#xA;  `),&#xA;);&#xA;</code></pre>&#xA;",0,user2643810,,2019-03-22 10:32:18,2019-03-30 14:17:29,How to limit the number of images I get back from graphql?,<graphql><relay>,1,0,0,2019-03-22 10:23:01
55301676,1,,,2,2536,"<p>I am implementing a Relay style pagination for a GraphQL server, and using the excellent TypeORM library.</p>&#xA;&#xA;<p>I want to find the best way to create a PageInfo object after a query:</p>&#xA;&#xA;<pre><code>type PageInfo {&#xA;  endCursor: String&#xA;  hasNextPage: Boolean!&#xA;  hasPreviousPage: Boolean!&#xA;  startCursor: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code>if (before) {&#xA;  qb = qb.andWhere('note.notedAt &lt;=(:before)', { before });&#xA;}&#xA;&#xA;if (after) {&#xA;  qb = qb.andWhere('note.notedAt &gt;(:after)', { after });&#xA;}&#xA;&#xA;qb = qb.take(args.take)&#xA;const [entities, totalEntitesCount] = qb.getManyWithCount()&#xA;</code></pre>&#xA;&#xA;<p>So with this info how do we calculate <code>hasNextPage</code> and <code>hasPreviousPage</code></p>&#xA;&#xA;<p>My current thinking:</p>&#xA;&#xA;<pre><code>function createPageInfo(&#xA;  noteEdges: Array&lt;{ node: Note; cursor: Date }&gt;,&#xA;  totalCount: number,&#xA;  findOptions: NoteFindOptions&#xA;) {&#xA;&#xA;  let hasNextPage: boolean;&#xA;  let hasPreviousPage: boolean;&#xA;&#xA;  if(findOptions.after) {&#xA;    hasPreviousPage = true;&#xA;    hasNextPage = (noteEdges.length &lt; totalCount)&#xA;  } else if (findOptions.before) {&#xA;    hasNextPage = true;&#xA;    hasPreviousPage = (noteEdges.length &lt; totalCount)&#xA;  } else {&#xA;    hasPreviousPage = false;&#xA;    hasNextPage = (noteEdges.length &lt; totalCount)&#xA;  }&#xA;&#xA;  return {&#xA;    startCursor: noteEdges[0].cursor,&#xA;    endCursor: noteEdges[noteEdges.length - 1].cursor,&#xA;    hasNextPage,&#xA;    hasPreviousPage&#xA;  };&#xA;}&#xA;&#xA;</code></pre>&#xA;",192791,,192791,2019-03-22 14:34:35,2019-04-26 08:17:23,With TypeORM getManyWithCount how to generate a PageInfo for pagination,<graphql><apollo><apollo-client><relay><typeorm>,1,0,0,2019-03-22 14:21:35
55302520,2,,53829238,0,,"<p>@aymen is correct. You could then set your query to call multiple separate JSON files: </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export const pageQuery = graphql`&#xA;  query indexQuery {&#xA;    allSocialJson {&#xA;      edges {&#xA;        node {&#xA;          url&#xA;          type&#xA;        }&#xA;      }&#xA;    }&#xA;    allExperienceJson {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          company&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;    allCertificationsJson {&#xA;      edges {&#xA;        node {&#xA;          name&#xA;          id&#xA;          start&#xA;          end&#xA;          authority&#xA;        }&#xA;      }&#xA;    }&#xA;    allEducationJson {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          school&#xA;          program&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;&#xA;</code></pre>&#xA;",9878071,,,,2019-03-22 15:03:54,"",,0,0,0,2019-03-22 15:03:54
55305592,1,,,0,1386,"<p>I am unable to get a query out of my graphql and I wonder why the following codes fail me .</p>&#xA;&#xA;<p>while </p>&#xA;&#xA;<pre><code>query&#xA;{&#xA;  allCockpitHello{&#xA;    edges{&#xA;      node{&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>gives me the out put of </p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""allCockpitHello"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Cockpit__Hello__5c65992264343100000001c3""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Cockpit__Hello__5c90b32864343100000001ab""&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I cannot get any query by </p>&#xA;&#xA;<pre><code>query&#xA;{&#xA;  allCockpitHello{&#xA;    edges{&#xA;      node ( id :""Cockpit__Hello__5c90b32864343100000001ab""){&#xA;        Name{&#xA;          value&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to filter out the names by ID so that my out put gives me only one result. </p>&#xA;",3621842,,,,2019-03-23 12:52:51,How to get graphql query with filter,<reactjs><graphql>,1,3,0,2019-03-22 18:13:48
55306961,2,,55306245,1,,"<p>Don't confuse the operation with the actual field being queried. The syntax should look like this:</p>&#xA;&#xA;<pre><code>operationType [operationName] [variableDefinitions] {&#xA;  selectionSet&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>where <code>operationType</code> is one of <code>query</code>, <code>mutation</code> or <code>subscription</code>, <code>operationName</code> is an arbitrary name for your operation used in debugging, <code>variableDefinitions</code> are type definitions for any variables you reference inside the operation, and <code>selectionSet</code> is one or more fields you're actually querying.</p>&#xA;&#xA;<p>In this case, <code>search</code> is a field we're querying, so it should not be proceeded by the <code>query</code> keyword. This works fine, provided you're authenticated:</p>&#xA;&#xA;<pre><code>query OptionalName {&#xA;  search(first: 10, type: ISSUE, query: ""repo:angular/angular is:issue state:open"") {&#xA;    issueCount&#xA;    edges {&#xA;      # more fields&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If the operation type is <code>query</code>, you can omit the <code>query</code> keyword altogether. This is called ""query shorthand"":</p>&#xA;&#xA;<pre><code>{&#xA;  search(first: 10, type: ISSUE, query: ""repo:angular/angular is:issue state:open"") {&#xA;    issueCount&#xA;    edges {&#xA;      # more fields&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you use variables, define them inside parentheses beside your operation. Variable names are arbitrary, but by convention we use the input field names they will be used in:</p>&#xA;&#xA;<pre><code>query OptionalName ($first: Int, type: SearchType!, $query: String! ) {&#xA;  search(first: $first, type: $type, query: $query) {&#xA;    issueCount&#xA;    edges {&#xA;      # more fields&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6024220,,,,2019-03-22 19:54:26,"",,0,0,0,2019-03-22 19:54:26
55313925,2,,55305592,0,,"<p>If you already know a specific node ID, a common convention (from <a href=""https://facebook.github.io/relay/graphql/objectidentification.htm"" rel=""nofollow noreferrer"">Relay</a>) is for there to be a <em>top-level</em> query named <code>node</code> that returns its object.  (You can ""jump"" directly to the object, you don't have to run the whole query to get there.)  The one catch is that you have to know the object's type as well.</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>query GetHello($id: ID!) {&#xA;  node(id: $id) {&#xA;    ... on Hello {&#xA;      name {&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you don't know the object type from the schema, there is <a href=""https://facebook.github.io/graphql/June2018/#sec-Type-Name-Introspection"" rel=""nofollow noreferrer"">a built-in <code>__typename</code> field on all objects</a> that can return it.</p>&#xA;&#xA;<pre class=""lang-graphql prettyprint-override""><code>query { allCockpitHello { edges {&#xA;  node {&#xA;    __typename&#xA;    id&#xA;  }&#xA;} } }&#xA;</code></pre>&#xA;&#xA;<p>As @HemantParashar noted in a comment, GraphQL is much more of an API layer than a query language <em>per se</em>.  A service can define any parameters it wants to on any fields, but there aren't built-in options for things like filtering and sorting.  There is no universal GraphQL way to say ""find only child nodes that have this name"".</p>&#xA;",10008173,,,,2019-03-23 12:52:51,"",,0,0,0,2019-03-23 12:52:51
55317097,2,,55306424,1,,"<p>I believe you'll be wanting to add <code>@connection</code> directives to your <code>gql</code> definitions of <code>notesQuery</code> and <code>measurementsQuery</code>. You didn't post those, so unfortunately I can't show you exactly what that would look like for your use case.</p>&#xA;&#xA;<p>Anyway, the <code>@connection</code> directive will allow Apollo to match on <code>notebookId</code> for example, while ignoring the value of <code>first</code>.</p>&#xA;&#xA;<p>Unfortunately, you've bundled all your input into the object <code>input</code>, and I don't know how you would select just <code>notebookId</code> with the filter. Assuming that your <code>gql</code> definition looks something like this for <code>notesQuery</code>:</p>&#xA;&#xA;<pre><code>const notesQuery = gql`&#xA;  query notes($input: InputType!) {&#xA;    notes(input: $input) @connection(key: ""notes"", filter: [""input['notebookId']""]) {&#xA;      id&#xA;      ...&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>^^^ Unfortunately, that won't work because of the way that <code>apollo-utilities/lib/storeUtils.js</code> -> <code>getStoreKeyName()</code> function works. It'll just ignore the above attempt to get better resolution than an arg name, i.e. can't go beyond <code>input</code>. Any string in the filter array that doesn't match an arg name is silently ignored.</p>&#xA;&#xA;<p>Looks like you'll have to modify your schema.</p>&#xA;&#xA;<p>More info at: <a href=""https://www.apollographql.com/docs/react/features/pagination.html#connection-directive"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/features/pagination.html#connection-directive</a></p>&#xA;",5057805,,,,2019-03-23 18:33:58,"",,0,0,0,2019-03-23 18:33:58
55319629,1,55408294,,4,539,"<p>I'm fairly new to both Graphql and Kotlin, and I'm having an issue.  I have an object (Data Class in kotlin, type in graphql) called Ingredient.  Ingredient has a name and an ID, both strings, and a vegan and glutenfree value, both enums.</p>&#xA;&#xA;<p>The problem that I'm having is that when I try to create an ingredient with a mutation, I get a type mismatch for Vegan and GlutenFree where it expects ""type.Vegan"" and finds ""me.paxana.myapplication.models.Vegan""</p>&#xA;&#xA;<p>This is the function I'm using to create the ingredient.  In it ingredient.vegan and ingredient.gf are underlined because of the above mentioned type mismatch.</p>&#xA;&#xA;<pre><code>fun createIngredient(ingredient: Ingredient ) {&#xA;    val createIngredientInput = CreateIngredientInput.builder().name(ingredient.name).vegan(ingredient.vegan).gf(ingredient.gf).build()&#xA;    mAWSAppSyncClient!!.mutate(CreateIngredientMutation.builder().input(createIngredientInput).build())&#xA;        .enqueue(mutationCallback)&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the ingredient data class:</p>&#xA;&#xA;<pre><code>data class Ingredient(val id: String, val name: String, val vegan: Vegan = Vegan.UNKNOWN, val gf: GlutenFree = GlutenFree.UNKNOWN ) &#xA;</code></pre>&#xA;&#xA;<p>this is my enum class for Vegan</p>&#xA;&#xA;<pre><code>enum class Vegan {&#xA;    VEGAN, NONVEGAN, UNKNOWN&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here's my graphQL schema</p>&#xA;&#xA;<pre><code>input CreateIngredientInput {&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;input DeleteIngredientInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;enum GlutenFree {&#xA;    GLUTENFREE&#xA;    CONTAINSGLUTEN&#xA;    UNKNOWN&#xA;}&#xA;&#xA;type Ingredient {&#xA;    id: ID!&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;type IngredientConnection {&#xA;    items: [Ingredient]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input ModelBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input ModelFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input ModelIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input ModelIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;enum ModelSortDirection {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;&#xA;input ModelStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;type Mutation {&#xA;    createIngredient(input: CreateIngredientInput!): Ingredient&#xA;    updateIngredient(input: UpdateIngredientInput!): Ingredient&#xA;    deleteIngredient(input: DeleteIngredientInput!): Ingredient&#xA;}&#xA;&#xA;type Query {&#xA;    getIngredient(id: ID!): Ingredient&#xA;    listIngredients(filter: TableIngredientFilterInput, limit: Int, nextToken: String): IngredientConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""createIngredient""])&#xA;    onUpdateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""updateIngredient""])&#xA;    onDeleteIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""deleteIngredient""])&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIngredientFilterInput {&#xA;    id: TableIDFilterInput&#xA;    name: TableStringFilterInput&#xA;    vegan: TableBooleanFilterInput&#xA;    gf: TableBooleanFilterInput&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input UpdateIngredientInput {&#xA;    id: ID!&#xA;    name: String&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;enum Vegan {&#xA;    VEGAN&#xA;    NONVEGAN&#xA;    UNKNOWN&#xA;}&#xA;</code></pre>&#xA;",5526712,,,,2019-03-28 23:20:01,mapping a graphql enum to a kotlin enum,<kotlin><enums><graphql><aws-appsync>,1,0,0,2019-03-24 00:23:16
55415125,1,67434820,,18,18553,"<p>It's easy to pass a parameter to a GraphQL query. But what about GraphQL fragments?</p>&#xA;<p>This code contains some perfectly normal querying with a parameter (itemId) and a hint at what I attempt to do (includeExtraResults) :</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const GET_ITEM = gql`&#xA;  query GetItem($itemId: ID!, $includeExtraResults:BOOLEAN) {&#xA;    container {&#xA;      item(itemId: $itemId) {&#xA;        itemId&#xA;        someField&#xA;        innerItem(someExtraOption: $includeExtraResults) {&#xA;          ...InnerItemFragment&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;  ${INNER_ITEM_FRAGMENT}&#xA;`;&#xA;&#xA;export const INNER_ITEM_FRAGMENT = gql`&#xA;  fragment InnerItemFragment on InnerItemType {&#xA;    innerItemId&#xA;    innerInnerItem(someExtraOption: $includeExtraResults) {&#xA;      someFields&#xA;    }&#xA;  }&#xA;  ${INNER_INNER_ITEM_FRAGMENT}&#xA;`;&#xA;&#xA;&#xA;export const INNER_INNER_ITEM_FRAGMENT = gql`&#xA;  /* (not detailed here) */&#xA;`;&#xA;</code></pre>&#xA;<p>When inner-inner items get automatically queried as part of inner items, I don't want them to return the <em>field</em> based upon which the filter works. The client doesn't know the logic either. Instead I want to use the <em>parameter</em>, and the logic is decided on server side.</p>&#xA;<p>Still, their query is implemented in a way that it wants the (optional) parameter &quot;includeExtraResults&quot;, which is passed to GetItem in the first place.</p>&#xA;<p>So, is there a way to pass &quot;includeExtraResults&quot; to the inner fragment? What should be changed for this to make sense? In real life this is a complex system with many levels of inner fragments.</p>&#xA;",9359785,,3632722,2020-07-10 08:11:34,2021-05-07 12:17:04,How to pass parameter to graphql fragment?,<react-native><graphql>,2,0,0,2019-03-29 10:15:19
55432387,2,,55034241,0,,"<p>given that your data is in a connection, you can use the updaterConfig. Check the relay docs <a href=""https://facebook.github.io/relay/docs/en/mutations.html#range-add"" rel=""nofollow noreferrer"">here</a>.</p>&#xA;&#xA;<p>If you are not using a connection, it is a bit more tricky, but you can use the optimisticUpdater function to update the relay store. Relay docs <a href=""https://facebook.github.io/relay/docs/en/mutations.html#using-updater-and-optimisticupdater"" rel=""nofollow noreferrer"">here</a></p>&#xA;",4557188,,,,2019-03-30 14:25:16,"",,0,0,0,2019-03-30 14:25:16
55434662,2,,55164824,0,,"<p>I ran into the same issue. It seems Antd does not allow to place arbitrary components into a <code>Menu/SubMenu</code>. My guess is that <code>Menu.Item</code> needs to get some props, which are passed from <code>Menu/SubMenu</code> to its children.</p>&#xA;&#xA;<p>So you can either create a custom component that passes all props down, or <strong>remove the inner <code>&lt;React.Fragment&gt;</code> declaration</strong> (the one that is inside the <code>SubMenu</code>), which is not needed anyway.</p>&#xA;",2017490,,2017490,2019-03-30 19:00:39,2019-03-30 19:00:39,"",,0,0,0,2019-03-30 18:49:23
55435951,1,55621611,,4,1230,"<p>I have a DynamoDB with ingredients.  AWS Appsync created a resolver for me so I could get an ingredient by ID, but I need to be able to get an ingredient by name.  I've tried writing a resolver for this but it doesn't work.  </p>&#xA;&#xA;<p>Eventually I need to write a resolver or API that takes a list of strings and returns the ingredients that match those strings, if they exist, but this is the first step and I'm hoping if I can do this I can create a batch version of it.</p>&#xA;&#xA;<p>The resolver:</p>&#xA;&#xA;<pre><code>{&#xA;    ""version"": ""2017-02-28"",&#xA;    ""operation"": ""GetItem"",&#xA;    ""key"": {&#xA;        ""name"": $util.dynamodb.toDynamoDBJson($util.transform.toDynamoDBFilterExpression($ctx.args.filter))&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The response mapping template</p>&#xA;&#xA;<pre><code>$util.toJson($ctx.result)&#xA;</code></pre>&#xA;&#xA;<p>The Schema:</p>&#xA;&#xA;<pre><code>input CreateIngredientInput {&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;input DeleteIngredientInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;enum GlutenFree {&#xA;    GLUTENFREE&#xA;    CONTAINSGLUTEN&#xA;    UNKNOWN&#xA;}&#xA;&#xA;type Ingredient {&#xA;    id: ID!&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;type IngredientConnection {&#xA;    items: [Ingredient]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input ModelBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input ModelFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input ModelIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input ModelIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;enum ModelSortDirection {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;&#xA;input ModelStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;type Mutation {&#xA;    createIngredient(input: CreateIngredientInput!): Ingredient&#xA;    updateIngredient(input: UpdateIngredientInput!): Ingredient&#xA;    deleteIngredient(input: DeleteIngredientInput!): Ingredient&#xA;}&#xA;&#xA;type Query {&#xA;    getIngredient(id: ID!): Ingredient&#xA;    getIngredientByName(name: String!): Ingredient&#xA;    listIngredients(filter: TableIngredientFilterInput, limit: Int, nextToken: String): IngredientConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""createIngredient""])&#xA;    onUpdateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""updateIngredient""])&#xA;    onDeleteIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""deleteIngredient""])&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIngredientFilterInput {&#xA;    id: TableIDFilterInput&#xA;    name: TableStringFilterInput&#xA;    vegan: TableBooleanFilterInput&#xA;    gf: TableBooleanFilterInput&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input UpdateIngredientInput {&#xA;    id: ID!&#xA;    name: String&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;enum Vegan {&#xA;    VEGAN&#xA;    NONVEGAN&#xA;    UNKNOWN&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When I run this query:</p>&#xA;&#xA;<pre><code>query getIt {&#xA;  getIngredientByName(name: ""demerara"") {&#xA;    id&#xA;    name&#xA;    vegan&#xA;    gf&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I get the response:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""getIngredientByName"": null&#xA;  },&#xA;  ""errors"": [&#xA;    {&#xA;      ""path"": [&#xA;        ""getIngredientByName""&#xA;      ],&#xA;      ""data"": null,&#xA;      ""errorType"": ""DynamoDB:AmazonDynamoDBException"",&#xA;      ""errorInfo"": null,&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 2,&#xA;          ""column"": 3,&#xA;          ""sourceName"": null&#xA;        }&#xA;      ],&#xA;      ""message"": ""The provided key element does not match the schema (Service: AmazonDynamoDBv2; Status Code: 400; Error Code: ValidationException; Request ID: 58EKL6IO63VL44Q1DTG9JFNJB7VV4KQNSO5AEMVJF66Q9ASUAAJG)""&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Though demerara is definitely an ingredient in my database.</p>&#xA;",5526712,,,,2020-07-27 16:01:52,"GraphQL Resolver for getting item by name, not ID",<graphql><aws-appsync><resolver>,2,3,0,2019-03-30 21:50:49
55489467,2,,55482003,2,,"<p>You can use <code>limit</code> to get only a certain amount of data: <a href=""https://www.gatsbyjs.org/docs/graphql-reference/#limit"" rel=""nofollow noreferrer"">https://www.gatsbyjs.org/docs/graphql-reference/#limit</a></p>&#xA;",10164092,,,,2019-04-03 07:32:41,"",,0,0,0,2019-04-03 07:32:41
55522214,2,,55194380,2,,"<p>Here's another query you could consider using <code>@normalize</code> to only return aliased predicates and <code>@cascade</code> to only return results that contain all the edges in the query:</p>&#xA;&#xA;<pre><code>{&#xA;  personWithFriendPetP3(func: has(person.name)) @normalize @cascade {&#xA;    name: person.name&#xA;    age: person.age&#xA;    friend {&#xA;      owns_pet @filter(eq(pet.name, ""P3"")) {&#xA;        pet.name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Response:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""personWithFriendPetP3"": [&#xA;      {&#xA;        ""name"": ""A1"",&#xA;        ""age"": 43&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://stackoverflow.com/a/55208872/2709415"">Your answer</a> would work great given that you'd set the reverse edges in the schema types for <code>owns_pet</code> and <code>friend</code>. It would do less work than the above query, given that it's using an indexed query in the root func with an equality check for the specific pet name first, and then traversing for the other friends.</p>&#xA;&#xA;<p>The query in this answer would first find all the people who have names in the root func, and then check whether their friend's pet name is P3.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>Dgraph docs:</p>&#xA;&#xA;<p><a href=""https://docs.dgraph.io/query-language/#normalize-directive"" rel=""nofollow noreferrer"">https://docs.dgraph.io/query-language/#normalize-directive</a></p>&#xA;&#xA;<p><a href=""https://docs.dgraph.io/query-language/#cascade-directive"" rel=""nofollow noreferrer"">https://docs.dgraph.io/query-language/#cascade-directive</a></p>&#xA;",2709415,,,,2019-04-04 17:52:42,"",,0,0,0,2019-04-04 17:52:42
55534451,1,,,0,141,"<p>When clicking ""Popular"", how to replace  contents with result from new query (getPopular)?</p>&#xA;&#xA;<p>( v-for=""casino in allCasinos""  needs to instead show: v-for=""casino in getPopular"" )</p>&#xA;&#xA;<pre><code>&lt;div @click=""activate(1); getPopular();""&gt;Popular&lt;/div&gt;&#xA;&lt;div @click=""activate(2); getNew();""&gt;New&lt;/div&gt;&#xA;&#xA;&lt;div id=""list"" v-for=""casino in allCasinos"" :key=""casino.name""&gt;&#xA;  &lt;div v-if=""$apollo.loading""&gt;Loading...&lt;/div&gt;&#xA;  &lt;div&gt;{{ casino.name}}&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script&gt;&#xA;import gql from 'graphql-tag';&#xA;methods: {&#xA;  activate:function(el){&#xA;      this.active_el = el;&#xA;  },&#xA;},&#xA;apollo: {&#xA;  allCasinos: gql`{&#xA;    allCasinos(limit: 6) {&#xA;      name,&#xA;    }&#xA;  }`,&#xA;  getPopular: gql`{&#xA;    getPopular(limit: 6) {&#xA;      name,&#xA;    }&#xA;  }`,&#xA;  getNew gql`{&#xA;    getNew(limit: 6) {&#xA;      name,&#xA;    }&#xA;  }`,&#xA;&lt;/script&gt;&#xA;</code></pre>&#xA;",4238995,,,,2019-04-06 09:51:00,"Multiple Queries, show result in same div",<vue.js><vuejs2><graphql><apollo><vue-apollo>,2,0,0,2019-04-05 11:32:37
55534976,2,,55534451,1,,"<p>In this case, there is no reason to use separate queries - use one common query with <code>filter</code> (beside <code>limit</code>) parameter.</p>&#xA;&#xA;<p><hr />&#xA;<strong>UPDATE</strong></p>&#xA;&#xA;<pre><code>casinos: gql`query casinos($filter: String!) {&#xA;    casinos(filter: $filter, limit: 6) {&#xA;        name&#xA;    }&#xA;}`,&#xA;</code></pre>&#xA;",6124657,,6124657,2019-04-06 09:51:00,2019-04-06 09:51:00,"",,0,5,0,2019-04-05 12:05:09
55543947,1,55548171,,0,460,"<p>When I retrieve a list of Ingredient objects from AWS Appsync, it comes back to me in the form of a list of <code>ListIngredientsQuery.Item</code>.</p>&#xA;&#xA;<p>I'd like to my Ingredient object in my Kotlin code to extend the <code>ListIngredientsQuery.Item</code> so I can retrieve a list of Ingredients from the server instead, and perform the functions that are relevant to my Ingredient object on the members therein.</p>&#xA;&#xA;<p>I used the : in my data class, to extend ListIngredientQuery.item, but when I get my list from the server, if I try to get it as a list of Ingredients, I get a <code>type mismatch: required:List&lt;Ingredient&gt; found: &lt;ListIngredientsQuery.item!&gt;</code> error.</p>&#xA;&#xA;<p>If I was in Java I would just use the ""Extends"" keyword.</p>&#xA;&#xA;<p><strong>my function to get the list:</strong></p>&#xA;&#xA;<pre><code>fun getIngredients() {&#xA;    mAWSAppSyncClient!!.query(ListIngredientsQuery.builder().build())&#xA;        .responseFetcher(AppSyncResponseFetchers.CACHE_AND_NETWORK)&#xA;        .enqueue(ingredientsCallback)&#xA;}&#xA;&#xA;&#xA;private val ingredientsCallback = object:GraphQLCall.Callback&lt;ListIngredientsQuery.Data&gt;() {&#xA;    override fun onResponse(response: com.apollographql.apollo.api.Response&lt;ListIngredientsQuery.Data&gt;) {&#xA;        var mIngredientsList: List&lt;Ingredient&gt;&#xA;        mIngredientsList = response.data()!!.listIngredients()!!.items()!!.toList()&#xA;        mIngredientsList!!.forEach {&#xA;            Log.d(""All Ingredients: "", it.name())}&#xA;    }&#xA;    override fun onFailure(e: ApolloException) {&#xA;        Log.e(""Error"", e.toString())&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Ingredient.kt:</strong></p>&#xA;&#xA;<pre><code>import com.amazonaws.amplify.generated.graphql.ListIngredientsQuery&#xA;&#xA;data class Ingredient(val id: String, val name: String, val vegan: type.Vegan = type.Vegan.UNKNOWN, val gf: type.GlutenFree = type.GlutenFree.UNKNOWN ) :&#xA;    ListIngredientsQuery.Item(""Ingredient"", id, name, vegan, gf)&#xA;</code></pre>&#xA;&#xA;<p><strong>my Graphql Schema:</strong></p>&#xA;&#xA;<pre><code>input CreateIngredientInput {&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;input DeleteIngredientInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;enum GlutenFree {&#xA;    GLUTENFREE&#xA;    CONTAINSGLUTEN&#xA;    UNKNOWN&#xA;}&#xA;&#xA;type Ingredient {&#xA;    id: ID!&#xA;    name: String!&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;type IngredientConnection {&#xA;    items: [Ingredient]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input ModelBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input ModelFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input ModelIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input ModelIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;enum ModelSortDirection {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;&#xA;input ModelStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;type Mutation {&#xA;    createIngredient(input: CreateIngredientInput!): Ingredient&#xA;    updateIngredient(input: UpdateIngredientInput!): Ingredient&#xA;    deleteIngredient(input: DeleteIngredientInput!): Ingredient&#xA;}&#xA;&#xA;type Query {&#xA;    getIngredient(id: ID!): Ingredient&#xA;    getIngredientByName(name: String!): Ingredient&#xA;    listIngredients(filter: TableIngredientFilterInput, limit: Int, nextToken: String): IngredientConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""createIngredient""])&#xA;    onUpdateIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""updateIngredient""])&#xA;    onDeleteIngredient(&#xA;        id: ID,&#xA;        name: String,&#xA;        vegan: Vegan,&#xA;        gf: GlutenFree&#xA;    ): Ingredient&#xA;        @aws_subscribe(mutations: [""deleteIngredient""])&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIngredientFilterInput {&#xA;    id: TableIDFilterInput&#xA;    name: TableStringFilterInput&#xA;    vegan: TableBooleanFilterInput&#xA;    gf: TableBooleanFilterInput&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input UpdateIngredientInput {&#xA;    id: ID!&#xA;    name: String&#xA;    vegan: Vegan&#xA;    gf: GlutenFree&#xA;}&#xA;&#xA;enum Vegan {&#xA;    VEGAN&#xA;    NONVEGAN&#xA;    UNKNOWN&#xA;}&#xA;</code></pre>&#xA;",5526712,,,,2019-04-06 10:28:07,How can I extend my graphql object into my Kotlin object?,<kotlin><graphql><aws-appsync>,1,0,0,2019-04-05 22:06:10
55598930,2,,33354818,1,,"<p>You can pass <code>client:root</code> as the <code>parentID</code>. And then your <code>pathToConnection</code> would be <code>['client:root', 'someConnection']</code>.</p>&#xA;&#xA;<p>(Tested with Relay Modern. Not sure if this also applies to Relay Classic, but that's officially deprecated now anyways. But this is still one of the top Google results for this issue, so answering.)</p>&#xA;&#xA;<p>(Found in <a href=""https://github.com/facebook/relay/issues/1991"" rel=""nofollow noreferrer"">this GitHub issue</a>)</p>&#xA;",3187556,,,,2019-04-09 18:18:15,"",,0,0,0,2019-04-09 18:18:15
55604984,1,,,0,217,"<p>I have a component which receives an array of objects called periods</p>&#xA;<pre><code>[&#xA;{id: 4, endDate: &quot;2018-06-30T10:00:00+10:00&quot;}&#xA;,{id: 3, endDate: &quot;2017-06-30T10:00:00+10:00&quot;}&#xA;,{id: 5, endDate: &quot;2017-06-30T10:00:00+10:00&quot;}&#xA;]&#xA;</code></pre>&#xA;<p>This is passed down from its parent, which receives via a graphql call.&#xA;How can I sort this prop in descending date order and pass it down to a child component to use.&#xA;I have tried</p>&#xA;<pre><code>      const arr = [...this.props.periods];&#xA;      const a2 = arr.sort((a, b) =&gt; b.endDate.localeCompare(a.endDate));&#xA;this.props.periods = a2&#xA;.&#xA;.&#xA;.(child component)&#xA;&lt;Dropdown options={this.props.periods} /&gt;&#xA;&#xA;</code></pre>&#xA;<p>And receive this error</p>&#xA;<h2>TypeError: Cannot assign to read only property 'periods' of object '#'</h2>&#xA;",6181130,,-1,2020-06-20 09:12:55,2019-04-10 05:41:32,Sorting a Props array of objects by date before passing to child,<javascript><reactjs><sorting><graphql-js>,2,2,0,2019-04-10 04:59:05
55605424,2,,55604984,0,,"<p>all property in this.props is read-only and you should use state </p>&#xA;&#xA;<pre><code>const periods = [...this.props.periods].sort((a, b) =&gt; &#xA;b.endDate.localeCompare(a.endDate));&#xA;&#xA;this.setState({periods})&#xA;&#xA;&lt;Dropdown options={this.state.periods} /&gt;&#xA;</code></pre>&#xA;",3243488,,,,2019-04-10 05:41:32,"",,0,0,0,2019-04-10 05:41:32
55616802,1,,,3,698,"<p>I've been using GraphQL for probably 8 or so months. I've never run into a problem like this before. When I make a change in my datamodel, and run the command which generates a prisma file. I have an existing field in a table which's type is an array of strings, so <code>languages:[String!]</code>. However, in my generated prisma file, I do not see an option to query on <code>languages</code> in my table.</p>&#xA;&#xA;<p>This is not an issue of prisma not generating an update to the file. I have deleted it and it generates the same thing. Furthermore, <code>languages</code> is present in other generated types, just not the <code>ItemDescriptionWhereInput</code> (table name is ItemDescription). Lastly, this field is currently in use, I've updated this field in my API and it works fine. So this seems to be a prisma issue, not something related to my code. </p>&#xA;&#xA;<p>Here is my ItemDescription table:</p>&#xA;&#xA;<pre><code>type ItemDescription {&#xA;    id: ID! @unique&#xA;    item: ItemData! @relation(name: ""ItemDescriptionToItemData"")&#xA;    languages: [String!]&#xA;    description: String&#xA;    shootDates: String&#xA;    location: String&#xA;    productionCompany: String&#xA;    assetSource: String&#xA;    assetUsageMotion: String&#xA;    assetUsageStill: String&#xA;    talentUsage: String&#xA;    earliestStart: String&#xA;    earliestEnd: String&#xA;    generalNotes: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is the Where input that gets generated by prisma, notice the missing <code>languages</code> here: </p>&#xA;&#xA;<pre><code>input ItemDescriptionWhereInput {&#xA;  """"""Logical AND on all given filters.""""""&#xA;  AND: [ItemDescriptionWhereInput!]&#xA;&#xA;  """"""Logical OR on all given filters.""""""&#xA;  OR: [ItemDescriptionWhereInput!]&#xA;&#xA;  """"""Logical NOT on all given filters combined by AND.""""""&#xA;  NOT: [ItemDescriptionWhereInput!]&#xA;  id: ID&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  id_not: ID&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  id_in: [ID!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  id_not_in: [ID!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  id_lt: ID&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  id_lte: ID&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  id_gt: ID&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  id_gte: ID&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  id_contains: ID&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  id_not_contains: ID&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  id_starts_with: ID&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  id_not_starts_with: ID&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  id_ends_with: ID&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  id_not_ends_with: ID&#xA;  description: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  description_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  description_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  description_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  description_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  description_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  description_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  description_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  description_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  description_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  description_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  description_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  description_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  description_not_ends_with: String&#xA;  shootDates: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  shootDates_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  shootDates_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  shootDates_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  shootDates_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  shootDates_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  shootDates_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  shootDates_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  shootDates_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  shootDates_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  shootDates_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  shootDates_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  shootDates_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  shootDates_not_ends_with: String&#xA;  location: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  location_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  location_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  location_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  location_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  location_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  location_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  location_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  location_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  location_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  location_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  location_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  location_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  location_not_ends_with: String&#xA;  productionCompany: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  productionCompany_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  productionCompany_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  productionCompany_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  productionCompany_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  productionCompany_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  productionCompany_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  productionCompany_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  productionCompany_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  productionCompany_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  productionCompany_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  productionCompany_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  productionCompany_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  productionCompany_not_ends_with: String&#xA;  assetSource: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  assetSource_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  assetSource_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  assetSource_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  assetSource_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  assetSource_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  assetSource_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  assetSource_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  assetSource_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  assetSource_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  assetSource_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  assetSource_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  assetSource_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  assetSource_not_ends_with: String&#xA;  assetUsageMotion: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  assetUsageMotion_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  assetUsageMotion_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  assetUsageMotion_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  assetUsageMotion_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  assetUsageMotion_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  assetUsageMotion_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  assetUsageMotion_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  assetUsageMotion_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  assetUsageMotion_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  assetUsageMotion_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  assetUsageMotion_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  assetUsageMotion_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  assetUsageMotion_not_ends_with: String&#xA;  assetUsageStill: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  assetUsageStill_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  assetUsageStill_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  assetUsageStill_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  assetUsageStill_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  assetUsageStill_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  assetUsageStill_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  assetUsageStill_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  assetUsageStill_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  assetUsageStill_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  assetUsageStill_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  assetUsageStill_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  assetUsageStill_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  assetUsageStill_not_ends_with: String&#xA;  talentUsage: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  talentUsage_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  talentUsage_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  talentUsage_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  talentUsage_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  talentUsage_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  talentUsage_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  talentUsage_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  talentUsage_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  talentUsage_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  talentUsage_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  talentUsage_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  talentUsage_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  talentUsage_not_ends_with: String&#xA;  earliestStart: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  earliestStart_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  earliestStart_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  earliestStart_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  earliestStart_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  earliestStart_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  earliestStart_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  earliestStart_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  earliestStart_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  earliestStart_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  earliestStart_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  earliestStart_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  earliestStart_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  earliestStart_not_ends_with: String&#xA;  earliestEnd: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  earliestEnd_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  earliestEnd_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  earliestEnd_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  earliestEnd_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  earliestEnd_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  earliestEnd_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  earliestEnd_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  earliestEnd_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  earliestEnd_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  earliestEnd_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  earliestEnd_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  earliestEnd_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  earliestEnd_not_ends_with: String&#xA;  generalNotes: String&#xA;&#xA;  """"""All values that are not equal to given value.""""""&#xA;  generalNotes_not: String&#xA;&#xA;  """"""All values that are contained in given list.""""""&#xA;  generalNotes_in: [String!]&#xA;&#xA;  """"""All values that are not contained in given list.""""""&#xA;  generalNotes_not_in: [String!]&#xA;&#xA;  """"""All values less than the given value.""""""&#xA;  generalNotes_lt: String&#xA;&#xA;  """"""All values less than or equal the given value.""""""&#xA;  generalNotes_lte: String&#xA;&#xA;  """"""All values greater than the given value.""""""&#xA;  generalNotes_gt: String&#xA;&#xA;  """"""All values greater than or equal the given value.""""""&#xA;  generalNotes_gte: String&#xA;&#xA;  """"""All values containing the given string.""""""&#xA;  generalNotes_contains: String&#xA;&#xA;  """"""All values not containing the given string.""""""&#xA;  generalNotes_not_contains: String&#xA;&#xA;  """"""All values starting with the given string.""""""&#xA;  generalNotes_starts_with: String&#xA;&#xA;  """"""All values not starting with the given string.""""""&#xA;  generalNotes_not_starts_with: String&#xA;&#xA;  """"""All values ending with the given string.""""""&#xA;  generalNotes_ends_with: String&#xA;&#xA;  """"""All values not ending with the given string.""""""&#xA;  generalNotes_not_ends_with: String&#xA;  item: ItemDataWhereInput&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Also to prove this has nothing to do with prisma not updating my generated file, here's another type that prisma generated from this same table <code>ItemDescription</code></p>&#xA;&#xA;<pre><code>input ItemDescriptionUpdateWithoutItemDataInput {&#xA;  description: String&#xA;  shootDates: String&#xA;  location: String&#xA;  productionCompany: String&#xA;  assetSource: String&#xA;  assetUsageMotion: String&#xA;  assetUsageStill: String&#xA;  talentUsage: String&#xA;  earliestStart: String&#xA;  earliestEnd: String&#xA;  generalNotes: String&#xA;  languages: ItemDescriptionUpdatelanguagesInput&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So my question is, why is prisma not generating a whereinput that includes a value with a type of array of strings? I have no way to query on this now.</p>&#xA;",10887595,,,,2019-04-10 15:57:51,Prisma not generating field in WhereInput for an array of strings,<graphql><prisma-graphql>,0,1,0,2019-04-10 15:57:51
55621613,2,,55607812,1,,"<p>if <code>sections</code> &amp; menuSections are string or arrays of string, maybe you can filter for <code>null</code>:</p>&#xA;&#xA;<pre><code>{&#xA;  ""menuSections"": ""...""&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code>// query&#xA;{&#xA;  allDataJson(filter: {&#xA;    menuSections: {&#xA;      ne: null&#xA;    }&#xA;  }) {&#xA;    nodes {&#xA;      menuSections&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If they are object, you can still filter for <code>null</code>, but it has to be applied to one of the field inside that object. If your objects don't have a common field, this won't work:</p>&#xA;&#xA;<pre><code>{&#xA;  ""menuSections"": {&#xA;    ""menuSectionField"": ""...""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code>// query&#xA;{&#xA;  allDataJson(filter: {&#xA;    menuSections: {&#xA;      menuSectionField: {&#xA;        ne: null&#xA;      }&#xA;    }&#xA;  }) {&#xA;    nodes {&#xA;      menuSections&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If they are array of objects, you can do the same thing but with <code>elemMatch</code>:</p>&#xA;&#xA;<pre><code>{&#xA;  ""menuSections"": [&#xA;    { ""menuSectionField"": ""..."" },&#xA;    { ""other"": ""..."" }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code>// query&#xA;allDataJson(filter: {&#xA;    menuSections: {&#xA;      elemMatch: {&#xA;        menuSectionField: {&#xA;          ne: null&#xA;        }&#xA;      }&#xA;    }&#xA;  }) { ... }&#xA;</code></pre>&#xA;&#xA;<p>Worst case worst, I think you might be able to define some sort of custom types that ensure existence of menuSections so you can query <code>allDataWithMenuSections</code> etc., but if filter works it's much simpler.</p>&#xA;",10340970,,,,2019-04-10 21:33:57,"",,0,3,0,2019-04-10 21:33:57
55684867,2,,55684783,2,,"<p>The best way to handle sorting I guess should be to handle it on server-side. If you really want to do it on client-side, you should first show data as they are and then trigger <code>onChage</code> when user change sorting or keyword.</p>&#xA;&#xA;<p>I would recommend you to use <code>lodash</code> library: <a href=""https://www.npmjs.com/package/lodash"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/lodash</a> for sorting and filtering.</p>&#xA;&#xA;<p>Here are some useful link that will tell you more about server-side and client-side sorting.</p>&#xA;&#xA;<p><a href=""https://www.c-sharpcorner.com/forums/difference-between-client-side-paging-and-server-side-paging"" rel=""nofollow noreferrer"">https://www.c-sharpcorner.com/forums/difference-between-client-side-paging-and-server-side-paging</a></p>&#xA;&#xA;<p><a href=""https://stackoverflow.com/questions/407878/pagination-server-side-or-client-side"">Pagination: Server Side or Client Side?</a></p>&#xA;&#xA;<p><a href=""https://stackoverflow.com/questions/10721430/where-data-sort-should-be-done-server-or-client"">Where data sort should be done ? Server or client?</a></p>&#xA;&#xA;<p><a href=""https://softwareengineering.stackexchange.com/questions/249897/web-app-filtering-information-client-side-vs-server-side"">https://softwareengineering.stackexchange.com/questions/249897/web-app-filtering-information-client-side-vs-server-side</a></p>&#xA;",11338984,,11338984,2019-04-15 08:42:32,2019-04-15 08:42:32,"",,0,7,0,2019-04-15 08:06:10
55691162,2,,52343079,2,,"<p><strong><code>The best thing about GraphQL is we can use the query as model</code></strong></p>&#xA;&#xA;<p>Because the response would be as same as the query, so better we can assign the response to a variable of Query type.</p>&#xA;&#xA;<p>Let me explain with an example:-</p>&#xA;&#xA;<p>Suppose if I need to query about my profile data, </p>&#xA;&#xA;<p><strong>Profile.graphql</strong></p>&#xA;&#xA;<pre><code>query MyProfile{&#xA;    player {&#xA;        me {&#xA;            id&#xA;            secret&#xA;            name&#xA;            email&#xA;            state&#xA;            country&#xA;            timezone&#xA;            picture&#xA;            pictureType&#xA;            audio&#xA;            rank&#xA;        }&#xA;    }&#xA;    countries{&#xA;        value&#xA;        viewValue&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>Once we'll build the app, it'll create MyProfileQuery in API.swift. In viewController we can use the response as below- </p>&#xA;</blockquote>&#xA;&#xA;<pre><code>var myProfileData: MyProfileQuery.Data.Player.Me? // Declaring the valiable of player Type&#xA;&#xA;ApolloClientManager.sharedInstance&#xA;                .fetchQuery(MyProfileQuery(), showLoader: true,&#xA;                            viewController: self) { (response) in // Fetching response using Apollo Client Manager&#xA;                if let allData = response {&#xA;                    if let profiledata = allData.player?.me {&#xA;                        self.myProfileData = profiledata // Assigning response into the variable declared&#xA;                        self.myEdittingProfileData = profiledata&#xA;                        self.updateUI()&#xA;                    }&#xA;                    if let countryData = allData.countries {&#xA;                        self.allCountrydata = countryData&#xA;                        self.getPickerDataForState(comppletion: {&#xA;                            self.openTimeZonePicker(completion: {&#xA;                                print(""got timeZone Data"")&#xA;                            })&#xA;                        })&#xA;                    }&#xA;                }&#xA;&#xA;            }&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>Now we have response into the <strong>myProfileData</strong> variable which we can use&#xA;  as follows -</p>&#xA;</blockquote>&#xA;&#xA;<p>Now we can access all the values we have mentioned in our query as below</p>&#xA;&#xA;<pre><code>print(""player id is-          \(myProfileData?.id)"")&#xA;print(""player name is-        \(myProfileData?.name)"")&#xA;print(""player email is-       \(myProfileData?.email)"")&#xA;print(""player state is-       \(myProfileData?.state)"")&#xA;print(""player rank is-        \(myProfileData?.rank)"")&#xA;print(""player pictureType is- \(myProfileData?.pictureType)"")&#xA;&#xA;// player id is-          10&#xA;// player name is-        jordan&#xA;// player email is-       jordan@domain.com&#xA;// player state is-       Ohio&#xA;// player rank is-        101&#xA;// player pictureType is- custome&#xA;// &#xA;</code></pre>&#xA;&#xA;<p>Hope this will help you out </p>&#xA;",8101862,,8101862,2019-05-06 06:19:15,2019-05-06 06:19:15,"",,0,0,0,2019-04-15 14:15:06
55717302,1,55736232,,1,1283,"<p>In AWS Amplify+ Appsync, using @connection to generate connection between tables is very easy. A simple example of this is the following <code>Task</code> table and related <code>Comments</code></p>&#xA;&#xA;<pre><code>type Task @model{&#xA;    id: ID!&#xA;    createdAt: String&#xA;    name: String&#xA;    comments: [Comments] @connection(name:""TaskComments"", sortField: ""createdAt"")&#xA;    status: String&#xA;}&#xA;&#xA;type Comments @model{&#xA;    id: ID!&#xA;    createdAt: String&#xA;    task: Task @connection(name:""TaskComments"", sortField: ""createdAt"")&#xA;    taskId: String&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>and it even autogenerates the schema for you:</p>&#xA;&#xA;<pre><code>type Task {&#xA;  id: ID!&#xA;  createdAt: String&#xA;  name: String&#xA;  comments(limit: Int, nextToken: String): ModelCommentsConnection&#xA;  Status: String&#xA;}&#xA;&#xA;&#xA;type Query {&#xA;    ///... other not-related queries omitted&#xA;  getTask(id: ID!): Task&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem is that the query only returns 10 items <code>(Comments)</code> even when I have a lot more. (I can see the <code>nextToken</code> in the response but that's a different story). I want to be able to return 20, 30 or more comments per initial load. </p>&#xA;&#xA;<p>I tried to pass <code>limit:1000</code>, but the query is ignoring it.</p>&#xA;&#xA;<pre><code>graphql(&#xA;    gql(getTask),&#xA;    {&#xA;      options: ({match: {params: {id}}}) =&gt; ({&#xA;        variables: {id, limit:1000},&#xA;        fetchPolicy: 'cache-and-network',&#xA;      }),&#xA;      props: ({data: {getTask: task, loading}}) =&gt; ({&#xA;        task,&#xA;        loading,&#xA;      }),&#xA;    },&#xA;   ),&#xA;&#xA;</code></pre>&#xA;&#xA;<p>This is a very similar question to : <a href=""https://stackoverflow.com/questions/55716924/aws-amplify-graphql-query-on-connection"">AWS Amplify Graphql query on @connection</a></p>&#xA;&#xA;<p>But in my case I'm using React + AWS Amplify.</p>&#xA;&#xA;<p>Thanks a lot.</p>&#xA;",4030637,,,,2019-11-02 13:33:39,I need to extend the 10 item limit in @connection responses,<reactjs><graphql><apollo><aws-appsync>,2,0,0,2019-04-16 22:13:37
55736232,2,,55717302,2,,"<p>The code that Amplify generates for you is meant as a jumping off point. It may require some limited editing.</p>&#xA;&#xA;<p>If you got to src/graphql/queries.js, do you see something that looks like this?</p>&#xA;&#xA;<pre><code>query GetTasks(id:ID!, limit:Int) {&#xA;    getTask(input: {id: $id}) {&#xA;      id&#xA;      createdAt&#xA;      name&#xA;      comments(limit: $limit) {&#xA;        items {&#xA;          id&#xA;        }&#xA;      }&#xA;      status&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you don't see limit in this query definition, you may need to add it. (PS - I am not 100% sure on the syntax I've used above, but hopefully this points you in the right direction.)</p>&#xA;",4692445,,,,2019-04-17 21:28:57,"",,0,2,0,2019-04-17 21:28:57
55797444,2,,55654061,0,,"<p>I had not set a connection even though the datamodel has an @relation directive against user. Line 5 should read </p>&#xA;&#xA;<p>user: { connect: {id : ""5cbae19924aa9a0008fde67c""} }</p>&#xA;&#xA;<p>Thanks to everyone for commenting.</p>&#xA;",8483183,,,,2019-04-22 16:14:13,"",,0,0,0,2019-04-22 16:14:13
55797620,1,55798400,,6,13770,"<p>Trying out relay with react and ran into this today. Here is what I've done so far.</p>&#xA;&#xA;<p>Root Query:</p>&#xA;&#xA;<pre><code>query {&#xA;  tasks {&#xA;    id&#xA;    taskName&#xA;    taskStatus&#xA;    userId&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>React component hierarchy</p>&#xA;&#xA;<pre><code>App   &#xA; ↳--TaskList (props: tasks)&#xA;    ↳--TaskListItem (props: task)&#xA;</code></pre>&#xA;&#xA;<p>Now due to the principle of colocation I know I have to write fragments in each component to describe their data needs.</p>&#xA;&#xA;<p>TaskListItem.js</p>&#xA;&#xA;<pre><code>const TaskListItemContainer = createFragmentContainer(&#xA;    TaskListItem,&#xA;    graphql`&#xA;        fragment TaskListItem_task on task {&#xA;            id&#xA;            taskName&#xA;            taskDone&#xA;            authorId&#xA;        }&#xA;    `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>TaskList.js</p>&#xA;&#xA;<pre><code>const TaskListContainer = createFragmentContainer(&#xA;    TaskList,&#xA;    graphql`&#xA;        fragment TaskList_tasks on task {&#xA;            tasks {&#xA;                ...TaskListItem_task&#xA;            }&#xA;        }&#xA;    `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>App.js</p>&#xA;&#xA;<pre><code>&lt;QueryRenderer&#xA;   environment={relayEnvironment}&#xA;   query={graphql`&#xA;       query AppQuery {&#xA;         ...TaskList_tasks&#xA;       }&#xA;     `&#xA;   }&#xA;</code></pre>&#xA;&#xA;<p>When I run the relay compiler I get the following error.</p>&#xA;&#xA;<pre><code>Fragment ""TaskList_tasks"" cannot be spread here as objects of type ""Query"" can never be of type ""task"".&#xA;&#xA;App.js (3:15)&#xA;2:             query AppQuery {&#xA;3:               ...TaskList_tasks&#xA;                 ^&#xA;4:             }&#xA;</code></pre>&#xA;&#xA;<p>Not able to figure out how to organize the structure because of this problem. Should I modify the schema just to facilitate the structure and reuse of fragments on the client side?</p>&#xA;",3598286,,3598286,2019-04-22 16:31:10,2019-04-22 17:29:12,"fragment cannot be spread here as objects of type ""Query""",<graphql-js><relayjs><relay><relaymodern><react-relay>,1,0,0,2019-04-22 16:25:28
55798400,2,,55797620,18,,"<p>A basic Fragment consists of five things:</p>&#xA;&#xA;<ul>&#xA;<li>the <code>fragment</code> keyword</li>&#xA;<li>the name of the Fragment</li>&#xA;<li>the <code>on</code> keyword</li>&#xA;<li>the type the Fragment applies to</li>&#xA;<li>the selection set wrapped in a set of curly brackets</li>&#xA;</ul>&#xA;&#xA;<p>The selection set is one or more fields of the type you specify that you want to request when you use the Fragment. Think of the Fragment as a drop in replacement for a single selection set. If I have a query like this:</p>&#xA;&#xA;<pre><code>query {&#xA;  foo&#xA;  bar&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>then <code>{ foo bar }</code> is the selection set I'm requesting, in this case on the <code>Query</code> type (or whatever your query root operation type is called in your schema). So if I want to use a fragment, I would write:</p>&#xA;&#xA;<pre><code>query {&#xA;  ...QueryFields&#xA;}&#xA;&#xA;fragment QueryFields on Query {&#xA;  foo&#xA;  bar&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In your code, you're trying to write a query like:</p>&#xA;&#xA;<pre><code>query {&#xA;  ...TaskList_tasks&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, as the error indicates, the type associated with the <code>TaskList_tasks</code> fragment is <code>task</code>. But you're not replacing a selection set for a <code>task</code> type here, you're replacing a selection set for the <code>Query</code> type. So your request is not valid.</p>&#xA;&#xA;<p><strong>TLDR;</strong> You need to change the type on your Fragment to <code>Query</code>:</p>&#xA;&#xA;<pre><code>fragment TaskList_tasks on Query {&#xA;  tasks {&#xA;    ...TaskListItem_task&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6024220,,,,2019-04-22 17:29:12,"",,0,0,0,2019-04-22 17:29:12
55824050,1,55895620,,4,2932,"<p>I have the following datamodel:</p>&#xA;&#xA;<pre><code>type Job { &#xA;    // ...&#xA;    example: String&#xA;    selections: [Selection!]&#xA;    // ...&#xA;}&#xA;&#xA;type Selection { &#xA;    ...&#xA;    question: String&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I define my object type so:</p>&#xA;&#xA;<pre><code>export const Job = prismaObjectType({&#xA;  name: 'Job',&#xA;  definition(t) {&#xA;    t.prismaFields([&#xA;      // ...&#xA;      'example',&#xA;      {&#xA;        name: 'selections',&#xA;      },&#xA;      // ...&#xA;    ])&#xA;  },&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>I do my resolver this way:</p>&#xA;&#xA;<pre><code>t.field('createJob', {&#xA;  type: 'Job',&#xA;  args: {&#xA;    // ...&#xA;    example: stringArg(),&#xA;    selections: stringArg(),&#xA;    // ...&#xA;  },&#xA;  resolve: (parent, {&#xA;    example,&#xA;    selections&#xA;  }, ctx) =&gt; {&#xA;    // The resolver where I do a ctx.prisma.createJob and connect/create with example&#xA;  },&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>So now in the resolver I can receive the selections as json string and then parse it and connect/create with the job.</p>&#xA;&#xA;<p>The mutation would look like this:</p>&#xA;&#xA;<pre><code>mutation {&#xA;  createJob(&#xA;    example: ""bla""&#xA;    selections: ""ESCAPED JSON HERE""&#xA;  ){&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I was wondering if there's anything more elegant where I could do something like:</p>&#xA;&#xA;<pre><code>mutation {&#xA;  createJob(&#xA;    example: ""bla""&#xA;    selections: {&#xA;       question: ""bla""&#xA;    }&#xA;  ){&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>or </p>&#xA;&#xA;<pre><code>mutation {&#xA;  createJob(&#xA;    example: ""bla""&#xA;    selections(data: {&#xA;      // ...&#xA;    })&#xA;  ){&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've noticed that with <a href=""https://github.com/prisma/nexus"" rel=""nofollow noreferrer"">nexus-prisma</a> you can do <code>stringArg({list: true})</code> but you can't really do objects. </p>&#xA;&#xA;<p>My main question is what is the most elegant way to do either nested mutation or connect all in one.</p>&#xA;",463065,,,,2022-10-04 14:08:06,How to do a nested mutation resolver with nexus-prisma,<graphql><prisma><prisma-graphql><nexus-prisma>,1,0,0,2019-04-24 06:58:00
55862560,2,,55862250,0,,"<p>Although it's not the best practice you can use <code>global</code> object like this:</p>&#xA;&#xA;<pre><code>global.host = host;&#xA;</code></pre>&#xA;&#xA;<p>And then use <code>global.host</code> wherever you need.</p>&#xA;&#xA;<p>Oficial docs <a href=""https://nodejs.org/api/globals.html#globals_global"" rel=""nofollow noreferrer"">global object</a></p>&#xA;",9110955,,,,2019-04-26 07:14:22,"",,0,1,0,2019-04-26 07:14:22
55862656,2,,55862250,0,,"<p>You can use <a href=""https://nodejs.org/api/globals.html#globals_global"" rel=""nofollow noreferrer""><strong>global</a></strong> object which is keyword in Node. </p>&#xA;&#xA;<pre><code>global.hostname = req.headers['host']&#xA;</code></pre>&#xA;&#xA;<p>and use it anywhere in app.</p>&#xA;",8707545,,,,2019-04-26 07:21:06,"",,0,0,0,2019-04-26 07:21:06
55863512,2,,55301676,2,,"<p>This will pretty much work, but keep in mind that <code>totalEntitiesCount</code> is not count of all entries in the table but only of those that match your cursor condition (<code>note.notedAt &gt; :after</code> or <code>note.notedAt &lt;= :before</code>). <code>gb.getManyAndCount()</code> internally removes any orderBy, limit, skip, etc. but keeps where conditions (see <a href=""https://github.com/typeorm/typeorm/blob/master/src/query-builder/SelectQueryBuilder.ts#L1728"" rel=""nofollow noreferrer"">this file</a>).</p>&#xA;&#xA;<p>Also IDK if relaying on <code>before</code> / <code>after</code> cursor to determine <code>hasNext</code> / <code>hasPrev</code> respectively is ok. If you'd pass first ID or date in the table to the <code>after</code> cursor you'd still get <code>hasPreviousPage = true</code> but in fact there would be none.</p>&#xA;&#xA;<p>You can see my take on this in <a href=""https://gist.github.com/VojtaSim/6b03466f1964a6c81a3dbf1f8cec8d5c"" rel=""nofollow noreferrer"">this gist</a>. The idea is to query results first and then create count query for totalCount and items before and after the results. Count query is cloned before applying where conditions. This allows to keep any previous conditions but avoid cursor condition. As a bonus you'll get count of next/prev items.</p>&#xA;&#xA;<p>It's still WIP, I haven't tested it yet.</p>&#xA;",2044543,,,,2019-04-26 08:17:23,"",,0,0,0,2019-04-26 08:17:23
55913500,1,55920826,,0,1218,"<p>I have a rather tricky question about GraphQl and multi-tenancy.</p>&#xA;<p>Let's assume there are 3 tables, <strong>OWNER</strong>, <strong>HOUSE</strong> and <strong>TENANTS</strong>. I will describe them in Sequelize and GraphQl pseudo code:</p>&#xA;<p>Owner table (has multiple houses and multiple tenants)</p>&#xA;<pre><code>const OWNER = sequelize.define('owner', {&#xA;  ownerId: type: Sequelize.INTEGER,&#xA;  name: type: Sequelize.STRING&#xA;}&#xA;&#xA;OWNER.associate = models =&gt; {&#xA;  models.owner.hasMany(models.house, {foreignKey: {name: 'ownerId', field: 'ownerId'}})&#xA;  models.owner.hasMany(models.tenant, {foreignKey: {name: 'ownerId', field: 'ownerId'}})&#xA;}&#xA;</code></pre>&#xA;<p>House table (belongs to owner and has multiple tenants)</p>&#xA;<pre><code>const HOUSE = sequelize.define('house', {&#xA;  houseId: type: Sequelize.INTEGER,&#xA;  ownerId: type: Sequelize.INTEGER,&#xA;  name: type: Sequelize.STRING&#xA;}&#xA;&#xA;HOUSE.associate = models =&gt; {&#xA;  models.house.belongsTo(models.owner, {foreignKey: {name: 'ownerId', field: 'ownerId'}})&#xA;  models.house.hasMany(models.tenant, {foreignKey: {name: 'houseId', field: 'houseId'}})&#xA;}&#xA;</code></pre>&#xA;<p>Tenant table (belongs to owner and house)</p>&#xA;<pre><code>const TENANT = sequelize.define('tenant', {&#xA;  tenantId: type: Sequelize.INTEGER,&#xA;  ownerId: type: Sequelize.INTEGER,&#xA;  houseId: type: Sequelize.INTEGER,&#xA;  name: type: Sequelize.STRING&#xA;}&#xA;&#xA;TENANT.associate = models =&gt; {&#xA;  models.tenant.belongsTo(models.owner, {foreignKey: {name: 'ownerId', field: 'ownerId'}})&#xA;  models.tenant.belongsTo(models.house, {foreignKey: {name: 'houseId', field: 'houseId'}})&#xA;}&#xA;</code></pre>&#xA;<p>The owner graphql object</p>&#xA;<pre><code>const OwnerType = new GraphQLObjectType({&#xA;  name: 'Owner',&#xA;  fields: () =&gt; ({&#xA;    ownerId: { type: GraphQLInt },&#xA;    name: { type: GraphQLString },&#xA;    houses: {&#xA;      type: GraphQLList(HouseType),&#xA;      resolve(owner) {&#xA;        return owner.getHouse()&#xA;      }&#xA;    },&#xA;    houseById: {&#xA;      type: HouseType,&#xA;      args: &lt;args is not defined&gt;&#xA;      resolve(owner) {&#xA;        return &lt;???&gt;&#xA;      }&#xA;    },&#xA;  })&#xA;})&#xA;</code></pre>&#xA;<p>Here are a few simple GraphQL queries:</p>&#xA;<pre><code>ownerById = {&#xA;  type: OwnerType,&#xA;  args: {&#xA;    ownerId: { type: GraphQLInt },&#xA;  },&#xA;  resolve(parents, args){&#xA;    return models.owner.findOne({ where: args })&#xA;  }&#xA;}&#xA;&#xA;houses = {&#xA;  type: GraphQLList(HouseType),&#xA;  resolve(parents, args){&#xA;    return models.house.findAll()&#xA;  }&#xA;}&#xA;&#xA;houseById = {&#xA;  type: HouseType,&#xA;  args: {&#xA;    houseId: { type: GraphQLInt },&#xA;  },&#xA;  resolve(parents, args){&#xA;    return models.house.findOne({ where: args })&#xA;  }&#xA;}&#xA;&#xA;tenants = {&#xA;  type: GraphQLList(TenantType),&#xA;  resolve(parents, args){&#xA;    return models.tenant.findAll()&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>These client queries work:</p>&#xA;<pre><code>{&#xA;  ownerById(ownerId: 1) {&#xA;    ownerId&#xA;    name&#xA;    house {&#xA;      houseId&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;{&#xA;  houseById(houseId: 2) {&#xA;    houseId&#xA;    name&#xA;    tenant {&#xA;      tenantId&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>What I need to make multi-tenancy to work is something like that:</p>&#xA;<pre><code>{&#xA;  ownerById(ownerId: 1) {&#xA;    ownerId&#xA;    name&#xA;    houseById(houseId: 2) {&#xA;      houseId&#xA;      name&#xA;      tenant {&#xA;        tenantId&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is there a way to archive this or is that out of scope what GraphQl can do?</p>&#xA;<p>If yes, how would the graphql object <code>houseById</code> query look like?</p>&#xA;<p>Thanks in advance.</p>&#xA;",4893825,,2308683,2022-03-03 22:27:45,2022-03-03 22:27:45,Is it possible to do a multi tenancy with Graphql and Sequelize?,<graphql><sequelize.js><multi-tenant>,1,3,0,2019-04-30 03:16:26
55920826,2,,55913500,1,,"<p>Unless I'm missing something, it seems like your resolver for <code>houseById</code> would not be that different from the resolver for the <code>houses</code> field on the same type.</p>&#xA;&#xA;<pre><code>houseById: {&#xA;  type: HouseType,&#xA;  args: {&#xA;    houseId: { type: GraphQLInt },&#xA;  },&#xA;  async resolve(owner, { houseId }) {&#xA;    const houses = await owner.getHouses({ where: { id: houseId } })&#xA;    return houses[0]&#xA;  }&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>For a <code>HasMany</code> association, the getter for the target model resolves to an array of instances. So we need to grab that array first and then return just the first item in it, since our field represents a single object and not a list. If you don't want to use async/await, you can also do:</p>&#xA;&#xA;<pre><code>return owner.getHouses({ where: { id: houseId } })&#xA;  .then(houses =&gt; houses[0])&#xA;</code></pre>&#xA;&#xA;<p>It would also be worth mentioning that this sort of pattern for a schema defies convention. Rather than having a <code>houses</code> field, a <code>houseById</code> field, a <code>houseBySomeOtherArg</code> field, etc., consider exposing a single <code>houses</code> field with one or more arguments like <code>id</code>, <code>name</code> or whatever filter criteria you want to provide. Your field can then just filter the houses based on whatever arguments are passed in, or return all results if no filter arguments were provided.</p>&#xA;",6024220,,,,2019-04-30 12:17:41,"",,0,1,0,2019-04-30 12:17:41
55926756,2,,55830930,1,,"<p>I don't think there's a solution, In my project, I need random order, increment/decrement, aggregation... use raw finally. </p>&#xA;",1050897,,,,2019-04-30 18:23:30,"",,0,0,0,2019-04-30 18:23:30
55930539,1,55953416,,0,273,"<p>I have been searching around for a while and been getting a lot of help from the SO community. But, it seems that the setup of my project isn't allowing normal queries such as sort, limit, filter, or others.</p>&#xA;&#xA;<p>I am querying a custom middleware/drupal site.</p>&#xA;&#xA;<p>Examples that throw errors:</p>&#xA;&#xA;<pre><code>{&#xA;  umdHub(limit: 5) {&#xA;    articles {&#xA;      data {&#xA;        id&#xA;        title&#xA;        subtitle&#xA;        body&#xA;        summary&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>or</p>&#xA;&#xA;<pre><code>{&#xA;  umdHub(&#xA;    sort: {&#xA;      fields: [authorship_date___time]&#xA;      order: ASC&#xA;    }&#xA;  ) {&#xA;    articles {&#xA;      data {&#xA;        id&#xA;        title&#xA;        subtitle&#xA;        body&#xA;        summary&#xA;        authorship_date {&#xA;          formatted_short&#xA;          unix&#xA;          unix_int&#xA;          formatted_long&#xA;          formatted_short&#xA;          time&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>All return errors in <a href=""http://localhost:8000/___graphql"" rel=""nofollow noreferrer"">http://localhost:8000/___graphql</a> like:</p>&#xA;&#xA;<pre><code>{&#xA;  ""errors"": [&#xA;    {&#xA;      ""message"": ""Unknown argument \""limit\"" on field \""umdHub\"" of type \""Query\""."",&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 2,&#xA;          ""column"": 10&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I resolve these issues?</p>&#xA;",4279496,,,,2019-05-02 13:19:08,normal graphql queries causing errors,<reactjs><graphql><gatsby>,2,1,0,2019-05-01 01:15:29
55930667,2,,55930539,2,,"<p>That because you don't have argument <code>limit</code> in on field <code>umdHub</code>. &#xA;To resolve, let's check your schema, on the <code>umdHub</code> field of type <code>Query</code>, and add <code>limit</code> arguments, then restart your server.</p>&#xA;&#xA;<p>Exemple:</p>&#xA;&#xA;<pre><code>type Query {&#xA;  umdHub(limit: Int, sort: SortInput) { // &lt;-- Add this&#xA;   articles&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8585114,,,,2019-05-01 01:37:21,"",,0,1,0,2019-05-01 01:37:21
55935022,1,55935500,,2,312,"<p>Relay <strong>createFragmentContainer</strong> is useful feature and it is easy to use:</p>&#xA;<pre><code>const MyComponent = createFragmentContainer(&#xA;    MyFragmentComponent,&#xA;    {&#xA;        job: graphql`&#xA;            fragment MyComponent_job on Job {&#xA;                id&#xA;            }&#xA;        `&#xA;    }&#xA;);&#xA;</code></pre>&#xA;<p>The problem is it really  hard to read code when query is at the end of my file. I prefer to have it at the top right after imports. Like this:</p>&#xA;<pre><code>const QUERY_FRAGMENT = graphql`&#xA;    fragment MyComponent_job on Job {&#xA;        id&#xA;    }     &#xA;`&#xA;// Main code here&#xA;&#xA;const MyComponent = createFragmentContainer(&#xA;    MyFragmentComponent,&#xA;    {&#xA;        job: QUERY_FRAGMENT&#xA;    }&#xA;);&#xA;</code></pre>&#xA;<p>But relay compiler throws error in that case: <code>FindGraphQLTags: 'createFragmentContainer' expects fragment definitions to be 'key: graphql'.</code></p>&#xA;<h3>Is there a way to separate <code>createFragmentContainer</code> and <code>graphql</code>?</h3>&#xA;",8163773,,-1,2020-06-20 09:12:55,2019-05-01 11:24:57,Relay: use constant inside Fragment instead of graphql`...`,<javascript><graphql><relayjs><relay>,1,0,0,2019-05-01 10:48:53
55935500,2,,55935022,1,,"<p>This seems to be a known issue with <code>babel-plugin-relay</code>. As noted in <a href=""https://github.com/facebook/relay/issues/1698"" rel=""nofollow noreferrer"">this issue</a>, the workaround is to change your imports:</p>&#xA;&#xA;<pre><code>import Relay, { graphql } from 'react-relay'&#xA;&#xA;const fragment = graphql`...`&#xA;&#xA;...&#xA;&#xA;Relay.createFragmentContainer(Component, fragment)&#xA;</code></pre>&#xA;",6024220,,,,2019-05-01 11:24:57,"",,0,0,0,2019-05-01 11:24:57
55939219,1,,,0,211,"<p>I am using graphiQL to debug my react project's graphql query. </p>&#xA;&#xA;<p>This is my query:</p>&#xA;&#xA;<pre><code>{&#xA;  testdataJson{&#xA;    E{&#xA;      D{&#xA;        A&#xA;        B&#xA;        entries&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>on dataset testdata.json:</p>&#xA;&#xA;<pre><code>{&#xA;  ""E"": [&#xA;    {&#xA;      ""D"": [&#xA;        [&#xA;          {&#xA;            ""A"": ""Y1"",&#xA;            ""entries"": [&#xA;              ""Z1""&#xA;            ]&#xA;          },&#xA;          {&#xA;            ""A"": ""Y2"",&#xA;            ""entries"": [&#xA;              ""Z2""&#xA;            ]&#xA;          }&#xA;        ],&#xA;        [&#xA;          {&#xA;            ""A"": ""Y3"",&#xA;            ""entries"": [&#xA;              ""Z3""&#xA;            ]&#xA;          },&#xA;          {&#xA;            ""A"": ""Y4"",&#xA;            ""entries"": [&#xA;              ""Z4""&#xA;            ],&#xA;            ""B"": true&#xA;          }&#xA;        ],&#xA;        [&#xA;          {&#xA;            ""A"": ""Y5"",&#xA;            ""entries"": [&#xA;              ""Z5""&#xA;            ],&#xA;            ""B"": true&#xA;          }&#xA;        ]&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which gives the error: <code>Cannot query field \""B\"" on type \""TestdataJsonED\"".</code></p>&#xA;&#xA;<p>If I change the snippet: </p>&#xA;&#xA;<pre><code>[&#xA;      {&#xA;        ""A"": ""Y1"",&#xA;        ""entries"": [&#xA;          ""Z1""&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""A"": ""Y2"",&#xA;        ""entries"": [&#xA;          ""Z2""&#xA;        ]&#xA;      }&#xA;],&#xA;</code></pre>&#xA;&#xA;<p>to </p>&#xA;&#xA;<pre><code>[&#xA;      {&#xA;       ""A"": ""Y1"",&#xA;       ""entries"": [&#xA;          ""Z1""&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""A"": ""Y2"",&#xA;        ""entries"": [&#xA;          ""Z2""&#xA;        ]&#xA;        ""B"": true&#xA;      }&#xA;],&#xA;</code></pre>&#xA;&#xA;<p>then everything is fine.</p>&#xA;&#xA;<p>This seems weird as I would expect to be able to have lists which don't necessarily contain at least one element with a ""B"" value. In fact, my JSON data (which I did not create) has this a lot. Alternatively, this is not the cause and I have done something silly!</p>&#xA;&#xA;<p>Cheers,</p>&#xA;&#xA;<p>Edit: related issue - <a href=""https://github.com/gatsbyjs/gatsby/issues/2392"" rel=""nofollow noreferrer"">https://github.com/gatsbyjs/gatsby/issues/2392</a></p>&#xA;",4474022,,4474022,2019-05-02 15:36:19,2019-05-02 15:36:19,graphiql only allows query if at least one element of each sublist contains queried field,<json><graphql>,0,5,0,2019-05-01 16:11:53
55948831,1,,,3,968,"<p>I'd like to be able to write a query that looks like this, using a human primary key rather than the opaque relay IDs:</p>&#xA;&#xA;<pre><code>query {&#xA;    issue(pk: 10) {&#xA;        pk&#xA;        state&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've been able to add the int <code>pk</code> field from the model; however, I haven't been able to figure out how to query it (and I'm a little confused about how I'd switch to a custom filterset for this).</p>&#xA;&#xA;<pre><code>from django.db import models&#xA;import graphene&#xA;from graphene import relay&#xA;&#xA;class Issues(models.Model):&#xA;    state = models.CharField(default='')&#xA;    text = models.TextField(default='')&#xA;&#xA;class IssueNode(DjangoObjectType):&#xA;   pk = graphene.Int(source='pk')&#xA;   class Meta:&#xA;       model = Issue&#xA;       interfaces = (relay.Node,)&#xA;       filter_fields = ['pk', 'state']&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    issue = relay.Node.Field(IssueNode)&#xA;    issues = DjangoFilterConnectionField(IssueNode)&#xA;</code></pre>&#xA;&#xA;<p>This will raise an error about <code>pk</code>:</p>&#xA;&#xA;<pre><code>TypeError: 'Meta.fields' contains fields that are not defined on this FilterSet: pk&#xA;</code></pre>&#xA;&#xA;<p>With this set up, I <em>can</em> write a query that looks like:</p>&#xA;&#xA;<pre><code>query {&#xA;    issue(id: 'ascadf2e31af=') {&#xA;        state&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but since the application previously used human readable IDs, I'd like to support that as well.</p>&#xA;&#xA;<p>Any ideas on how to set up a custom filterset or if there's a native way to do this with graphene-django?</p>&#xA;",1316786,,,,2019-08-06 06:39:26,Look up by primary key in graphene-django (with relay),<django><graphql><graphene-python><graphene-django>,1,0,0,2019-05-02 08:54:01
55949869,1,,,2,1314,"<p>I'm trying to run multiple independent queries from the same relay page, but I can't make it run properly. I have to run the fragment query in a child component while passing the props (resolved from query renderer) to the parent component and then to the child component. Below is my QueryRenderer code:</p>&#xA;&#xA;<pre><code>import React from ""react"";&#xA;import { graphql, QueryRenderer } from ""react-relay"";&#xA;import environment from ""../config/network"";&#xA;import ProductPerformance from ""../component/ProductPerformance"";&#xA;import moment from ""moment"";&#xA;&#xA;let ProductPerformancePageQuery = graphql`&#xA;  query ProductPerformancePageQuery(&#xA;    $first: Int&#xA;    $from: String&#xA;    $to: String&#xA;    $count: Int&#xA;    $offset: Int&#xA;    $searchTerm: String&#xA;    $filteredEntity: String&#xA;    $rating: String&#xA;    $searchCustomer: String&#xA;  ) {&#xA;    ...ProductPerformance_query&#xA;    ...customerSearch_chatCustomers&#xA;  }&#xA;`;&#xA;class ProductPerformancePage extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;div className=""container""&gt;&#xA;          &lt;QueryRenderer&#xA;            environment={environment}&#xA;            query={ProductPerformancePageQuery}&#xA;            variables={{&#xA;              from: moment(&#xA;                new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)&#xA;              ).format(""YYYY-MM-DD 00:00:00""),&#xA;              to: moment(new Date()).format(""YYYY-MM-DD 23:59:59""),&#xA;              count: 3,&#xA;              offset: 0,&#xA;              searchTerm: null,&#xA;              filteredEntity: null,&#xA;              rating: ""NEGATIVE"",&#xA;              searchCustomer: null&#xA;            }}&#xA;            render={({ error, props }) =&gt; {&#xA;              if (error) {&#xA;                return &lt;div&gt;{error}&lt;/div&gt;;&#xA;              }&#xA;              if (!props) {&#xA;                return &lt;div&gt;Loading.....&lt;/div&gt;;&#xA;              }&#xA;              return &lt;ProductPerformance query={props} chatCustomers={props} /&gt;;&#xA;            }}&#xA;          /&gt;&#xA;        &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default ProductPerformancePage;&#xA;</code></pre>&#xA;&#xA;<p>Parent Component's render function and graphql fragments:&#xA;(The &lt; CustomerSearch /> is the child component of this parent component where I ultimately need the props from the query renderer above.)</p>&#xA;&#xA;<pre><code>render() {&#xA;    console.log(""SEE HEREEE customers"", this.props.chatCustomers);&#xA;    console.log(""SEE HEREEE "", this.props.query);&#xA;&#xA;&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;h1&gt;Product Performance&lt;/h1&gt;&#xA;        &lt;Container&gt;&#xA;          &lt;Row&gt;&#xA;            &lt;Col&gt;&#xA;              &lt;FormGroup&gt;&#xA;                &lt;label&gt;Search Term:&lt;/label&gt;&#xA;                &lt;Input&#xA;                  type=""text""&#xA;                  name=""search""&#xA;                  placeholder=""Search Term""&#xA;                  value={this.state.searchTerm}&#xA;                  onChange={e =&gt; this.setState({ searchTerm: e.target.value })}&#xA;                  onKeyUp={event =&gt; this.handleEnter(event)}&#xA;                /&gt;&#xA;              &lt;/FormGroup&gt;&#xA;            &lt;/Col&gt;&#xA;            &lt;CustomerSearch chatCustomers={this.props.chatCustomers} /&gt;&#xA;          &lt;/Row&gt;&#xA;        &lt;/Container&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;module.exports = createRefetchContainer(&#xA;  ProductPerformance,&#xA;  graphql`&#xA;    fragment ProductPerformance_query on Query {&#xA;      ratedEntities(&#xA;        first: $first&#xA;        from: $from&#xA;        to: $to&#xA;        count: $count&#xA;        offset: $offset&#xA;        searchTerm: $searchTerm&#xA;        filteredEntity: $filteredEntity&#xA;        rating: $rating&#xA;      ) @connection(key: ""ProductPerformance_ratedEntities"") {&#xA;        edges {&#xA;          node {&#xA;            entity&#xA;            negative&#xA;            positive&#xA;            mixed&#xA;            neutral&#xA;          }&#xA;          cursor&#xA;        }&#xA;        totalCount&#xA;        pageInfo {&#xA;          endCursor&#xA;          startCursor&#xA;        }&#xA;      }&#xA;    }&#xA;  `,&#xA;  graphql`&#xA;    query ProductPerformanceQuery(&#xA;      $first: Int&#xA;      $from: String&#xA;      $to: String&#xA;      $count: Int&#xA;      $offset: Int&#xA;      $searchTerm: String&#xA;      $filteredEntity: String&#xA;      $rating: String&#xA;    ) {&#xA;      ...ProductPerformance_query&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>Child Component (Customer Search):</p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import { createFragmentContainer, graphql } from ""react-relay"";&#xA;import { Col, FormGroup } from ""reactstrap"";&#xA;&#xA;class CustomerSearch extends Component {&#xA;  constructor(props, context) {&#xA;    super(props, context);&#xA;    this.state = {&#xA;      uName: """"&#xA;    };&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;Col&gt;&#xA;          &lt;FormGroup&gt;&#xA;            &lt;label&gt;Customers:&lt;/label&gt;&#xA;            &lt;select&#xA;              className=""form-control t2mselectlist""&#xA;              type=""select""&#xA;              name=""Customer Search""&#xA;              value={this.state.customer}&#xA;              onChange={this.onCustomerSelect}&#xA;            &gt;&#xA;              //map for dropdown options&#xA;              &lt;option value=""NEGATIVE""&gt;Negative&lt;/option&gt;&#xA;            &lt;/select&gt;&#xA;          &lt;/FormGroup&gt;&#xA;        &lt;/Col&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;module.exports = createFragmentContainer(&#xA;  CustomerSearch,&#xA;  graphql`&#xA;    fragment customerSearch_chatCustomers on Query {&#xA;      chatCustomers(searchCustomer: $searchCustomer) {&#xA;        edges {&#xA;          node {&#xA;            customer_name&#xA;            customer_email&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `&#xA;);&#xA;</code></pre>&#xA;",3762961,,,,2019-05-02 09:54:08,How to run multiple queries from same page using relay and graphql?,<javascript><node.js><reactjs><graphql><relayjs>,0,1,0,2019-05-02 09:54:08
55950040,2,,55942454,0,,"<p>Edit&#xA;Ok I'm very sorry, I found that the problem was with my mongoose query limit:</p>&#xA;&#xA;<pre><code>Movie.find({}).skip(args.skip).limit(args.limit)&#xA;</code></pre>&#xA;&#xA;<p>Limit is simply my page size (number of records per page)</p>&#xA;&#xA;<pre><code>Movie.find({}).skip(args.skip).limit(args.per_page)&#xA;</code></pre>&#xA;",7838249,,7838249,2019-05-02 12:16:45,2019-05-02 12:16:45,"",,0,0,0,2019-05-02 10:03:32
55964944,2,,55961762,4,,"<p>Try using</p>&#xA;&#xA;<pre><code>createFragmentContainer(Component, {&#xA;  viewer: graphql`&#xA;    fragment UsersGrid_viewer on Query { ... }&#xA;  `&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>instead</p>&#xA;&#xA;<pre><code>createFragmentContainer(Component,&#xA;  graphql`&#xA;    fragment UsersGrid_viewer on Query { ... }&#xA;  `&#xA;)&#xA;</code></pre>&#xA;",1279744,,,,2019-05-03 07:16:22,"",,0,5,0,2019-05-03 07:16:22
55977640,1,56281561,,2,2989,"<p>Working on a React app with AWS Appsync and trying graphQL for the first time. My <code>schema.graphql</code> makes sense to me but throwing an error that I don't really know how to see what's going on.</p>&#xA;&#xA;<p>It's an app where users can make a post and comment with a notification system. Getting <code>Resource is not in the state stackUpdateComplete</code> error message on <code>amplify push</code></p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  following: [User]&#xA;  follower: [User]&#xA;  post: [Post] @connection(name: ""UserPost"")&#xA;  comment: [Comment] @connection(name: ""UserComment"")&#xA;  notification: [Notification] @connection(name: ""UserNotification"")&#xA;}&#xA;&#xA;type Post @model {&#xA;  id: ID!&#xA;  user: User! @connection(name: ""UserPost"")&#xA;  privacy: String!&#xA;  content: String!&#xA;  loved: [User]&#xA;  comment: [Comment] @connection(name: ""PostComment"")&#xA;}&#xA;&#xA;type Comment @model {&#xA;  id: ID!&#xA;  user: User! @connection(name: ""UserComment"")&#xA;  content: String!&#xA;  loved: [User]&#xA;  post: Post @connection(name: ""PostComment"")&#xA;}&#xA;&#xA;type Notification @model {&#xA;  id: ID!&#xA;  content: String!&#xA;  link: String!&#xA;  category: String!&#xA;  user: User! @connection(name: ""UserNotification"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Can anyone see anything wrong on my schema file and know how to debug the error in the best way on Appsync?</p>&#xA;",7724980,,4692302,2019-05-07 18:09:31,2019-05-23 19:08:40,AWS Appsync schema error (Resource is not in the state stackUpdateComplete),<amazon-web-services><graphql><aws-amplify><aws-appsync>,1,3,0,2019-05-03 22:09:22
56001993,1,56255808,,1,967,"<p>In my app I have a <code>mutation</code> where I want to use the <code>optimisticUpdater</code> to update the view before the server response. For that I need to remove some records from a list into the relay store, like that: </p>&#xA;&#xA;<pre><code>optimisticUpdater: storeProxy =&gt; {&#xA;  storeProxy.delete(recordDataID)&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem is that relay don't <strong>remove</strong> the record, but it transforms the record in <code>null</code>.&#xA;This can be annoying because I have to filter the list every time I use it in my app.</p>&#xA;&#xA;<p>Some one know how can I <strong>remove</strong> the record ?&#xA;thx</p>&#xA;",9390415,,,,2020-10-18 16:38:32,Relay Modern: delete record in optimisticUpdater,<reactjs><graphql><relayjs><relay><relaymodern>,2,0,0,2019-05-06 09:06:11
56016306,2,,56016111,1,,"<p>Just use <code>.find</code> instead of <code>.where</code> - <a href=""http://mongoosejs.com/docs/api.html#model_Model.find"" rel=""nofollow noreferrer"">doc</a> , your code will come to </p>&#xA;&#xA;<pre><code>authorModel.find({age: { $gte: 30 }})&#xA;</code></pre>&#xA;&#xA;<p>or we can instead write,</p>&#xA;&#xA;<pre><code>authorModel.where('age').gte(30)&#xA;</code></pre>&#xA;",5196394,,,,2019-05-07 05:54:38,"",,0,0,0,2019-05-07 05:54:38
56038784,2,,56037913,2,,"<p><code>apollo-server-express</code> already includes <code>body-parser</code> so you shouldn't add it again as middleware. Instead, you can pass <code>body-parser</code> options to Apollo when calling <code>applyMiddlware</code>:</p>&#xA;&#xA;<pre><code>server.applyMiddleware({&#xA;  app: WebApp.connectHandlers,&#xA;  path: '/graphql',&#xA;  bodyParserConfig: {&#xA;    limit: '100mb',&#xA;  },&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>See the <a href=""https://www.apollographql.com/docs/apollo-server/api/apollo-server#apolloserverapplymiddleware"" rel=""nofollow noreferrer"">docs</a> for a full list of available options.</p>&#xA;",6024220,,,,2019-05-08 10:38:00,"",,0,1,0,2019-05-08 10:38:00
56045563,2,,56044061,0,,"<p>The problem was in the selected method ""GET"", it worked when I selected the ""POST"" method.</p>&#xA;",5339534,,,,2019-05-08 16:51:38,"",,0,0,0,2019-05-08 16:51:38
56051119,2,,55947301,3,,"<p>GraphQL does not support arbitrary fields, there is a <a href=""https://github.com/graphql/graphql-spec/issues/101"" rel=""nofollow noreferrer"">RFC to support a <code>Map</code> type</a> but it has not been merged/approved into the specification. </p>&#xA;&#xA;<p>I see two possible workarounds that both require to change your schema a little bit.</p>&#xA;&#xA;<p>Say you have the following schema:</p>&#xA;&#xA;<pre class=""lang-gql prettyprint-override""><code>type Mutation {&#xA; saveBot(input: BotInput) : Boolean&#xA;}&#xA;&#xA;input BotInput {&#xA; id: ID!&#xA; title: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and the input object is: </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA; ""id"": ""123"",&#xA; ""title"": ""GoogleBot"",&#xA; ""unrelated"": ""field"",&#xA; ""ext_gps"": ""else""&#xA;}&#xA;</code></pre>&#xA;&#xA;<h3>Option 1: Pass the arbitrary fields as <a href=""https://docs.aws.amazon.com/appsync/latest/devguide/scalars.html"" rel=""nofollow noreferrer""><code>AWSJSON</code></a></h3>&#xA;&#xA;<p>You would change your schema to:</p>&#xA;&#xA;<pre class=""lang-gql prettyprint-override""><code>type Mutation {&#xA; saveBot(input: BotInput) : Boolean&#xA;}&#xA;&#xA;input BotInput {&#xA; id: ID!&#xA; title: String&#xA; arbitraryFields: AWSJSON  // this will contain all the arbitrary fields in a json string, provided your clients can pluck them from the original object, make a map out of them and json serialize it. &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So the input in our example would be now:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA; ""id"": ""123"",&#xA; ""title"": ""GoogleBot"",&#xA; ""arbitraryFields"": ""{\""unrelated\"": \""field\"", \""ext_gps\"": \""else\""}""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In your resolver, you could take the <code>arbitraryFields</code> string, deserialize it, and hydrate the values on the <code>BotInput</code> object before passing it to the data source.</p>&#xA;&#xA;<h3>Option 2: Pass the input as <code>AWSJSON</code></h3>&#xA;&#xA;<p>The principle is the same but you pass the entire <code>BotInput</code> as <code>AWSJSON</code>.</p>&#xA;&#xA;<pre class=""lang-gql prettyprint-override""><code>type Mutation {&#xA; saveBot(input: AWSJSON) : Boolean&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You don't have to do the resolver hydration and you don't have to change your client, but you lose the GraphQL type validation as the whole <code>BotInput</code> is now a blob.</p>&#xA;",1060799,,,,2019-05-09 01:49:39,"",,0,0,0,2019-05-09 01:49:39
56062548,1,,,0,393,"<p>Application: AWS AppSync&#xA;Database: DynamoDB&#xA;Auth: Cognito</p>&#xA;&#xA;<p>Partition Key: Id&#xA;Sort Key: Id</p>&#xA;&#xA;<p>Goal: Return a collection of records where the sort key matches one of the values in an array of strings.</p>&#xA;&#xA;<p>The partition key and sort key are used to organize parent/child relationships between content.  Root records have a generic Partition Key, which allows me to easily locate root records.  Example:</p>&#xA;&#xA;<p>PK: root&#xA;SK: id0001</p>&#xA;&#xA;<p>PK: root&#xA;SK: id0002</p>&#xA;&#xA;<p>PK: id0001&#xA;SK: id0003</p>&#xA;&#xA;<p>There are obviously other properties, but this demonstrates how I can quickly query for root records (anything with PK of root) or any children of a specific parent record (PK = parent id).</p>&#xA;&#xA;<p>I want to pass the following array:&#xA;[""id0001"", ""id0002""]&#xA;...and have it query for all root records where the SK contains one of the array values.</p>&#xA;&#xA;<p>1) I tried using contains in the query expressions, which generates an error.  Apparently contains can only be used in filters.&#xA;2) I tried moving the contains logic to a filter, which generates an error.  Apparently I can't filter on sort keys within a filter.</p>&#xA;&#xA;<p>Any assistance is greatly appreciated.</p>&#xA;",422967,,,,2019-05-09 15:12:19,How to filter graphql results where sort key is in an array of strings,<amazon-dynamodb><graphql><aws-appsync><dynamodb-queries><aws-appsync-ios>,0,3,0,2019-05-09 15:12:19
56098471,1,56098591,,0,64,"<p><strong>GraphQL schema</strong> </p>&#xA;&#xA;<p>Object inside an object</p>&#xA;&#xA;<p>Here's the <strong>Schema</strong>:</p>&#xA;&#xA;<pre><code>ingredients {&#xA;  id&#xA;  amount&#xA;  unit&#xA;  food {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My input and what is working so far</p>&#xA;&#xA;<pre><code>ingredients: [{&#xA;  id: 2,&#xA;  amount: ""1"",&#xA;  unit: ""BUND""&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>How do I assign food the name of e.g Noodles?</p>&#xA;",8526945,,8526945,2019-05-12 10:57:25,2019-05-12 11:04:44,Objects inside objects,<javascript><graphql>,1,1,0,2019-05-12 10:49:39
56098591,2,,56098471,0,,"<p>So, your <code>ingredients</code> is a <code>[]</code> list of <code>{}</code> objects. </p>&#xA;&#xA;<p>Each of the objects contained in <code>ingredients</code> contains a set of key/value pairs; e.g.: <code>id: 2, amount: ""1""</code>.</p>&#xA;&#xA;<p>One of these keys has as its value an <code>{}</code> object again.</p>&#xA;&#xA;<p>You can assign the key <code>food</code> the object with its key/value pairs as <code>{name: ""Noodles""}</code> as following:</p>&#xA;&#xA;<pre><code>ingredients: [{&#xA;  id: 2,&#xA;  amount: ""1"",&#xA;  unit: ""BUND"",&#xA;  food: {&#xA;    name: ""Noodles""&#xA;  }&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>Let me know how it goes :)</p>&#xA;",4603295,,,,2019-05-12 11:04:44,"",,0,1,0,2019-05-12 11:04:44
56103329,1,,,2,1542,"<p>I'm trying to make dynamic tabs in Material-ui.&#xA;My business domain is conferences. A conference runs over X days and every day there's a number of sessions being hosted.</p>&#xA;&#xA;<p>I need some way to show these sessions in tabs using Material-ui. Since the number of days a conference is running is not fixed i need the number of tabs to vary. Plus on every tab I want to show the sessions for the day.</p>&#xA;&#xA;<p>I'm using GraphQL, Apollo, React and Material-Ui.</p>&#xA;&#xA;<p>I have the following GraphQL schema defined:</p>&#xA;&#xA;<pre><code>    export default `&#xA;&#xA;   scalar Date&#xA;&#xA;   enum SortDirection {&#xA;    ASCENDING&#xA;    DESCENDING&#xA;}&#xA;&#xA;enum SortableSessionField {&#xA;    start_date&#xA;} &#xA;&#xA;&#xA;&#xA;  type Conference {&#xA;    id: ID!&#xA;    title: String!&#xA;    address: String!&#xA;    start_date: String&#xA;    end_date: String&#xA;    sessions: [Session]&#xA;  }&#xA;&#xA;  type Paper{&#xA;    id: ID!&#xA;    title: String!&#xA;  }&#xA;&#xA;  type Session {&#xA;     conference_session_id: ID!&#xA;     session_title: String&#xA;     session_no: String&#xA;     chair_name: String&#xA;     discussant_1_name: String&#xA;     discussant_2_name: String&#xA;     room_description:String&#xA;     start_date: String&#xA;     start_time: String&#xA;     end_time: String&#xA;     papers: [Paper]&#xA;  }&#xA;&#xA;&#xA;type Query {&#xA;    conferences: [Conference!]!&#xA;    sessions(conferenceId: ID!, day: String!&#xA;             sort: SortDirection = DESCENDING&#xA;             sortBy: SortableSessionField = start_date): [Session]&#xA;    conference(id: ID!): Conference &#xA;    session(id: ID!): Session&#xA;  }  &#xA;&#xA;&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>The interesting function here is:</p>&#xA;&#xA;<pre><code>sessions(conferenceId: ID!, day: String!&#xA;                 sort: SortDirection = DESCENDING&#xA;                 sortBy: SortableSessionField = start_date): [Session]&#xA;</code></pre>&#xA;&#xA;<p>Which given a conferenceid and a date returns all the sessions for the conference on that day. Testing in Graphql playground it returns the correct data.</p>&#xA;&#xA;<p>I have the following basic React page:</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import FullWidthTabs from '../components/Sessions'&#xA;&#xA;&#xA;class SessionsPage extends React.Component {&#xA;&#xA;    render() {&#xA;        return (&#xA;          &lt;div&gt;&#xA;              &lt;FullWidthTabs days={['2018-06-11', '2018-06-12', '2018-06-13']}/&gt;&#xA;          &lt;/div&gt;&#xA;&#xA;        );&#xA;    }&#xA;}&#xA;export default (SessionsPage);&#xA;</code></pre>&#xA;&#xA;<p>what it does is basically just sending three dates to the FullWidthTabs page i just stole directly from Material-UI and modified to suit my needs:</p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import PropTypes from 'prop-types';&#xA;import { withStyles } from '@material-ui/core/styles';&#xA;import SwipeableViews from 'react-swipeable-views';&#xA;import AppBar from '@material-ui/core/AppBar';&#xA;import Tabs from '@material-ui/core/Tabs';&#xA;import Tab from '@material-ui/core/Tab';&#xA;import Typography from '@material-ui/core/Typography';&#xA;import gql from 'graphql-tag'&#xA;import { graphql } from 'react-apollo'&#xA;import { Query } from 'react-apollo'&#xA;import SessionTab from '../components/SessionTab'&#xA;&#xA;&#xA;        function TabContainer( { children }) {&#xA;            return (&#xA;                    &lt;Typography component=""div"" style={{padding: 8 * 3}}&gt;&#xA;                        {children}&#xA;                    &lt;/Typography&gt;&#xA;                    );&#xA;        }&#xA;&#xA;        TabContainer.propTypes = {&#xA;            children: PropTypes.node.isRequired,&#xA;            dir: PropTypes.string.isRequired,&#xA;        };&#xA;&#xA;        const styles = theme =&gt; ({&#xA;                root: {&#xA;                    backgroundColor: theme.palette.background.paper,&#xA;                    width: 500,&#xA;                },&#xA;            });&#xA;&#xA;        class FullWidthTabs extends React.Component {&#xA;            state = {&#xA;                value: 0,&#xA;            };&#xA;&#xA;            handleChange = (event, value) =&gt; {&#xA;                this.setState({value});&#xA;            }&#xA;            ;&#xA;                    handleChangeIndex = index =&gt; {&#xA;                        this.setState({value: index});&#xA;                    }&#xA;            ;&#xA;        render() {&#xA;&#xA;&#xA;                const tabs = this.props.days.map((day) =&gt; {&#xA;                    return (&lt;Tab key={day.gridIndex} label={day} /&gt;)&#xA;                });&#xA;                const content = this.props.days.map((day) =&gt; {&#xA;                    return (&lt;TabContainer&gt;&lt;SessionTab conferenceId = ""57"" day={day}/&gt;&lt;/TabContainer&gt;)&#xA;                });&#xA;&#xA;                const {classes, theme} = this.props;&#xA;&#xA;                return (&#xA;                        &lt;div className={classes.root}&gt;&#xA;                            &lt;AppBar position=""static"" color=""default""&gt;&#xA;                                &lt;Tabs&#xA;                                    value={this.state.value}&#xA;                                    onChange={this.handleChange}&#xA;                                    indicatorColor=""primary""&#xA;                                    textColor=""primary""&#xA;                                    variant=""fullWidth""&#xA;                                    &gt;&#xA;                                    { tabs }&#xA;                                &lt;/Tabs&gt;&#xA;                            &lt;/AppBar&gt;&#xA;                            &lt;SwipeableViews&#xA;                                axis={theme.direction === 'rtl' ? 'x-reverse' : 'x'}&#xA;                                index={this.state.value}&#xA;                                onChangeIndex={this.handleChangeIndex}&#xA;                                &gt;&#xA;                                { content }&#xA;                            &lt;/SwipeableViews&gt;&#xA;                        &lt;/div&gt;&#xA;                        );&#xA;            }&#xA;        }&#xA;&#xA;        FullWidthTabs.propTypes = {&#xA;            classes: PropTypes.object.isRequired,&#xA;            theme: PropTypes.object.isRequired,&#xA;        };&#xA;&#xA;        export default withStyles(styles, {withTheme: true})(FullWidthTabs);&#xA;</code></pre>&#xA;&#xA;<p>This component receives (in this case) three dates from the HOC and should initalize the three tabs and put some session info on each tab.</p>&#xA;&#xA;<p>The component to show the session data is the SessionTab:</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import gql from 'graphql-tag'&#xA;import { graphql } from 'react-apollo'&#xA;import { Query } from 'react-apollo'&#xA;import ConferenceCard from '../components/ConferenceCard';&#xA;&#xA;const SESSIONS_QUERY = gql`&#xA; query sessions($id: ID!, $day: String!){&#xA;    sessions(conferenceId: $id, day: $day)&#xA;      {conference_session_id&#xA;       session_title&#xA;       start_date&#xA;       start_time&#xA;       end_time&#xA;     }&#xA;  }&#xA;`&#xA;&#xA;class SessionsTab extends React.Component {&#xA;    constructor(props) {&#xA;        super(props);&#xA;        console.log(props);&#xA;    }&#xA;&#xA;    render() {&#xA;        let id = this.props.conferenceId;&#xA;        let day = this.props.day;&#xA;        console.log(""SessionTab "" + id + ""  "" + day);&#xA;        return (&#xA;                &lt;Query query={SESSIONS_QUERY} variables={{id, day}}&gt;&#xA;                    {({ loading, error, data }) =&gt; {&#xA;                        if (loading)&#xA;                                return &lt;div&gt;Fetching&lt;/div&gt;&#xA;                            if (error)&#xA;                                return &lt;div&gt;Error&lt;/div&gt;&#xA;                            const sessionsToRender = data.sessions&#xA;                        return (&#xA;                           &lt;div&gt;&#xA;                              {sessionsToRender.map(session =&gt; &lt;div&gt; {session.conference_session_id} &lt;/div&gt;)}&#xA;                           &lt;/div&gt;&#xA;                        )&#xA;                    }}&#xA;                &lt;/Query&gt;&#xA;                )&#xA;    }&#xA;}&#xA;&#xA;export default (SessionsTab);&#xA;</code></pre>&#xA;&#xA;<p>The sessionTab receives a conferenceId and a Data and finds all the sessions for the day. Testing in GraphQL playground it works.</p>&#xA;&#xA;<p>Each SessionTab is intialized in the FullWidthTab like this:</p>&#xA;&#xA;<pre><code> const content = this.props.days.map((day) =&gt; {&#xA;                    return (&lt;TabContainer&gt;&lt;SessionTab conferenceId = ""57"" day={day}/&gt;&lt;/TabContainer&gt;)&#xA;                });&#xA;</code></pre>&#xA;&#xA;<p>where the days props contain the dates passed from the sessionpage.</p>&#xA;&#xA;<p>But it does not seem to work.</p>&#xA;&#xA;<p>My questions are:</p>&#xA;&#xA;<p>1) is this the right way to do things?&#xA;2) when run tab1 shows data while tab2 and tab3 shows error.</p>&#xA;&#xA;<p>I don't know what it wrong but it looks like the SessionTab are not correctly intialized except for the first one.</p>&#xA;&#xA;<p>Kim</p>&#xA;",887028,,887028,2019-05-12 21:04:21,2019-05-12 21:04:21,How to make dynamic tabs with Material-ui and GraphQL,<reactjs><graphql><material-ui><react-apollo>,0,0,0,2019-05-12 20:45:26
56111483,1,,,0,150,"<h3>GraphQL Nested Mutations</h3>&#xA;<p>How do I access created ingredients  key/value?</p>&#xA;<p>This's the <code>ingredients</code> query:</p>&#xA;<pre><code>ingredients{&#xA;    amount &#xA;    unit &#xA;    food{&#xA;      bls &#xA;     name &#xA;    kcal&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<pre><code>mutation {&#xA;  createRecipe(&#xA;    data: {&#xA;      title: &quot;ABC&quot;&#xA;      author: &quot;XYZ&quot;&#xA;      level:  EASY&#xA;      ingredients: {amount: 250, unit: GRAMM,  food:  {name: &quot;Flour&quot;, bls: &quot;xxx&quot;, kcal: 203}&#xA;       }&#xA;    }&#xA;</code></pre>&#xA;<h3>Resolver</h3>&#xA;<pre><code>Mutation: {&#xA;  createRecipe: (_, args) =&gt; {&#xA;    const newRecipe = {&#xA;      title: args.data.title,&#xA;      author: args.data.author,&#xA;      level: args.data.level,&#xA;      ingredients: args.........??????&#xA;    };&#xA;}&#xA;}&#xA;</code></pre>&#xA;<h3>Results</h3>&#xA;<pre><code>&quot;data&quot;: {&#xA;    &quot;createRecipe&quot;: {&#xA;      &quot;title&quot;: &quot;ABC&quot;,&#xA;      &quot;author&quot;: &quot;XYZ&quot;,&#xA;      &quot;level&quot;: &quot;EASY&quot;,&#xA;      &quot;ingredients&quot;: null,&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>How do I access <code>ingredients' amount, unit</code> then <code>ingredients food name,bls,kcal</code> and populate the ingredients array that is on gql playground?</p>&#xA;",8526945,,-1,2020-06-20 09:12:55,2019-05-15 12:52:19,How to access Nested Objects,<javascript><graphql>,0,4,0,2019-05-13 11:34:45
56117612,1,,,4,1449,"<p>I try to understand Graphql in django and use <code>graphene</code> and <code>graphene_django</code>.&#xA;My frontend will probably be built with Vuejs and Apollo client.&#xA;All the tutorials on the internet are about wether classic Graphql or Relay.&#xA;Relay with its Nodes and Edges seem to be advised (is it ?). &#xA;But Node and Edges are available with wether the interface <code>graphene.Node</code> or the interface <code>graphene.relay.Node</code>.</p>&#xA;&#xA;<p>Is there any difference between these two ?</p>&#xA;&#xA;<p>Complementary question : Is it a good practice to use node and edges, even though I wont use Relay/React ? Apollo docs are all about classic Graphql.</p>&#xA;&#xA;<p>Regards</p>&#xA;",7833014,,7833014,2019-05-13 21:53:43,2020-01-28 19:04:23,What is the difference between graphene.Node and graphene.relay.Node?,<django><graphql><graphene-python><graphene-django>,1,2,0,2019-05-13 17:58:50
56144197,2,,56143361,-1,,"<p><strong>SOLVED</strong></p>&#xA;&#xA;<p>Need to pass fragment before/after method call body <code>{}</code> in the same <strong>Query</strong>;</p>&#xA;&#xA;<pre><code>{""query"":""fragment pubInfo on Publisher {name licenseNumber contactNumber} {findPublisherByLicenseNumber(licenseNumber :\""UAE_DXB_CMH-971\"") {...pubInfo}}""}&#xA;</code></pre>&#xA;",2736849,,2736849,2019-05-16 06:12:58,2019-05-16 06:12:58,"",,0,1,0,2019-05-15 07:54:36
56167529,2,,54815466,2,,"<p>I was running into the same issue. So far, this seems to work for us:</p>&#xA;&#xA;<pre><code>{&#xA;    ""version"": ""2018-05-29"",&#xA;    ""statements"": [&#xA;        ""INSERT INTO customer_addresses (`id`, `customerid`, `firstname`, `lastname`) VALUES (NULL, :CUSTOMERID, :FIRSTNAME, :LASTNAME)"",&#xA;        ""SELECT * FROM customer_addresses WHERE id = LAST_INSERT_ID()""&#xA;    ],&#xA;    ""variableMap"": {&#xA;        "":CUSTOMERID"": $context.args.customerid,&#xA;        "":FIRSTNAME"": ""$context.args.input.firstname"",&#xA;        "":LASTNAME"": ""$context.args.input.lastname""&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",3970776,,,,2019-05-16 11:28:30,"",,0,1,0,2019-05-16 11:28:30
56171092,1,56225589,,8,2747,"<p>I have the following REST endpoints:</p>&#xA;&#xA;<blockquote>&#xA;  <p>/orders/{id}</p>&#xA;</blockquote>&#xA;&#xA;<pre><code>returns {&#xA;    orderId,&#xA;    orderItem,&#xA;    customerId&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>/customers/{id}</p>&#xA;</blockquote>&#xA;&#xA;<pre><code>returns {&#xA;   customerId,&#xA;   firstName,&#xA;   lastName&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am limited by these two endpoints, which are going to be wrapped in my graphql schema.</p>&#xA;&#xA;<p>I would like the following Schema:</p>&#xA;&#xA;<pre><code>type Order {&#xA;  orderId: ID!,&#xA;  orderItem: String,&#xA;  customer: Customer&#xA;}&#xA;&#xA;type Customer{&#xA;  customerId: ID!&#xA;  firstName: String!&#xA;  lastName: String!&#xA;}&#xA;&#xA;type Query {&#xA;  getOrder(id: String!): Order,&#xA;  getCustomer(id: String!): Customer&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm wondering if it is possible to have GraphQL resolve the Customer object in the Order type?  I understand that you cannot pass the result of a query into the parameter of another.</p>&#xA;&#xA;<p>I have considered the resolver of <code>getOrder</code> be:</p>&#xA;&#xA;<pre><code>const getOrderResolver = axios.get(`/orders/${id}`)&#xA;  .then((ordersRes) =&gt; {&#xA;    let customerId;&#xA;    if(ordersRes.data.customerId !== null) {&#xA;      customerId = ordersRes.data.customerId &#xA;      axios.get(`/customers/${customerId}`)&#xA;      .then((customerRes) =&gt; ({&#xA;        return {&#xA;          orderId: ordersRes.data.orderId&#xA;          orderItem: ordersRes.data.orderItem&#xA;          customer: {&#xA;            customerId: customerRes.data.customerId&#xA;            firstName: customerRes.data.firstName&#xA;            lastName: customerRes.data.lastName &#xA;          }&#xA;        }&#xA;      })&#xA;    } else {&#xA;      return {&#xA;          orderId: ordersRes.data.orderId&#xA;          orderItem: ordersRes.data.orderItem&#xA;          customer: null&#xA;      }&#xA;    }&#xA;    })&#xA;  })&#xA;</code></pre>&#xA;&#xA;<p><code>getCustomer</code> resolver</p>&#xA;&#xA;<pre><code>const getCustomerResolver = axios.get(`/customers/${customerId}`)&#xA;          .then((customerRes) =&gt; ({&#xA;            return {&#xA;                customerId: customerRes.data.customerId&#xA;                firstName: customerRes.data.firstName&#xA;                lastName: customerRes.data.lastName &#xA;            }&#xA;          })&#xA;</code></pre>&#xA;&#xA;<p>It seems with my solution, there will be the additional cost of always fetching the <code>Customer</code> type whether or not it is queried within the <code>getOrder</code> query.  Is it possible to rewrite my GraphQL schema in a way that GraphQL would be able to resolve the <code>Customer</code> type only when queried?</p>&#xA;&#xA;<p>The limitation of my given my <code>ORDERS</code> REST API only returns the <code>CustomerId</code>  makes it difficult to resolve in <code>getOrder</code>, since the <code>Customer</code> API requires a <code>customerId</code></p>&#xA;",1575719,,1575719,2019-05-16 16:04:36,2019-05-20 17:26:14,Can GraphQL optionally resolve a field given result of a query in resolver?,<javascript><ecmascript-6><graphql>,1,2,0,2019-05-16 14:38:52
56176429,1,56200332,,0,126,<p>I am not able to find anything that relates to how a response of a query can be ordered using a date. </p>&#xA;&#xA;<p>I want to be able to send an ordered response rather than make the front end make the query that needs ordering.</p>&#xA;,8588359,,,,2019-05-18 16:16:23,How to support ordering in GraphqlJava queries,<java><graphql><sql-order-by><graphql-java>,1,0,0,2019-05-16 20:51:21
56193104,1,,,0,170,"<p>I am using DynamoDB as my database. Since it's a NoSQL database, I store data in a certain way that doesn't fit the way I want to receive the data from GraphQL. I am fairly new to everything around GraphQL, Apollo and DynamoDB.</p>&#xA;&#xA;<p>If we set those schema as an exemple:</p>&#xA;&#xA;<pre><code>type App: { &#xA;  activities: [Activity] &#xA;}&#xA;&#xA;type Activity: { &#xA;  name: String!&#xA;  desc: String&#xA;}&#xA;&#xA;type Query {&#xA;  activity(name: String!): Activity&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My goal for my <code>activity</code> query is to get the activity going by the name provided. To get easy access, I store it this way in DynamoDB.</p>&#xA;&#xA;<pre><code>{ &#xA;  activities: {&#xA;    exempleName: {&#xA;      desc: 'exempleDesc'&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This way, I can easily find it by getting <code>activity.exempleName</code>, except now I get an object like this:</p>&#xA;&#xA;<pre><code>{ &#xA;  desc:'exempleDesc'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>when I need this to fit my schema:</p>&#xA;&#xA;<pre><code>{ &#xA;  name:'exempleName'&#xA;  desc:'exempleDesc'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What is the most efficient way of doing this? Keep in mind that it must be reused for many objects with different field names.</p>&#xA;",6174615,,6174615,2019-05-21 14:09:07,2019-05-21 14:09:07,Format data to fit GraphQL schema,<node.js><amazon-dynamodb><graphql><apollo><apollo-server>,0,4,0,2019-05-17 20:22:13
56228039,1,56243912,,1,439,"<p>I am new to both graphql &amp; AWS Amplify, so please forgive any ignorance :) </p>&#xA;&#xA;<p>I have a graphql schema like this:</p>&#xA;&#xA;<pre><code>type Location @model @auth(rules: [{allow: owner}]){&#xA;  street: String&#xA;  city: String&#xA;  state: String&#xA;  zip: String&#xA;}&#xA;&#xA;type Trip @model @auth(rules: [{allow: owner}]){&#xA;  id: String!&#xA;  ...&#xA;  location: Location&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm trying to create both the location and the trip at the same time with a mutation request like this:</p>&#xA;&#xA;<pre><code>mutation {&#xA;  createTrip(input: {&#xA;      id: ""someIdentifier"",&#xA;      location: {&#xA;        street: ""somewhere""&#xA;      }&#xA;  }) {&#xA;      id&#xA;      location {&#xA;        street&#xA;      }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But I'm getting an error like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": null,&#xA;  ""errors"": [&#xA;    {&#xA;      ""path"": null,&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 2,&#xA;          ""column"": 21,&#xA;          ""sourceName"": null&#xA;        }&#xA;      ],&#xA;      ""message"": ""Validation error of type WrongType: argument 'input' with value '...' contains a field not in 'CreateTripInput': 'location' @ 'createTrip'""&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Checking the generated <code>schema.graphql</code> file, I see that there is indeed no <code>location</code> object on the input model:</p>&#xA;&#xA;<pre><code>input CreateTripInput {&#xA;  id: String!&#xA;  ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I have amplify generate the proper input schema so that I can create both the Trip and the location objects at the same time?</p>&#xA;",2526141,,,,2019-05-21 17:52:30,AWS Amplify not generating proper graphql input depth,<amazon-web-services><graphql><aws-amplify><amplifyjs>,1,0,0,2019-05-20 20:53:08
56243912,2,,56228039,0,,"<p>I was able to get an answer from the aws-amplify team <a href=""https://github.com/aws-amplify/amplify-cli/issues/1499#issuecomment-494470702"" rel=""nofollow noreferrer"">here</a>. To summarize:</p>&#xA;&#xA;<p>Both Trip and Location have <code>model</code> directive. There isn't a @connection directive connecting the Trip with Location. The two options to ""resolving"" this is:</p>&#xA;&#xA;<p>Update the schema connecting the models if you want them to be in 2 separate tables and want the ability to query Trip based on Location. Using 2 separate table you won't be able to create both Trip and Location in a single mutation, though. For example:</p>&#xA;&#xA;<pre><code>type Location @model @auth(rules: [{allow: owner}]){&#xA;  street: String&#xA;  city: String&#xA;  state: String&#xA;  zip: String&#xA;  trips: Trip @connection(name:""TripLocation"")&#xA;}&#xA;&#xA;type Trip @model @auth(rules: [{allow: owner}]){&#xA;  id: String!&#xA;  location: Location @connection(name:""TripLocation"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The second option, if the Location data is very specific to a trip and you don't want to create a separate table, then get rid of @model directive from your Location type. Doing so would allow you to create Location as a part of same mutation.</p>&#xA;&#xA;<pre><code>type Location {&#xA;  street: String&#xA;  city: String&#xA;  state: String&#xA;  zip: String&#xA;&#xA;}&#xA;&#xA;type Trip @model @auth(rules: [{allow: owner}]){&#xA;  id: String!&#xA;  location: Location&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The later was the solution that I moved forward with.</p>&#xA;",2526141,,,,2019-05-21 17:52:30,"",,0,0,0,2019-05-21 17:52:30
56247671,1,56268112,,1,1517,"<p>I'm having troubles conditionally calling a mutation from a handler within my main render class. Unfortunately, I am unable to implement a submit button(limitations of project definition, my DOM inputs must dynamically render the new graph onChange) and have to verify conditions before allowing a mutation to execute, yet I seem to be unable to diagnose a fix for this!</p>&#xA;&#xA;<p>Below, you can find the parent component code. Note that the mutation is still within the validation handler, sitting there temporarily until a fix is established.</p>&#xA;&#xA;<p>I've also had a few of the apollo documentation tutorials pointed my way, but unfortunately they rely on a different project structure that I cannot replicate due to project limitations.</p>&#xA;&#xA;<p>Below, you can find the parent component code. Note that the mutation is still within the validation handler, sitting there temporarily until a fix is established.</p>&#xA;&#xA;<pre><code>import React, { Component } from ""react"";&#xA;import CurrencyInput from ""./CurrencyInput"";&#xA;import SliderInput from ""./SliderInput"";&#xA;import DisplayGraph from ""./DisplayGraph"";&#xA;import ""./InputGraphSection.css"";&#xA;import FrequencyInput from ""./FrequencyInput"";&#xA;import { Mutation } from ""react-apollo"";&#xA;import gql from ""graphql-tag"";&#xA;&#xA;const SAVINGS_MUTATION = gql`&#xA;    mutation savingsmutation(&#xA;        $paymentFrequency: Int!&#xA;        $initialDeposit: Float!&#xA;        $monthlyDeposit: Float!&#xA;        $interestRate: Float!&#xA;    ) {&#xA;        createSavings(&#xA;            paymentFrequency: $paymentFrequency&#xA;            initialDeposit: $initialDeposit&#xA;            monthlyDeposit: $monthlyDeposit&#xA;            interestRate: $interestRate&#xA;        ) {&#xA;            savings {&#xA;                months {&#xA;                    id&#xA;                    totalInterest&#xA;                    totalValue&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;&#xA;export default class InputGraphSectionContainer extends Component {&#xA;    constructor(props) {&#xA;        super(props);&#xA;        this.state = {&#xA;            savT: [{ x: 0, y: 0 }],&#xA;            intT: [{ x: 0, y: 0 }]&#xA;        };&#xA;    }&#xA;    handleComplete = ({ data: { createSavings } }) =&gt; {&#xA;        this.setState(prevState =&gt; ({&#xA;            savT: [&#xA;                ...prevState.savT,&#xA;                // month is inside the data returned by the API????&#xA;                { x: createSavings.savings.months.id, y: createSavings.savings.months.totalValue }&#xA;            ],&#xA;            intT: [&#xA;                ...prevState.intT,&#xA;                { x: createSavings.savings.months.id, y: createSavings.savings.months.totalInterest }&#xA;            ]&#xA;        }));&#xA;    };&#xA;    render() {&#xA;        const { savT, intT } = this.state;&#xA;        return (&#xA;            &lt;Mutation mutation={SAVINGS_MUTATION} onCompleted={this.handleComplete}&gt;&#xA;                {savingsmutation =&gt; (&#xA;                    &lt;InputGraphSection mutate={savingsmutation} savT={savT} intT={intT} /&gt;&#xA;                )}&#xA;            &lt;/Mutation&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;class InputGraphSection extends Component {&#xA;    constructor(props) {&#xA;        super(props);&#xA;        this.state = {&#xA;            initialDeposit: """",&#xA;            monthlyDeposit: """",&#xA;            interestRate: 0,&#xA;            paymentFrequency: """"&#xA;        };&#xA;    }&#xA;    componentDidUpdate({ mutate }, prevState) {&#xA;        console.log(this.state);&#xA;&#xA;        if (&#xA;            this.state.initialDeposit !== """" &amp;&amp;&#xA;            this.state.monthlyDeposit !== """" &amp;&amp;&#xA;            this.state.paymentFrequency !== """" &amp;&amp;&#xA;            prevState !== this.state&#xA;        ) {&#xA;            //If currencyInput elements are returning strings, convert to ints here.&#xA;            var paymentF = Number(this.state.paymentFrequency);&#xA;            var initialD = parseFloat(this.state.initialDeposit);&#xA;            var monthlyD = parseFloat(this.state.monthlyDeposit);&#xA;            var interestR = parseFloat(this.state.interestRate)/100;&#xA;&#xA;            console.log(""execute mutation"");&#xA;            mutate({&#xA;                variables: {&#xA;                    paymentFrequency: paymentF,&#xA;                    initialDeposit: initialD,&#xA;                    monthlyDeposit: monthlyD,&#xA;                    interestRate: interestR&#xA;                }&#xA;            });&#xA;            console.log(""Mutation query commencing"")&#xA;        } else {&#xA;            console.log(""Input Requirements not met, will not generate graph."");&#xA;        }&#xA;    }&#xA;    handleChange = evt =&gt; {&#xA;        const { name, value } = evt.target;&#xA;        this.setState({ [name]: value });&#xA;    };&#xA;&#xA;    render() {&#xA;        const {&#xA;            initialDeposit,&#xA;            monthlyDeposit,&#xA;            interestRate,&#xA;            paymentFrequency&#xA;        } = this.state;&#xA;        const { savT, intT } = this.props;&#xA;        return (&#xA;            &lt;div&gt;&#xA;                &lt;p className=""input-label""&gt;&#xA;                    Inputs must be positive and have no more than 15 digits with 2 decimal&#xA;                    places!&#xA;                &lt;/p&gt;&#xA;                &lt;div className=""financial-inputs""&gt;&#xA;                    &lt;p className=""input-label""&gt;What is your initial Deposit?&lt;/p&gt;&#xA;                    &lt;CurrencyInput&#xA;                        name=""initialDeposit""&#xA;                        value={initialDeposit}&#xA;                        onInputChange={this.handleChange}&#xA;                    /&gt;&#xA;                    &lt;p className=""input-label""&gt;How much will you save each month?&lt;/p&gt;&#xA;                    &lt;CurrencyInput&#xA;                        name=""monthlyDeposit""&#xA;                        value={monthlyDeposit}&#xA;                        onInputChange={this.handleChange}&#xA;                    /&gt;&#xA;                    &lt;p className=""input-label""&gt;&#xA;                        What is the annual interest rate you have acquired?&#xA;                    &lt;/p&gt;&#xA;                    &lt;SliderInput&#xA;                        name=""interestRate""&#xA;                        value={Number(interestRate)}&#xA;                        onInputChange={this.handleChange}&#xA;                    /&gt;&#xA;                    &lt;p className=""input-label""&gt;&#xA;                        Specify the frequency of interest compounding.&#xA;                    &lt;/p&gt;&#xA;                    &lt;FrequencyInput&#xA;                        name=""paymentFrequency""&#xA;                        value={paymentFrequency}&#xA;                        onInputChange={this.handleChange}&#xA;                    /&gt;&#xA;                &lt;/div&gt;&#xA;                &lt;div className=""financial-display""&gt;&#xA;                    &lt;DisplayGraph savT={savT} intT={intT} /&gt;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;}&#xA;&#xA;</code></pre>&#xA;",7724545,,7724545,2019-05-24 22:07:39,2019-05-24 22:07:39,Looking to conditionally call a mutation,<reactjs><apollo><react-apollo>,1,0,0,2019-05-21 23:55:32
56247727,1,,,0,23,"<p>I have a read-only stack of data that I cannot add an ID to. Therefore the only unique identifier I can use is a field ""name"". I was able to retrieve the data ok on a normal list screen. When I click on one of the items, it Routes to a page using that same identifier to name that screen (subfix the URL). Here's a sample of the query.</p>&#xA;&#xA;<pre><code>const ORDERS_QUERY = gql`&#xA;  query pizzaShop {&#xA;    pizzaSizes {&#xA;      name&#xA;      maxToppings&#xA;      basePrice&#xA;      toppings {&#xA;        defaultSelected&#xA;        topping {&#xA;          name&#xA;          price&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>When I query that with this (and having Routes imported of course). I do go to a new page localhost/name-here </p>&#xA;&#xA;<pre><code>&lt;Query query={ORDERS_QUERY}&gt;&#xA;      {({ loading, error, data }) =&gt; {&#xA;        if (loading) return &lt;h4&gt;Loading...&lt;/h4&gt;;&#xA;        if (error) console.log('error');&#xA;        return (&#xA;          &lt;div className='pizza-sizes'&gt;&#xA;            {data.pizzaSizes.map(pizzaSizes =&gt; (&#xA;               &lt;Link key={pizzaSizes.name} to={`/pizzaSize/${name}`}&gt;&#xA;                  &lt;button&gt;{name}&lt;/button&gt;&#xA;              &lt;/Link&gt;&#xA;            ))}&#xA;          &lt;/div&gt;&#xA;        );&#xA;      }}&#xA;&lt;/Query&gt;&#xA;</code></pre>&#xA;&#xA;<p>Now, here is the thing I'm having problems with. This new page that opens is supposed to show the props from that item only. So, bringing in the query for the stuff that needs to show on this page, here's the new query of items from GgraphQL. See Below. I normally do this with an id just fine, like this:</p>&#xA;&#xA;<pre><code>const SINGLE_ITEM_QUERY = gql`&#xA;    query sample($id: Int!) {&#xA;       parent(id: $id) {&#xA;          ...data here&#xA;       }&#xA;    }&#xA;`;&#xA;&#xA; //in render method...&#xA; let { id } = this.props.match.params;&#xA; id = parseInt(id); //becasue it may be saved as a string&#xA;</code></pre>&#xA;&#xA;<p>However, in this case the unique identifier is a string. but I'm getting nothing with this below, zilch, potatoes</p>&#xA;&#xA;<pre><code>const TOPPINGS_QUERY = gql`&#xA;    query orderQuery($name: String!) {&#xA;        pizzaSizes(name: $name) {                &#xA;           maxToppings&#xA;           basePrice&#xA;           toppings {&#xA;              defaultSelected&#xA;              topping {&#xA;                 name&#xA;                 price&#xA;              }&#xA;           }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>what am I missing? I wish I could give a demo but there is a lot of component dependency tying other stuff together that will just confuse this even more</p>&#xA;",2083766,,,,2019-05-22 00:04:27,"indexing through graphQL by a string, instead of ID in React/Apollo",<reactjs><graphql><react-apollo>,0,3,0,2019-05-22 00:04:27
56251153,2,,56250662,2,,"<p>I think you can add a statement to your reducer function to add the desired fields. I added the single line, and annotated the rest of the method so you can see what's going on:</p>&#xA;&#xA;<pre><code>const newBooks = books.reduce((acc, cv) =&gt; {&#xA;    // acc is an ""accumulation"" of the results so far.&#xA;    // cv is the next item that hasn't been processed.&#xA;&#xA;    // Search for author in ""accumulator"" array acc. Put results in arr.&#xA;    const arr = acc.filter(obj =&gt; {&#xA;      return obj.author === cv.author;&#xA;    });&#xA;&#xA;    if (arr.length === 0) {&#xA;      // Haven't seen this author, yet. Add new item to ""accumulator"" array.&#xA;      acc.push({ name: cv.author, born: cv.born, bookCount: 1 });&#xA;    } else {&#xA;      // This author already exists in ""accumulator"" array, referenced by arr[0].&#xA;      // Update pre-existing item.&#xA;      arr[0].bookCount += 1;&#xA;      arr[0].born = cv.born;  // &lt;-- This is the new code that is required.&#xA;    }&#xA;&#xA;    return acc;&#xA;}, []);&#xA;</code></pre>&#xA;",117030,,,,2019-05-22 07:09:38,"",,0,2,0,2019-05-22 07:09:38
56255808,2,,56001993,2,,"<p>You have to remove your records from the list</p>&#xA;&#xA;<pre><code>optimisticUpdater: (store) =&gt; {&#xA;    const listOfRecords = store.getRoot().getLinkedRecords('list')&#xA;    const newList = listOfRecords.filter(record =&gt; record.getDataID() !== recordDataID)&#xA;    store.getRoot().setLinkedRecords(newList, 'list')&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In this example I assume your list is placed at the root of your graph</p>&#xA;",11494476,,,,2019-05-22 11:26:40,"",,0,2,0,2019-05-22 11:26:40
56268443,1,56268601,,-4,167,"<p>I am new to javascript, and I am using SilverStripe, with GraphQL, which is giving me edges and nodes:</p>&#xA;<p>This is the array full of objects:</p>&#xA;<pre><code>Genre: [&#xA;  { ID: &quot;1&quot;, Title: &quot;English&quot;, StudySubject: { &quot;edges&quot;: [ { &quot;node&quot;: { &quot;ID&quot;: &quot;4&quot;, &quot;Title&quot;: &quot;English&quot;}}]}},&#xA;  { ID: &quot;2&quot;, Title: &quot;Maths&quot;, StudySubject: { &quot;edges&quot;: [ { &quot;node&quot;: { &quot;ID&quot;: &quot;4&quot;, &quot;Title&quot;: &quot;Maths&quot;}}]}},&#xA;]&#xA;</code></pre>&#xA;<p>I'm wondering if it's possible to remove the unneeded edge, and node from each object so I have less dot notation on my frontend?</p>&#xA;<p>I would ideally like it to look like</p>&#xA;<pre><code>Genre: [&#xA;  { ID: &quot;1&quot;, Title: &quot;English&quot;, StudySubject: { &quot;ID&quot;: &quot;4&quot;, &quot;Title&quot;: &quot;English&quot;}},&#xA;  { ID: &quot;2&quot;, Title: &quot;Maths&quot;, StudySubject: { &quot;ID&quot;: &quot;4&quot;, &quot;Title&quot;: &quot;Maths&quot;}},&#xA;]&#xA;</code></pre>&#xA;",2551591,,2551591,2020-09-21 03:37:32,2020-09-21 03:37:32,How do i remove an un-needed Key from a Javascript object?,<javascript><arrays><vue.js><graphql><silverstripe>,1,4,0,2019-05-23 05:14:28
56268601,2,,56268443,1,,"<p>Your input data is inaccurate. You cannot have repeated keys at the same level in a JSON data structure. The below answer is with modifications to your data structure.</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const data = [&#xD;&#xA;  {&#xD;&#xA;    ID: 1, &#xD;&#xA;    Subject: &#xD;&#xA;      {&#xD;&#xA;        edge : [&#xD;&#xA;          {node: {ID : 1, Title: ""English""}}&#xD;&#xA;        ]&#xD;&#xA;      }&#xD;&#xA;  }, &#xD;&#xA;  {&#xD;&#xA;    ID: 2, &#xD;&#xA;    Subject: {&#xD;&#xA;        edge: [&#xD;&#xA;           {node: {ID: 1, Title: ""Maths""}}&#xD;&#xA;        ]&#xD;&#xA;     }&#xD;&#xA;  }&#xD;&#xA;];&#xD;&#xA;&#xD;&#xA;const result = data.map(x =&gt; ({...x, Subject: x.Subject.edge[0].node}));&#xD;&#xA;console.log(result);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",5153944,,,,2019-05-23 05:32:34,"",,0,1,0,2019-05-23 05:32:34
56273444,1,56273812,,3,4936,"<p>I am trying to make test on Karate by using .graphql file and passing variables. On my graphql schema, I am trying to reuse fragment from another .graphql file. I tried following the explanation on <a href=""https://www.apollographql.com/docs/react/advanced/fragments#webpack-importing-fragments"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/advanced/fragments#webpack-importing-fragments</a> but when I run the Karate test with #import statement on .graphql file, the test failed saying the fragment is unknown.</p>&#xA;&#xA;<p>FindProfile.feature</p>&#xA;&#xA;<pre><code>@smoke&#xA;Feature: Test GraphQL FindTrendingProfiles&#xA;&#xA;    Background:&#xA;        * url 'https://192.168.0.0.1'&#xA;&#xA;    Scenario: FindTrendingProfiles Request&#xA;        Given def query = read('FindProfile.graphql')&#xA;        And def variables = { cursor: ""1"", cursorType: PAGE, size: 2 }&#xA;        And request { query: '#(query)', variables: '#(variables)' }&#xA;        When method post&#xA;        Then status 200&#xA;&#xA;</code></pre>&#xA;&#xA;<p>FindProfile.graphql</p>&#xA;&#xA;<pre><code>#import ""./Media.graphql""&#xA;&#xA;query FindProfile($cursor: String, $cursorType: CursorType!, $size: Int!) {&#xA;  FindProfile(cursor: $cursor, cursorType: $cursorType, size: $size) {&#xA;   edges{&#xA;        id&#xA;       profilePictureMedia{&#xA;               ...Media&#xA;             }&#xA;  }&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Media.graphql</p>&#xA;&#xA;<pre><code>    fragment Media on Media {&#xA;    id&#xA;    title&#xA;    description&#xA;  }&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I expect that I can reuse the fragment from another .graphql file, but the actual I cannot do that. Any help is greatly appreciated. Thank you.</p>&#xA;",2857357,,,,2019-05-23 11:01:50,Import Fragment from GraphQL File to Another GraphQL File Does Not Work,<graphql><karate>,1,0,0,2019-05-23 10:40:50
56282998,2,,54003825,18,,"<p>You can use this query to filter 2 <code>AWSDateTime</code>:</p>&#xA;&#xA;<pre><code>query {&#xA;  searchNotes(filter:{createdAt: { between: [""2018-12-27T00:00:00"", ""2019-01-27T00:00:00""]}}) {&#xA;    items{&#xA;      id&#xA;        title&#xA;      createdAt&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;",2940908,,2940908,2019-05-25 07:43:39,2019-05-25 07:43:39,"",,0,7,0,2019-05-23 21:12:48
56286888,1,56287140,,3,1198,"<p>I'm new to AppSync and trying to see how this works and what's the proper way to set this up.</p>&#xA;&#xA;<p>I created schema.graphql looks like below.</p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: String!&#xA;  following: [String]&#xA;  follower: [String]&#xA;  journals: [Journal] @connection(name: ""UserJournals"", sortField: ""createdAt"")&#xA;  notifications: [Notification] @connection(name: ""UserNotifications"", sortField: ""createdAt"")&#xA;}&#xA;&#xA;type Journal @model {&#xA;  id: ID!&#xA;  author: User! @connection(name: ""UserJournals"")&#xA;  privacy: String!&#xA;  content: AWSJSON!&#xA;  loved: [String]&#xA;  createdAt: String&#xA;  updatedAt: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and this created queries.js automatically by AppSync.</p>&#xA;&#xA;<pre><code>export const getUser = `query GetUser($id: ID!) {&#xA;  getUser(id: $id) {&#xA;    id&#xA;    following&#xA;    follower&#xA;    journals {&#xA;      items {&#xA;        id&#xA;        privacy&#xA;        content&#xA;        loved&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;    notifications {&#xA;      items {&#xA;        id&#xA;        content&#xA;        category&#xA;        link&#xA;        createdAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>I noticed that querying <code>getUser</code> only returns 10 <code>journals</code> items and not sure how to set that to more than 10 or proper way to query and add more journals into that 10 items that were queried by <code>getUser</code>.</p>&#xA;",7724980,,640607,2019-07-02 23:16:59,2019-07-02 23:16:59,AWS AppSync only returns 10 items on query on connection,<amazon-web-services><graphql><aws-appsync>,1,0,0,2019-05-24 06:21:52
56287911,2,,56270908,0,,<p>I've created custom query which return a fragment and seems the error gone.</p>&#xA;,3153799,,,,2019-05-24 07:38:16,"",,0,0,0,2019-05-24 07:38:16
56300255,1,,,0,55,"<p>I have a list of products from database and wants to update list by querying the products with passing some filter parameters to the Query component as variables.</p>&#xA;&#xA;<p>the problem is when I use refetch from Query component it renders the whole components, containing in Query component <code>&lt;Filter /&gt; &lt;ProductList /&gt;</code> and I am losing my previous state of these components cause of rendring as show in code in bellow  </p>&#xA;&#xA;<pre><code>  return (&#xA;    &lt;Query&#xA;      query={GET_FILTER_QUERY}&#xA;      pollInterval={160000}&#xA;      variables={{ input: {} }}&#xA;    &gt;&#xA;      {({ loading, error, data, refetch }) =&gt; {&#xA;        if (loading) return null&#xA;        if (data) {&#xA;          return (&#xA;            &lt;Fragment&gt;&#xA;              &lt;Filter refetch={refetch} filterData={data} /&gt;&#xA;              &lt;ProductList products={data} /&gt;&#xA;            &lt;/Fragment&gt;&#xA;          )&#xA;        }&#xA;      }}&#xA;    &lt;/Query&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>in filter component submitting the form I call refetch as bellow </p>&#xA;&#xA;<p><code>onSubmit={async formValue =&gt; { refetch({ input: formValue }) }}</code></p>&#xA;&#xA;<p>because of this problem instead of refetch I run my query manually using <code>&lt;ApolloConsumer&gt;</code> but I can't update the cash using client from <code>&lt;ApolloConsumer&gt;</code></p>&#xA;&#xA;<pre><code>  const { brands, types, suppliers, tags } = props.filterData&#xA;  const { refetch } = props&#xA;&#xA;  const mutators = {&#xA;    setSelector: (args, state, utils) =&gt; {&#xA;      utils.changeValue(state, args[0].key, () =&gt; args[0].value)&#xA;    }&#xA;  }&#xA;&#xA;  return (&#xA;    &lt;ApolloConsumer&gt;&#xA;      {client =&gt; (&#xA;        &lt;div className=""row mt-5 mb-5""&gt;&#xA;          &lt;FinalForm&#xA;            onSubmit={async formValue =&gt; {&#xA;              // refetch({ input: formValue })&#xA;              const { data } = await client.query({&#xA;                query: GET_FILTER_QUERY,&#xA;                variables: { input: formValue }&#xA;              })&#xA;&#xA;              // const stores = client.readQuery({ query: GET_PRODUCTS_QUERY })&#xA;&#xA;              return client.writeQuery({&#xA;                query: GET_FILTER_QUERY,&#xA;                data: {&#xA;                  getfilterProducts: data.getfilterProducts&#xA;                }&#xA;              })&#xA;              // console.log(stores)&#xA;            }}&#xA;            mutators={mutators}&#xA;            render={({ handleSubmit, form, values }) =&gt; (&#xA;              &lt;form onSubmit={handleSubmit} noValidate&gt;&#xA;                &lt;div className=""filter-controll""&gt;&#xA;                  &lt;div className=""filter-control-options""&gt;&#xA;                    &lt;ul className=""sellect-group""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;SearchBox&#xA;                          onChange={e =&gt; {&#xA;                            form.mutators.setSelector({&#xA;                              key: 'text',&#xA;                              value: e.target.value&#xA;                            })&#xA;                          }}&#xA;                        /&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                    &lt;ul className=""sellect-group""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;Select&#xA;                          name=""type""&#xA;                          classNamePrefix=""fiter-select""&#xA;                          className=""filter-select""&#xA;                          options={types}&#xA;                          placeholder=""Product type""&#xA;                          isClearable&#xA;                          onChange={type =&gt; {&#xA;                            form.mutators.setSelector({&#xA;                              key: 'type',&#xA;                              value: type.value&#xA;                            })&#xA;                          }}&#xA;                        /&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                    &lt;ul className=""sellect-group""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;Select&#xA;                          classNamePrefix=""fiter-select""&#xA;                          className=""filter-select""&#xA;                          options={brands}&#xA;                          placeholder=""All brands""&#xA;                          onChange={brand =&gt; {&#xA;                            form.mutators.setSelector({&#xA;                              key: 'brand',&#xA;                              value: brand.value&#xA;                            })&#xA;                          }}&#xA;                        /&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                    &lt;ul className=""sellect-group""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;Select&#xA;                          classNamePrefix=""fiter-select""&#xA;                          className=""filter-select""&#xA;                          options={suppliers}&#xA;                          placeholder=""All suppliers""&#xA;                          onChange={supplier =&gt; {&#xA;                            form.mutators.setSelector({&#xA;                              key: 'supplier',&#xA;                              value: supplier.value&#xA;                            })&#xA;                          }}&#xA;                        /&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                    &lt;ul className=""sellect-group""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;Select&#xA;                          classNamePrefix=""fiter-select""&#xA;                          className=""filter-select""&#xA;                          options={tags}&#xA;                          placeholder=""All tags""&#xA;                          isMulti&#xA;                          onChange={type =&gt; {&#xA;                            form.mutators.setSelector({&#xA;                              key: 'tags',&#xA;                              value: type.map(type =&gt; type.value)&#xA;                            })&#xA;                          }}&#xA;                        /&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                    &lt;ul className=""sellect-group ml-5x""&gt;&#xA;                      &lt;li&gt;&#xA;                        &lt;Button type=""submit""&gt;Apply filter&lt;/Button&gt;&#xA;                      &lt;/li&gt;&#xA;                    &lt;/ul&gt;&#xA;                  &lt;/div&gt;&#xA;                &lt;/div&gt;&#xA;              &lt;/form&gt;&#xA;            )}&#xA;          /&gt;&#xA;        &lt;/div&gt;&#xA;      )}&#xA;    &lt;/ApolloConsumer&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;",2620132,,2620132,2019-05-24 22:56:09,2019-05-25 08:10:10,How to update cash after running query manually using ApolloConsumer?,<javascript><reactjs><react-apollo><apollo-client>,1,0,0,2019-05-24 22:49:05
56314654,1,56314916,,5,4555,"<p>I have a tree structure. Let's say Folder for example.</p>&#xA;&#xA;<p>How do I query nested queries to N level using GraphQL.</p>&#xA;&#xA;<p>Let's take an example as I have following properties in class.</p>&#xA;&#xA;<pre><code>public class DocumentField&#xA;    {&#xA;        public int Id { get; set; }&#xA;&#xA;        public string Name { get; set; }&#xA;&#xA;        public List&lt;DocumentField&gt; Children { get; set; }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Server side is designed in a way that if children are there then it will include as children. But graphql layer is restricting it because my query which is following.</p>&#xA;&#xA;<p>Following query will not bring result of children.</p>&#xA;&#xA;<pre><code>query ($folderId: Int!) {&#xA;                              folder(folderId: $folderId) {&#xA;                                id,&#xA;                                name&#xA;                              }&#xA;                            }&#xA;</code></pre>&#xA;&#xA;<p>Following query gives error as: nested query Field children of type DocumentFieldICollection must have a sub selection</p>&#xA;&#xA;<pre><code>query ($folderId: Int!) {&#xA;                          folder(folderId: $folderId) {&#xA;                            id,&#xA;                            name,&#xA;                            children&#xA;                          }&#xA;                        }&#xA;</code></pre>&#xA;",9263418,,,,2019-05-26 15:33:09,Nested query to unknown level GraphQL,<graphql>,1,0,0,2019-05-26 15:01:58
56314916,2,,56314654,12,,"<p>GraphQL does not allow to query such recursive structure down to all levels dynamically. You have to explicitly specify how many levels that you want to query. For example , to query to down 4 levels , the query looks liked : </p>&#xA;&#xA;<pre><code>query ($folderId: Int!) {&#xA;  folder(folderId: $folderId) {&#xA;    id&#xA;    name&#xA;    children {&#xA;       id &#xA;       name&#xA;       children{&#xA;          id&#xA;          name&#xA;          children{&#xA;            id&#xA;            name&#xA;          }&#xA;       }&#xA;    }&#xA;  }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>You can use <a href=""https://github.com/graphql/graphql-spec/issues/91#issuecomment-254895093"" rel=""noreferrer""><code>fragment</code></a> to reduce some duplication in this query. For details , please see <a href=""https://github.com/graphql/graphql-spec/issues/91"" rel=""noreferrer"">this</a>.</p>&#xA;",339637,,,,2019-05-26 15:33:09,"",,0,1,0,2019-05-26 15:33:09
56316028,1,,,0,521,"<p>I have been using react and redux and everytime ,I make a call to some rest api in ComponentDidMount ,I can set a state with it and pass that state onto my child or change that state and play with it .&#xA;I can keep that data in my redux too and do all what i want .&#xA;I recently started using graphql and I see that as one fetches data inside render using a query , we render the data that we want to and so on .&#xA;But I am concerned as how instead of rendering it ,I can store it in some state ,play with it and then pass it down to the child .&#xA;I came acroos this link state in apollo but couldn't have a clear understanding of it as what it basically does ?&#xA;How to solve this issue of state management and playing with that state which is set by the data coming from the apollo .&#xA;I am really missing out this feature of </p>&#xA;&#xA;<pre><code>this.setState({&#xA;  data:(some api data )&#xA;)}&#xA;</code></pre>&#xA;",9141338,,,,2019-05-26 20:41:33,storing data in state when data is fetched using graphql and apollo client,<javascript><reactjs><graphql><apollo>,1,2,0,2019-05-26 17:50:55
56322284,1,56491520,,7,1850,"<p>What is the best way to keep order of nested objects in the schema.</p>&#xA;&#xA;<p>My schema:</p>&#xA;&#xA;<pre><code>type Article {&#xA;  id: ID! @id&#xA;  pages: [Page!]!&#xA;}&#xA;&#xA;type Page {&#xA;  id: ID! @id&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is how I'm trying to sort the pages(unsuccessfully):</p>&#xA;&#xA;<pre><code>  updateArticle({&#xA;    variables: {&#xA;      aricle.id,&#xA;      data: {&#xA;        pages: {&#xA;          connect: reorderPages(aricle.pages)&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>The resolver:</p>&#xA;&#xA;<pre><code> t.field(""updateArticle"", {&#xA;      type: ""Article"",&#xA;      args: {&#xA;        id: idArg(),&#xA;        data: t.prismaType.updateArticle.args.data&#xA;      },&#xA;      resolve: (_, { id, data }) =&gt; {&#xA;        return ctx.prisma.updateArticle({&#xA;          where: { id },&#xA;          data&#xA;        });&#xA;      }&#xA;    });&#xA;</code></pre>&#xA;&#xA;<p>I understand why this approach is wrong. I guess that the order should be written in the database by an order index in the connection table. I don't know how to process that by GraphQL/Nexus/Prisma/MySQL.</p>&#xA;",1685510,,1685510,2019-05-27 15:37:25,2019-06-07 11:11:30,Nexus-prisma: order nested connections,<javascript><graphql><prisma-graphql><nexus-prisma>,1,2,0,2019-05-27 08:25:26
56340948,1,63227062,,13,9137,"<p>I have made a bunch of React component calling GraphQL using the Query component and everything is working fine.</p>&#xA;&#xA;<p>In one component I need to have some initial data from the database, but without any visual representation.</p>&#xA;&#xA;<p>I have tried to use the query component but it seems to be triggered only on the render cycle. I have tried to package it into a function and call this function in the component that needs the data. But the code / query is not executed since there's no component to show.</p>&#xA;&#xA;<p>How do I go about getting this data from the database without a component?</p>&#xA;&#xA;<p>I can't find any documentation on how to solve this problem. But I can't be &#xA;the only one doing this.</p>&#xA;&#xA;<p>Is ApolloConsumer or ApolloProvider the answer to my problems?</p>&#xA;&#xA;<p>I'm working with conferences and sessions. A conference runs over a couple of days and each day has a number of sessions.</p>&#xA;&#xA;<p>What I'm trying to achieve is to render a page with X numbers of tabs one for each day. Each tab represents a day and it shows the number of sessions for the day.</p>&#xA;&#xA;<p>My sessions page:</p>&#xA;&#xA;<pre><code>    import React from 'react';&#xA;import FullWidthTabs from '../components/Sessions';&#xA;import SessionTab from '../components/SessionTab';&#xA;import BwAppBar2 from '../components/BwAppBar2';&#xA;import ConferenceDays from '../components/ConferenceDays';&#xA;&#xA;&#xA;class SessionsPage extends React.Component {&#xA;&#xA;    static async getInitialProps() {&#xA;        console.log(""GetInitProps SessionsPage"");&#xA;    }&#xA;&#xA;    render() {&#xA;        let a = ConferenceDays();&#xA;        return (&#xA;&#xA;                &lt;div&gt;&#xA;                    &lt;BwAppBar2 /&gt;&#xA;                    {a}&#xA;                     &lt;FullWidthTabs days={['2018-06-11', '2018-06-12', '2018-06-13']} day1={ &lt; SessionTab conferenceId = ""57"" day = '2018-06-11' / &gt; } &#xA;                                   day2={ &lt; SessionTab conferenceId = ""57"" day = '2018-06-12' / &gt; } day3={ &lt; SessionTab conferenceId = ""57"" day = '2018-06-13' / &gt; }&gt;&#xA;                    &lt;/FullWidthTabs&gt;&#xA;                &lt;/div&gt;&#xA;                );&#xA;        }&#xA;}&#xA;export default (SessionsPage);&#xA;</code></pre>&#xA;&#xA;<p>Here the dates have been hardcoded in the page just for testing.</p>&#xA;&#xA;<p>But order to know how many days the conference spans i'll have to find the conference and decide the start and end date and generate all the dates in between:</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react'&#xA;import { graphql } from 'react-apollo'&#xA;import { Query } from 'react-apollo'&#xA;import gql from 'graphql-tag'&#xA;import Link from '@material-ui/core/Link';&#xA;import { useQuery } from ""react-apollo-hooks"";&#xA;&#xA;import conferencesQuery from '../queries/conferences'&#xA;import { Table, Head, Cell } from './Table'&#xA;import ConferenceCard from './ConferenceCard';&#xA;import Grid from '@material-ui/core/Grid';&#xA;import Paper from '@material-ui/core/Paper';&#xA;import moment from 'moment';&#xA;&#xA;&#xA;const CONFERENCE_QUERY = gql`&#xA; query conference($conferenceId : ID!){&#xA;      conference(id: $conferenceId){&#xA;          title&#xA;          start_date&#xA;          end_date&#xA;     }    &#xA;}&#xA;`&#xA;let index = 0;&#xA;let loopDate = 0;&#xA;let dates = [];&#xA;let conferenceId = 57;&#xA;&#xA;const ConferenceDays = () =&gt; (&#xA;&lt;Query query={CONFERENCE_QUERY} variables={{conferenceId}}&gt;&#xA;    {({ loading, error, data }) =&gt; {&#xA;                        if (loading)&#xA;                            return &lt;div&gt;Fetching&lt;/div&gt;&#xA;                        if (error)&#xA;                            return &lt;div&gt;Error&lt;/div&gt;&#xA;                        const startDate = moment(data.conference.start_date, 'x');&#xA;                        const endDate = moment(data.conference.end_date, 'x');&#xA;&#xA;                        for (loopDate = parseInt(data.conference.start_date);&#xA;                                loopDate &lt; parseInt(data.conference.end_date);&#xA;                                loopDate += 86400000) {&#xA;&#xA;                            let aDate = moment(loopDate, 'x');&#xA;                            dates.push(aDate.format('YYYY-MM-DD').toString());&#xA;                        }&#xA;                        console.log(dates);&#xA;                        return(dates);&#xA;                    }}&#xA;&lt;/Query&gt;);&#xA;&#xA;export default ConferenceDays&#xA;</code></pre>&#xA;&#xA;<p>But is this approach incorrect? </p>&#xA;&#xA;<p>Would it be more correct to lift the ConferenceDates component up in the hierarchy?</p>&#xA;&#xA;<p>Kim</p>&#xA;",887028,,887028,2019-05-28 13:05:11,2021-07-13 11:54:34,How to call GraphQL outside a component,<reactjs><graphql><apollo>,5,0,0,2019-05-28 11:13:54
56371131,1,56371590,,0,2932,"<p>This is how my schema.graphql looks like.</p>&#xA;&#xA;<pre><code>type Post &#xA;  @model&#xA;  @auth(&#xA;    rules: [&#xA;      { allow: owner }&#xA;    ]&#xA;  ) {&#xA;  id: ID!&#xA;  author: User! @connection(name: ""UserPosts"")&#xA;  content: AWSJSON!&#xA;  createdAt: AWSDateTime&#xA;  updatedAt: AWSDateTime&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which generated GraphQL query showing below</p>&#xA;&#xA;<pre><code>export const listPosts = `query listPosts(&#xA;  $filter: ModelPostFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listPosts(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      author {&#xA;        id&#xA;        uuid&#xA;      }&#xA;      content&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>I'm calling <code>listPosts</code> to query list of Posts but not sure how to implement date range into below query that I'm using to get data.</p>&#xA;&#xA;<p><code>await API.graphql(graphqlOperation(queries.listPosts, {limit: 10, nextToken: nextToken}))</code></p>&#xA;&#xA;<p>Is it possible to add two strings <code>start: TODAY</code> and <code>end: 30 DAYS BEFORE TODAY</code> to the query above and get it returns 30 latest posts?</p>&#xA;",7724980,,,,2019-05-30 05:07:10,AWS AppSync - How to query data by date range(Today to 30 days before)?,<amazon-web-services><graphql><aws-appsync>,2,0,0,2019-05-30 03:09:34
56371935,2,,56371131,3,,"<p>I did not try the new <code>@key</code> directive mentioned by Richard.<br>&#xA;The solution I was using so far is to pass the parameter to the resolver and implement the query expression at resolver level.</p>&#xA;&#xA;<p>For example, to query all bookings in the future (when booking start date is > today), I used</p>&#xA;&#xA;<pre><code>#set( $todayString = $util.time.nowISO8601().substring(0, 10) )&#xA;{&#xA;  ""version"": ""2017-02-28"",&#xA;  ""operation"": ""Query"",&#xA;  ""query"": {&#xA;    ""expression"": ""guestId = :gId AND startDate &gt; :startDate"",&#xA;    ""expressionValues"": {&#xA;      "":gId"": $util.dynamodb.toDynamoDBJson($ctx.args.guestId),&#xA;      "":startDate"": $util.dynamodb.toDynamoDBJson($todayString)&#xA;    }&#xA;  },&#xA;  ""index"": ""guestId-startDate-index""&#xA;}&#xA;</code></pre>&#xA;",663360,,,,2019-05-30 05:07:10,"",,0,4,0,2019-05-30 05:07:10
56420064,1,56489322,,1,2339,"<p>From this schema.graphql below it returns 10 posts from the oldest post to latest when I query userPosts.</p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: String!&#xA;  posts: [Post] @connection(name: ""UserPosts"", sortField: ""createdAt"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How do I set this order to DESC so it returns latest 10 posts instead of oldest?</p>&#xA;",7724980,,,,2019-06-07 07:02:52,"AppSync query sortField: ""ceatedAt"" set to descending order",<amazon-web-services><graphql><aws-appsync>,1,0,0,2019-06-03 00:56:45
56448610,1,,,1,877,"<p>I'm having trouble filtering items in a GraphQL query in GatsbyJS. I thought I could create key-value pairs in the <code>context</code> section of <code>createPage</code> (like <code>currentDate</code> and <code>minusFiveDays</code> below) and then use them as arguments in page components, but it doesn't seem to be working.</p>&#xA;&#xA;<p>In <code>gatsby-node.js</code>:</p>&#xA;&#xA;<pre><code>        const currentDate = moment().format('YYYY-MM-DD');&#xA;        const minusFiveDays = moment()&#xA;            .subtract(5, 'days')&#xA;            .format('YYYY-MM-DD');&#xA;&#xA;        console.log('DATE', minusFiveDays); // this logs correctly&#xA;&#xA;        result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {&#xA;            createPage({&#xA;                path: node.frontmatter.slug,&#xA;                component: someContentTypeTemplate,&#xA;                context: {&#xA;                    // Can the names passed in here be accessed in&#xA;                    // graphql queries, prefixed with a dollar sign?&#xA;                    currentDate: currentDate,&#xA;                    minusFiveDays: minusFiveDays,&#xA;                },&#xA;            });&#xA;        });&#xA;</code></pre>&#xA;&#xA;<p>In my <code>src/pages/someContentType.js</code> file:</p>&#xA;&#xA;<pre><code>// TODO: this query doesn't work. No matter what condition I try to use&#xA;// for $minusFiveDays, it doesn't affect the output. The query does work in&#xA;// graphiql when I hard-code a string there like ""2018-11-01"".&#xA;export const pageQuery = graphql`&#xA;    query($minusFiveDays: Date) { // this is the key from the file above&#xA;        allMarkdownRemark(&#xA;            filter: {&#xA;                frontmatter: {&#xA;                    content_type: { eq: ""some_content_type"" }&#xA;                    start_date: { ne: null, gte: $minusFiveDays }&#xA;                }&#xA;            }&#xA;            sort: { order: ASC, fields: [frontmatter___start_date] }&#xA;        ) {&#xA;            edges {&#xA;                node {&#xA;                    id&#xA;                    frontmatter {&#xA;                        created_at&#xA;                        slug&#xA;                        title&#xA;                        start_date(formatString: ""DD MMMM YYYY"")&#xA;                        end_date&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Even if I hard-code it like this, it doesn't work, so the context doesn't appear to be getting passed into the component's GraphQL query:</p>&#xA;&#xA;<pre><code>                context: {&#xA;                    currentDate: currentDate,&#xA;                    minusFiveDays: ""2018-11-01"",&#xA;                },&#xA;</code></pre>&#xA;&#xA;<p>This <em>does</em> work in GraphiQL:</p>&#xA;&#xA;<pre><code>{&#xA;    allMarkdownRemark(filter: {frontmatter: {content_type: {eq: ""some_content_type""}, start_date: {ne: null, gte: ""2018-11-01""}}}, sort: {order: DESC, fields: [frontmatter___start_date]}) {&#xA;        edges {&#xA;            node {&#xA;                id&#xA;                    frontmatter {&#xA;                        created_at&#xA;                            slug&#xA;                            title&#xA;                            start_date(formatString: ""DD MMMM YYYY"")&#xA;                            end_date&#xA;                    }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I think my syntax must be wrong, but I'm new to GraphQL and Gatsby, and there are no error messages. <strong>EDIT:</strong> there is an error message when I change <code>Date</code> to <code>Date!</code>: <code>Variable ""$minusFiveDays"" of required type ""Date!"" was not provided.</code></p>&#xA;",1365699,,1365699,2019-06-05 18:33:50,2019-06-24 12:16:43,GraphQL Arguments in GatsbyJS from context in gatsby-node.js,<graphql><gatsby>,2,5,0,2019-06-04 17:20:11
56453386,2,,56176223,0,,"<p>Not sure why it is not generated in codegen - to create custom resolvers, did you manually edit on appsync console, or adding files under <code>/amplify/backend</code>? For the latter, it should codegen. If you did the former, consider do the latter.</p>&#xA;&#xA;<p>In your case, you can simply do below:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const GetNearbyZVL = `...` // the query that works in appsync console&#xA;&#xA;const data = await API.graphql(graphqlOperation(GetNearbyZVL, {filter: filter}));&#xA;</code></pre>&#xA;",7550592,,7550592,2019-06-05 04:35:37,2019-06-05 04:35:37,"",,0,0,0,2019-06-05 01:56:49
56466730,2,,56448610,0,,"<p>I think it may be because the value you are getting from this line:</p>&#xA;&#xA;<pre><code>const minusFiveDays = moment().subtract(5, 'days').format('YYYY-MM-DD');&#xA;</code></pre>&#xA;&#xA;<p>is not a <code>Date</code> type. From a little trial in console, it appears to be a string.</p>&#xA;&#xA;<p>If instead change it to:</p>&#xA;&#xA;<pre><code>$minusFiveDays: String!&#xA;</code></pre>&#xA;&#xA;<p>It might work, without seeing your project I can't tell for certain.</p>&#xA;",10996907,,,,2019-06-05 19:18:48,"",,0,2,0,2019-06-05 19:18:48
56483701,2,,56482350,0,,"<p>I think using two different <code>Mutation</code> components does not make sense. If I understand correctly, there can be two ways to solve your problem.</p>&#xA;&#xA;<ol>&#xA;<li>Using Apollo client <code>client.mutate</code> function to do manual mutation based on the state and set <code>mutation</code> and <code>variables</code> properties based on the new state. To access the client in current component, you need to pass along the client from parent component where it was created to child components where mutation is taking place.</li>&#xA;<li>Using single <code>Mutation</code> component inside <code>render</code> method of your component and setting <code>mutation</code> and <code>variables</code> attributes based on the <code>state</code> variable.</li>&#xA;</ol>&#xA;",4830612,,,,2019-06-06 19:10:01,"",,0,0,0,2019-06-06 19:10:01
56489116,1,,,11,7780,"<p>My <code>schema.graphql</code> file auto generated below query in <code>graphql/queries.js</code> file by running <code>amplify push</code> command.</p>&#xA;&#xA;<p>Here is the schema file that generates query automatically.</p>&#xA;&#xA;<p><strong>schema.graphql</strong></p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: String!&#xA;  uuid: String!&#xA;  following: [String]&#xA;  follower: [String]&#xA;  posts: [Post] @connection(name: ""Userposts"", sortField: ""createdAt"")&#xA;}&#xA;&#xA;type Post &#xA;  @model&#xA;  @auth(&#xA;    rules: [&#xA;      { allow: owner },&#xA;      { allow: groups, groups: [""Admin""] }&#xA;    ]&#xA;  ) {&#xA;  id: ID!&#xA;  author: User! @connection(name: ""Userposts"")&#xA;  status: Status!&#xA;  draft: Boolean&#xA;  content: AWSJSON!&#xA;  loved: [String]&#xA;  comments: [Comment] @connection(name: ""PostComments"", sortField: ""createdAt"")&#xA;  createdAt: AWSDateTime&#xA;    updatedAt: AWSDateTime&#xA;}&#xA;&#xA;enum Status {&#xA;  PRIVATE&#xA;  PUBLIC&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here's the queries generated by schema graphql.</p>&#xA;&#xA;<p><strong>queries.js</strong></p>&#xA;&#xA;<pre><code>export const getUser = `query GetUser($id: ID!) {&#xA;  getUser(id: $id) {&#xA;    id&#xA;    uuid&#xA;    following&#xA;    follower&#xA;    posts(limit: 10, sortDirection: DESC) {&#xA;      items {&#xA;        id&#xA;        privacy&#xA;        draft&#xA;        content&#xA;        loved&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;    notifications {&#xA;      items {&#xA;        id&#xA;        content&#xA;        category&#xA;        link&#xA;        createdAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>I added <code>(limit: 10, sortDirection: DESC)</code> to <code>posts</code> to get the 10 latest posts from the user but can't figure out how to pass <code>nextToken</code> value to get another 10 posts after the first query. </p>&#xA;&#xA;<p>How do I pass <code>nextToken</code> value to the posts so I can get next 10 posts?</p>&#xA;",7724980,,7724980,2019-06-07 15:53:15,2020-05-05 06:25:12,AppSync GraphQL query with nextToken,<graphql><aws-amplify><aws-appsync>,2,2,0,2019-06-07 06:37:27
56498113,1,,,2,1211,"<p>I am new to react.&#xA;For e.g, input value entered 1,2,3,4 and after the event onChange it takes only numbers, then I can&#xA;remove 4,3,2 with backspace but not 1. And in HTML DOM also, the 1 cannot be removed.</p>&#xA;&#xA;<pre><code> class House extends Component {&#xA;&#xA;    state = {&#xA;        room: null,&#xA;      };&#xA;&#xA;    componentDidMount() {&#xA;&#xA;        if (this.props.house.rent) {&#xA;          this.setState({ rent: this.props.house.rent });&#xA;        }&#xA;      }&#xA;&#xA;         onChange = (field, value, mutate) =&gt; {&#xA;            if (field === ""houseroom"") {&#xA;              value = parseInt(value.replace(/[@,]/g, """"));&#xA;&#xA;            }&#xA;&#xA;         mutate({&#xA;              variables: {&#xA;              },&#xA;            });&#xA; this.setState({&#xA;      [field]: value,&#xA;    });&#xA;          };&#xA;&#xA;&#xA;            render(){&#xA;     const {house} = this.props;&#xA;             &lt;SomeInput&#xA;&#xA;                        type=""text""&#xA;                        value={&#xA;                          (house.room&amp;&amp;&#xA;                            `$${house.room.toLocaleString(""en"")}`) ||&#xA;                          """"&#xA;                        }&#xA;                        onChange={e =&gt; {&#xA;                          e.target.placeholder = ""Room"";&#xA;                          this.onChange(""houseroom"", e.target.value, mutate);&#xA;                        }}&#xA;&#xA;        }&#xA;        /&gt;&#xA;&#xA;    }&#xA;</code></pre>&#xA;",11614946,,11614946,2019-06-09 00:56:30,2020-08-07 06:30:56,The cursor backspace doesn’t remove last char of number format in react,<reactjs><react-apollo>,2,4,0,2019-06-07 16:26:26
56505099,2,,56489116,6,,"<p>Assuming you are using the <code>graphqlOperation</code> helper method:</p>&#xA;&#xA;<pre><code>const newData = await API.graphql(graphqlOperation(listUser, { nextToken }));&#xA;</code></pre>&#xA;&#xA;<p>Here, <code>nextToken</code> from previous request is passed as an argument using <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015"" rel=""noreferrer"">object shorthand notation</a>.</p>&#xA;",8331756,,,,2019-06-08 09:28:12,"",,0,9,0,2019-06-08 09:28:12
56505387,1,,,2,525,"<p>I have a subscription for a new records in my relay paginationContainer component. When it retrieves a new record from backend I insert it into connection this way (inside an <code>updater</code> option of <code>requestSubscription</code>):</p>&#xA;&#xA;<pre><code>const newEdge = ConnectionHandler.createEdge(&#xA;  store,&#xA;  connection,&#xA;  newPostNode,&#xA;  'posts'&#xA;)&#xA;ConnectionHandler.insertEdgeBefore(connection, newEdge)&#xA;</code></pre>&#xA;&#xA;<p>It works correctly as i see a new inserted edge in <code>console.log(props.posts.edges)</code>.&#xA;However a <code>cursor</code> parameter of this new inserted edge is <code>undefined</code> while it's <code>node</code> parameter is a record itself, as i expect.</p>&#xA;&#xA;<p>I think it is not correct as each edge in connection must have a <code>cursor</code>.</p>&#xA;&#xA;<p>What is the correct way to insert a new edge into Relay connection so it includes a <code>cursor</code>?</p>&#xA;",10486137,,10486137,2019-06-08 11:47:19,2019-06-19 13:25:43,What is the correct way to insert an edge into relay connection?,<connection><graphql><graphql-js><relayjs><relay>,1,0,0,2019-06-08 10:09:45
56506167,2,,56491680,0,,"<p>You need to have the regex string as an input parameter to be used by the resolver, GraphQL is not going to do the filter for you, you need to do/call that logic in the resolver based on your inputs.</p>&#xA;&#xA;<p>Based on your example, you could have something like this on the schema and resolver:</p>&#xA;&#xA;<pre><code>type Node {&#xA;   name: String!&#xA;}&#xA;&#xA;type NodeQueries {&#xA;   nodes (filterRegEx :String): [Node]!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Once you have the input string on the resolver, the implementation of the filter mechanism is up to you.</p>&#xA;&#xA;<pre><code>const resolvers = {&#xA;...&#xA;NodeQueries: {&#xA;    nodes: (parent, params) =&gt; {&#xA;      const {filterRegEx} = params; // regex input string&#xA;&#xA;      const ar = ['one','two','three'];&#xA;&#xA;      // Create a RegExp based on the input, &#xA;      // Compare the with the elements in ar and store the result...&#xA;      // You might end up with ... res = ['one', 'three'];&#xA;      // Now map the result to match your schema:&#xA;&#xA;      return _.map(res, name =&gt; ({name}) ); // to end up with [{name: 'one'}, {name: 'three'}]&#xA;    }&#xA;}&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>}</p>&#xA;",8581745,,,,2019-06-08 12:00:08,"",,0,0,0,2019-06-08 12:00:08
56518809,2,,56518569,-5,,"<p>Yes, I think the first line of the mutation should look like this;</p>&#xA;&#xA;<pre><code>export const createStudent = `mutation CreateStudent($input: ID!)&#xA;</code></pre>&#xA;",5786924,,,,2019-06-09 22:23:05,"",,0,0,0,2019-06-09 22:23:05
56527086,2,,56521359,1,,"<p>Your query only returns a single node and filters are only for filtering nodes (and not the data within nodes).</p>&#xA;&#xA;<p>It looks like you trying to query only <code>content</code> that has <code>activityMeta.contentType === ""iframe-game""</code>.</p>&#xA;&#xA;<p>Are you able to split your json up into seperate files? If yes, then you can actually create different node types with <code>gatsby-transformer-json</code>.</p>&#xA;&#xA;<p>Assuming a folder structure of:</p>&#xA;&#xA;<pre><code>src/&#xA;  data/&#xA;    category.json&#xA;    content.json&#xA;    contentGroup.json&#xA;    menu.json&#xA;</code></pre>&#xA;&#xA;<p>you can create a different node type for each file like this:</p>&#xA;&#xA;<pre><code>    plugins: [&#xA;        {&#xA;          resolve: `gatsby-transformer-json`,&#xA;          options: {&#xA;            typeName: ({ node }) =&gt; {&#xA;              return node.relativePath.split('.').slice(0, -1).join('.')&#xA;            }&#xA;          }&#xA;        },&#xA;        ...&#xA;    ]&#xA;</code></pre>&#xA;&#xA;<p>and this will allow you to make separate queries such as <code>allCategory</code>, <code>allContent</code>, <code>allContentGropup</code>, <code>allMenu</code>.  </p>&#xA;&#xA;<p>Once you are at this point, you easily filter the <code>allContent</code> query to only match nodes if <code>node.activityMeta.contentType === ""iframe-game""</code> with the following query</p>&#xA;&#xA;<pre><code>    query MyQuery {&#xA;      allContent(filter: {activityMeta: {contentType: {eq: ""iframe-game""}}}) {&#xA;        nodes {&#xA;          name&#xA;          activityMeta {&#xA;            contentType&#xA;            contentLink&#xA;            inScene&#xA;            backgroundImages {&#xA;              path&#xA;            }&#xA;          }&#xA;          type&#xA;          link&#xA;          description&#xA;          content {&#xA;            score&#xA;            gameOverTitle&#xA;            gameOverProgress&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;",5385381,,5385381,2019-06-11 08:07:25,2019-06-11 08:07:25,"",,0,0,0,2019-06-10 13:10:23
56531717,2,,55695632,3,,"<p>This worked</p>&#xA;&#xA;<pre><code>   query = """"""&#xA;        {&#xA;          advertiserCommissions(forAdvertisers: ""inputID"",sinceEventDate: ""%s"",&#xA;            beforeEventDate: ""%s"")  {&#xA;          records {&#xA;            commissionId&#xA;            orderDiscountPubCurrency&#xA;            aid&#xA;            orderId&#xA;            postingDate&#xA;            lockingDate&#xA;            actionStatus&#xA;            advertiserId&#xA;            advertiserName&#xA;            saleAmountUsd&#xA;            originalActionId&#xA;            pubCommissionAmountUsd&#xA;            cjFeeUsd&#xA;            actionTrackerId&#xA;            actionType&#xA;            eventDate&#xA;            original&#xA;            actionTrackerName&#xA;        }&#xA;          limit&#xA;          maxCommissionId&#xA;          payloadComplete&#xA;          count&#xA;        }&#xA;        }&#xA;        """""" % (beginDate, endDate)&#xA;</code></pre>&#xA;",4450310,,,,2019-06-10 18:29:14,"",,0,1,0,2019-06-10 18:29:14
56552911,1,,,0,131,"<p>With Prisma, </p>&#xA;&#xA;<p>How can we order by the numbers of childs (nested)? </p>&#xA;&#xA;<p>Examples: &#xA;Let's assume we have 2 objects: Post and Comment. 1 Post has many comments.</p>&#xA;&#xA;<p>What is the query to get All posts order by the number of comments? </p>&#xA;",5449450,,5449450,2019-06-12 18:28:46,2019-06-14 09:50:48,Prisma: How can we order by the numbers of Childs? (GraphQL),<graphql><prisma>,1,0,0,2019-06-11 23:38:34
56574629,1,,,1,396,"<p>I am trying to implement GraphQL mutation/query in my react application, using 'react-apollo' Mutation/Query component. The queries are working fine on their own and on the server side but I am getting a <strong>POST <a href=""http://localhost:4000/graphql"" rel=""nofollow noreferrer"">http://localhost:4000/graphql</a> 400 (Bad Request)</strong> when sending variables via 'react-apollo' Mutation/Query.</p>&#xA;&#xA;<p>Here's the code to my Schema on server side:</p>&#xA;&#xA;<pre><code>import { gql } from 'apollo-server-express';&#xA;&#xA;export default gql`&#xA;&#xA;    type Edge {&#xA;        node: [BusinessDevelopment!] &#xA;    }&#xA;&#xA;    type PageInfo {&#xA;        endCursor: String&#xA;        hasNextPage: Boolean!&#xA;    }&#xA;&#xA;    type BusinessDevelopmentResultCursor {&#xA;        edges: Edge!&#xA;        pageInfo: PageInfo!&#xA;    }&#xA;&#xA;    type BusinessDevelopment {&#xA;        id: ID!&#xA;        firstName: String!&#xA;        lastName: String!&#xA;        phone: String!&#xA;        email: String&#xA;        state: State!&#xA;        active: Boolean!&#xA;        admin: Boolean!&#xA;        regionAdmin: Boolean!&#xA;        createdBy: User&#xA;        createdOn: Date!&#xA;        lastModifiedOn: Date!&#xA;        department: String!&#xA;    }&#xA;&#xA;    extend type Query {&#xA;        allBusinessDevelopment(&#xA;            cursor: String&#xA;            limit: Int&#xA;            byMe: Boolean&#xA;        ): BusinessDevelopmentResultCursor&#xA;    }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Here's the code to my Query on client side:</p>&#xA;&#xA;<pre><code>import gql from 'graphql-tag'&#xA;import * as fragments from './../fragments'&#xA;&#xA;export default gql`&#xA;    query (&#xA;        $cursor: String!,&#xA;        $limit: Int!,&#xA;        $byMe: Boolean!&#xA;    ) {&#xA;        allBusinessDevelopment(&#xA;            cursor: $cursor,&#xA;            limit: $limit,&#xA;            byMe: $byMe&#xA;        ) {&#xA;            edges {&#xA;                node {&#xA;                    ...Emlpoyee&#xA;                }&#xA;            },&#xA;            pageInfo {&#xA;                endCursor,&#xA;                hasNextPage&#xA;            }&#xA;        }&#xA;    }&#xA;    ${fragments.employee}&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Here's me using the query using 'react-apollo' Query Component:</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import { Query } from 'react-apollo';&#xA;&#xA;import { getPersonaleAllQuery } from '../../../../../graphql/remoteQueries'&#xA;&#xA;const PersonaleAll = (me) =&gt; {&#xA;    // ONLY BY admin&#xA;    const currentUser = me.me;&#xA;&#xA;    if (currentUser.admin) {&#xA;        return (&#xA;            &lt;&gt;&#xA;                &lt;Query&#xA;                    query={getPersonaleAllQuery}&#xA;                    variables={{&#xA;                        cursor: 'null',&#xA;                        limit: 10,&#xA;                        byMe: false&#xA;                    }}&#xA;                &gt;&#xA;                    {({loading, error, data}) =&gt; {&#xA;                        if (loading) return &lt;div&gt;Loading...&lt;/div&gt;&#xA;                        if (error) return &lt;div&gt;Error&lt;/div&gt;&#xA;                        if (data) {&#xA;                            console.log(data);&#xA;                        }&#xA;                    }}&#xA;                &lt;/Query&gt;&#xA;            &lt;/&gt;&#xA;        );&#xA;    }&#xA;    return &lt;h3&gt;Not authorise .!..&lt;/h3&gt;&#xA;}&#xA;&#xA;export default PersonaleAll;&#xA;</code></pre>&#xA;",11347517,,,,2019-06-13 06:37:39,Error when passing variables to graphql query/mutation using react-apollo Query & Mutation components,<reactjs><graphql><react-apollo>,0,2,0,2019-06-13 06:37:39
56605813,2,,56355600,8,,<p>I think you can use graphQL fragments to solve your issue. Apollo should generate the same fragment class for each of your queries.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>fragment AllowedPeriodFragment on AllowedPeriod {&#xA;    startsAt&#xA;    endsAt&#xA;}&#xA;&#xA;query GetDevicesQuery() {&#xA;    devices {&#xA;        allowedPeriod { &#xA;            ...AllowedPeriodFragment &#xA;        }&#xA;    }&#xA;&#xA;    actions {&#xA;        allowedPeriod { &#xA;            ...AllowedPeriodFragment &#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The generated fragment can be accessed through the fragments() method.</p>&#xA;&#xA;<p>It should look something like:&#xA;<code>device.fragments().allowedPeriodFragment()</code> or <code>action.fragments().allowedPeriodFragment()</code></p>&#xA;,3308320,,3308320,2019-06-14 22:39:15,2019-06-14 22:39:15,"",,0,1,0,2019-06-14 22:30:15
56623117,1,56623566,,1,1894,"<p>In my database (postgres) I store a table of events and each event has an ""id"" column which is a UUID type. But when I send a GraphQL query the id I receive back is not a string UUID but looks like some encrypted version. </p>&#xA;&#xA;<p>I'm using Relay and Graphene on the server side if that information helps.</p>&#xA;&#xA;<pre><code>query {&#xA;  allEvents {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&#xA;{&#xA;  ""data"": {&#xA;    ""allEvents"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""RXZlbnQ6NzRkZTIxZmUtZWQyNy00OTg1LTk2NjEtNmU4ZDUzMGEwMjQ3""&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;",11656332,,7385033,2019-06-17 00:36:27,2022-05-26 09:53:11,Are ids automitaclly encrypted in Graphql queries?,<graphql><relay>,1,0,0,2019-06-16 22:42:13
56658086,1,,,5,1465,"<p>I'm trying to add Apollo to an app. I'll be using it for fetching data, and want to follow best practices and use the new API (as of Apollo 2.5) to store local UI state as well. </p>&#xA;&#xA;<p>I've been looking at <a href=""https://www.apollographql.com/docs/react/essentials/local-state/"" rel=""nofollow noreferrer"">these docs</a>, but their UI state is simpler than the one I want to implement. </p>&#xA;&#xA;<p>I want to port over a pattern I've been using in Redux apps, where the values of many UI elements are stored centrally. In Redux, I've had a reducer object which stored my UI values, and looked like this:</p>&#xA;&#xA;<pre><code>{&#xA;  dropdowns: {&#xA;    someDropdown: [{ index: 0, value: 'Selected Value' }]&#xA;  },&#xA;  checkboxes: {&#xA;    someCheckbox: true&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>As in, different types of elements were represented as objects for which each key was the unique ID of a UI element, and the value varied based on the element type. </p>&#xA;&#xA;<p>I'm also open to a flattened version of the above, where there are no sub-categorizations by UI element type. </p>&#xA;&#xA;<p>I also had a separate reducer storing the <em>state</em> of some UI elements, eg:</p>&#xA;&#xA;<pre><code>{&#xA;  openDropdownId: 'someDropdown',&#xA;  openModalId: null&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>Crucially, it seems, this data includes objects whose keys are not predictable. I'm both unsure how to type this using <code>gql</code> and unsure how to fetch this data efficiently (see bottom of question).</p>&#xA;</blockquote>&#xA;&#xA;<p>I've tried reproducing this with Apollo Client, but have run into a ton of errors. Here's my client setup:</p>&#xA;&#xA;<blockquote>&#xA;  <p>For, say, a dropdown, the idea is that <code>states</code> here stores open/closed state , whereas <code>values</code> stores info about the selected value.</p>&#xA;</blockquote>&#xA;&#xA;<pre><code>import { ApolloClient } from 'apollo-client';&#xA;import { InMemoryCache } from 'apollo-cache-inmemory';&#xA;import gql from 'graphql-tag';&#xA;&#xA;const typeDefs = gql`&#xA;  extend type UI {&#xA;    states: Object&#xA;    values: Object&#xA;  }&#xA;`;&#xA;&#xA;const defaults = {&#xA;  ui: {&#xA;    __typename: 'UI',&#xA;    states: {},&#xA;    values: {}&#xA;  }&#xA;};&#xA;&#xA;const cache = new InMemoryCache();&#xA;const client = new ApolloClient({&#xA;  cache,&#xA;  resolvers: {},&#xA;  typeDefs&#xA;});&#xA;&#xA;console.log({ defaults });&#xA;cache.writeData({ data: defaults });&#xA;&#xA;export default client;&#xA;</code></pre>&#xA;&#xA;<p>Then I use that client like so:</p>&#xA;&#xA;<pre><code>&lt;ApolloProvider client={client}&gt;&#xA;  &lt;App /&gt;&#xA;&lt;/ApolloProvider&gt;&#xA;</code></pre>&#xA;&#xA;<p>And here's an example of a query that throws an error:</p>&#xA;&#xA;<pre><code>const QUERY = gql`&#xA;  {&#xA;    ui @client {&#xA;      states&#xA;      values&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>The errors I'm seeing are:</p>&#xA;&#xA;<ul>&#xA;<li><code>Uncaught Invariant Violation: Missing selection set for object of type undefined returned for query field states</code></li>&#xA;</ul>&#xA;&#xA;<p>That error shows up in the Query component. </p>&#xA;&#xA;<p>I also get two warnings (probably one for <code>states</code> and one for <code>values</code>) that:</p>&#xA;&#xA;<ul>&#xA;<li><code>Missing field __typename in {}</code></li>&#xA;</ul>&#xA;&#xA;<p>Do I need to structure my data differently to query it like this?</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>Follow-up question: If a component has a UID, it'd be nice to be able to query its values like:</p>&#xA;&#xA;<pre><code>const QUERY = gql`&#xA;  {&#xA;    ui @client {&#xA;      states {&#xA;        ${uid}&#xA;      }&#xA;      values {&#xA;        ${uid}&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Instead of getting <em>all</em> UI values and then finding the appropriate one in the component. </p>&#xA;&#xA;<p>That throws an error, however:</p>&#xA;&#xA;<pre><code>Syntax Error: Invalid number, expected digit but got: ""d"".&#xA;</code></pre>&#xA;&#xA;<p>Is there a way to perform such a query, or a better way to handle all this? Although this data structure might not be idiomatic, it does seem that Apollo should support this for filtered queries, no?</p>&#xA;",1408935,,1408935,2019-06-19 14:54:12,2019-08-27 12:12:42,Apollo local state - querying for object w unknown keys,<reactjs><graphql><apollo><react-apollo><apollo-client>,1,0,0,2019-06-18 22:59:56
56668759,2,,56505387,0,,"<p>Every edge must have a cursor, and it should normally be provided by the server. Which means a subscription or mutation returning a node that could be part of an edge, should also provide the cursor.</p>&#xA;&#xA;<p>There are two main approaches for this. If it's only possible for a connection to be sorted in one way (thereby guaranteeing the same node always has the same cursor), you can just return the entire edge type:</p>&#xA;&#xA;<pre><code>type PostEdge {&#xA;    node: Post!&#xA;    cursor: String!&#xA;}&#xA;&#xA;type MyMutationPayload {&#xA;    edge: PostEdge!    &#xA;}&#xA;&#xA;type Mutation {&#xA;    newPost(input: NewPostInput!): MyMutationPayload!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If a connection can be sorted in multiple ways (eg by title, publication date, author), then the cursor is vary per sort option, which means you can't return the edge itself, but you can instead return the necessary information to construct the edges in the client updater:</p>&#xA;&#xA;<pre><code>enum PostSort {&#xA;    NEWEST_FIRST&#xA;    AUTHOR_AZ&#xA;    TITLE_AZ &#xA;}&#xA;&#xA;type PostCursors {&#xA;    sortKey: PostSort!&#xA;    cursor: String!&#xA;}&#xA;&#xA;type MyMutationPayload {&#xA;    node: Post!&#xA;    cursors: [PostCursors!]!&#xA;}&#xA;&#xA;type Mutation {&#xA;    newPost(input: NewPostInput!): MyMutationPayload!&#xA;}&#xA;</code></pre>&#xA;",15687,,,,2019-06-19 13:25:43,"",,0,0,0,2019-06-19 13:25:43
56701039,1,56748836,,2,5721,"<p>I use apollo-server to write a graphql code. before send data I want to  do some sort  on data based on optional fields and filters, and I need to know right way to write my code? &#xA;Is there a method in graphql to automatically sort my data?</p>&#xA;&#xA;<p>I used <a href=""https://www.npmjs.com/package/lodash"" rel=""nofollow noreferrer"">lodash</a> for sort and I think they are not optimized&#xA;after I searched&#xA;I saw <a href=""https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer"">prisma</a> but my data is returned by another api not in database.&#xA;I need somthing like prisma.</p>&#xA;&#xA;<p>my code something like this&#xA;I want to sort book base on name or lastName in query&#xA;but in real book objects returned by an api.</p>&#xA;&#xA;<pre><code>const { ApolloServer, gql, } = require('apollo-server');&#xA;&#xA;const books = [&#xA;{&#xA;    title: 'Harry Potter and the Chamber of Secrets',&#xA;    authors: [{""name"":""a1"", ""lastName"":""aa1""},{""name"":""b1"", ""lastName"":""bb1""},{""name"":""c1"", ""lastName"":""cc1""}]&#xA;  },&#xA;  {&#xA;    title: 'Jurassic Park',&#xA;    authors: [{""name"":""a"" ,""lastName"":""aa""},{""name"":""b"", ""lastName"":""bb""},{""name"":""c"", ""lastName"":""cc""}]&#xA;  },&#xA;];&#xA;const typeDefs = gql`&#xA;&#xA;type Book {&#xA;    title: String&#xA;    authors: [Author]&#xA;  }&#xA;type Query{&#xA;    books: [Book]&#xA;  }&#xA;type Author{&#xA;name: String&#xA;lastName: String&#xA;}&#xA;  `;&#xA;const resolvers = {&#xA;  Query: &#xA;  {&#xA;    books: () =&gt; books,&#xA;// in real this book return by an api !&#xA;&#xA;  },&#xA;};&#xA;const server = new ApolloServer({ typeDefs, resolvers });&#xA;&#xA;server.listen({port: 3002, path: '/graphql'}).then(({ url }) =&gt; {&#xA;  console.log(`  Server ready at ${url}`);&#xA;});&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Is there a function In graphql?</p>&#xA;",3116869,,3116869,2019-06-21 11:29:28,2019-06-25 07:24:01,How to sort data in graphQl with apollo server?,<node.js><sorting><apollo><graphql-js>,1,1,0,2019-06-21 09:54:18
56738061,2,,56737279,1,,<p>You can make a copy of the props and put it into the state. If your goal is to change state in the parent's component state from the child. You need to use Context Api or Redux</p>&#xA;,11483018,,,,2019-06-24 13:51:06,"",,0,1,0,2019-06-24 13:51:06
56742133,2,,56547036,0,,"<p>There is a default limit of 10 when using scan to prevent you from browning out your table. In your VTL Mapping Template, specify a higher limit to get all the items. See <a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-scan"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-scan</a> to specify this limit. You can set the limit as high as you want; DynamoDB will stop once it reaches the total number of items in the table or the limit, whichever is smaller.</p>&#xA;",1457398,,,,2019-06-24 18:35:40,"",,0,0,0,2019-06-24 18:35:40
56753248,1,,,0,114,"<p>I'm wondering if I can create an object using GraphQL, instead of manipulating the data that GraphQL returns. I'm using GraphQL in Gatsby. </p>&#xA;&#xA;<p>My query looks something like this:</p>&#xA;&#xA;<pre><code>nodes {&#xA;  name&#xA;  url&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The data looks like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""nodes"": [&#xA;      {&#xA;        ""name"": ""ABC""&#xA;        ""url"": ""ABC.com""&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to use GraphQL to return something that looks like this?</p>&#xA;&#xA;<pre><code>{&#xA;   ""data"": {&#xA;      ""ABC"": ""ABC.com""&#xA;   }&#xA;}&#xA;</code></pre>&#xA;",1369063,,,,2019-06-26 00:50:30,Can I return a mapped object from a GraphQL query?,<graphql><gatsby>,1,0,0,2019-06-25 11:39:38
56756556,2,,56742968,0,,"<p>Move commented line:</p>&#xA;&#xA;<pre><code>  render() {&#xA;    this.fetchMoreData(); // move this line from here to `componentWillMount`&#xA;    const { items } = this.state;&#xA;</code></pre>&#xA;&#xA;<p>componentWillMount will fetch the data and  </p>&#xA;&#xA;<pre><code>componentWillMount(){&#xA;   this.fetchMoreData();&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Also, You need to push into array not set it.&#xA;1st of all, make sure what kind of <code>data</code> you are getting from <code>Query</code>&#xA;then <code>concat</code> to your array.</p>&#xA;&#xA;<pre><code>return this.setState({&#xA;      items: this.state.items.concat( data ) //make sure yr data is properly concatenate!&#xA;      cursor: cursor + 9&#xA;});&#xA;</code></pre>&#xA;",2325924,,,,2019-06-25 14:38:43,"",,0,0,0,2019-06-25 14:38:43
56762236,2,,56713311,2,,"<p>What you are trying to do should be possible without using a custom resolver.</p>&#xA;&#xA;<p>You should be able to do it with something in the likes of the following</p>&#xA;&#xA;<pre><code>type Query {&#xA;    userSearch(name: String @eq, email: String @eq, phone: String @eq, city_id: Int @eq): [User] @paginate&#xA;}&#xA;type User {&#xA;    id: ID!&#xA;    name: String!&#xA;    email: String&#xA;    phone: String&#xA;    credit: Int&#xA;    city_id: Int&#xA;    city: City @belongsTo&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here we utilize the <a href=""https://lighthouse-php.com/3.7/eloquent/getting-started.html#pagination"" rel=""nofollow noreferrer"">paginate method</a> and extending it with some <a href=""https://lighthouse-php.com/3.7/eloquent/getting-started.html#adding-query-constraints"" rel=""nofollow noreferrer"">constraints</a>.</p>&#xA;",2304480,,,,2019-06-25 21:27:56,"",,0,2,0,2019-06-25 21:27:56
56766069,1,,,-1,55,"<p>I have a schema as follows:</p>&#xA;&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  firstName: String!&#xA;  lastName: String!&#xA;  locations: [Location]&#xA;}&#xA;&#xA;type Location @model {&#xA;  id: ID!&#xA;  listOfPictures: [String]&#xA;  address: String!&#xA;  owner: User&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Currently I have entries to both Locations and Users.  The entries for my Locations are all null.&#xA;I want to update one of my Locations, of ID '1234' to have the field 'owner' set to the User of ID '5678'.</p>&#xA;&#xA;<p>What is the correct syntax for this?  What do I have to enter into he Appsync console?</p>&#xA;&#xA;<p>Additionally, how could I update the 'locations' field of my User of id 'abc' model to add a Location, to the array of Locations, of Location with id 'def' ?&#xA;Thanks.</p>&#xA;",11466854,,,,2019-07-03 00:56:35,How can I update a graphql entry?,<reactjs><graphql><aws-appsync>,1,0,0,2019-06-26 05:54:20
56772873,2,,56510868,1,,"<p>You do not add it on the type itself, you add in in the query.&#xA;So to follow your example you would do </p>&#xA;&#xA;<pre><code>type TypeA {&#xA;   ...&#xA;}&#xA;&#xA;type Query {&#xA; typeA(id: ID @eq): TypeA @find(model: ""TypeA"")&#xA; typeAs(): [TypeA] @all(model: ""TypeA"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can find it in the <a href=""https://lighthouse-php.com/master/api-reference/directives.html#all"" rel=""nofollow noreferrer"">docs</a> also.</p>&#xA;",2304480,,,,2019-06-26 12:30:01,"",,0,0,0,2019-06-26 12:30:01
56847935,1,56849534,,52,43149,"<p>I got the above error on a graphql query, I am using apollo-react by the way and using the Query component for rendering the data</p>&#xA;<p>this is my code</p>&#xA;<pre><code>const GET_VEHICLE_CHECKS = gql`&#xA;query getVehicleChecks($uuid: String!) {&#xA;  tripDetails(uuid: $uuid){&#xA;    departmentAssigned{&#xA;      vehicleChecks{&#xA;        conditions{&#xA;          id&#xA;          name&#xA;          standard&#xA;          valueType&#xA;          spinnerItems&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;`;&#xA;</code></pre>&#xA;<p>and this is what my actual query looks like</p>&#xA;<pre><code>{&#xA;  tripDetails(uuid: &quot;c0e7233093b14afa96f39e2b70c047d8&quot;){&#xA;    departmentAssigned{&#xA;      vehicleChecks{&#xA;        conditions{&#xA;          id&#xA;          name&#xA;          standard&#xA;          valueType&#xA;          spinnerItems&#xA;        }&#xA;      }&#xA;    }&#xA;    vehicleConditions{&#xA;      id&#xA;      condition{&#xA;        id&#xA;        standard&#xA;      }&#xA;      value&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>I tried changing variable names, but that didn't work</p>&#xA;",10177043,,10177043,2020-09-03 11:07:42,2020-09-03 11:07:42,"GraphQLError: Syntax Error: Expected Name, found <EOF>",<graphql><react-apollo><graphql-tag>,1,0,0,2019-07-02 08:04:21
56849534,2,,56847935,151,,<p>You are missing a closing bracket <code>}</code> at the end of your query.</p>&#xA;&#xA;<pre><code>const GET_VEHICLE_CHECKS = gql`&#xA;query getVehicleChecks($uuid: String!) {&#xA;  tripDetails(uuid: $uuid){&#xA;    departmentAssigned{&#xA;      vehicleChecks{&#xA;        conditions{&#xA;          id&#xA;          name&#xA;          standard&#xA;          valueType&#xA;          spinnerItems&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;} &lt;- THIS&#xA;`;&#xA;</code></pre>&#xA;,3708153,,,,2019-07-02 09:40:44,"",,0,1,0,2019-07-02 09:40:44
56855321,1,56857427,,1,1119,"<p>According to the connection based model for pagination using graphQL, I have the following simplified schema.</p>&#xA;&#xA;<pre><code>type User {&#xA;  id: ID!&#xA;  name: String!&#xA;}&#xA;&#xA;type UserConnection {&#xA;  totalCount: Int&#xA;  pageInfo: PageInfo&#xA;  edges: [UserEdge]&#xA;}&#xA;&#xA;type UserEdge {&#xA;  cursor: String&#xA;  node: User&#xA;}&#xA;&#xA;type PageInfo {&#xA;  lastCursor: Int&#xA;  hasNextPage: Boolean&#xA;}&#xA;&#xA;type Query {&#xA;  users(first: Int, after: String): UserConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Consider the following router on within SPA front-end:   </p>&#xA;&#xA;<p><code>/users</code> - once the user hit this page, I'm fetching first 10 records right up from the top of the list and further I'm able to paginate by reusing a cursor that I've retrieved from the first response.</p>&#xA;&#xA;<p><code>/user/52</code> - here I'd like to show up 10 records that should go right from the position of user52.</p>&#xA;&#xA;<p><strong>Problem</strong> What are the possible ways to retrieve a particular subset of records on the very first request? On this moment I don't have any cursor to construct something similar to</p>&#xA;&#xA;<pre><code>  query GetTenUsersAfter52 {&#xA;    users(first: 10, after: ""????"") { # struggling to pass anything as a cursor...&#xA;      edges {&#xA;        node {&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p><strong>What I've already tried(a possible solution)</strong> is that I know that on a back-end the cursor is encoded value of an <code>_id</code> of the record in the DB. So, being on <code>/users/52</code> I can make an individual request for that particular user, grab the value of <code>id</code>, then on the front-end I can compute a cursor and pass it to the back-end in the query above.</p>&#xA;&#xA;<p>But in this case personally, I found a couple of disadvantages:</p>&#xA;&#xA;<ol>&#xA;<li>I'm exposing the way of how my cursor is computed to the front-end, which is bad since if I needed to change that procedure I need to change it on front-end and back-end...</li>&#xA;<li>I don't want to make another query field for an individual user simply because I need its id to pass to the <code>users</code> query field.</li>&#xA;<li>I don't want to make 2 API calls for that as well...</li>&#xA;</ol>&#xA;",6306714,,6306714,2019-07-02 15:08:53,2019-07-02 17:26:37,GraphQL Pagination | The very first request,<graphql><apollo><graphql-js><apollo-server><relay>,1,2,0,2019-07-02 15:03:21
56857427,2,,56855321,1,,"<p>This is a good example of how Relay-style pagination can be limiting. You'll hit a similar scenario with create mutations, where manually adding a created object into the cache ends up screwing up your pagination because you won't have a cursor for the created object.</p>&#xA;&#xA;<p>As long as you're not actually using Relay client-side, one solution is to just abandon using cursors altogether. You can keep your <code>before</code> and <code>after</code> fields, but instead simply accept the <code>id</code> (or <code>_id</code> or whatever PK) value instead of a cursor. This is what I ended up doing on a recent project and it simplified things significantly.</p>&#xA;",6024220,,,,2019-07-02 17:26:37,"",,0,1,0,2019-07-02 17:26:37
56858295,2,,56847242,0,,"<p>Since you're running a query the response will have the following structure:</p>&#xA;&#xA;<pre><code>{&#xA;    items = [ ... ],&#xA;    nextToken = ""a pagination token"",&#xA;    scannedCount = 10&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-query"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-query</a></p>&#xA;&#xA;<p>In your response mapping template you want to handle that result:</p>&#xA;&#xA;<ul>&#xA;<li>either by just returning <em>ctx.result.items</em> </li>&#xA;<li>or, like in your case, if the fields are marked required and can't be null you need to handle the null case</li>&#xA;</ul>&#xA;",11730550,,,,2019-07-02 18:30:37,"",,0,0,0,2019-07-02 18:30:37
56883100,1,56888877,,0,1024,"<p>The problem I am facing is that I have <code>custom_filter</code> of <code>MyModel</code> which return the list of <code>&lt;QuerySet&gt;</code> like</p>&#xA;&#xA;<pre><code>[&lt;QuerySet [&lt;MyModel: xyz&gt;]&gt;, &lt;QuerySet [&lt;MyModel: xyz&gt;, &lt;MyModel: xyz&gt;,&lt;MyModel: xyz&gt;]&gt;]&#xA;</code></pre>&#xA;&#xA;<p><strong>The object type</strong></p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>class MyModelNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model=MyModel&#xA;        filter_fields=['id]&#xA;        interfaces = (graphene.relay.Node,)&#xA;&#xA;&#xA;</code></pre>&#xA;&#xA;<p><strong>Query</strong></p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>class Query(graphene.ObjectType):&#xA;   my_model_items = graphene.List(MyModelNode)&#xA;&#xA;   def resolve_my_model_items(self, info, **kwargs):&#xA;      my_model_filtered_items = MyModel.objects.custom_filter(kwargs)&#xA;      # my_model_filtered_items holds the list of querysets&#xA;      return my_model_filtered_items&#xA;&#xA;</code></pre>&#xA;&#xA;<p>How to handle list of querysets.&#xA;The graphql respone of the query should give a list which have the querysets as elements.</p>&#xA;&#xA;<pre><code>[&#xA;  {&#xA;  //These are from first &lt;QuerySet&gt;&#xA;  ""myModelItems"":[&#xA;      {&#xA;        ""fieldsIaskedFor"":""response""&#xA;      }&#xA;    ]&#xA;&#xA;  },&#xA;&#xA;&#xA;  {&#xA;  //These are from second &lt;QuerySet&gt;&#xA;  ""myModelItems"":[&#xA;      {&#xA;        ""fieldsIaskedFor"":""resp""&#xA;      },&#xA;      {&#xA;        ""fieldsIaskedFor"":""resp""&#xA;      },&#xA;      {&#xA;        ""fieldsIaskedFor"":""resp""&#xA;      },&#xA;    ]&#xA;&#xA;  },&#xA;&#xA;&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>How to get results of different querysets in separate list elements ?&#xA;The number of <code>&lt;QuerySet&gt;</code> are  not fixed.</p>&#xA;&#xA;<p><strong>What I have to do to achieve that ?.</strong></p>&#xA;",10095818,,10095818,2019-07-04 07:58:31,2019-07-04 16:00:13,How to return List of QuerySets in graphql query as separate list elements?,<django><graphql><graphene-python><graphene-django>,1,0,0,2019-07-04 07:51:03
56888696,2,,56875895,2,,"<p>I had a similar problem when upgrading to <code>v4.0.0</code>. It seems that they've removed support for passing the <code>graphql</code> literal as the second argument, so instead you should pass an object like</p>&#xA;&#xA;<pre><code>export default createFragmentContainer(Link, {&#xA;  link: graphql`&#xA;    fragment Link_link on Link {&#xA;      id&#xA;      description&#xA;      url&#xA;    }&#xA;  `&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>It's annoying but it should work. I hope they fix this issue for future versions.</p>&#xA;",667598,,,,2019-07-04 13:09:27,"",,0,0,0,2019-07-04 13:09:27
56940395,1,56941706,,0,894,"<p>I am attempting to specify a subtype in a graphql mutation&#xA;Using AWS Amplify and AWS AppSync.</p>&#xA;&#xA;<pre><code>mutation CreatePhoneType {&#xA;  createPhoneType(input: {&#xA;    desc: ""Mobile Phone""&#xA;  }) {&#xA;    id&#xA;    desc&#xA;  }&#xA;}&#xA;&#xA;mutation CreatePhone {&#xA;  createPhone(input: {&#xA;    number: ""+91 704-011-2342"",&#xA;    phonetype: { id: ""f6b3c538-378a-48d1-a264-96dfef4472a4"" }    &#xA;  }) {&#xA;    id&#xA;    number,&#xA;    phonetype {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is the schema definition:</p>&#xA;&#xA;<pre><code>type Phone @model {&#xA;  id: ID!&#xA;  number: AWSPhone!&#xA;  phonetype: PhoneType&#xA;  createdAt: AWSDateTime&#xA;  updatedAt: AWSDateTime&#xA;}&#xA;&#xA;type PhoneType @model {&#xA;  id: ID!&#xA;  desc: String!&#xA;  createdAt: AWSDateTime&#xA;  updatedAt: AWSDateTime&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm attempting to insert a new phone value. The Phone type has a subtype of PhoneType. I've created the PhoneType successfully and would like to reference the existing phone type as part of a mutation to create a Phone value. I've tried specifying the ID! but that does not work. How can you specify an existing subtype when creating a new value in a GraphQL mutation?&#xA;I've checked the GraphQL docs but there is not a lot of information.</p>&#xA;",7103625,,,,2021-05-27 15:53:38,Subtypes in GraphQL mutation,<reactjs><graphql>,1,0,0,2019-07-08 18:05:42
56941706,2,,56940395,1,,"<p>You need to add <code>@connection</code> to generate the related type.</p>&#xA;<p>So Phone should be:</p>&#xA;<pre><code>type Phone @model {&#xA;  id: ID!&#xA;  number: AWSPhone!&#xA;  phonetype: PhoneType @connection&#xA;  createdAt: AWSDateTime&#xA;  updatedAt: AWSDateTime&#xA;}&#xA;</code></pre>&#xA;<p>Once you do this, a generated type is available to reference.</p>&#xA;<p>So this now works:</p>&#xA;<pre><code>mutation CreatePhone {&#xA;  createPhone(input: {&#xA;    number: &quot;+91 704-011-2342&quot;,&#xA;    phonePhonetypeId: &quot;f6b3c538-378a-48d1-a264-96dfef4472a4&quot;  &#xA;  }) {&#xA;    id&#xA;    number&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",7103625,,4685471,2021-05-27 15:53:38,2021-05-27 15:53:38,"",,0,0,0,2019-07-08 19:48:54
56951677,1,56953477,,0,538,"<p>I have a schema like this:</p>&#xA;&#xA;<pre><code>type SectionItem = {&#xA;  a: String&#xA;}&#xA;&#xA;type SectionRowConnection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [SectionRowEdge]&#xA;}&#xA;&#xA;type SectionRowEdge {&#xA;  node: [SectionItem]&#xA;  cursor: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to get a list in each node of connection, and when I run below query manually, everything works fine:</p>&#xA;&#xA;<pre><code>query {&#xA;  sectionRows(type:someType){&#xA;    edges{&#xA;      node{&#xA;        a&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I'm using Relay in client, but I get this error trying to build the query using relay:</p>&#xA;&#xA;<blockquote>&#xA;  <p>ERROR:&#xA;  Encountered 1 error(s):&#xA;  - @connection used on invalid field <code>sectionRows</code>. Expected the field type <code>SectionRowConnection</code> to have an <code>edges { node }</code> field that returns an object, interface, or union.</p>&#xA;</blockquote>&#xA;&#xA;<p>As the Error suggests, I can not use List inside a relay connection, but I want to have a schema like this, any Ideas on how to use relay with this schema or recommend a workaround for this problem?</p>&#xA;",7025986,,11167163,2019-07-09 11:39:29,2019-07-09 13:15:20,How to Handle List inside Connection in Graphql Relay,<graphql><graphql-js><relayjs>,2,0,0,2019-07-09 11:35:30
56952625,2,,56951677,1,,"<p>From the Relay <a href=""https://facebook.github.io/relay/graphql/connections.htm#sec-Node"" rel=""nofollow noreferrer"">spec</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>An “Edge Type” must contain a field called node. This field must return either a Scalar, Enum, Object, Interface, Union, or a Non‐Null wrapper around one of those types. Notably, this field <em>cannot</em> return a list.</p>&#xA;</blockquote>&#xA;&#xA;<p>In other words, <code>SectionRowConnection</code> does not meet Relay's requirements for a connection type because its node field is a List. There is no workaround for this other than modifying your schema so that <code>node</code>'s type is <code>SectionItem!</code> instead of <code>[SectionItem]</code>. If you want to use Relay, your schema must be compliant with the Relay specification.</p>&#xA;&#xA;<p>The connection itself represents a collection of individual nodes (or ""resources"" if we borrow REST terminology), with each edge connecting the root node to an individual node in the collection.</p>&#xA;&#xA;<p>For example, we can imagine a single User node that has a <code>friends</code> field that returns a UserConnection. Each edge in the connection would represent the association between the original User node and one of the friend users. Each edge would have a single User node.</p>&#xA;&#xA;<p>This collection of User nodes can naturally be sorted and filtered as needed. However, if we wanted to <em>group</em> them together according to some criteria (similar to <code>GROUP BY</code> in SQL), we would create a separate UserGroup type and a UserGroupConnection. Each UserGroup node inside a UserGroupConnection would then itself have some field that is a UserConnection. Even in this scenario, <em>each connection's edge still only has one node</em>.</p>&#xA;&#xA;<p>It's unclear from just your schema if you were trying to do just simple filtering or ""grouping"" your nodes as shown above. Either way, conceptually, there is no reason to ever have an edge return a List for its <code>node</code> field.</p>&#xA;",6024220,,,,2019-07-09 12:29:36,"",,0,1,0,2019-07-09 12:29:36
56953477,2,,56951677,0,,"<p>What I ended up doing was to wrap the result list inside an object, i.e. each node is of <code>SectionRow</code> type which is a <code>graphQlObjectType</code> that has an <code>items</code> field, the list is inside the items list. here is the resulting schema:</p>&#xA;&#xA;<pre><code>type SectionItem = {&#xA;  a: String&#xA;}&#xA;&#xA;type SectionRow = {&#xA;  items: [SectionItem]&#xA;}&#xA;&#xA;type SectionRowConnection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [SectionRowEdge]&#xA;}&#xA;&#xA;type SectionRowEdge {&#xA;  node: SectionRow&#xA;  cursor: String!&#xA;}&#xA;</code></pre>&#xA;",7025986,,,,2019-07-09 13:15:20,"",,0,0,0,2019-07-09 13:15:20
56977086,1,56986217,,0,1785,"<p>Hi I'm making a navigation component by mapping through gatsby pages&#xA;I'm trying to filter out both the ""/"" index page and the ""/dev-404-page/"" page</p>&#xA;&#xA;<p>my query which successfully filters the ""/dev-404-page/""</p>&#xA;&#xA;<pre><code> query MyQuery {&#xA;        allSitePage(filter: {path: {ne: ""/dev-404-page/""}}) {&#xA;          nodes {&#xA;            path&#xA;          }&#xA;        }&#xA;      }&#xA;</code></pre>&#xA;&#xA;<p>How should I go about adding </p>&#xA;&#xA;<pre><code>{ne: ""/""}&#xA;</code></pre>&#xA;&#xA;<p>have tried commas and ""&amp;"", but I think I'm barking up the wrong tree.</p>&#xA;&#xA;<p>Thanks in advance</p>&#xA;",482095,,,,2019-07-11 09:39:06,Multiple filters on the same graphql query,<graphql><gatsby>,1,0,0,2019-07-10 19:00:54
56984668,1,,,4,766,"<p>How do you manage effective data fetching with nested cursors in a relay-esk schema (with a SQL data source)?</p>&#xA;&#xA;<ol>&#xA;<li>Do you try make a single complicated SQL query to resolve the N+1 problem with a ""LIMIT args_first"", ""ORDER BY args_orderby"" and ""WHERE cursor > :args_after""</li>&#xA;<li>Do you run 2 queries to the DB and make use of facebook data loader?</li>&#xA;</ol>&#xA;&#xA;<p>For example, I've got a schema structured as below:</p>&#xA;&#xA;<pre><code>enum BookSortKeys {&#xA;    ID,&#xA;    TITLE,&#xA;    PRICE,&#xA;    UPDATED_AT,&#xA;    CREATED_AT&#xA;}&#xA;enum ReviewSortKeys {&#xA;    ID,&#xA;    REVIEW,&#xA;    UPDATED_AT,&#xA;    CREATED_AT&#xA;}&#xA;type Book {&#xA;  id: ID!&#xA;  title: String!&#xA;  description: String&#xA;  price: Float!&#xA;  updatedAt: String!&#xA;  createdAt: String!&#xA;  reviews(""""""&#xA;    Returns the elements that come after the specified cursor.&#xA;    """"""&#xA;    after: String&#xA;    """"""&#xA;    Returns the elements that come before the specified cursor.&#xA;    """"""&#xA;    before: String&#xA;    """"""&#xA;    Returns up to the first `n` elements from the list.&#xA;    """"""&#xA;    first: Int&#xA;    """"""&#xA;    Returns up to the last `n` elements from the list.&#xA;    """"""&#xA;    last: Int&#xA;    """"""&#xA;    Reverse the order of the underlying list.&#xA;    """"""&#xA;    reverse: Boolean = false&#xA;    """"""&#xA;    Sort the underlying list by the given key.&#xA;    """"""&#xA;    sortKey: ReviewSortKeys = ID): ReviewConnection!&#xA;}&#xA;type Query {&#xA;  books(""""""&#xA;    Returns the elements that come after the specified cursor.&#xA;    """"""&#xA;    after: String&#xA;    """"""&#xA;    Returns the elements that come before the specified cursor.&#xA;    """"""&#xA;    before: String&#xA;    """"""&#xA;    Returns up to the first `n` elements from the list.&#xA;    """"""&#xA;    first: Int&#xA;    """"""&#xA;    Returns up to the last `n` elements from the list.&#xA;    """"""&#xA;    last: Int&#xA;    """"""&#xA;    Supported filter parameters:&#xA;     - `title`&#xA;     - `id`&#xA;     - `price`&#xA;     - `description`&#xA;     - `created_at`&#xA;     - `updated_at`&#xA;    """"""&#xA;    query: String&#xA;    """"""&#xA;    Reverse the order of the underlying list.&#xA;    """"""&#xA;    reverse: Boolean = false&#xA;    """"""&#xA;    Sort the underlying list by the given key.&#xA;    """"""&#xA;    sortKey: BookSortKeys = ID): BookConnection!&#xA;}&#xA;type ReviewConnection {&#xA;    pageInfo: PageInfo!&#xA;    edges: [ReviewEdge!]!&#xA;}&#xA;type ReviewEdge {&#xA;    cursor: String!&#xA;    node: Review!&#xA;}&#xA;type BookConnection {&#xA;    pageInfo: PageInfo!&#xA;    edges: [BookEdge!]!&#xA;}&#xA;type BookEdge {&#xA;    cursor: String!&#xA;    node: Book!&#xA;}&#xA;type PageInfo {&#xA;    hasNextPage: Boolean!&#xA;    hasPreviousPage: Boolean!&#xA;}&#xA;type Review {&#xA;    review: String!&#xA;    id: ID!&#xA;    updatedAt: String!&#xA;    createdAt: String!&#xA;}&#xA;type Mutation {&#xA;}&#xA;schema {&#xA;  query: Query&#xA;  mutation: Mutation&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And I'd like to execute a query like the below and retrieve the data in the most efficient manner.</p>&#xA;&#xA;<pre><code>query GET_BOOKS {&#xA;  books(first:10, sortKey: PRICE, reverse: true) {&#xA;       pageInfo {&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;    } &#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        title&#xA;        description&#xA;        reviews(after:""base64-cursor"" first: 5, sortKey: CREATED_AT) {&#xA;          edges {&#xA;            node{&#xA;              review&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I can very easily convert all of the pagination parameters for the top query (book) into a sql statement but with the nested cursor, I can only see 2 options (mentioned above)... current issues I'm facing before implementing these options are:</p>&#xA;&#xA;<ol>&#xA;<li>If I go the pure SQL approach - is there even a clean way to run a single query and apply the <code>LIMIT</code> and <code>WHERE createdAt &gt; :after_cursor_val</code> at the nested (JOIN) level</li>&#xA;<li>If the above is possible, is it more performant than dataloader at scale? As the query seems like it will be pretty verbose and complex if implemented.</li>&#xA;<li>What happens if the nested pagination tree grows (i.e. requests with 4 nested paginations)? Would a pure Query object level sql command suffice here? or is it more scalable to add resolvers on each relationship (i.e. book -> reviews has a sql query to pull all this book's specific reviews, reviews -> publications has a query to pull all the review's specific publications it's been in and so on and batch them in data loader)</li>&#xA;<li>if you go the dataloader route, the batching seems to use a ""WHERE IN"" clause, (i.e. <code>SELECT * FROM reviews ""reviews"" WHERE ""reviews"".bookId IN (...list of book ids batched)</code> - would adding <code>LIMIT</code>, <code>ORDER BY</code>  and <code>WHERE createdAt &gt; :cursor</code> provide unexpected results as my result set is a mix of entries across multiple 'book ids'?</li>&#xA;<li>long term, my personal feeling is that the pure sql approach is going to be messy from a code perspective, thoughts on this?</li>&#xA;</ol>&#xA;",11768911,,,,2019-07-11 08:20:41,What is the best way to implement nested cursor pagination with a SQL datasarouce in a graphQL server?,<sql><graphql><graphql-js><relay>,0,1,0,2019-07-11 08:20:41
56989560,1,62565528,,18,2296,"<p>I am having terrible problems getting a real cursor for resolving a database pagination result in GraphQL. No matter what kind of database (SQL e.g. mysql or NoSQL document e.g. mongodb) I am using, there is no way, I seem to be able to get a cursor or cursorlike object.</p>&#xA;&#xA;<p>Propably I am missing out on some fundamental concepts but after searching my b... off I am beginning to seriously doubt whether the official GraphQL pagination documentation</p>&#xA;&#xA;<p><a href=""https://graphql.org/learn/pagination/"" rel=""noreferrer"">https://graphql.org/learn/pagination/</a></p>&#xA;&#xA;<p>is based on any real live experience at all.</p>&#xA;&#xA;<p>Here's my question: How can I get anything even remotely resembling a cursor from a SQL query like this?</p>&#xA;&#xA;<pre><code>SELECT authors.id, authors.last_name, authors.created_at FROM authors&#xA;ORDER BY authors.last_name, author.created_at&#xA;LIMIT 10&#xA;OFFSET 20&#xA;</code></pre>&#xA;&#xA;<p>I know, offset based pagination should not be used and instead cursor based navigation is considered a remedy. And I'd definitely like to cure my application from the offset disease. But in order to do that I need to be able to retrieve a cursor from <strong>somewhere</strong>.</p>&#xA;&#xA;<p>I also understand (forgot where I read that) that primary keys should not be used for pagination either.</p>&#xA;&#xA;<p>So, I am stuck here.</p>&#xA;",716568,,716568,2019-07-11 13:10:02,2020-06-24 23:33:05,How to get a cursor for pagination in Graphql from a database?,<database><graphql><graphql-js><cursor-position><resolver>,1,1,0,2019-07-11 12:45:50
56992346,1,,,0,30,"<p>If I have a query <code>user</code> and it takes <code>uuid</code> but my variables are deep <code>user.uuid</code> can I pass <code>uuid</code> to the <code>user</code> query?</p>&#xA;&#xA;<pre><code>query User($user.uuid: string) {&#xA;  user (uuid:$user.uuid) {&#xA;    createdAt&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Query Variables:</p>&#xA;&#xA;<pre><code>{&#xA;  ""user"":{&#xA;    ""uuid"": ""abc""&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",340688,,,,2019-07-11 15:22:53,Pass deep prop to shallow input,<graphql>,1,1,0,2019-07-11 15:09:28
56995111,1,57004171,,4,3014,"<p>I have been using prisma-binding npm, I don't know how to get the total matched count of the query in order to perform pagination.</p>&#xA;&#xA;<p>I'm using below code to pull record which working fine. Now i want total number of records.</p>&#xA;&#xA;<pre><code>const users = await prisma.query.users(null,`{id, name}`)&#xA;</code></pre>&#xA;&#xA;<p>Note: By default prisma returns maximum of 3000 records only, but have 9000 records.</p>&#xA;",1283203,,,,2019-07-12 09:30:03,how to get the total matched record count in prisma-binding npm,<node.js><graphql><prisma><prisma-binding>,1,0,0,2019-07-11 18:09:42
57004171,2,,56995111,3,,"<p>You need to use the <code>usersConnection</code> query to get a count.</p>&#xA;&#xA;<pre><code>const count = await prisma.query.usersConnection({&#xA;  where: {&#xA;    // whatever your filter parameters are&#xA;  }&#xA;}, `{ aggregate { count } }`)&#xA;</code></pre>&#xA;&#xA;<p>I haven't heard of this maximum returned records, but the usersConnection count is a single record being returned (the count), so that isn't an issue and as you want to do this for pagination I would imagine you would be returning at most 50 records at a time in your query.</p>&#xA;",10526685,,,,2019-07-12 09:30:03,"",,0,1,0,2019-07-12 09:30:03
57021636,1,,,2,205,"<p>Given the general structure:</p>&#xA;&#xA;<pre><code>class Article(Page):&#xA;  body = RichTextField(...)&#xA;  search_fields = Page.search_fields + [index.SearchField('body')]&#xA;&#xA;class ArticleFilter(FilterSet):&#xA;  search = SearchFilter()&#xA;&#xA;  class Meta:&#xA;    model = Article&#xA;    fields = ['slug']&#xA;&#xA;class Query(ObjectType):&#xA;  articles = DjangoFilterConnectionField(ArticleNode, filterset_class=ArticleFilter)&#xA;</code></pre>&#xA;&#xA;<p>I thought to create a ""SearchFilter"" to expose the wagtail search functionality, since I ultimately want to perform full text search via graphql like so:</p>&#xA;&#xA;<pre><code>query {&#xA;  articles (search: ""some text in a page"") {&#xA;     edges {&#xA;        nodes {&#xA;           slug&#xA;        }&#xA;     }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>""search"" is not a field on the Django model which is why I created a custom field in the Django FilterSet. My thought was to do something like:</p>&#xA;&#xA;<pre><code>class SearchFilter(CharFilter):&#xA;  def filter(self, qs, value):&#xA;     search_results = [r.pk for r in qs.search(value)]&#xA;     return self.get_method(qs)(pk__in=search_results)&#xA;</code></pre>&#xA;&#xA;<p>however, I'm curious if there's a better pattern that's more efficient. At the bare minimum I'd want to ensure the SearchFilter is added last (so the query searched is filtered first).</p>&#xA;&#xA;<p>Should the ""search"" be moved outside of the FilterSet and into the Query/Node/custom connection, and if so, how can I add an additional field to ""articles"" to see it as the final step in resolving articles (i.e. tack it on to the end of the filter queryset)? If this does belong in a separate Connection, is it possible to combine that connection with the django filter connection?</p>&#xA;&#xA;<p>I would think this pattern of accessing Wagtail search via graphene already exists, however I've had no luck on finding this in the documentation.</p>&#xA;",1336653,,1336653,2019-07-13 18:23:20,2019-07-13 18:23:20,How do I expose Wagtail search in a Django Graphene query?,<python><django><graphql><wagtail><graphene-django>,0,0,0,2019-07-13 18:01:44
57028362,1,57030318,,6,3539,"<p>Hi I am new to GraphQL and I am trying to sort my data based on column content. I have an query endpoint where I can send:</p>&#xA;&#xA;<pre><code>query {&#xA;  user(count:20, firstName:""Foo"") {&#xA;    data {&#xA;      name&#xA;      region&#xA;      birthDate&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the result is an array of 20 users with the first name <code>Foo</code>. But I want to order them by <code>birthDate</code>. I already tried so many things, but I just can not figure out. I already tried prepending <code>sort</code> and <code>orderBy</code> after the firstName, but I always get errors such as:</p>&#xA;&#xA;<pre><code>{&#xA;  ""errors"": [&#xA;    {&#xA;      ""message"": ""Unknown argument \""sort\"" on field \""user\"" of type \""Query\""."",&#xA;      ""extensions"": {&#xA;        ""category"": ""graphql""&#xA;      },&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 2,&#xA;          ""column"": 31&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am using Laravel Lighthouse as a wapper for GraphQL. I am surprised I could not find any information in regards on how to do this.</p>&#xA;&#xA;<p>My query:</p>&#xA;&#xA;<pre><code>type Query {&#xA;    user(firstName: String @eq): [User!]! @paginate(type: ""paginator"" model: ""App\\User"")&#xA;}&#xA;&#xA;type User {&#xA;    id: ID!&#xA;    firstName: String!&#xA;    lastName: String!&#xA;    birthDate: DateTime!&#xA;    email: String!&#xA;    created_at: DateTime!&#xA;    updated_at: DateTime!&#xA;}&#xA;</code></pre>&#xA;",6281648,,6024220,2019-07-24 16:03:37,2019-07-24 16:03:37,Laravel Lighthouse GraphQL - Sorting on server side,<php><laravel><graphql><laravel-lighthouse>,1,0,0,2019-07-14 14:38:51
57030318,2,,57028362,15,,"<p>After searching for another hour, I finally found it. I updated my graphql file to this:</p>&#xA;&#xA;<pre><code>type Query {&#xA;    user(firstName: String @eq orderBy: [OrderByClause!] @orderBy): [User!]! @paginate(type: ""paginator"" model: ""App\\User"")&#xA;}&#xA;&#xA;type User {&#xA;    id: ID!&#xA;    firstName: String!&#xA;    lastName: String!&#xA;    birthDate: DateTime!&#xA;    email: String!&#xA;    created_at: DateTime!&#xA;    updated_at: DateTime!&#xA;}&#xA;&#xA;input OrderByClause{&#xA;    field: String!&#xA;    order: SortOrder!&#xA;}&#xA;&#xA;enum SortOrder {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now using this query will correctly sort them by birthDate:</p>&#xA;&#xA;<pre><code>query {&#xA;  user(count:20, firstName:""Foo"", orderBy: [&#xA;        {&#xA;          field: ""birthDate""&#xA;          order: DESC&#xA;        }&#xA;    ]) {&#xA;    data {&#xA;      name&#xA;      region&#xA;      birthDate&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6281648,,,,2019-07-14 19:04:10,"",,0,1,0,2019-07-14 19:04:10
57057314,1,,,0,276,"<p>Imagine that I have this ""Schema"":</p>&#xA;&#xA;<pre><code>type User {&#xA;    id: ID!&#xA;    name: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now, in one of my components (A) I need the user <code>id</code>; and in another component (B) I need the user <code>id</code> and the user <code>name</code>.</p>&#xA;&#xA;<p>What I'm doing now is to make a User query in <code>A Component</code> requesting only the ID. And in <code>B Component</code> I'm making another User query requesting id and name.</p>&#xA;&#xA;<p>There's a piece of the query that's always the same: </p>&#xA;&#xA;<pre><code>// Component A request&#xA;const query = gql`{&#xA;    User(id: 1) {&#xA;        id&#xA;    }&#xA;}`&#xA;</code></pre>&#xA;&#xA;<pre><code>// Component B request&#xA;const query = gql`{&#xA;    User(id: 1) {&#xA;        id&#xA;        name&#xA;    }&#xA;}`&#xA;</code></pre>&#xA;&#xA;<p>That <code>User(id:1){}</code> is the same and what is suggested to change is the response parameters. What is the correct approach to this? Is correct to duplicate that fixed part of the query? </p>&#xA;&#xA;<p>Our problem is that if in the future the Schema suffers a change, we gonna need to refactor all the queries in all the places they are. What we want is a way to centralize it and parameterize it in order to be scalable in response of Schema changes.</p>&#xA;&#xA;<p>One of my teammates has made a function that receives a string and places it inside the GQL query. I don't like that approach. What do you think?</p>&#xA;",11707692,,,2019-07-16 13:28:19,2019-07-16 13:28:19,How to reuse GQL queries?,<javascript><graphql><apollo><apollo-angular>,0,4,0,2019-07-16 12:29:13
57083540,2,,55108732,0,,"<p>I also had the same experience.&#xA;For me,</p>&#xA;&#xA;<pre><code>extend type User {&#xA;    Customer(id: string): [Orders]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This showed me args.id as whatever I passed id from the graphiql.</p>&#xA;",7575440,,4228052,2020-05-04 04:51:36,2020-05-04 04:51:36,"",,0,0,0,2019-07-17 20:18:49
57117442,1,57124346,,0,1760,"<p>I want to increase the number of rows returned greater than the default 10. Using the limit parameter does not seem to work.</p>&#xA;&#xA;<p>I have tried passing the limit in several different ways but I always receive only the default 10 rows returned. There should be 12 rows returned which match the filter criteria. </p>&#xA;&#xA;<pre><code>  const filter = {&#xA;    or: [&#xA;      { firstname: { contains: searchValue } },&#xA;      { lastname: { contains: searchValue } },&#xA;      { emailaddress: { contains: searchValue } },&#xA;      { phone: { contains: searchValue } }&#xA;    ]&#xA;&#xA;  };&#xA;&#xA;  const limit = {limit: 50};&#xA;  // const limit = 50; // this does not work either&#xA;&#xA;  const result = await API.graphql(&#xA;    graphqlOperation(listProviders, {filter}, {limit})&#xA;  );&#xA;</code></pre>&#xA;&#xA;<p>I expect to receive true number of rows which match the filter criteria. Only receive 10 rows back. What am I doing incorrectly?</p>&#xA;",7103625,,,,2019-07-20 17:21:07,AWS Appsync - setting limit on rows returned from a list query,<graphql><aws-amplify><aws-appsync><ampl>,1,1,0,2019-07-19 17:50:30
57124346,2,,57117442,3,,"<p>You were close.</p>&#xA;&#xA;<pre><code>const result = await API.graphql(&#xA;  graphqlOperation(listProviders, {filter}, {limit})&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>is the wrong syntax. <code>graphqlOperation</code> only takes two arguments: the query and some options. You want to put both keys onto that object.</p>&#xA;&#xA;<pre><code>const limit = 50;&#xA;const result = await API.graphql(&#xA;  graphqlOperation(listProviders, {filter, limit})&#xA;);&#xA;</code></pre>&#xA;",8331756,,8331756,2019-07-20 17:21:07,2019-07-20 17:21:07,"",,0,0,0,2019-07-20 11:38:59
57148364,1,,,2,4676,"<p>So I have this Apollo Query Component like this:</p>&#xA;&#xA;<pre><code>&lt;Query&#xA;    fetchPolicy='network-only' // also tried without and with 'no-cache'&#xA;    query={GET_MENUS}&#xA;    variables={{&#xA;        foo // This has the default value of the state&#xA;    }}&#xA;&gt;&#xA;    {({ loading, error, data, refetch }) =&gt; {&#xA;&#xA;      // Display Data here&#xA;&#xA;      // We have an Imput here that can change the State of Bar in the parent Component&#xA;      &lt;Button&#xA;          onPress={() =&gt; {&#xA;              /*refetch({&#xA;                  foo: { bar}&#xA;              }); */&#xA;              setBar(blubb); // I am using react hooks (useState)&#xA;          }}&#xA;          text='Refresh!'&#xA;      /&gt;&#xA;      }&#xA;    )}&#xA;&lt;/Query&gt;&#xA;</code></pre>&#xA;&#xA;<p>I tried to refetch by using the refetch method and also by just updating the state. Actually I checked the Apollo Server and in both methods the new variables get passed, but the new Data is not updated. The funny thing is, that if I just use another default value in the state, it works fine. I also tried different fetch-policies without any luck.</p>&#xA;&#xA;<p>I thought it should be quite basic, but I didn't find any solution so far...</p>&#xA;&#xA;<p>So how do I get data with my new variables?</p>&#xA;&#xA;<p>EDIT:</p>&#xA;&#xA;<p>GET_MENUS is a bit complicated, but this is the whole thing. I am passing the variables into different resolvers, because they are nested. The Foo Bar thingy is the ""daily"" variable</p>&#xA;&#xA;<pre><code>const GET_MENUS = gql`&#xA;    query getMenus($lat: Float!, $lng: Float!, $daily: Daily) {&#xA;        getMenus(lat: $lat, lng: $lng) {&#xA;            distance&#xA;            location {&#xA;                _id&#xA;                street&#xA;                streetNumber&#xA;                plz&#xA;                city&#xA;                coordinates&#xA;                shopIDs {&#xA;                    name&#xA;                    togo&#xA;                    shopType&#xA;                    menus(daily: $daily) {&#xA;                        _id&#xA;                        name&#xA;                        price&#xA;                        hot&#xA;                        sweet&#xA;                        togo&#xA;                        allergies&#xA;                        components&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;",7973832,,3708153,2019-08-02 11:41:52,2020-09-26 05:50:28,Apollo Refetch Query Component with new Variables,<reactjs><variables><apollo><graphql-tag>,1,3,0,2019-07-22 14:38:38
57152911,1,,,3,941,"<p>I have a graphql schema in aws-amplify, appsync. </p>&#xA;&#xA;<p>my schema is:</p>&#xA;&#xA;<pre><code>type Project &#xA;  @model &#xA;  {&#xA;    id: ID!&#xA;    project_number: String!&#xA;    name: String!&#xA;    architect: String!&#xA;    interfaces: [Interface] @connection(name: ""ProjectInterfaces"")&#xA;&#xA;  }&#xA;type Interface&#xA;  @model &#xA;  {&#xA;    id: ID!             &#xA;    interface_name: String!&#xA;    version: String!&#xA;    release: String!              &#xA;    source_feature: String!&#xA;    MFT_feature_id: String!&#xA;    state: String!&#xA;    source_application: String!     &#xA;    source_env: String!               &#xA;    source_go_live: String!              &#xA;    source_payload: String! &#xA;    source_payload_format: String!&#xA;    source_payload_volume: String!              &#xA;    source_protocol: String! &#xA;    target_application: String!       &#xA;    target_env: String!&#xA;    target_go_live: String!&#xA;    target_payload: String!&#xA;    target_payload_format: String!&#xA;    target_payload_volume: String!             &#xA;    target_protocol: String!&#xA;    frequency: String!                &#xA;    authentication: String!&#xA;    payload_security: String!&#xA;    transport_security: String!&#xA;    network_paths: String!&#xA;    project: Project @connection(name: ""ProjectInterfaces"")&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>and I want to know if I can search a projects interfaces by project_number instead of id. I added an index on project_name, but it doesn't seem to work. My current query is </p>&#xA;&#xA;<pre><code>query GetProject {&#xA;  getProject(project_number:""P200"") {&#xA;    name&#xA;    architect&#xA;    interfaces{&#xA;      items{&#xA;        interface_name&#xA;        version&#xA;        release              &#xA;        source_feature&#xA;        MFT_feature_id&#xA;        state&#xA;        source_application     &#xA;        source_env             &#xA;        source_go_live          &#xA;        source_payload&#xA;        source_payload_format&#xA;        source_payload_volume         &#xA;        source_protocol&#xA;        target_application  &#xA;        target_env&#xA;        target_go_live&#xA;        target_payload&#xA;        target_payload_format &#xA;        target_payload_volume       &#xA;        target_protocol&#xA;        frequency                &#xA;        authentication&#xA;        payload_security&#xA;        transport_security&#xA;        network_paths &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Please let me know if this is possible. I would like it so that I can just search by project_name, and then get all the details from interface.</p>&#xA;",10007811,,,,2022-02-06 16:53:13,How to query by non-primary key in AWS-amplify graphql schema,<indexing><amazon-dynamodb><graphql><aws-amplify>,1,1,0,2019-07-22 19:54:48
57162332,1,,,0,1563,"<p>I am running a GraphQl mutation via a resolver. Its against a Neo4j database. The query is working fine but I am not able to structure the results in a way that they are displayed back in the result. I've tried several different combinations of results and record mapping but I can't get the properties of the returned result set to show in the outputs.</p>&#xA;&#xA;<p>Specifically, you will see in the below examples that the name field in the response (via GraphiQL) is null when I expect it to be set to the value returned.</p>&#xA;&#xA;<p><strong>Resolver:</strong></p>&#xA;&#xA;<pre><code> AddIdiomHasChildIdiom(object, params, ctx, resolveInfo) {&#xA;      //************************************************************************************************************************************&#xA;      //** Author:        MOS&#xA;      //** Date:          22/07/2019&#xA;      //** Description:   Add a child Idiom         &#xA;      //************************************************************************************************************************************&#xA;&#xA;      //Build the cypher query across multiple lines so that we can adjust the query depending on which parameters are passed&#xA;      let query = new StringBuilder();&#xA;&#xA;      query.appendLine(""MATCH (p:entity:Idiom {id:'"" + params.from.id + ""'}), (c:entity:Idiom {id:'"" + params.to.id + ""'})"")&#xA;      query.appendLine(""MERGE (p)-[r:HAS_CHILD_IDIOM]-&gt;(c)"")&#xA;      query.appendLine(""RETURN p,c"")&#xA;&#xA;      console.log(query)&#xA;      //Execute the query and send the results back to the user&#xA;      return ctx.driver.session().run(query.toString(), {props:params})&#xA;        .then(result =&gt; {&#xA;          return {&#xA;            from: result.records.map(record =&gt; { return record.get(""p"").properties}),&#xA;            to: result.records.map(record =&gt; { return record.get(""c"").properties})&#xA;          }  &#xA;          }) &#xA;        .catch(error =&gt; {&#xA;          //ToDo: Error handling code need to go here&#xA;        })&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p><strong>GraphQL Query</strong></p>&#xA;&#xA;<pre><code>mutation{&#xA;  AddIdiomHasChildIdiom(from:{id:""d94676b0-ac6c-11e9-a7a1-edf120d553ac""},to:{id:""e730a720-ac74-11e9-a45f-df629a6df5e1""})&#xA;  {&#xA;    from{&#xA;      name&#xA;    }&#xA;    to{&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Output:</strong></p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""AddIdiomHasChildIdiom"": {&#xA;      ""from"": {&#xA;        ""name"": null&#xA;      },&#xA;      ""to"": {&#xA;        ""name"": null&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Relevant Schema Parts</strong></p>&#xA;&#xA;<pre><code>type Mutation{&#xA;  AddIdiomHasChildIdiom(&#xA;    from: _IdiomInput!&#xA;    to: _IdiomInput!&#xA;  ): _AddIdiomHasChildIdiomPayload&#xA;}&#xA;&#xA;type _AddIdiomHasChildIdiomPayload {&#xA;  from: Idiom&#xA;  to: Idiom&#xA;}&#xA;input _IdiomInput {&#xA;  id: ID!&#xA;}&#xA;&#xA;type _AddIdiomHasChildIdiomPayload {&#xA;  from: Idiom&#xA;  to: Idiom&#xA;}&#xA;type Idiom {&#xA;    id: ID&#xA;    name: String &#xA;    type: IdiomType&#xA;    description: String&#xA;    lifecycle: IdiomLifecycle&#xA;    quality: Float&#xA;    numStates: Int&#xA;    numChildIdioms: Int&#xA;    hasChildIdiom: [Idiom]&#xA;    first: Int&#xA;    offset: Int&#xA;    orderBy: [_IdiomOrdering]&#xA;}&#xA;</code></pre>&#xA;",7506888,,,,2019-07-25 08:40:43,Response from GraphQL Mutation not working as expected,<neo4j><graphql><neo4j-graphql-js>,1,0,0,2019-07-23 10:44:41
57191221,1,,,0,62,"<p>I'm trying to learn GraphQL and I think I may be misunderstanding something.  I want to be able to given a brand and a page, get some information back.  I also need to be able to query for a brand and get all pages.  Any thoughts on what I'm doing wrong?</p>&#xA;&#xA;<pre><code>query {&#xA;     base(brand: ""somebrand"") {&#xA;      brand&#xA;      pages(route: ""/"") {&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So i wrote a schema like</p>&#xA;&#xA;<pre><code>&#xA;type Page {&#xA;  name: String&#xA;  route: String &#xA;}&#xA;&#xA;type Base {&#xA;  brand: String&#xA;  pages: [Page]&#xA;}&#xA;&#xA;type Query {&#xA;  base(brand: String): Base&#xA;  pages(route: String): Page&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I get an error like Unknown argument ""route"" on field ""pages"" of type ""base""</p>&#xA;",2356770,,,,2019-07-24 21:03:38,Nested query in GraphQL,<graphql>,0,3,0,2019-07-24 21:03:38
57227422,1,57332377,,1,691,"<p>I am building an AWS AppSync graphQL server connected to DynamoDB which is using composite keys (let's say postID which is totally unique for my HASH and clientID for my RANGE).</p>&#xA;&#xA;<p>GraphQL specs ask for a <a href=""https://relay.dev/docs/en/graphql-server-specification.html?source=post_page---------------------------#object-identification"" rel=""nofollow noreferrer"">unique ID</a>.</p>&#xA;&#xA;<p>In order for me to fetch an item from DynamoDB I need to pass it both. How should I handle the schema in order to follow the graphQL specs?</p>&#xA;&#xA;<p>Would I create the graphQL ID build from postID+clientID? Is there a standardized way?</p>&#xA;&#xA;<p>It may be possible to I am overreading the specs and that it's totally fine to always require the clientID to be also passed for queries and mutation but I could not find a definitive answer. I have not yet worked with Relay so I am uncertain of what it sends back and forth.</p>&#xA;",856498,,856498,2019-07-26 22:45:00,2019-08-02 19:23:24,GraphQL Relay unique id requirement and dynamo composite keys,<amazon-dynamodb><graphql><aws-appsync>,1,0,0,2019-07-26 21:58:13
57234498,1,,,0,181,"<p>I have a GraphQL Schema that has a project, and every project has associated interfaces. I was able to query it by @key by project number. But now, I am not able to get the items associated by a project. Here is some info:</p>&#xA;&#xA;<p>My GraphQL Schema:</p>&#xA;&#xA;<pre><code>type Project &#xA;  @model @key(fields: [""project_number""]) &#xA;  {&#xA;    project_number: String!&#xA;    name: String!&#xA;    architect: String!&#xA;    interfaces: [Interface] @connection(name: ""ProjectInterfaces"")&#xA;&#xA;  }&#xA;type Interface&#xA;  @model &#xA;  {&#xA;    id: ID!             &#xA;    interface_name: String!&#xA;    version: String!&#xA;    release: String!    &#xA;    project: Project @connection(name: ""ProjectInterfaces"")          &#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Here is the query I made:</p>&#xA;&#xA;<pre><code>query GetProject {&#xA;  getProject(project_number:""P100"") {&#xA;    project_number&#xA;    name&#xA;    architect&#xA;    interfaces{&#xA;      items{&#xA;        id&#xA;        interface_name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Before I used the above schema without the key as project_number so I had something like <code>id:ID!</code> for project. With this, I was able to use the same query, and get the associated items with that ID. But now that I use the key for project_number it won't allow me to return the associated items. Perhaps it is a schema problem? I was thinking that it might be a resolver problem but I played around with the resolvers, and nothing seems to work. For background on the resolver. I believe it is due to the interfaceTable resolver. Here is the code that it autogenerated. I don't know what exactly to fix.</p>&#xA;&#xA;<pre><code>#set( $limit = $util.defaultIfNull($context.args.limit, 10) )&#xA;#set( $query = {&#xA;  ""expression"": ""#connectionAttribute = :connectionAttribute"",&#xA;  ""expressionNames"": {&#xA;      ""#connectionAttribute"": ""interfaceProjectId""&#xA;  },&#xA;  ""expressionValues"": {&#xA;      "":connectionAttribute"": {&#xA;          ""S"": ""$context.source.id""&#xA;    }&#xA;  }&#xA;} )&#xA;{&#xA;  ""version"": ""2017-02-28"",&#xA;  ""operation"": ""Query"",&#xA;  ""query"":   $util.toJson($query),&#xA;  ""scanIndexForward"":   #if( $context.args.sortDirection )&#xA;    #if( $context.args.sortDirection == ""ASC"" )&#xA;true&#xA;    #else&#xA;false&#xA;    #end&#xA;  #else&#xA;true&#xA;  #end,&#xA;  ""filter"":   #if( $context.args.filter )&#xA;$util.transform.toDynamoDBFilterExpression($ctx.args.filter)&#xA;  #else&#xA;null&#xA;  #end,&#xA;  ""limit"": $limit,&#xA;  ""nextToken"":   #if( $context.args.nextToken )&#xA;""$context.args.nextToken""&#xA;  #else&#xA;null&#xA;  #end,&#xA;  ""index"": ""gsi-ProjectInterfaces""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I also currently have a gsi index for the interfaces table called, ""gsi-ProjectInterfaces""</p>&#xA;&#xA;<p>Please let me know what you all think could be the issue! Thank you!</p>&#xA;",10007811,,,,2019-07-31 07:14:27,"Querying in GraphQL, get the list of items associated to a category",<amazon-dynamodb><graphql><aws-amplify>,1,0,0,2019-07-27 17:26:36
57238880,1,,,1,621,"<p>I'm using gridsome, which is pulling data from airtable. I have a table called Nouns, which have a self-referencing hierarchy (any Noun can be either parent or child of any other Noun). I have defined parents only in airtable, and want to write a graphql query for the single detail view (Noun.vue) to find all Nouns that have listed the current one as a parent.</p>&#xA;&#xA;<p>I have tried to use filters, but can't figure out how to filter on a nested object properly. Here's what the query looks like:</p>&#xA;&#xA;<pre><code>query Noun( $path: String!, $parents__id: [String] ) {&#xA;  main: noun( path: $path ) {&#xA;    id&#xA;    path&#xA;    name&#xA;    parents {&#xA;      id&#xA;      path&#xA;      name&#xA;    }&#xA;  }&#xA;  children: allNoun(filter: { id: { contains: $parents__id }}) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        path&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and the markup</p>&#xA;&#xA;<pre><code>&lt;h2&gt;Children&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;        &lt;li v-for=""(node, index) in $page.children.edges"" :key=""node.id+index""&gt;&#xA;          &lt;g-link :to=""node.path""&gt;{{ node.name }}&lt;/g-link&gt;&#xA;        &lt;/li&gt;&#xA;      &lt;/ul&gt;&#xA;</code></pre>&#xA;&#xA;<p>I'm not sure what I'm doing wrong here, but continue to get this error: <code>Error: Field ""contains"" is not defined by type NounFilterIdFilter</code>.</p>&#xA;",11847460,,,,2019-07-28 07:40:05,How to find children from parent reference nodes in graphql,<vue.js><graphql><airtable><gridsome>,0,0,0,2019-07-28 07:40:05
57280170,2,,57278764,1,,"<p>This is a known issue in Prisma.</p>&#xA;&#xA;<p><a href=""https://github.com/prisma/prisma/issues/3897"" rel=""nofollow noreferrer"">https://github.com/prisma/prisma/issues/3897</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>No, these were disabled in the Mongo connector in order to enable filters on relations. We might bring them back in the future, but for now we valued a quicker implementation of relational filters higher than OR, NOT.</p>&#xA;</blockquote>&#xA;",7152576,,,,2019-07-30 21:17:55,"",,0,0,0,2019-07-30 21:17:55
57288281,2,,57187810,0,,"<p>Filtering for Kentico Cloud API does not currently allow you to specify filters on nested properties and thefore filter such as <code>elements.produkte[].url_name</code> gives this exception when run against Delivery API directly:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Operator '[].produkte' was not recognized as a valid operator.</p>&#xA;</blockquote>&#xA;&#xA;<p>What you are trying to do is perfectly valid scenario, though currently you will have to make additional request on your products, filter it and combine results of your queries to give one final result.</p>&#xA;",2223843,,,,2019-07-31 10:07:21,"",,0,0,0,2019-07-31 10:07:21
57306680,1,,,0,1625,"<p>I'm currently writing something that can filter a list of users. The filter is based on a query which passes a <code>filter</code> parameter which is then picked up by a resolver which searches through various fields and returns the data.</p>&#xA;&#xA;<p>This works well for text, but prisma has some restrictions in the types of searches that you can do for scalars. So it's hard to see what the best way to search for a boolean would be.</p>&#xA;&#xA;<p>My resolver looks like this:</p>&#xA;&#xA;<pre><code>const listUsers = async (parent, args, context, info) =&gt; {&#xA;  const where = args.filter&#xA;    ? {&#xA;        OR: [&#xA;          { name_contains: args.filter },&#xA;          { email_contains: args.filter },&#xA;          { phone_contains: args.filter },&#xA;          { active: args.filter },&#xA;        ],&#xA;      }&#xA;    : {}&#xA;&#xA;  return await context.prisma.users({&#xA;    where,&#xA;  })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And a sample query looks like this:</p>&#xA;&#xA;<pre><code>&#xA;    query {&#xA;      listUsers(filter: ""test@test.com"") {&#xA;        name&#xA;        email&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>In theory, this would work if I simply passed 'TRUE' or 'FALSE' as my filter argument but this obviously doesn't work as more booleans are added to the User type, and also is not very clear.</p>&#xA;&#xA;<p>What is the best way to handle this?</p>&#xA;",5155510,,,,2019-08-16 09:44:47,How to filter a boolean in prisma,<javascript><graphql><prisma><prisma-graphql>,1,0,0,2019-08-01 10:10:08
57328349,1,57329303,,1,336,"<p>I am creating a graphql server using express, and I have a resolver that can transform my fields as per input from the user query.&#xA;The transformer that I am using is returning a function, which is the cause of my issues.</p>&#xA;&#xA;<p>I want to sort my result by some user determined field, but since the field is a function, it won't work.</p>&#xA;&#xA;<p>So the resolver looks like this:</p>&#xA;&#xA;<pre><code>const resolver = (req, param) =&gt; {&#xA;  return {&#xA;    history: async input =&gt; {&#xA;      let size = input.pageSize || 3;&#xA;      let start = (input.page || 0) * size;&#xA;      let end = start + size;&#xA;      let sortField = (input.sort || {}).field || 'timestamp';&#xA;      return fs.promises.readFile(""./history/blitz.json"", ""utf8"").then(data =&gt;&#xA;        JSON.parse(data)&#xA;          .slice(start, end)&#xA;          .map(job =&gt; historyTransformer(job))&#xA;          .sort((a,b) =&gt; a[sortField] &gt; b[sortField] ? 1 : a[sortField] &lt; b[sortField] ? -1 : 0)&#xA;      );&#xA;    }&#xA;  };&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>and the transformer:</p>&#xA;&#xA;<pre><code>const historyTransformer = job =&gt; {&#xA;  return {&#xA;    ...job,&#xA;    timestamp: input =&gt;&#xA;      dateFormat(job.timestamp, input.format || ""mm:hh dd-mm-yyyy"")&#xA;  };&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>I am not sure if I am missing something but is there an easy way of resolving the function call before starting the sorting?</p>&#xA;",3566441,,,,2019-08-02 15:15:31,resolve field function before sort,<javascript><node.js><express><graphql>,1,0,0,2019-08-02 14:20:52
57329303,2,,57328349,1,,"<p>GraphQL fields are resolved in a hierarchal manner, such that the <code>history</code> field has to resolve before any of its child fields (like <code>timestamp</code>) can be resolved. If the child field's resolver transforms the underlying property and your intent is to somehow use that value in the parent resolver (in this case, to do some sorting), that's tricky because you're working against the execution flow.</p>&#xA;&#xA;<p>Because you're working with dates, you should consider whether the format of the field even matters. As a user, if I sort by timestamp, I expect the results to be sorted chronologically. Even if the response is formatted to put the time first, I probably don't want dates with the same times but different years grouped together. Of course, I don't know your business requirements and it still doesn't solve the problem if we're working with something else, like translations, which would cause the same problem.</p>&#xA;&#xA;<p>There's two solutions I can think of:</p>&#xA;&#xA;<ul>&#xA;<li>Update your schema and lift the <code>format</code> argument into the parent field. This is easier to implement, but obviously not as nice as putting the argument on the field it applies to.</li>&#xA;<li>Keep the argument where it is, but <a href=""https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a"" rel=""nofollow noreferrer"">parse the info parameter</a> passed to the resolver to determine the value of the argument inside the parent resolver. This way, you can keep the argument on the child field, but move the actual formatting logic into the parent resolver.</li>&#xA;</ul>&#xA;",6024220,,,,2019-08-02 15:15:31,"",,0,0,0,2019-08-02 15:15:31
57352609,1,,,0,813,"<p>I'm starting a new project using AWS Amplify, and have some trouble to correctly define my schema for my use case with nested objects</p>&#xA;&#xA;<p>I have the following schema</p>&#xA;&#xA;<pre><code>type Company&#xA;  @model&#xA;{&#xA;  id: ID!&#xA;  name: String!&#xA;  teams: [Team] @connection (name: ""CompanyTeams"", sortField: ""name"")&#xA;}&#xA;&#xA;type Team&#xA;  @model&#xA;{&#xA;  id: ID!&#xA;  name: String!&#xA;  users: [User] @connection (name: ""TeamUsers"", sortField: ""createdAt"")&#xA;  company: Building @connection (name: ""CompanyTeams"", sortField: ""name"")&#xA;  teamCompanyId: ID!&#xA;}&#xA;&#xA;type User&#xA;  @model&#xA;{&#xA;  id: ID!&#xA;  createdAt: String&#xA;  name: String!&#xA;  email: String!&#xA;  team: Unit @connection (name: ""TeamUsers"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would like to be able to query a list of teams based on a list of companies and a user name. </p>&#xA;&#xA;<p>For example, get all teams in companies A/B/C with user name starts with ""David"".</p>&#xA;&#xA;<p>Is my current schema fine for that?</p>&#xA;&#xA;<p>I can easily retrieve a list of teams based on the company with this kind of query</p>&#xA;&#xA;<pre><code>query listTeams {&#xA;  listTeams(filter: {&#xA;    teamCompanyId: {&#xA;      eq:""A""&#xA;    } &#xA;  }) {&#xA;    items {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But not sure how to include search on the user model. Should I override the filter and add a new custom resolver including the new filters?</p>&#xA;&#xA;<p>Also is using filters the best solution? I believe with DynamoDB filter is only applied after we got results from the query or scan. And due to the limitation of 1mb, it might introduce a lot of reads to retrieve some results?</p>&#xA;&#xA;<p>Happy to get any insights as I'm relatively new with AppSync / GraphQL and DynamoDB.</p>&#xA;&#xA;<p>Thanks.</p>&#xA;",2285361,,,,2019-09-12 17:22:27,AppSync GraphQL query with nested objects,<amazon-dynamodb><graphql><aws-amplify><aws-appsync>,0,4,0,2019-08-05 05:27:35
57421446,1,,,0,1335,"<p>I code a Gatsby app with a Main page and two components. The value from a select form will be used to query a Postgresql database through a graphql query. </p>&#xA;&#xA;<p><strong>What I can already do:</strong> in the form component, I get the value from the select menu and pass it from this child component to the parent (the main page). In the data component, I can query the database with graphql and get the results with hardcoded values. </p>&#xA;&#xA;<p><strong>What I can't do yet:</strong> get the value from the select component to the data component and use it in my graphql query.</p>&#xA;&#xA;<p>I tried different ways to get the value without success using this.props.value1 or this.state.value1. I also tested a simple component to make sure I could get the value from the parent to a child component and it worked seamlessly. So it's the way I try to import the value in a querying component that is the problem.</p>&#xA;&#xA;<pre><code>**//Data component**&#xA;let val = 88 //for hardcoded test. That works.&#xA;&#xA;const DataPage = () =&gt; {&#xA;  const data = useStaticQuery(query)&#xA;  return (&#xA;    &lt;div&gt;&#xA;      &lt;p&gt;From Postgres: {data.postgres.allEstivalsList[val].nbr}&lt;/p&gt;&#xA;    &lt;/div&gt;&#xA;  )&#xA;}&#xA;&#xA;const query = graphql`&#xA;{&#xA;  postgres {&#xA;    allAveragesList {&#xA;     avg&#xA;    }&#xA;     allEstivalsList {&#xA;      year&#xA;      nbr&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;&#xA;export default DataPage; &#xA;&#xA;**//Main page**&#xA;export default class App extends React.Component {&#xA;  constructor(props) {&#xA;    super(props);&#xA;  }&#xA;  state = {&#xA;    value1: null,&#xA;    // other values&#xA;  }&#xA;&#xA;  render() {&#xA;        return (&#xA;          &lt;div&gt;&#xA;            &lt;p&gt;Get state in main page: {this.state.value1}&lt;/p&gt;&#xA;            &lt;DataPage val = {this.state.value1} /&gt;&#xA;            &lt;SelectForm clickHandler={y =&gt; { this.setState({ value1: y }); }} /&gt;&#xA;          &lt;/div&gt;&#xA;        )&#xA;    }&#xA;}&#xA;&#xA;**//Form component**&#xA;&#xA;export default class IndexPage extends React.Component {&#xA;  state = {&#xA;    value1: null,&#xA;  }&#xA;&#xA;  handleClick = () =&gt; {&#xA;    this.props.clickHandler(this.state.value1);&#xA;&#xA;    this.setState(prevState =&gt; {&#xA;      return { value1: prevState.value1 };&#xA;    });&#xA;  };&#xA;&#xA;  render() {&#xA;    return (&#xA;      &lt;Formlayout&gt;                                    &#xA;      &lt;p&gt;Test -- Value for the selected year: {this.state.value1}&lt;/p&gt;&#xA;      &lt;select onChange = {(e) =&gt; this.setState({ value1: e.target.value })}&gt;&#xA;      &lt;option value=""""&gt;-- Year --&lt;/option&gt;&#xA;      &lt;option value=""1""&gt;1901&lt;/option&gt;&#xA;      &lt;option value=""2""&gt;1902&lt;/option&gt;&#xA;      &lt;option value=""3""&gt;1903&lt;/option&gt;&#xA;      &lt;/select&gt;&#xA;      &lt;button onClick={this.handleClick}&gt;Go!&lt;/button&gt;&#xA;      &lt;/Formlayout&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I'd appreciate to get some directions to get the select value in the data component. As my test variable val is effectively working when used in the query, what I'd like to achieve is to apply to that variable the state from  the component. And that's where I'm stuck right now.</p>&#xA;",2949510,,2949510,2019-08-09 15:01:08,2019-08-10 19:17:24,Get state from select form in child component with Gatsby,<graphql><gatsby>,1,0,0,2019-08-08 22:33:48
57438138,1,57438599,,0,533,"<p>I prettify my GraphQL query in the GraphiQL window of my browser. I use the Gatsby GrapiQL implementation. The filter part is always condensed in one long line so that I have to use the horizontal scroll bar. This has been bugging me for months now.</p>&#xA;&#xA;<p>The prettyfied code</p>&#xA;&#xA;<pre><code>{&#xA;  allFile(filter: {sourceInstanceName: {eq: ""tour-data""}}, sort: {fields: base, order: ASC}) {&#xA;    edges {&#xA;      node {&#xA;        relativePath&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How it looks in the browser: Without scrolling I cannot see or edit how it is sorted. <a href=""https://i.stack.imgur.com/wrjHZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wrjHZ.png"" alt=""truncated filter line""></a></p>&#xA;&#xA;<p>It's a small inconvenience but this scrolling adds up over time. Prettify implemented like this has terrible user experience. I filter all my queries so I have to do a lot of scrolling.</p>&#xA;&#xA;<p>I looked in the official documentation and the github project. I did not find a way to alter the formatting rules.</p>&#xA;&#xA;<p>Is there a way to tell prettify to give the filter its own lines?</p>&#xA;",3689364,,,,2022-03-30 12:18:26,Prettify GraphiQL query: filter always formatted in one long unreadable line,<graphql><gatsby><graphql-js><graphiql>,1,0,0,2019-08-09 23:23:53
57438599,2,,57438138,1,,"<p>I don't think there's any way to configure that unless you built an instance of GraphiQL yourself and pointed it at your endpoint. You might try a client like <a href=""https://altair.sirmuel.design/"" rel=""nofollow noreferrer"">Altair</a> though no promises.</p>&#xA;<p>The other option is to simply make filter a variable. I think the prettify works a little better on the variables JSON object in that regard.</p>&#xA;<pre><code>query ($filter: FileFilterInput!, $sort: FileSortInput!) {&#xA;  allFile(filter: $filter, sort: $sort) {&#xA;    edges {&#xA;      node {&#xA;        relativePath&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;filter&quot;: {&#xA;    &quot;sourceInstanceName&quot;: {&#xA;      &quot;eq&quot;: &quot;tour-data&quot;&#xA;    }&#xA;  },&#xA;  &quot;sort&quot;: {&#xA;    &quot;fields&quot;: &quot;base&quot;,&#xA;    &quot;order&quot;: &quot;ASC&quot;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I'm guessing at the actual type names -- check the schema docs for the correct names. Also bear in mind that <a href=""https://github.com/gatsbyjs/gatsby/issues/10482"" rel=""nofollow noreferrer"">variables can't be used with StaticQuery</a>.</p>&#xA;",6024220,,247482,2022-03-30 12:18:26,2022-03-30 12:18:26,"",,0,2,0,2019-08-10 01:17:02
57440439,2,,57440369,0,,"<p>I solved it using componentDidUpdate lifecycle method</p>&#xA;&#xA;<pre><code>componentDidUpdate(prevProps, prevState) {&#xA;        if (prevProps.car !== this.props.car) {&#xA;            this.onCarRender()&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;",10351114,,,,2019-08-10 08:03:18,"",,0,0,0,2019-08-10 08:03:18
57446167,1,57743227,,3,5255,"<p>This is my first time using GraphQL, and I've created a schema for an app that has Users, Songs, and Tips. Note that both listeners &amp; artists are represented as a User, and that any User can 'tip' a Song by Creating a tip</p>&#xA;&#xA;<p>I'm having trouble correctly defining the one-to-many &amp; many-to-many relationships in the schema. I'm also confused about how to write mutations for creating Song/User/Tip objects that correctly point to one another.</p>&#xA;&#xA;<p>I know I need to use the @connection directive in my schema definition and I've tried following <a href=""https://aws-amplify.github.io/docs/cli-toolchain/graphql#usage-3"" rel=""nofollow noreferrer"">this example</a>, but I'm still confused on how to translate this design to my use case. </p>&#xA;&#xA;<p>Here's a stab I took at specifying relationships between objects:</p>&#xA;&#xA;<pre><code>type Song @model{&#xA;  id: ID!&#xA;  title: String!&#xA;  artist: String!&#xA;  artistArray: [User]! @connection(name: ""SongArtists"")&#xA;  tips: [Tip]! @connection(name: ""SongTips"")&#xA;  totalAmountReceived: Float!&#xA;}&#xA;&#xA;type Tip @model{&#xA;  id: ID!&#xA;  from: User! @connection(name: ""UserTipsSent"")&#xA;  to: User! @connection(name: ""UserTipsReceived"")&#xA;  song: Song! @connection(name: ""SongTips"")&#xA;  amount: Float!&#xA;  createdAt: String!&#xA;  hash: String!&#xA;}&#xA;&#xA;type User @model{&#xA;  id: ID!&#xA;  name: String!&#xA;  walletAddress: String!&#xA;  totalAmountDonated: Float!&#xA;  totalAmountReceived: Float!&#xA;  songs: [Song]! @connection(name: ""SongArtists"")&#xA;  tipsSent: [Tip]! @connection(name: ""UserTipsSent"")&#xA;  tipsReceived: [Tip]! @connection(name: ""UserTipsReceived"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>My schema without specifying any connections</h2>&#xA;&#xA;<pre><code>type Song @model {&#xA;  id: ID!&#xA;  title: String!&#xA;  artist: String!&#xA;  artistArray: [User]!&#xA;  tips: [Tip]!&#xA;  totalAmountReceived: Float!&#xA;}&#xA;&#xA;type Tip @model {&#xA;  id: ID!&#xA;  from: User!&#xA;  to: User!&#xA;  song: Song!&#xA;  amount: Float!&#xA;  createdAt: String!&#xA;  hash: String!&#xA;}&#xA;&#xA;type User @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  walletAddress: String!&#xA;  totalAmountDonated: Float!&#xA;  totalAmountReceived: Float!&#xA;  songs: [Song]!&#xA;  tipsSent: [Tip]!&#xA;  tipsReceived: [Tip]!&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>I want to implement the following relationships</h2>&#xA;&#xA;<ul>&#xA;<li>A Tip must be associated with one Song, a 'from' User and a 'to' User</li>&#xA;<li>A Song must have at least one artist (User)</li>&#xA;<li>A User may have many Songs</li>&#xA;<li>A User may have sent and/or received many Tips</li>&#xA;</ul>&#xA;&#xA;<p>I also don't know how I would write a mutation that (for example) creates a Song (pointing to the correct artist(s)/User(s)) while ensuring the artist (songs array in User object) also references the Song I just created.</p>&#xA;&#xA;<p>It's worth noting that I've created 3 tables in my AWS AppySync DynamoDB (Song, User, Tip), and would like to be able to retrieve (for example) a User, all the Songs they've made, and all the Tips they've ever received in a single query.</p>&#xA;",5942450,,5942450,2019-08-10 23:11:48,2019-09-01 04:38:20,How do I implement one-to-many & many-to-many relationships in my GraphQL schema?,<graphql><aws-appsync>,1,0,0,2019-08-10 22:41:35
57459376,1,,,1,179,"<p>In my drupal 8 decoupled project with Gatsby I want to filter with a graphql query posts. I am using the json-api module.&#xA;I only want in Gatsby the output of a query for posts of the last week. So I need something like:</p>&#xA;&#xA;<pre><code>allNodePosts(filter: {date: {eq: ""between today and last seven days""}}) {&#xA;  edges {&#xA;    node {&#xA;      body {&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Is this possible with graphql? And if yes how must the query looks like? </p>&#xA;",5189291,,5189291,2019-08-12 12:28:52,2019-08-12 12:28:52,How to query to show only posts of the last week,<graphql><drupal-8><gatsby>,0,2,0,2019-08-12 10:17:51
57482983,1,57484012,,0,466,"<p>Return from Server</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/vXTai.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vXTai.png"" alt=""return from server""></a>In Apollo I can query down about two levels and then I get ""returns undefined"".  I can get down to ""project"" on line 7, But I cannot get ""Checklists"" on line 12.  Any help would be greatly appreciated.</p>&#xA;&#xA;<pre><code>updateNotication(){&#xA;  this.apollo&#xA;  .watchQuery({&#xA;    query: gql`&#xA;      query&#xA;      {&#xA;        project&#xA;        (id:[2272],accesstoken:""val"")&#xA;        {&#xA;          ID,&#xA;          Title,&#xA;          Checklists&#xA;            {&#xA;              ID,&#xA;              Name,&#xA;              DateDue&#xA;            }&#xA;        }&#xA;      }&#xA;    `,&#xA;  })&#xA;  .valueChanges.subscribe((result: ApolloQueryResult&lt;any&gt; ) =&gt; {&#xA;    console.log('data', result.data); // returns data Object&#xA;    console.log('project', result.data.project); // returns project array&#xA;    console.log('Checklists', result.data.project.Checklists); // returns undefined&#xA;  }); &#xA;}&#xA;</code></pre>&#xA;",4425620,,4425620,2019-08-13 18:47:36,2019-08-13 19:11:42,Apollo query array within an array,<ionic-framework><graphql><apollo>,1,2,0,2019-08-13 17:52:06
57486224,2,,54218505,1,,"<p>I had trouble implementing the 'in' filter as well--it appears to be misimplemented in graphene-django right now and does not work as expected. Here are the steps to make it work:</p>&#xA;&#xA;<ol>&#xA;<li>Remove the 'in' filter from your filter_fields</li>&#xA;<li>Add an input value to your DjangoFilterConnectionField entitled 'id__in' and make it a list of IDs</li>&#xA;<li>Rename your resolver to match the 'samples' field.</li>&#xA;<li>Handle filtering by 'id__in' in your resolver for the field. For you this will look as follows:</li>&#xA;</ol>&#xA;&#xA;<pre><code>from base64 import b64decode&#xA;&#xA;def get_pk_from_node_id(node_id: str):&#xA;    """"""Gets pk from node_id""""""&#xA;    model_with_pk = b64decode(node_id).decode('utf-8')&#xA;    model_name, pk = model_with_pk.split("":"")&#xA;    return pk&#xA;&#xA;&#xA;class SampleType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Sample&#xA;        filter_fields = {&#xA;            'id': ['exact'],&#xA;         }&#xA;        interfaces = (graphene.relay.Node,)&#xA;&#xA;&#xA;class Query(object):&#xA;&#xA;    samples = DjangoFilterConnectionField(SampleType, id__in=graphene.List(graphene.ID))&#xA;&#xA;    def resolve_samples(self, info, **kwargs):&#xA;        # filter_field for 'in' seems to not work, this hack works&#xA;        id__in = kwargs.get('id__in')&#xA;        if id__in:&#xA;            node_ids = kwargs.pop('id__in')&#xA;            pk_list = [get_pk_from_node_id(node_id) for node_id in node_ids]&#xA;            return Sample._default_manager.filter(id__in=pk_list)&#xA;        return Sample._default_manager.all()&#xA;</code></pre>&#xA;&#xA;<p>This will allow you to call the filter with the following api. Note the use of an actual array in the signature (I think this is a better API than sending a comma separated string of values). This solution still allows you to add other filters to the request and they will chain together correctly.</p>&#xA;&#xA;<pre><code>{&#xA;  samples(id_In: [""U2FtcGxlU2V0VHlwZToxMjYw"", ""U2FtcGxlU2V0VHlwZToxMjYx""]) {&#xA;    edges {&#xA;      nodes {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;} &#xA;</code></pre>&#xA;",5728276,,5728276,2019-08-14 01:00:37,2019-08-14 01:00:37,"",,0,0,0,2019-08-13 22:53:19
57504905,1,,,2,931,"<p>My backend REST API takes a list of <code>id</code>'s and returns a list of, say, <code>Person</code> objects whose <code>id</code> was requested. Each <code>Person</code> has a <code>children</code> property, which is a list of <code>Person.id</code>. A nice family tree.</p>&#xA;&#xA;<pre><code>// GET /id/[1,2]&#xA;{&#xA;  ""id"": 1,&#xA;  ""name"": ""Jacob"",&#xA;  ""children"": [3, 4]&#xA;},&#xA;{&#xA;  ""id"": 2,&#xA;  ""name"": ""Jack"",&#xA;  ""children"": [5, 6]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Using AppSync to front said API, I have a resolver for <code>children</code> that makes a call to my API using the following template:</p>&#xA;&#xA;<pre><code>#set( $myMap = {&#xA;  ""id"" : $context.source.children&#xA;} )&#xA;&#xA;{&#xA;  ""version"" : ""2017-02-28"",&#xA;  ""operation"": ""Invoke"",&#xA;  ""payload"": {&#xA;    ""id"": $util.toJson($myMap)&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This works fine, and AppSync nicely ""unwraps"" the <code>children</code> array with the appropriate <code>Person</code>. The issue is that if a <code>Person</code> has <code>N</code> children, then <code>N</code> calls are made to my backend API if the client requests the children.</p>&#xA;&#xA;<p>Since my API could take all of the children IDs for all <code>N</code> children at once, it would be nice if AppSync had a way to batch those calls, and then somehow untangle the response and put each <code>Person</code> in the right place.</p>&#xA;&#xA;<h1>Question</h1>&#xA;&#xA;<p>Is there a way to batch all of individual calls for a nested property into a single call per nested level?</p>&#xA;&#xA;<h3>Edit</h3>&#xA;&#xA;<p>My GraphQL schema for the example above:</p>&#xA;&#xA;<pre><code>type Person {&#xA;  id: Int&#xA;  name: String&#xA;  children: [Person]&#xA;}&#xA;</code></pre>&#xA;",774907,,,,2019-08-21 23:11:07,AppSync batch call for nested properties,<rest><graphql><aws-appsync>,2,0,0,2019-08-15 04:34:14
57513870,2,,57510637,1,,"<p>Okay so my last answer didn't work as intended, so I thought I would create an entirely new example to demonstrate what I am talking about. Simply, the goal here is to have a child component within a parent component that only re-renders when it receives NEW props. Note, I have made use of the component lifecycle method <code>shouldComponentUpdate()</code> to prevent the <code>Child</code> component from re-rendering unless there is a change to the prop. Hope this helps with your problem. </p>&#xA;&#xA;<p><a href=""https://codesandbox.io/s/pedantic-sea-kis3i?fontsize=14"" rel=""nofollow noreferrer""><img src=""https://codesandbox.io/static/img/play-codesandbox.svg"" alt=""Edit pedantic-sea-kis3i""></a></p>&#xA;&#xA;<pre><code>class Child extends React.Component {&#xA;  shouldComponentUpdate(nextProps) {&#xA;    if (nextProps.id === this.props.id) {&#xA;      return false&#xA;    } else {&#xA;      return true&#xA;    }&#xA;  }&#xA;  componentDidUpdate() {&#xA;    console.log(""Child component updated"")&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        {`Current child ID prop: ${this.props.id}`}&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;class Parent extends React.Component {&#xA;  constructor(props) {&#xA;    super(props)&#xA;    this.state = {&#xA;      id: 14,&#xA;      text: 15&#xA;    }&#xA;  }&#xA;  onChange = (event) =&gt; {&#xA;    this.setState({ text: event.target.value })&#xA;  }&#xA;  onClick = () =&gt; {&#xA;    this.setState({ id: this.state.text })&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;input type='text' onChange={this.onChange} /&gt;&#xA;        &lt;button onClick={this.onClick}&gt;Change ID&lt;/button&gt;&#xA;        &lt;Child id={this.state.id} /&gt;&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;function App() {&#xA;  return (&#xA;    &lt;div className=""App""&gt;&#xA;      &lt;Parent /&gt;&#xA;    &lt;/div&gt;&#xA;  );&#xA;}&#xA;</code></pre>&#xA;",9636451,,,,2019-08-15 17:41:09,"",,0,0,0,2019-08-15 17:41:09
57522395,2,,57306680,0,,"<p>You could split between the <code>filter</code> (with text) and the <code>options</code> with boolean and such:</p>&#xA;&#xA;<pre><code>query {&#xA;  listUsers(filter: ""test@test.com"", options: {active: true}) {&#xA;    name&#xA;    email&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<pre><code>const fields = ['name', 'email', 'phone']&#xA;&#xA;const listUsers = async (parent, args, context, info) =&gt; {&#xA;  const where = {&#xA;    OR: [&#xA;      ...fields.reduce((acc, field) =&gt; {&#xA;        acc[name+'_contains'] = args.filter&#xA;        return acc&#xA;      },{}),&#xA;      ...args.options&#xA;    ]&#xA;  }&#xA;&#xA;  return await context.prisma.users({&#xA;    where,&#xA;  })&#xA;}&#xA;</code></pre>&#xA;",10721492,,,,2019-08-16 09:44:47,"",,0,0,0,2019-08-16 09:44:47
57529979,1,57575938,,1,1980,"<p>I have a simple query auto-generated from aws AppSync, and I'm trying to use the Connect Component, with a FlatList and use a TextInput to filter and auto-update the list. But I confess I didn't found out a way to do that... any hints?</p>&#xA;&#xA;<p>Tried to find more information about this without success...</p>&#xA;&#xA;<p>Auto-Generated query:</p>&#xA;&#xA;<pre><code>export const listFood = `query ListFood(&#xA;  $filter: ModelFoodFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listFood(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      description&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>My current code, which I don't quite know where to place my filter value:</p>&#xA;&#xA;<pre><code>            &lt;Connect query={graphqlOperation(queries.listFood)}&gt;&#xA;                {&#xA;                    ( { data: { listFood }, loading, error } ) =&gt; {&#xA;&#xA;                        if(error) return (&lt;Text&gt;Error&lt;/Text&gt;);&#xA;&#xA;                        if(loading || !listFood) return (&lt;ActivityIndicator /&gt;);&#xA;&#xA;                        return (&#xA;                            &lt;FlatList&#xA;                                data={listFood.items}&#xA;                                renderItem={({item}) =&gt; {&#xA;                                    return (&#xA;                                        &lt;View style={styles.hcontainer}&gt;&#xA;                                            &lt;Image source={{uri:this.state.logoURL}}&#xA;                                                style={styles.iconImage}&#xA;                                            /&gt;                                    &#xA;                                            &lt;View style={styles.vcontainer}&gt;&#xA;                                                &lt;Text style={styles.textH3}&gt;{item.name}&lt;/Text&gt;&#xA;                                                &lt;Text style={styles.textP}&gt;{item.description}&lt;/Text&gt;&#xA;                                            &lt;/View&gt;&#xA;                                        &lt;/View&gt;&#xA;                                    );&#xA;                                }}&#xA;                                keyExtractor={(item, index) =&gt; item.id}&#xA;                            /&gt;&#xA;                        );&#xA;&#xA;&#xA;                    }&#xA;                }&#xA;            &lt;/Connect&gt;&#xA;</code></pre>&#xA;&#xA;<p>What I aim is mainly to filter by item.name, refreshing the list while typing from a TextInput, probably going somewhere on the $filter variable...</p>&#xA;",6466366,,,,2020-07-08 17:08:17,How to use the $filter variable on graphql query under the Connect component?,<react-native><graphql><aws-amplify><aws-appsync>,2,1,0,2019-08-16 19:13:33
57548142,1,57548159,,-1,1063,"<p>I'm using apollo-client and want to send some variable for each request. Let's call it <code>locale</code>. I don't want to pass it to every <code>Query</code> component, it's not DRY pattern.</p>&#xA;",532247,,,,2020-01-14 16:41:09,How to set variable for each request for apollo-client?,<reactjs><apollo><react-apollo>,2,0,0,2019-08-18 20:26:36
57567884,2,,45674423,4,,"<p>If you are using <a href=""https://prisma.io"" rel=""nofollow noreferrer"">Prisma</a> as backend, you could use the greater than operator (<code>_gt</code>), like so:</p>&#xA;&#xA;<pre><code>query {&#xA;  persons(where: {age_gt: 18}) {&#xA;    firstName&#xA;    lastName&#xA;    age&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can also use other operators like:</p>&#xA;&#xA;<ul>&#xA;<li><code>_gt</code> (greater than)</li>&#xA;<li><code>_lt</code> (less than)</li>&#xA;<li><code>_gte</code> (greater than or equal to)</li>&#xA;<li><code>_lte</code> (less than or equal to)</li>&#xA;<li><code>_in</code> (equal to)</li>&#xA;<li><code>_not_in</code> (not equal to)</li>&#xA;</ul>&#xA;&#xA;<p>They are compatible with any data types like Integer, Float, Double, Text, Boolean, Date, etc.</p>&#xA;",7602110,,7602110,2019-08-20 06:41:02,2019-08-20 06:41:02,"",,0,0,0,2019-08-20 06:35:29
57575938,2,,57529979,2,,"<p>Ok, I think I've figured out the usage with the AWS AppSync Out-of-the-box queries...</p>&#xA;&#xA;<pre><code>query MyFoodList{&#xA;  listFood(&#xA;    filter: {&#xA;      name: {&#xA;        contains:""a""&#xA;      }&#xA;    }&#xA;  ) {&#xA;    items {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>And it is finally working properly with this disposition on my react-native code:</p>&#xA;&#xA;<pre><code>        &lt;Connect query={ this.state.filter!=="""" ? &#xA;                         graphqlOperation(queries.listFood, {&#xA;                            filter: {&#xA;                                name: {&#xA;                                    contains: this.state.filter&#xA;                                }&#xA;                            }&#xA;                         })&#xA;                         :&#xA;                         graphqlOperation(queries.listFood)&#xA;&#xA;        }&gt;&#xA;</code></pre>&#xA;&#xA;<p>I still didn't manage to make the sort key work yet... will try a little more and open another topic for it if I didn't get anything...</p>&#xA;",6466366,,6466366,2019-08-22 12:24:21,2019-08-22 12:24:21,"",,0,1,0,2019-08-20 14:30:39
57582990,1,,,5,823,"<p>I am trying to get this Query to sort the <code>ideas</code> of <code>users</code>:</p>&#xA;&#xA;<pre><code>  users {&#xA;    id&#xA;    ideas(orderBy: createdAt_DESC) {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It works without the <code>orderBy</code> argument.&#xA;However with the <code>orderBy</code> arg, I get this error: <code>""Unknown argument \""orderBy\"" on field \""ideas\"" of type \""User\"".""</code></p>&#xA;&#xA;<p>My <code>ideas</code> schema is <a href=""https://github.com/hmmChase/next-graphql-starter/blob/master/backend/src/schema/schema.graphql#L29"" rel=""noreferrer"">here</a></p>&#xA;&#xA;<p>My <code>ideas</code> resolver is <a href=""https://github.com/hmmChase/next-graphql-starter/blob/master/backend/src/resolvers/ideaResolver.js#L16"" rel=""noreferrer"">here</a></p>&#xA;&#xA;<p>Btw, if I Query <code>ideas</code> with the <code>orderBy</code> directly:</p>&#xA;&#xA;<pre><code>query ideas {&#xA;  ideas(orderBy: createdAt_DESC) {&#xA;    id&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>It works.&#xA;I am just confused how to make the nested field sorting work.</p>&#xA;",4864527,,,,2019-08-21 00:23:03,How to sort nested field in a Query?,<graphql><apollo><prisma>,0,1,0,2019-08-21 00:23:03
57612167,1,57621521,,5,3374,"<p>There have been a couple of similar questions, but none helped me really understand using a GraphQL inside a (class) component other than the ones in the pages folder.</p>&#xA;&#xA;<p>My project structure looks like that:</p>&#xA;&#xA;<pre><code>-src&#xA;--components&#xA;---aboutBody&#xA;----index.js&#xA;--pages&#xA;---about.js&#xA;</code></pre>&#xA;&#xA;<p>I have a page component called <code>about</code> (Prismic single page type) and set up some components to ""fill"" this page (cleaned up for better readability).</p>&#xA;&#xA;<pre><code>class AboutPage extends Component {&#xA;&#xA;  render() {&#xA;    return (&#xA;        &lt;LayoutDefault&gt;&#xA;          &lt;AboutBody&#xA;            introHeadline={this.props.data.prismicAbout.data.intro_headline.text}&#xA;            introParagraph={this.props.data.prismicAbout.data.intro_paragraph.text}&#xA;          /&gt;&#xA;        &lt;/LayoutDefault&gt;&#xA;    )&#xA;  }&#xA;&#xA;}&#xA;&#xA;export default AboutPage&#xA;</code></pre>&#xA;&#xA;<p>This is what my query looks like (had it like this in both files):</p>&#xA;&#xA;<pre><code>export const aboutQuery = graphql`&#xA;  query About {&#xA;    prismicAbout {&#xA;      data {&#xA;&#xA;        # Intro Block&#xA;        intro_headline {&#xA;          text&#xA;        }&#xA;        intro_paragraph {&#xA;          text&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>(In case I am missing a bracket at the bottom, it's due to cleaning up the query example for SO — as mentioned earlier, it's working in my page component).</p>&#xA;&#xA;<p>My graphql query is at the bottom of the <code>AboutPage</code> page component. It works like a charm and as intended.</p>&#xA;&#xA;<p>But to clean this page up a bit I wanted to create appropriate components and put my query inside each component (e.g. <code>aboutBody</code>, <code>aboutCarousel</code>), again cleaned up a bit:</p>&#xA;&#xA;<pre><code>class AboutBody extends Component {&#xA;&#xA;  render() {&#xA;&#xA;    return (&#xA;      &lt;StyledIntro&gt;&#xA;        &lt;h3&gt;About&lt;/h3&gt;&#xA;        &lt;h1&gt;{this.props.data.prismicAbout.data.intro_headline.text}&lt;/h1&gt;&#xA;      &lt;/StyledIntro&gt;&#xA;    )&#xA;  }&#xA;&#xA;}&#xA;&#xA;export default AboutBody&#xA;&#xA;</code></pre>&#xA;&#xA;<p>And I deleted the query from my <code>about</code> page component and put it inside my <code>AboutBody</code> component (exactly the way as shown above).</p>&#xA;&#xA;<p>But with this it always returns the error <code>Cannot read property 'prismicAbout' of undefined</code> (I can't even console log the data, it always returns the same error).</p>&#xA;&#xA;<p>I used <code>import { graphql } from ""gatsby""</code> in both files.</p>&#xA;&#xA;<p>Long story short, how can I achieve putting a query inside my class component and render only the component without clarifying the props in my page component like this:</p>&#xA;&#xA;<pre><code>class AboutPage extends Component {&#xA;&#xA;  render() {&#xA;    return (&#xA;        &lt;LayoutDefault&gt;&#xA;          &lt;AboutBody /&gt;&#xA;        &lt;/LayoutDefault&gt;&#xA;    )&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Some blogs posts mention GraphQL Query Fragments, but not sure if this is the correct use case or if it's simply a stupid beginner mistake...</p>&#xA;",7693710,,,,2021-06-21 09:35:24,GraphQL query works in Gatsby page but not inside class component,<reactjs><graphql><gatsby><prismic.io>,3,0,0,2019-08-22 14:57:22
57619586,1,,,1,255,"<p>I am working on a Gatsby site for a freelance writer. I am using Sanity as the CMS. I am working to sort and organize a list of their published writing by category, not by date. My code works but is not very robust as you will see.  I am thinking there is a more effective way of accomplishing what I want to do. I am thinking the answer would be obvious here to someone more experienced with nested loops in react.</p>&#xA;&#xA;<p>I have been experimenting with a variety of loops and keep running into problems when I try to nest the loops to capture the results of both the <code>cats</code> variable and the <code>writing</code> variable.</p>&#xA;&#xA;<pre><code>const publishedList = () =&gt; {&#xA;  const data = useStaticQuery(graphql`&#xA;    query {&#xA;      allSanityPublishedWork {&#xA;        nodes {&#xA;          title&#xA;          category&#xA;          id&#xA;          publishedBy&#xA;          publishedDate&#xA;        }&#xA;        distinct(field: category)&#xA;      }&#xA;    }&#xA;  `);&#xA;  const writing = data.allSanityPublishedWork.nodes;&#xA;  const cats = data.allSanityPublishedWork.distinct;&#xA;  return (&#xA;    &lt;div&gt;&#xA;      &lt;h3&gt;{cats[0]}&lt;/h3&gt;&#xA;      {writing&#xA;        .filter(pub =&gt; pub.category === cats[0])&#xA;        .map(pub =&gt; (&#xA;          &lt;p&gt;{pub.title}&lt;/p&gt;&#xA;        ))}&#xA;      &lt;h3&gt;{cats[1]}&lt;/h3&gt;&#xA;      {writing&#xA;        .filter(pub =&gt; pub.category === cats[1])&#xA;        .map(pub =&gt; (&#xA;          &lt;p&gt;{pub.title}&lt;/p&gt;&#xA;        ))}&#xA;      &lt;h3&gt;{cats[2]}&lt;/h3&gt;&#xA;      {writing&#xA;        .filter(pub =&gt; pub.category === cats[2])&#xA;        .map(pub =&gt; (&#xA;          &lt;p&gt;{pub.title}&lt;/p&gt;&#xA;        ))}&#xA;    &lt;/div&gt;&#xA;  );&#xA;};&#xA;&#xA;export default publishedList;&#xA;</code></pre>&#xA;&#xA;<p>As you can see in my code example I rely on specifying the array number like so <code>cats[0]</code> which is not a robust way to accomplish this as I need to know the exact number of categories which could change over time.  There should be a way to loop through my results from this query and do the following in a more efficient and resilient way than I have done above:</p>&#xA;&#xA;<ul>&#xA;<li><p>Category Heading</p>&#xA;&#xA;<ul>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;</ul></li>&#xA;<li><p>Category Heading</p>&#xA;&#xA;<ul>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;</ul></li>&#xA;<li><p>Category Heading</p>&#xA;&#xA;<ul>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;<li>Article Name, Date, Published By</li>&#xA;</ul></li>&#xA;</ul>&#xA;&#xA;<p>Etc.</p>&#xA;",11965615,,,,2019-08-23 06:26:58,"How to properly sort Graphql query results into categories, such as organizing blog posts by category",<graphql><gatsby>,1,0,0,2019-08-23 03:36:34
57620888,2,,57619586,2,,"<p>are you looking for this?</p>&#xA;&#xA;<pre><code>cats.map(cat =&gt; (&#xA;  &lt;&gt;&#xA;    &lt;h3&gt;{cat}&lt;/h3&gt;&#xA;    {writing&#xA;      .filter(pub =&gt; pub.category === cat)&#xA;      .map(pub =&gt; (&#xA;       &lt;p&gt;{pub.title}&lt;/p&gt;&#xA;    ))}&#xA;  &lt;/&gt;&#xA;))&#xA;</code></pre>&#xA;&#xA;<p>Still, if you can influence how GraphQL schema looks like, I would highly recommend you to design your schema in a way that fits more your needs.</p>&#xA;",2474898,,,,2019-08-23 06:26:58,"",,0,1,0,2019-08-23 06:26:58
57621221,1,,,0,1305,"<p>I am new to GraphQL. I know this is a basic question but hope someone could help me to add variables to my query as I tried many times and failed :(</p>&#xA;&#xA;<p>In my query, below schema is used:</p>&#xA;&#xA;<pre><code>type Query {&#xA;    ContinentInfo(id: ID): Continent&#xA;}&#xA;&#xA;type Continent {&#xA;  id  : ID&#xA;  name: String&#xA;  countries: [Country]&#xA;}&#xA;&#xA;type Country {&#xA;  id        : ID&#xA;  name      : String&#xA;  population: Float&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Below query is executed successfully:</p>&#xA;&#xA;<pre><code>{&#xA;    ContinentInfo(id: ""continent01"") {&#xA;        name&#xA;        countries {&#xA;            name&#xA;            population&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I want to add more conditions in the query, for example add a variable ""populationMoreThan"" to filter the result. so the query may look like:</p>&#xA;&#xA;<pre><code>{&#xA;    ContinentInfo(id: ""continent01"") {&#xA;        name&#xA;        countries(populationMoreThan: $populationMoreThan) {&#xA;            name&#xA;            population&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but it always failed when I tried to add this variable in the schema and in the query.&#xA;Could anyone provide me an example of adding variable in my case?&#xA;Also, it looks I need to pass the parameter value into the query? Now I'm using graphql.GraphQL.execute(queryString) to pass the query string. How to pass the variable value here?</p>&#xA;",6661397,,,,2019-08-23 09:33:26,GraphQL-java add variables to query,<graphql><graphql-java>,1,0,0,2019-08-23 06:54:56
57623481,2,,57621221,0,,"<p>Finally found a way to filter the result.&#xA;Update the schema with:</p>&#xA;&#xA;<pre><code>type Continent {&#xA;  id  : ID&#xA;  name: String&#xA;  countries(populationMoreThan: Float = 0): [Country]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And query with:</p>&#xA;&#xA;<pre><code>{&#xA;    ContinentInfo(id: ""continent01"") {&#xA;        name&#xA;        countries(populationMoreThan: 1.0) {&#xA;            name&#xA;            population&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",6661397,,,,2019-08-23 09:33:26,"",,0,0,0,2019-08-23 09:33:26
57624854,1,,,0,750,"<p>I have a mock server using Apollo Server to return GraphQL responses. One of the queries is to get <code>teams</code> which has an array of <code>metrics</code> (see schema below):</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const mocks = {&#xA;  Query: () =&gt; ({&#xA;    teams: (/*parent, args, context, info*/) =&gt; teamsFixture,&#xA;  }),&#xA;};&#xA;&#xA;const graphServer = new ApolloServer({ typeDefs: schema, mocks });&#xA;graphServer.applyMiddleware({ app });&#xA;</code></pre>&#xA;&#xA;<p>And my query used to be (fields redacted):</p>&#xA;&#xA;<pre><code>teams {&#xA;  bpxId&#xA;  metrics {&#xA;    timestamp&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The real (java) server has changed this to allow me to query (<strong>Relay</strong> style) only the first item in the metrics array as it wasn't performant:</p>&#xA;&#xA;<pre><code>teams {&#xA;  bpxId&#xA;  metrics(first: 1) {&#xA;    edges {&#xA;      node {&#xA;        timestamp&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>With the response in this shape:</p>&#xA;&#xA;<pre><code>metrics: {&#xA;  edges: [&#xA;    {&#xA;      node: [Team]&#xA;      __typename: ""TeamMetricsConnectionEdge""&#xA;    }&#xA;  ]&#xA;  __typename: ""TeamMetricsConnection""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to add this capability to my Apollo Server mocks but not sure how?</p>&#xA;&#xA;<p>New schema (relevant bits):</p>&#xA;&#xA;<pre><code>type TeamMetrics {&#xA;  timestamp: Int&#xA;  # etc&#xA;}&#xA;&#xA;type TeamMetricsConnection {&#xA;  edges: [TeamMetricsConnectionEdge]&#xA;  pageInfo: PageInfo&#xA;}&#xA;&#xA;type PageInfo {&#xA;  hasPreviousPage: Boolean!&#xA;  hasNextPage: Boolean!&#xA;  startCursor: String&#xA;  endCursor: String&#xA;}&#xA;&#xA;type Query {&#xA;  teams(bpxId: Int): [Team]&#xA;}&#xA;&#xA;type Team {&#xA;  bpxId: Int!&#xA;  metrics(first: Int! = 5, after: String): TeamMetricsConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I adjust my mock response to handle Relay pagination? Thanks</p>&#xA;",414062,,414062,2019-08-23 11:31:31,2019-08-23 11:36:04,Mock Relay-style pagination with Apollo Server,<javascript><graphql><apollo><apollo-server>,1,0,0,2019-08-23 10:53:41
57628148,1,,,0,360,"<p>I am using <code>""sequelize"": ""5.3.0""</code> in NodeJS and would like to calculate the distance upon GraphQL request and return it in the query result.</p>&#xA;&#xA;<p>I've calculated distance and added it in attributes like below:</p>&#xA;&#xA;<pre><code>export async function getJobsNear(parentValue,&#xA;  { latitude = 0, longitude = 0, radius = 0 }, { auth }) {&#xA;&#xA;&#xA;  const location = models.sequelize.literal(`ST_GeomFromText('POINT(${ latitude } ${  longitude })')`);&#xA;  const pickupLocation = models.sequelize.literal(`POINT(pickup_latitude, pickup_longitude)`);&#xA;  const distance = models.sequelize.fn('ST_Distance_Sphere', pickupLocation, location)&#xA;&#xA;&#xA;  return await models.Job.findAll({&#xA;    attributes: {&#xA;      include: [[distance, 'distance']]&#xA;    },&#xA;    where: models.sequelize.where(distance, {[models.Sequelize.Op.lte]: radius}),&#xA;    logging: console.log&#xA;  })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When I add <code>distance</code> field in the query, it fails:</p>&#xA;&#xA;<pre><code>{&#xA;  jobsNear(&#xA;    latitude: ""0""&#xA;    longitude: ""0""&#xA;    radius: ""1000""&#xA;  ){&#xA;    id&#xA;    title&#xA;    pickup_latitude&#xA;    pickup_longitude&#xA;    distance    &lt;-- I want this field to be returned&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Currently, it returns with the following error output:</p>&#xA;&#xA;<pre><code>{&#xA;  ""error"": {&#xA;    ""errors"": [&#xA;      {&#xA;        ""message"": ""Cannot query field \""distance\"" on type \""job\"". Did you mean \""est_distance\""?"",&#xA;        ""locations"": [&#xA;          {&#xA;            ""line"": 7,&#xA;            ""column"": 5&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I get the calculated <code>distance</code>?</p>&#xA;",6392347,,6392347,2019-08-26 07:07:04,2019-08-26 07:07:04,Sequelize - How to include new attribute in query result?,<node.js><graphql><sequelize.js>,0,7,0,2019-08-23 14:19:16
57643957,1,,,0,959,"<p>I'm new to GraphQL. I have a data structure that looks something like this:</p>&#xA;&#xA;<pre><code>{&#xA; ""employee_id"": ""123""&#xA; ""employee_name"":""John"",&#xA; ""location"": {&#xA;  ""city"": ""Delhi"",&#xA;  ""country"": ""India""&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I need to get all the employees whose country is India (i.e. location.country). Queries like &#xA;Employees(employee_id:""123"")&#xA;doesn't seem to work in this case.</p>&#xA;",11627551,,,,2019-08-25 11:31:59,Filter graphql query result,<graphql>,1,0,0,2019-08-25 07:07:30
57644084,2,,57643957,0,,"<p>Please see the documentation for filtering by argument:</p>&#xA;&#xA;<p><a href=""https://graphql.org/learn/queries/#arguments"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#arguments</a></p>&#xA;&#xA;<p>You're probably looking for </p>&#xA;&#xA;<pre><code>{&#xA;  Employees(location: { city: ""Delhi""}}) {&#xA;     ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can also turn the query around like this:</p>&#xA;&#xA;<pre><code>{&#xA;  Location(city: ""Delhi"") {&#xA;     Employees&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2288436,,2288436,2019-08-25 11:31:59,2019-08-25 11:31:59,"",,0,4,0,2019-08-25 07:26:41
57668110,1,,,2,1526,"<p>Bare-bones example from another post...</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>new Vue({&#xD;&#xA;  el: '#app',&#xD;&#xA;  data: {&#xD;&#xA;    filters: {&#xD;&#xA;      id: '',&#xD;&#xA;      issuedBy: '',&#xD;&#xA;      issuedTo: ''&#xD;&#xA;    },&#xD;&#xA;    items: [{id:1234,issuedBy:'Operator',issuedTo:'abcd-efgh'},{id:5678,issuedBy:'User',issuedTo:'ijkl-mnop'}]&#xD;&#xA;  },&#xD;&#xA;  computed: {&#xD;&#xA;    filtered () {&#xD;&#xA;      const filtered = this.items.filter(item =&gt; {&#xD;&#xA;        return Object.keys(this.filters).every(key =&gt;&#xD;&#xA;            String(item[key]).includes(this.filters[key]))&#xD;&#xA;      })&#xD;&#xA;      return filtered.length &gt; 0 ? filtered : [{&#xD;&#xA;        id: '',&#xD;&#xA;        issuedBy: '',&#xD;&#xA;        issuedTo: ''&#xD;&#xA;      }]&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;})</code></pre>&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;link type=""text/css"" rel=""stylesheet"" href=""//unpkg.com/bootstrap/dist/css/bootstrap.min.css""/&gt;&lt;link type=""text/css"" rel=""stylesheet"" href=""//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.css""/&gt;&lt;script src=""https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js""&gt;&lt;/script&gt;&lt;script src=""//unpkg.com/babel-polyfill@latest/dist/polyfill.min.js""&gt;&lt;/script&gt;&lt;script src=""//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.js""&gt;&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;&lt;div id=""app""&gt;&#xD;&#xA;&lt;b-table striped show-empty :items=""filtered""&gt;&#xD;&#xA;  &lt;template slot=""top-row"" slot-scope=""{ fields }""&gt;&#xD;&#xA;    &lt;td v-for=""field in fields"" :key=""field.key""&gt;&#xD;&#xA;      &lt;input v-model=""filters[field.key]"" :placeholder=""field.label""&gt;&#xD;&#xA;    &lt;/td&gt;&#xD;&#xA;  &lt;/template&gt;&#xD;&#xA;&lt;/b-table&gt;&#xD;&#xA;&lt;/div&gt;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>Now I get how this works, but I am also integrating apollo for a graphql query. I have apollo populate items..</p>&#xA;&#xA;<p>So I add apollo and a mounted (to block)</p>&#xA;&#xA;<pre><code>    new Vue({&#xA;      el: '#app',&#xA;      apollo: {&#xA;        searchPersons: GET_PERSON&#xA;      },&#xA;      data: {&#xA;        filters: {&#xA;          name: '',&#xA;          location: '',&#xA;          relocate: ''&#xA;        },&#xA;      },&#xA;      computed: {&#xA;        filtered () {&#xA;          const filtered = this.items.filter(item =&gt; {&#xA;            return Object.keys(this.filters).every(key =&gt;&#xA;                String(item[key]).includes(this.filters[key]))&#xA;          })&#xA;          return filtered.length &gt; 0 ? filtered : [{&#xA;            name: '',&#xA;            location: '',&#xA;            relocate: ''&#xA;          }]&#xA;        }&#xA;      },&#xA;      mounted: function () {&#xA;          this.$apollo.queries.searchPersons.refetch().then((results) =&gt; {&#xA;            this.totalRows = results.data.searchPersons.length&#xA;            this.items = results.data.searchPersons&#xA;          })&#xA;      },&#xA;    })&#xA;</code></pre>&#xA;&#xA;<p>here is my GET_PERSON graphql if you were wondering</p>&#xA;&#xA;<pre><code>import { gql } from ""apollo-boost"";&#xA;&#xA;export const GET_PERSON = gql`&#xA;  query {&#xA;    searchPersons(keyword: """", fromSource: false){&#xA;      name&#xA;      location&#xA;      relocate&#xA;      currentSalary&#xA;      resumeBody&#xA;      personemailSet {&#xA;        email&#xA;      }&#xA;      personphoneSet {&#xA;        phoneType&#xA;        verified&#xA;        number&#xA;      }&#xA;      personskillsSet {&#xA;        term&#xA;        score&#xA;        weight&#xA;      }&#xA;      personresumeattachmentSet {&#xA;        attachment&#xA;      }&#xA;      personworkplacepreferenceSet{&#xA;        name&#xA;        label&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>So what happens is, the table tries to load (which is fine), but its trying to filter and grab the data before it has been returned so i am left with an error of&#xA;<code>vue.runtime.esm.js?2b0e:619 [Vue warn]: Error in render: ""TypeError: Cannot read property 'filter' of undefined""</code></p>&#xA;&#xA;<p>and honestly I feel like mounted may not be the right way to do this?</p>&#xA;&#xA;<p>I appreciate any help.</p>&#xA;&#xA;<p>Thanks!</p>&#xA;",6035688,,,,2019-08-27 05:31:22,VueJS Wait on Apollo before rendering data,<javascript><vue.js><apollo>,1,1,0,2019-08-27 05:22:56
57668175,2,,57668110,1,,"<p>So iitially define it as an empty array.</p>&#xA;&#xA;<pre><code>  data: {&#xA;    filters: {&#xA;      name: '',&#xA;      location: '',&#xA;      relocate: ''&#xA;    },&#xA;    items : []&#xA;    //---^-----&#xA;  },&#xA;</code></pre>&#xA;",3037257,,,,2019-08-27 05:31:22,"",,0,0,0,2019-08-27 05:31:22
57674772,2,,57641571,3,,<p>Check your list query. I had the same issue and then realised that generated list query was missing relation attributes after I updated schema with name connection. In your case something like this</p>&#xA;&#xA;<pre><code>listUsers { &#xA;  items { &#xA;    id &#xA;    teacherClassrooms { &#xA;      items { &#xA;        linkCode &#xA;        id name &#xA;      } &#xA;    } &#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>inside your <code>listUsers</code> query</p>&#xA;,5794791,,5794791,2019-09-02 08:25:46,2019-09-02 08:25:46,"",,0,1,0,2019-08-27 12:31:15
57677908,1,,,0,1003,"<p>How can we create a paginated query using graphql spqr, java, mongo?</p>&#xA;&#xA;<p>Below is how query would look like:</p>&#xA;&#xA;<p>allUsers(first : int, last :int, after : String, before: String)</p>&#xA;",8691550,,,,2020-04-09 09:38:32,"Relay pagination using graphql-spqr, java and mongo",<mongodb><spring-data-mongodb><graphql-java><graphql-spqr>,1,0,0,2019-08-27 15:22:47
57679057,1,,,1,48,"<p>I am trying to return students of who are either mature or highscool</p>&#xA;&#xA;<pre><code>graphqlOperation(listStudents, {&#xA;        filter: {&#xA;          type: { eq: 'student' },&#xA;          OR: [{ category: { eq: 'mature' },  { eq: 'highschool'  }]&#xA;        },&#xA;&#xA;      })&#xA;    );&#xA;</code></pre>&#xA;&#xA;<p>It looks like I need to add the logical OR in my schema</p>&#xA;&#xA;<pre><code>    input TableStudentFilterInput {&#xA;        ID: TableStringFilterInput&#xA;        type: TableStringFilterInput&#xA;        category: TableStringFilterInput&#xA;        name: TableStringFilterInput&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>and my filter</p>&#xA;&#xA;<pre><code>input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How  do I allow my schema to accept a logical operator?</p>&#xA;",10589809,,,,2019-08-27 16:41:41,Logical OR in SDL - field name 'OR' that is not defined for input object type,<graphql><schema><graphql-js>,0,0,0,2019-08-27 16:41:41
57720291,2,,57720083,6,,"<p><strong>Original answer</strong></p>&#xA;&#xA;<p>you're missing a closing parenthesis after the <code>begins_with(sk, :sk1)</code>. That is, the third line should be:</p>&#xA;&#xA;<pre><code>        ""expression"": ""pk = :pk and (begins_with(sk,:sk) or begins_with(sk, :sk1))""&#xA;</code></pre>&#xA;&#xA;<p>I just ran the fixed expression and it worked as expected.</p>&#xA;&#xA;<p><strong>Revised</strong></p>&#xA;&#xA;<p>Actually, there are subtleties. </p>&#xA;&#xA;<p>the <code>or</code> operator can be used in filter-expression but not in key-condition-expressions. For instance, <code>a = :v1 and (b = :v2 or b = :v3)</code> will work as long as <code>a</code> and <code>b</code> are ""regular"" attributes. If <code>a</code> and <code>b</code> are the table's primary key (partition key, sort key) then DDB will reject the query.</p>&#xA;",27198,,27198,2019-08-31 19:50:40,2019-08-31 19:50:40,"",,0,3,0,2019-08-30 03:53:53
57721150,1,57721151,,3,1901,<h3>How I can get response from graphql server using pure js without libraries?</h3>&#xA;&#xA;<p>For example how I can do that using <code>XMLHttpRequest</code>?&#xA;Query and serverUrl are below:</p>&#xA;&#xA;<pre><code>const serverUrl = 'http://example.com/graphql/'&#xA;const query = {&#xA;    query: `{&#xA;        viewer {&#xA;            date&#xA;        }&#xA;    }`&#xA;};&#xA;</code></pre>&#xA;,8163773,,,,2020-10-05 06:31:40,How to fetch from graphql server using XMLHttpRequest?,<javascript><graphql>,1,0,0,2019-08-30 05:52:23
57725011,2,,57720083,1,,"<p>Reading <a href=""https://stackoverflow.com/questions/32100038/dynamodb-query-or-condition-in-keyconditionexpression"">this answer</a> seems that this isn't possible, as DynamoDB only accepts a single Sort key value and a single operation. </p>&#xA;&#xA;<p>There's also no ""OR"" condition in the operation: &#xA;<a href=""https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-KeyConditionExpression"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-KeyConditionExpression</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>If you also want to provide a condition for the sort key, it must be combined using AND with the condition for the sort key. Following is an example, using the = comparison operator for the sort key:</p>&#xA;</blockquote>&#xA;&#xA;<p>I am going to be restructuring the access pattern to better match my request.</p>&#xA;",1057052,,,,2019-08-30 10:27:16,"",,0,0,0,2019-08-30 10:27:16
57729975,2,,57714434,0,,"<p>No. Theres no way of getting the filtered options sent back. There are options where you can return the additional filtering abilities (similar to when you are viewing a category page) to return list of ways to filter but nothing that returns the current active filters in place. </p>&#xA;&#xA;<pre><code>     {&#xA;          products(filter: {sku: {like: ""%""} }  pageSize: 500) {&#xA;            filters{&#xA;              request_var&#xA;              name&#xA;              filter_items{&#xA;                label&#xA;                value_string&#xA;              }&#xA;            }&#xA;            items {&#xA;              id&#xA;              sku&#xA;              name&#xA;              ...&#xA;            }&#xA;          }&#xA;     }&#xA;</code></pre>&#xA;",4830080,,,,2019-08-30 16:00:35,"",,0,1,0,2019-08-30 16:00:35
57734493,1,,,1,198,"<p>I am using gatsby to create the static pages of my website, and I have my content in markdown files. I want to include the path to a zip file in markdown and query it using graphql to pass it to my React component.</p>&#xA;&#xA;<p>I have tried passing the path to the zip file, and also a string to the path to the zip file.</p>&#xA;&#xA;<p>example.md</p>&#xA;&#xA;<pre><code>---&#xA;zip: /location/to/zipfile.zip // have also tried '/location/to/zipfile.zip&#xA;---&#xA;</code></pre>&#xA;&#xA;<p>component.jsx</p>&#xA;&#xA;<pre><code>// some code&#xA;&#xA;// GraphQL query&#xA;export const ExampleQuery = graphql`&#xA;  query ExampleQuery($path: String!) {&#xA;    markdownRemark(frontmatter: { path: {eq: $path } }) {&#xA;      frontmatter {&#xA;        zip&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>I get the following error</p>&#xA;&#xA;<pre><code>error GraphQL Error Field ""zip"" of type ""File"" must have a selection of subfields. Did you mean ""zip { ... }""?&#xA;</code></pre>&#xA;&#xA;<p>I know I can also import the zip file directly in react, but I am avoiding that since I want to query different zip files and pass them down a component based on user selection.</p>&#xA;",9335323,,,,2019-08-31 01:02:44,How can I query a zip file in gatsby from a markdown file?,<reactjs><graphql><markdown><gatsby>,0,0,0,2019-08-31 01:02:44
57755553,2,,57747355,0,,"<p>I can give an example how to convert the timestamp in SQL: As far as I understand <code>Z</code> is the same as <code>UTC</code>.</p>&#xA;&#xA;<p>So in order to get the date and time in ""your"" timezone you can <code>select</code> it with the following syntax:</p>&#xA;&#xA;<pre><code># Example: America/Campo_Grande&#xA;select created_at at time zone 'utc' at time zone 'America/Campo_Grande' from cards;&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://www.postgresql.org/docs/10/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT"" rel=""nofollow noreferrer"">https://www.postgresql.org/docs/10/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT</a></p>&#xA;&#xA;<p>I do not know how this can be done in this specific GraphQL environment. </p>&#xA;",834114,,,,2019-09-02 10:42:53,"",,0,0,0,2019-09-02 10:42:53
57758396,2,,56309234,0,,"<p>We couldn't find a solution that matched our requirements, so built our own and released it as OSS (MIT).</p>&#xA;&#xA;<p><a href=""https://github.com/UnlyEd/conditions-matcher"" rel=""nofollow noreferrer"">https://github.com/UnlyEd/conditions-matcher</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>Compares a given context with a filter (a set of conditions) and resolves whether the context validates the filter. Strongly inspired by GraphQL filters.</p>&#xA;</blockquote>&#xA;",2391795,,,,2019-09-02 14:09:05,"",,0,0,0,2019-09-02 14:09:05
57766757,1,57766963,,-1,400,"<p>These day, i have studied <code>GraphQL</code> with <code>Laravel</code> framework, Lighthouse Library.&#xA;I have tried to do kind of <code>SELECT Query</code>.</p>&#xA;&#xA;<p>As a result, I wonder GraphQL can select below SQL Query</p>&#xA;&#xA;<pre><code>SELECT * FROM TABLE_A WHERE type=1 AND chart_id=(SELECT id FROM TABLE_B WHERE phone='0000~~')&#xA;</code></pre>&#xA;&#xA;<p>I expect, Client first get result from this query.</p>&#xA;&#xA;<pre><code>SELECT id FROM TABLE_B WHERE phone='0000~~'&#xA;</code></pre>&#xA;&#xA;<p>And then Do Second query, i think i can get a result.</p>&#xA;&#xA;<p>But i wonder I can get result from 1 request. Thanks.</p>&#xA;",10333868,,7051937,2019-09-03 07:35:25,2019-09-03 07:35:25,GraphQL Where Select Sub Query,<laravel><graphql><laravel-lighthouse>,1,2,0,2019-09-03 07:18:20
57798080,1,57799017,,-1,132,<p>I am learning about GraphQL with Laravel.&#xA;When i need to response from difficult Query (include subquery or group by)&#xA;I can do this with resolver.</p>&#xA;&#xA;<p>For example.</p>&#xA;&#xA;<blockquote>&#xA;  <p>select * from A where id in (select id from B where name='~~')</p>&#xA;</blockquote>&#xA;&#xA;<p>But i wonder this is the best way (best practice) to response.&#xA;Can anyone give me answer?</p>&#xA;,10333868,,10333868,2019-09-05 05:07:38,2019-09-05 06:26:10,Resolver is the best practice for difficult query to Graphql?,<laravel><graphql><resolver>,1,0,0,2019-09-05 03:33:35
57801520,2,,37635328,2,,"<p>The idea behind the <code>viewer</code> field (design pattern) was to group the top-level query fields that are only relevant to the currently logged in user. For example:</p>&#xA;<pre class=""lang-graphql prettyprint-override""><code># EXAMPLE 1&#xA;&#xA;quer {&#xA;  viewer {&#xA;    stories { ... } # the list of published stores as well as drafts (current user)&#xA;  }&#xA;&#xA;  stories { ... }   # the list of published stories (all users)&#xA;}&#xA;</code></pre>&#xA;<p>This currently logged user data was either merged into <code>viewer</code> field itself or nested under it:</p>&#xA;<pre class=""lang-graphql prettyprint-override""><code># EXAMPLE 2&#xA;&#xA;query {&#xA;  viewer {&#xA;    id&#xA;    email&#xA;    displayName&#xA;    stories { ... }&#xA;  }&#xA;}&#xA;&#xA;# EXAMPLE 3&#xA;&#xA;query {&#xA;  viewer {&#xA;    me { id email displayName }&#xA;    stories { ... }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>All three examples above can be simplified by removing the <code>viewer</code> field altogether and still have the exact same functionality (recommended):</p>&#xA;<pre class=""lang-graphql prettyprint-override""><code>query {&#xA;  # The currently logged in user or NULL if not logged in&#xA;  me {&#xA;    id&#xA;    email&#xA;    displayName&#xA;  }&#xA;&#xA;  # Published stories only (all users)&#xA;  stories {&#xA;    ...&#xA;  }&#xA;&#xA;  # Published stories as well as drafts (the current user)&#xA;  stories(drafts: true) {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>You can find the complete example in <a href=""https://github.com/kriasoft/relay-starter-kit"" rel=""nofollow noreferrer"">GraphQL API and Relay Starter Kit</a> which can be used either as a reference project or a seed/template for new developments. See <a href=""https://github.com/kriasoft/relay-starter-kit/blob/main/api/graphql.ts"" rel=""nofollow noreferrer""><code>api/graphql.ts</code></a>.</p>&#xA;",82686,,82686,2021-10-12 12:37:38,2021-10-12 12:37:38,"",,0,11,0,2019-09-05 08:35:42
57816044,1,,,21,3875,<p>I have Major categories and Minor Categories that belong to a Major category.&#xA;Both are ENUM type.&#xA;I want client to choose matching minor category ENUM to submit with its Major category.&#xA;I don't want to include all different minor category ENUMs as fields.</p>&#xA;&#xA;<p>I first tried doing&#xA;<code>union MinorCategories = Minor1 | Minor2</code>&#xA;However this failed because <code>union</code> only works with <code>ObjectTypes</code></p>&#xA;&#xA;<p>Enforcing minor category depending on the major category is not necessary. I only want to receive one field that can be selective by the client by ENUM.&#xA;Is there any work around?</p>&#xA;,6216378,,,,2021-04-23 00:06:36,GraphQL enum union workaround?,<enums><graphql>,1,0,0,2019-09-06 05:07:52
57817657,2,,50617628,0,,"<p>Yes, this is quite a pickle. Even with imports correctly working (>= v2.1.0 for <a href=""https://github.com/remind101/jest-transform-graphql"" rel=""nofollow noreferrer"">jest-transform-graphql</a>, they get added to the <code>query.definitions</code> object, which is completely sidestepped when calling <code>graphql</code> with <code>document.loc.source.body</code> as query argument.</p>&#xA;&#xA;<p>On the server end, graphql <a href=""https://github.com/graphql/graphql-js/blob/master/src/graphql.js#L182"" rel=""nofollow noreferrer"">(<code>function graphqlImpl</code>)</a> will reconstruct the <code>document</code> object using <code>parse(source)</code> - but it'll have zero knowledge of the imported fragment definitions...</p>&#xA;&#xA;<p>As far as I can tell, the best bet is to stamp fragments to the query source before sending it to the server. You'll need to explicitly find all lines starting with <code>#import</code> and replace these with actual text content of the to-be-imported <code>graphql</code> file.</p>&#xA;&#xA;<p>Below is the function that I use. (Not tested for recursive fragments)</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Async wrapper around dynamic `import` function&#xD;&#xA;import { importQuery } from ""./queries"";&#xD;&#xA;&#xD;&#xA;const importAndReplace = async (fileToImport, sourceDocument, line) =&gt; {&#xD;&#xA;  const doc = await importQuery(fileToImport);&#xD;&#xA;  const targetDocument = (await sourceDocument).replace(line, doc.loc.source.body);&#xD;&#xA;  return targetDocument;&#xD;&#xA;};&#xD;&#xA;&#xD;&#xA;// Inspired by `graphql-tag/loader` &#xD;&#xA;// Uses promises because of async function `importQuery` used&#xD;&#xA;export default async graphqlOperation =&gt; {&#xD;&#xA;  const { body } = graphqlOperation.loc.source;&#xD;&#xA;  const lines = body.split(/\r\n|\r|\n/);&#xD;&#xA;  const bodyWithInlineImports = await lines.reduce(&#xD;&#xA;    async (accumulator, line) =&gt; {&#xD;&#xA;      await accumulator;&#xD;&#xA;      const lineSplit = line.slice(1).split("" "");&#xD;&#xA;&#xD;&#xA;      return line[0] === ""#"" &amp;&amp; lineSplit[0] === ""import""&#xD;&#xA;        ? importAndReplace(lineSplit[1].replace(/""/g, """"), accumulator, line)&#xD;&#xA;        : Promise.resolve(accumulator);&#xD;&#xA;    },&#xD;&#xA;    Promise.resolve(body)&#xD;&#xA;  );&#xD;&#xA;  return bodyWithInlineImports;&#xD;&#xA;};</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",6295318,,,,2019-09-06 07:36:39,"",,0,0,0,2019-09-06 07:36:39
57818550,1,,,2,8675,"<p>I have an error in my application. I use <strong>Next.js / ApolloClient / GraphQL and Prisma</strong>. The error concerns the <strong>GraphQL</strong> schema and it's use in <code>Mutation</code>: </p>&#xA;&#xA;<blockquote>&#xA;  <p>Error :  Reason: 'end_date' Field 'end_date' is not defined in the&#xA;  input type <strong>ArticleCreateInput</strong></p>&#xA;</blockquote>&#xA;&#xA;<p>I tried to copy/paste the global schema on each file to have the good corresponding data, but it doesn't work.</p>&#xA;&#xA;<p>My data Model (datamodel.prisma):</p>&#xA;&#xA;<pre><code>type Article {&#xA;  id: ID! @id&#xA;  title: String!&#xA;  description: String!&#xA;  createdAt: DateTime! @createdAt&#xA;  updatedAt: DateTime! @updatedAt&#xA;  image: String&#xA;  maxUserNumber: Int!&#xA;  greatImage: String&#xA;  street: String!&#xA;  begin_date: DateTime!&#xA;  end_date: DateTime!&#xA;  price: Int!&#xA;  user: User!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My schema.graphql:</p>&#xA;&#xA;<pre><code>createArticle(&#xA;    title: String!&#xA;    description: String!&#xA;    image: String&#xA;    maxUserNumber: Int!&#xA;    greatImage: String&#xA;    street: String!&#xA;    begin_date: DateTime!&#xA;    end_date: DateTime!&#xA;    price: Int!&#xA;  ): Article!&#xA;</code></pre>&#xA;&#xA;<p>In my Genertated file (prisma.graphql):</p>&#xA;&#xA;<pre><code>input ArticleCreateInput {&#xA;  id: ID&#xA;  title: String!&#xA;  description: String!&#xA;  image: String&#xA;  maxUserNumber: Int&#xA;  greatImage: String&#xA;  street: String&#xA;  begin_date: DateTime&#xA;  end_date: DateTime&#xA;  price: Int!&#xA;  user: UserCreateOneInput!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>ClientSide Mutation and State:</p>&#xA;&#xA;<pre><code>const CREATE_ARTICLE_MUTATION = gql`&#xA;  mutation CREATE_ARTICLE_MUTATION(&#xA;    $title: String!&#xA;    $description: String!&#xA;    $image: String&#xA;    $maxUserNumber: Int!&#xA;    $greatImage: String&#xA;    $street: String!&#xA;    $begin_date: DateTime!&#xA;    $end_date: DateTime!&#xA;    $price: Int!&#xA;  ) {&#xA;    createArticle(&#xA;      title: $title&#xA;      description: $description&#xA;      image: $image&#xA;      maxUserNumber: $maxUserNumber&#xA;      greatImage: $greatImage&#xA;      street: $street&#xA;      begin_date: $begin_date&#xA;      end_date: $end_date&#xA;      price: $price&#xA;    ) {&#xA;      id&#xA;    }&#xA;  }&#xA;`;&#xA;export class CreateArticle extends Component {&#xA;  state = {&#xA;    adresse: """",&#xA;    title: """",&#xA;    description: """",&#xA;    image: """",&#xA;    greatImage: """",&#xA;    price: 0,&#xA;    nbPersons: 2,&#xA;    loadigImg: false,&#xA;    begin_date: moment(new Date(Date.now())).format(""YYYY-MM-DD""),&#xA;    end_date: moment(new Date(Date.now()))&#xA;      .add(1, ""days"")&#xA;      .format(""YYYY-MM-DD"")&#xA;  };&#xA;</code></pre>&#xA;&#xA;<p>With the Mutation call: </p>&#xA;&#xA;<pre><code> &lt;Mutation&#xA;        mutation={CREATE_ARTICLE_MUTATION}&#xA;        variables={{&#xA;          ...this.state,&#xA;          maxUserNumber: this.state.nbPersons,&#xA;          street: this.state.adresse&#xA;        }}&#xA;      &gt;&#xA;</code></pre>&#xA;&#xA;<p>And the backendMutation: </p>&#xA;&#xA;<pre><code>async createArticle(parent, args, ctx, info) {&#xA;&#xA;    if (!ctx.request.userId) {&#xA;      throw new Error(""Vous devez être connecté"");&#xA;    }&#xA;&#xA;&#xA;    const article = await ctx.db.mutation.createArticle(&#xA;      {&#xA;        data: {&#xA;          user: {&#xA;            connect: {&#xA;              id: ctx.request.userId&#xA;            }&#xA;          },&#xA;          ...args&#xA;        }&#xA;      },&#xA;      info&#xA;    );&#xA;&#xA;    return article;&#xA;  },&#xA;</code></pre>&#xA;&#xA;<p>When I use my createArticle mutation I have an error that specified:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Reason '<strong>end_date' field is not defined</strong> in the type&#xA;  <strong>ArticleCreateInput</strong></p>&#xA;</blockquote>&#xA;&#xA;<p>But, when I log the args on my mutation, I have all my fields!</p>&#xA;",9178844,,10871073,2020-05-29 06:52:20,2022-08-10 08:05:06,GraphQL Error : Field is not defined in the input type,<reactjs><graphql><field><apollo><prisma>,2,3,0,2019-09-06 08:39:15
57824460,1,57828987,,1,2347,"<p>What I need is very simple, in SQL I would say I would merely need a SORT ASCENDING or DESCENDING.</p>&#xA;<p>But it has been a while I'm working with GraphQL, AppSync, DynamoDB and React-Native, and I still did not figure out how to sort my output list by name...</p>&#xA;<p>I'm using the simple scenario, without React-Native Apollo, just with the Connect component.</p>&#xA;<p>My Output list:</p>&#xA;<pre><code>class PlantScreenNoApollo extends React.Component {&#xA;&#xA;...&#xA;&#xA;    render() {&#xA;       &#xA;        return (&#xA;    &#xA;    &lt;View style={{flex:1, flexDirection:&quot;column&quot;, justifyContent:&quot;flex-start&quot;}}&gt;&#xA;        &#xA;        &lt;View style={{flex:1,&#xA;                  flexDirection:&quot;row&quot;,&#xA;                  justifyContent:&quot;center&quot;,&#xA;        }}&gt;&#xA;            &lt;TextInput style={styles.sTextInput}&#xA;                        onChangeText={ (text) =&gt; this._updateFilter(text) }&#xA;                        value={this.state.filter}/&gt;&#xA;            &lt;Ionicons name={&quot;ios-search&quot;} size={30} /&gt;&#xA;        &lt;/View&gt;&#xA;&#xA;        &lt;View style={{  flex:1, &#xA;                        flexDirection:&quot;column&quot;,&#xA;                        justifyContent:&quot;flex-start&quot;,&#xA;                        alignContent: &quot;center&quot;,&#xA;                        minHeight: &quot;70%&quot;,}}&gt;&#xA;                        &#xA;        &lt;Connect query={ this.state.filter!==&quot;&quot; ? &#xA;                         graphqlOperation(queries.listPlants, {&#xA;                            filter: {&#xA;                                name: {&#xA;                                    contains: this.state.filter&#xA;                                }&#xA;                            }&#xA;                         })&#xA;                         :&#xA;                         graphqlOperation(queries.listPlants)&#xA;                        &#xA;        }&gt;&#xA;            {&#xA;                ( { data: { listPlants }, loading, error } ) =&gt; {&#xA;                    &#xA;                    if(error) return (&lt;Text&gt;Error&lt;/Text&gt;);&#xA;                    &#xA;                    if(loading || !listPlants) return (&lt;ActivityIndicator /&gt;);&#xA;                    &#xA;                    return (&#xA;                    &#xA;                          &lt;FlatList&#xA;                            data={listPlants.items}&#xA;                            renderItem={({item}) =&gt; {&#xA;                                return (&#xA;                                    &lt;View style={{borderBottomWidth:1, borderBottomColor:&quot;green&quot;, padding:5}}&gt;&#xA;                                    &lt;TouchableOpacity onPress={()=&gt;this._onPress(item)}&gt;&#xA;                                        &lt;View style={styles.hcontainer}&gt;&#xA;                                            &lt;Image source={{uri:this.state.logoURL}}&#xA;                                                style={styles.iconImage}&#xA;                                            /&gt;&#xA;                                            &lt;View style={styles.vcontainer}&gt;&#xA;                                                &lt;Text style={styles.textH3}&gt;{item.name}&lt;/Text&gt;&#xA;                                                &lt;View style={styles.hcontainerflexstart}&gt;&#xA;                                                    { item.tea &amp;&amp;  &lt;Image source={{uri:this.state.teaIconURL}} style={styles.iconImageSmall} /&gt;}&#xA;                                                    { item.bath &amp;&amp;  &lt;Image source={{uri:this.state.bathIconURL}} style={styles.iconImageSmall} /&gt;}&#xA;                                                    { item.insence &amp;&amp;  &lt;Image source={{uri:this.state.insenceIconURL}} style={styles.iconImageSmall} /&gt;}&#xA;                                                    { item.children &amp;&amp;  &lt;Image source={{uri:this.state.childrenIconURL}} style={styles.iconImageSmall} /&gt;}&#xA;                                                &lt;/View&gt;&#xA;                                            &lt;/View&gt;&#xA;                                            &lt;Text style={styles.textP}&gt;{item.description.substr(0,50) + &quot;(...)&quot;}&lt;/Text&gt;&#xA;                                        &lt;/View&gt;&#xA;                                    &lt;/TouchableOpacity&gt;    &#xA;                                    &lt;/View&gt;&#xA;                                );&#xA;                            }}&#xA;                            keyExtractor={(item, index) =&gt; item.id}&#xA;                        /&gt;&#xA;&#xA;                    );&#xA;                    &#xA;                    &#xA;                }&#xA;            }&#xA;        &lt;/Connect&gt;&#xA;        &lt;/View&gt;&#xA;        &lt;View style={{flex:1, flexDirection:&quot;column&quot;, justifyContent:&quot;flex-start&quot;}}&gt;&#xA;&#xA;&#xA;...&#xA;&#xA;        &lt;/View&gt;&#xA;    &lt;/View&gt;&#xA;      );  &#xA;    };&#xA;    &#xA;}&#xA;&#xA;</code></pre>&#xA;<p>And this is my query description (auto-generated by the model + codegen)</p>&#xA;<pre><code>export const listPlants = `query ListPlants(&#xA;  $filter: ModelPlantFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listPlants(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      description&#xA;      ...&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>All I want is to sort the scan by name.</p>&#xA;<p>I tried even to create a secondary index, but it didn't change anything...</p>&#xA;<p>Does anyone know the best way to accomplish this?</p>&#xA;",6466366,,16922044,2022-02-26 04:56:13,2022-02-26 04:56:13,How to sort a simple graphQL query in awsappsync?,<react-native><graphql><aws-amplify><aws-appsync>,1,0,0,2019-09-06 15:01:33
57827656,1,,,0,1091,"<p>I am trying to follow the tutorial at <a href=""https://www.howtographql.com/react-relay"" rel=""nofollow noreferrer"">https://www.howtographql.com/react-relay</a>, but trying to tweak it for a very similar project. However I am getting an error when I am trying to invoke the compiler:</p>&#xA;&#xA;<pre><code>Parse error: Error: RelayFindGraphQLTags: Fragment names in graphql tags must be prefixed with the module name. Got `ListItem_data` in module `listItem`. in ""components/showAll/list-item.js""&#xA;</code></pre>&#xA;&#xA;<p>Simplified Folder Structure: </p>&#xA;&#xA;<pre><code>|enviornment.js&#xA;|src&#xA;  |_showAll&#xA;      |_ list-item.js&#xA;      |_ list.js&#xA;      |_ show-all.js&#xA;&#xA;&#xA;Schema is in root folder&#xA;</code></pre>&#xA;&#xA;<p>Simplified Code:</p>&#xA;&#xA;<p>----show-all.js (entry point)</p>&#xA;&#xA;<pre><code>import {&#xA;    QueryRenderer,&#xA;    graphql&#xA;  } from 'react-relay';&#xA;  import environment from '../../Enviornment';&#xA;&#xA;  const ShowAllPageQuery = graphql`&#xA;    query ShowAllPageQuery {&#xA;        viewer {&#xA;            ...List_viewer&#xA;        }&#xA;    }&#xA;  `&#xA;const ShowAll = (props) =&gt; {&#xA;    return (&#xA;        &lt;QueryRenderer&#xA;             environment={environment}&#xA;             query={ShowAllPageQuery}&#xA;             render={({error, props}) =&gt; {&#xA;                  if(error) {&#xA;                      return &lt;div&gt;{error.message}&lt;/div&gt;&#xA;                  } else if(props) {&#xA;                      return &lt;List viewer={props.viewer} /&gt;&#xA;                  }&#xA;                      return &lt;div&gt;Loading&lt;/div&gt;&#xA;                  }}&#xA;          /&gt;&#xA;    )}&#xA;&#xA;export default ShowAll&#xA;</code></pre>&#xA;&#xA;<p>----list.js (child of showAll)</p>&#xA;&#xA;<pre><code>import {&#xA;    createFragmentContainer,&#xA;    graphql&#xA;  } from 'react-relay'&#xA;&#xA;const List = (props) =&gt; {&#xA;    return (&#xA;        &lt;&gt;&#xA;          {props.viewer.translations.edges.map(({node}, index) =&gt; {&#xA;                return(&#xA;                   &lt;ListItem color={index % 2 == 0 ? 1 : 0} key={node.__id} data={node} /&gt;&#xA;                )&#xA;            })}&#xA;        &lt;/&gt;&#xA;    )&#xA;}&#xA;&#xA;export default createFragmentContainer(List, graphql`&#xA;    fragment List_viewer on Viewer {&#xA;        translations(first: 10, orderBy: createdAt_DESC) @connection(key: ""List_translations"", filters:[]) {&#xA;            edges {&#xA;                node {&#xA;                    ...ListItem_data&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`)&#xA;</code></pre>&#xA;&#xA;<p>----list-item.js</p>&#xA;&#xA;<pre><code>import {&#xA;    createFragmentContainer,&#xA;    graphql&#xA;  } from 'react-relay'&#xA;&#xA;const ListItem = (props) =&gt; {&#xA;    // const link = `/showall/${props.data.planCode}`&#xA;    return (&#xA;        &lt;ListItemWrap color={props.color}&gt;&#xA;            &lt;Link to={link}&gt;&#xA;                &lt;Item&gt;&#xA;                    &lt;p&gt;{props.data.planCode}&lt;/p&gt;&#xA;                    &lt;p&gt;{props.data.longName}&lt;/p&gt;&#xA;                    &lt;p&gt;{props.data.shortName}&lt;/p&gt;&#xA;                &lt;/Item&gt;&#xA;            &lt;/Link&gt;&#xA;        &lt;/ListItemWrap&gt;&#xA;    )&#xA;}&#xA;&#xA;export default createFragmentContainer(ListItem, graphql`&#xA;    fragment ListItem_data on ListItem {&#xA;        id&#xA;        planCode&#xA;        longName&#xA;        shortName&#xA;    }&#xA;`)&#xA;</code></pre>&#xA;&#xA;<p>Schema:</p>&#xA;&#xA;<pre><code>type Mutation {&#xA;  createTranslation(planCode: String!, longName: String!, shortName: String!): Translation&#xA;  updateTranslation(id: ID!, planCode: String!, longName: String!, shortName: String!): String&#xA;  deleteTranslation(planCode: String!): String&#xA;}&#xA;&#xA;type Query {&#xA;  translations: [Translation]&#xA;  translation(planCode: String!): Translation&#xA;}&#xA;&#xA;type Translation {&#xA;  id: ID&#xA;  planCode: String&#xA;  longName: String&#xA;  shortName: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Am I doing something wrong here?</p>&#xA;",11311941,,,,2019-09-09 20:12:55,Relay: Fragment names in graphql tags must be prefixed with the module name,<reactjs><graphql><relay>,1,0,0,2019-09-06 19:36:08
57828987,2,,57824460,1,,"<p>Change your listPlants resolver to perform a Query instead of a Scan and you can utilize the scanIndexForward boolean to determine if you want to return the results in ascending or descending order based on the index provided (in your case - 'name').</p>&#xA;&#xA;<p>This will require you to index the name attribute in DynamoDB if it is not already.</p>&#xA;&#xA;<p>For more information - look at the Query section in the following documentation:</p>&#xA;&#xA;<ul>&#xA;<li><a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-scan"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-scan</a></li>&#xA;<li><a href=""https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#API_Query_RequestSyntax"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#API_Query_RequestSyntax</a></li>&#xA;</ul>&#xA;&#xA;<p>In particular:</p>&#xA;&#xA;<blockquote>&#xA;  <p>ScanIndexForward</p>&#xA;  &#xA;  <p>Specifies the order for index traversal: If true (default), the traversal is performed in ascending order; if false, the traversal is performed in descending order.</p>&#xA;  &#xA;  <p>Items with the same partition key value are stored in sorted order by sort key. If the sort key data type is Number, the results are stored in numeric order. For type String, the results are stored in order of UTF-8 bytes. For type Binary, DynamoDB treats each byte of the binary data as unsigned.</p>&#xA;  &#xA;  <p>If ScanIndexForward is true, DynamoDB returns the results in the order in which they are stored (by sort key value). This is the default behavior. If ScanIndexForward is false, DynamoDB reads the results in reverse order by sort key value, and then returns the results to the client.</p>&#xA;</blockquote>&#xA;&#xA;<p><a href=""https://stackoverflow.com/questions/52791010/aws-appsync-adding-global-secondary-index-to-dynamodb-and-pagination-using-gsi/54205431#54205431"">Here's a detailed stackoverflow answer that details this.</a></p>&#xA;",10886417,,,,2019-09-06 22:03:50,"",,0,2,0,2019-09-06 22:03:50
57837917,1,,,1,78,"<p>I have an ""event"" that I am trying to represent in an API response.  What is the best-practice (most rfc3339 compliant?) way to handle dates and times?</p>&#xA;&#xA;<p>The options are an all-day event (single day), multiple day event (may or may not have start and end times), event with no start time, event on a single day with just a start time, event on a single day with start and end time.</p>&#xA;&#xA;<p>My starting point is something like this:</p>&#xA;&#xA;<pre><code>start_date: null or date string (normalized to utc? what format?)&#xA;start_time: null or time string (normalized to utc? what format?)&#xA;end_date: null or date string (normalized to utc? what format?)&#xA;end_time: null or time string (normalized to utc? what format?)&#xA;tz: null or timezone string (what format?)&#xA;</code></pre>&#xA;&#xA;<p>I am wondering whether I should consider having <code>datetime</code> field as well (or in lieu of).  Also what other standards/considerations there are.</p>&#xA;&#xA;<p>Also, this also is being implemented in GraphQL (not sure it matters, but if it does, something to consider).</p>&#xA;",1325761,,,,2019-09-07 22:37:05,Represent the time and type of different events in an API response,<api><date><datetime><graphql><rfc3339>,0,1,0,2019-09-07 22:37:05
57873979,2,,57677908,1,,"<p><strong>No Spring</strong></p>&#xA;&#xA;<p>If you want SPQR to automatically map the result as a Relay page, make sure you return a <code>Page&lt;&gt;</code> from your method. So something like:</p>&#xA;&#xA;<pre><code>public Page&lt;User&gt; allUsers(int first, int last, String after, String before) {&#xA;    List&lt;User&gt; users = queryMongo(...); //however you query Mongo&#xA;    return translateListToPage(users); //get a Page instance somehow, see below&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I don't know if you can do real cursor-based pagination in Mongo (where you give it the last seen cursor and ask for the next batch of items), but if not you can always translate it to simple offset-based pagination or use a value of any field you can sort on as the cursor.</p>&#xA;&#xA;<p>See <a href=""https://stackoverflow.com/questions/44574964/graphql-how-to-implement-pagination-with-graphql-java/44589353#44589353"">my answer here</a> for an idea how to implement these approaches. It describes a solution meant for a relational DB but the logic is the same. E.g. you use <code>cursor.skip</code> and <code>cursor.limit</code> instead of SQL's <code>LIMIT</code> and <code>OFFSET</code>.</p>&#xA;&#xA;<p>In short, you can do something like:</p>&#xA;&#xA;<pre><code>public Page&lt;User&gt; allUsers(int first, String after) {&#xA;    //Treat 'after' as the offset to skip to&#xA;    int skip = Integer.valueOf(after);&#xA;&#xA;    //Query Mongo (this is Mongo shell, do whatever you normally do in Java instead)&#xA;    List&lt;User&gt; users = db.users.find().skip(skip).limit(first);&#xA;&#xA;    //Translate to Page&#xA;    Page&lt;User&gt; userPage = PageFactory.createOffsetBasedPage(users, totalUserCount, skip);&#xA;&#xA;    return userPage;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>There's many more ways to create a <code>Page</code> instance, including creating your own implementation of that interface.</p>&#xA;&#xA;<p>Another way is something like:</p>&#xA;&#xA;<pre><code>public Page&lt;User&gt; allUsers(int first, String after) {&#xA;    //This time 'after' is the last seen ID&#xA;    List&lt;User&gt; users = db.students.find({'_id': {'$gt': after}}).limit(first);&#xA;&#xA;    //Translate to Page somehow again (you have to somehow know if there's the next/previous page)&#xA;    Page&lt;User&gt; userPage = PageFactory.createPage(users, (user, ix) -&gt; () -&gt; user.getId(), hasNextPage, hasPreviousPage);&#xA;&#xA;    return userPage;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Spring Data</strong></p>&#xA;&#xA;<p>If you're using Spring Data, you can return <code>org.springframework.data.domain.Page</code> (or <code>Slice</code>) and configure SPQR to map that as a Relay page. This feature will be supported out-of-the-box in the next release of SPQR Spring Boot Starter.</p>&#xA;",294657,,294657,2020-04-09 09:38:32,2020-04-09 09:38:32,"",,0,0,0,2019-09-10 15:29:59
57877706,1,,,0,386,"<p>My aim is to create an AWS-AppSync GraphQL API that implements the <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay Cursor Connections Specification</a>. Specifically I want to add <a href=""https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"" rel=""nofollow noreferrer"">opaque cursors</a> for some Elasticsearch queries. My cursor would be the sort values array for the search_after API. But to make them opaque I would like to stringify and base64 encode them before sending them to the client. </p>&#xA;&#xA;<p>I know that AppSync exposes <a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-util-reference.html"" rel=""nofollow noreferrer"">base64 encode and decode</a> through its $util object. But decode returns a type of byte[] and not String. So my Question boils down to how to convert byte[] to String in Velocity?</p>&#xA;&#xA;<p>Can we use the underlying Java for something like this:</p>&#xA;&#xA;<pre class=""lang-java prettyprint-override""><code>new String(bytes)&#xA;</code></pre>&#xA;&#xA;<p>Unfortunately I don't know which classes are in the AppSync Velocity Context.</p>&#xA;&#xA;<p>Thanks in advance :)</p>&#xA;",11037594,,190089,2019-09-11 08:34:50,2019-09-11 08:34:50,Decode base64 string in AWS AppSync Velocity resolver?,<amazon-web-services><base64><graphql><velocity><aws-appsync>,1,0,0,2019-09-10 20:19:08
57891302,2,,57877097,0,,"<p>I located the solution for how to do this via the GraphQL documentation on Object types: <a href=""https://graphql.org/graphql-js/object-types/"" rel=""nofollow noreferrer"">https://graphql.org/graphql-js/object-types/</a>. Types can be declared as arguments by nesting them within { }.</p>&#xA;&#xA;<pre><code>{&#xA;  pokemons(query: {filter: {type: ""Water""}}) {&#xA;    edges {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4035626,,,,2019-09-11 14:23:09,"",,0,0,0,2019-09-11 14:23:09
57908071,2,,57901668,6,,"<p>Using connections lines your schema up with the <a href=""https://relay.dev/docs/en/graphql-server-specification"" rel=""noreferrer"">Relay specification</a> -- whether this is good practice when not using Relay is debatable.</p>&#xA;&#xA;<p>In Relay, the edges and nodes are nullable because that's what the spec implicitly specifies.</p>&#xA;&#xA;<p>The practical reason for this is because of the way GraphQL errors <a href=""https://graphql.github.io/graphql-spec/June2018/#sec-Errors-and-Non-Nullability"" rel=""noreferrer"">work</a>. When an execution error is encountered while resolving a field, that field will resolve to null. However, if the field is also non-null, it <em>can't</em> actually resolve to null and so GraphQL will make the entire parent field null instead. If the parent field is also non-null, then it will make <em>its</em> parent null... and so on. GraphQL errors will ""bubble up"" this way until either a nullable field is encountered or the <code>data</code> root field is reached (which is always nullable).</p>&#xA;&#xA;<p>In other words, by making the field and edge nullable, we allow the node to error out while resolving while still returning information about the edge itself, and, more importantly, <strong>still returning all the other edges</strong>. If both nodes and edges were non-null, an error inside a single node would cause the <code>edges</code> field itself to resolve to null. By making these fields nullable, we effectively enable support for GraphQL to return a partial response even if it encounters errors during execution.</p>&#xA;",6024220,,,,2019-09-12 13:41:47,"",,0,0,0,2019-09-12 13:41:47
57963008,1,58000759,,3,3479,"<p><strong>Problem and Expected Results</strong></p>&#xA;&#xA;<p>I'm using a proof of concept schema and DynamoDB Table setup to filter on nested field values. I've followed the ideas very generally <a href=""https://medium.com/open-graphql/implementing-search-in-graphql-11d5f71f179"" rel=""nofollow noreferrer"">here</a> as well as the documentation for <code>$utils.transform.toDynamoDBFilterExpression</code> (<a href=""https://docs.aws.amazon.com/appsync/latest/devguide/resolver-util-reference.html#transformation-helpers-in-utils-transform"" rel=""nofollow noreferrer"">here</a>).</p>&#xA;&#xA;<p>The basic idea is this: using the same sort of principles, I'd like to filter by any arbitrarily deep nested field (short of the 32 document path length limit in DynamoDB). The relevant setup looks like this:</p>&#xA;&#xA;<p>AppSync schema (apologies for the naming conventions; was supposed to be a quick and dirty PoC):</p>&#xA;&#xA;<pre><code>query {&#xA;    listActiveListingsBySubAndFilter(&#xA;        filter: TableTestMasterDataTable_ImportV1FilterInput!,&#xA;        limit: Int,&#xA;        nextToken: String&#xA;    ): TestMasterDataTable_ImportV1Connection&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableDataObjectFilterInput {&#xA;    beds: TableFloatFilterInput&#xA;    baths: TableFloatFilterInput&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input TableTestMasterDataTable_ImportV1FilterInput {&#xA;    id: TableStringFilterInput&#xA;    status: TableStringFilterInput&#xA;    sub: TableStringFilterInput&#xA;    data: TableDataObjectFilterInput&#xA;}&#xA;&#xA;type TestMasterDataTable_ImportV1 {&#xA;    id: String!&#xA;    status: String!&#xA;    sub: String!&#xA;    data: AWSJSON&#xA;}&#xA;&#xA;type TestMasterDataTable_ImportV1Connection {&#xA;    items: [TestMasterDataTable_ImportV1]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input UpdateTestMasterDataTable_ImportV1Input {&#xA;    id: String!&#xA;    status: String&#xA;    sub: String!&#xA;    data: AWSJSON&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>VTL request and response resolvers:</p>&#xA;&#xA;<pre><code>## Request resolver&#xA;&#xA;#set( $filter = $ctx.args.filter )&#xA;#set( $path = $filter.data )&#xA;&#xA;{&#xA;    ""version"" : ""2017-02-28"",&#xA;    ""operation"" : ""Query"",&#xA;    ""index"" : ""listings-index"",  ## GSI on table with HASH: status, RANGE: sub&#xA;    ""query"" : {&#xA;        ""expression"": ""#status = :status and #sub = :sub"",&#xA;        ""expressionNames"" : {&#xA;            ""#status"" : ""status"",&#xA;            ""#sub"" : ""sub""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":status"" : $util.dynamodb.toDynamoDBJson(""Active""),&#xA;            "":sub"" : $util.dynamodb.toDynamoDBJson($filter.sub.eq)&#xA;        }&#xA;    },&#xA;    ""filter"" : $util.transform.toDynamoDBFilterExpression($path),&#xA;    ""limit"": $util.defaultIfNull($ctx.args.limit, 20),&#xA;    ""nextToken"": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null))&#xA;}&#xA;&#xA;&#xA;## Response resolver&#xA;&#xA;{&#xA;    ""items"": $util.toJson($ctx.result.items),&#xA;    ""nextToken"": $util.toJson($util.defaultIfNullOrBlank($context.result.nextToken, null))&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Example DynamoDB Table element:</p>&#xA;&#xA;<pre><code>{&#xA;  ""_meta"": {&#xA;    ""exposure"": 0.08,&#xA;    ""lastActive"": 1557800000,&#xA;    ""lastUpdated"": 1557878400,&#xA;    ""lastView"": 1557878500,&#xA;    ""numViews"": 63,&#xA;    ""posted"": 1557878400&#xA;  },&#xA;  ""buildingID"": ""325-5th-Ave,-New-York,-NY-10016,-USA"",&#xA;  ""data"": {&#xA;    ""agent"": [&#xA;      {&#xA;        ""agentID"": ""daeo@gmail.com""&#xA;      },&#xA;      {&#xA;        ""agentID"": ""ben@gmail.com""&#xA;      }&#xA;    ],&#xA;    ""amenities"": [&#xA;      ""hot tub"",&#xA;      ""time machine""&#xA;    ],&#xA;    ""baths"": 2,&#xA;    ""beds"": 2&#xA;  },&#xA;  ""id"": ""325-5th-Ave,-New-York,-NY-10016,-USA#37C:1557878400"",&#xA;  ""status"": ""Active"",&#xA;  ""sub"": ""new-york/manhattan/listings"",&#xA;  ""unitNum"": ""37C"",&#xA;  ""unitRefID"": ""325-5th-Ave,-New-York,-NY-10016,-USA#37C""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Based on all of this, if I run the following query:</p>&#xA;&#xA;<pre><code>listActiveListingsBySubAndFilter(filter: {&#xA;    ""sub"" : {&#xA;      ""eq"" : ""new-york/manhattan/listings""&#xA;    },&#xA;    ""data"": {&#xA;      ""beds"": {&#xA;        ""eq"": 2.0&#xA;      }&#xA;    }) {&#xA;    items {&#xA;      id&#xA;      status&#xA;    }&#xA;    nextToken&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would expect to get something like this in return:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""listActiveListingsBySubAndFilter"": {&#xA;      ""items"": [&#xA;          {&#xA;              ""id"": ""325-5th-Ave,-New-York,-NY-10016,-USA#37C:1557878400"",&#xA;              ""status"": ""Active""&#xA;          }&#xA;      ],&#xA;      ""nextToken"": null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note: this is the only expected return since there's only one item matching these requirements in the database at this time.</p>&#xA;&#xA;<p><strong>Actual Results</strong></p>&#xA;&#xA;<p>All of that said, the results I'm getting (or lack thereof) aren't making much sense. No matter the query (<code>data.beds</code>, <code>data.baths</code>), if the field is nested in <code>data</code> the return is the same:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""listActiveListingsBySubAndFilter"": {&#xA;      ""items"": [],&#xA;      ""nextToken"": null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've verified the query is working as expected and the filter expression is formatted appropriately (it works on other non-nested fields like <code>id</code>). What's perplexing is that the filter just doesn't seem to get applied (or maybe is being applied in some non-intuitive way?). For reference, here's a snippet of a typical CloudWatch log for the above:</p>&#xA;&#xA;<pre><code>{&#xA;    ""context"": {&#xA;        ""arguments"": {&#xA;            ""filter"": {&#xA;                ""sub"": {&#xA;                    ""eq"": ""new-york/manhattan/listings""&#xA;                },&#xA;                ""data"": {&#xA;                    ""beds"": {&#xA;                        ""eq"": 2&#xA;                    }&#xA;                }&#xA;            },&#xA;            ""limit"": 200&#xA;        },&#xA;        ""stash"": {},&#xA;        ""outErrors"": []&#xA;    },&#xA;    ""fieldInError"": false,&#xA;    ""errors"": [],&#xA;    ""parentType"": ""Query"",&#xA;    ""graphQLAPIId"": ""q7ueubhsorehbjpr5e6ymj7uua"",&#xA;    ""transformedTemplate"": ""\n\n{\n    \""version\"" : \""2017-02-28\"",\n    \""operation\"" : \""Query\"",\n    \""index\"" : \""listings-index\"",\n    \""query\"" : {\n        \""expression\"": \""#status = :status and #sub = :sub\"",\n        \""expressionNames\"" : {\n        \t\""#status\"" : \""status\"",\n            \""#sub\"" : \""sub\""\n    \t},\n        \""expressionValues\"" : {\n            \"":status\"" : {\""S\"":\""Active\""},\n            \"":sub\"" : {\""S\"":\""new-york/manhattan/listings\""}\n        }\n    },\n    \""filter\"" : {\""expression\"":\""(#beds = :beds_eq)\"",\""expressionNames\"":{\""#beds\"":\""beds\""},\""expressionValues\"":{\"":beds_eq\"":{\""N\"":2.0}}},\n    \""limit\"": 200,\n    \""nextToken\"": null\n}""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Notice the filter <code>expressionValues</code> value in <code>transformedTemplate</code>: <code>{ ""N"" : 2.0 }</code> (sans <code>$util.toDynamoDBJson</code> formatting) and compare it to the value in the object in DynamoDB on that field.</p>&#xA;&#xA;<p>I've tried everything, including changing the fields themselves to strings and doing various filter operations like <code>eq</code> and <code>contains</code> to see if this was some odd type inconsistency, but no luck.</p>&#xA;&#xA;<p>As of now, I have two backup solutions that involve either ""pulling up"" all the relevant fields I might want to filter on (cluttering my records with attributes I'd rather keep nested) or creating a new nested type containing only high-level fields for filtering on -- i.e., effectively split the records into a record reference and a record filter reference. In this scenario, we'd get some ""<code>Listing</code>"" record that has as its <code>data</code> field value something like <code>ListingFilterData</code> -- e.g.:</p>&#xA;&#xA;<pre><code>type Listing {&#xA;    id: String!&#xA;    sub: String!&#xA;    status: String!&#xA;    data: ListingFilterData!&#xA;}&#xA;&#xA;type ListingFilterData {&#xA;    beds: Float!&#xA;    baths: Float!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Both are doable, but I'd rather try to solve the current issue instead of adding a bunch of extra data to my table.</p>&#xA;&#xA;<p>Any thoughts?</p>&#xA;&#xA;<p><strong>Update 9/17/19</strong></p>&#xA;&#xA;<p>After some more fiddling, I happened upon the solution implied <a href=""https://stackoverflow.com/questions/55132782/appsync-graphql-how-to-filter-a-list-by-nested-value"">here</a>. Following from what I could glean about solution, I successfully implemented a hardcoded nested query filter using the following VTL request resolver (and changing the filter expression keyname to avoid a reserved word conflict on <code>data</code>):</p>&#xA;&#xA;<pre><code>#set( $filter = $ctx.args.filter )&#xA;#set( $path = $filter.filterData ) ## currently, unused&#xA;&#xA;{&#xA;    ""version"" : ""2017-02-28"",&#xA;    ""operation"" : ""Query"",&#xA;    ""index"" : ""listings-index"",&#xA;    ""query"" : {&#xA;        ""expression"": ""#status = :status and #sub = :sub"",&#xA;        ""expressionNames"" : {&#xA;            ""#status"" : ""status"",&#xA;            ""#sub"" : ""sub""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":status"" : $util.dynamodb.toDynamoDBJson(""Active""),&#xA;            "":sub"" : $util.dynamodb.toDynamoDBJson($filter.sub.eq)&#xA;        }&#xA;    },&#xA;    ""filter"" : {&#xA;        ""expression"" : ""#filterData.beds = :beds"",&#xA;        ""expressionValues"" : {&#xA;            "":beds"" : $util.dynamodb.toDynamoDBJson(2.0)&#xA;        }&#xA;    },&#xA;    ""limit"": $util.defaultIfNull($ctx.args.limit, 20),&#xA;    ""nextToken"": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null))&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This returns my expected result:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""listActiveListingsBySubAndFilter"": {&#xA;      ""items"": [&#xA;        {&#xA;          ""id"": ""325-5th-Ave,-New-York,-NY-10016,-USA#37C:1557878400"",&#xA;          ""status"": ""Active""&#xA;        }&#xA;      ],&#xA;      ""nextToken"": null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Seems like progress, but any ideas on how to dynamically create the docpath and create an expression name for a nested attribute? Running more ideas and will report back if anything interesting shows up...</p>&#xA;&#xA;<p><strong>Update #2 from 9/17/19</strong></p>&#xA;&#xA;<p>After further playing around with the request resolver, I think I've found a quick and dirty way to dynamically grab the path and target vars for creating a filter expression for my nested attributes. <em>Note</em>: The whole thing still returns an empty result set and it assumes there's only one filter key (for now), but the reserved keyword bit seems to have been solved. Still wondering why the results aren't showing up as expected though.</p>&#xA;&#xA;<pre><code>#set( $filter = $ctx.args.filter )&#xA;#foreach( $parent in $filter.keySet() )&#xA;    #set( $path = $parent )&#xA;#end&#xA;#set( $target = $filter[$path] )&#xA;#foreach( $ff in $target.keySet() ) ## should only contain one Map key-value pair&#xA;    #set( $fp = $ff )&#xA;#end&#xA;#set( $fv = $target[$fp] )&#xA;&#xA;{&#xA;    ""version"" : ""2017-02-28"",&#xA;    ""operation"" : ""Query"",&#xA;    ""index"" : ""listings-index"",&#xA;    ""query"" : {&#xA;        ""expression"": ""#status = :status and #sub = :sub"",&#xA;        ""expressionNames"" : {&#xA;            ""#status"" : ""status"",&#xA;            ""#sub"" : ""sub""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":status"" : $util.dynamodb.toDynamoDBJson(""Active""),&#xA;            "":sub"" : $util.dynamodb.toDynamoDBJson($filter.sub.eq)&#xA;        }&#xA;    },&#xA;    ""filter"" : {&#xA;        ""expression"" : ""#ffp = :$fp"",  ## filter path parent.target = :target&#xA;        ""expressionNames"" : {&#xA;            ""#ffp"" : ""${path}.${fp}""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":$fp"" : $util.dynamodb.toDynamoDBJson(${fv.eq}), ## :target : value to filter for&#xA;        }&#xA;    },&#xA;    ""limit"": $util.defaultIfNull($ctx.args.limit, 200),&#xA;    ""nextToken"": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null))&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Inspecting the CloudWatch log <code>transformedTemplate</code> shows the expression names and values are being substituted appropriately:</p>&#xA;&#xA;<pre><code>""filter"" : {&#xA;    ""expression\"" : ""#ffp = :beds"",&#xA;    ""expressionNames"" : {&#xA;        ""#ffp"" : ""filterData.beds""&#xA;    },&#xA;    ""expressionValues"" : {&#xA;        "":beds"" : { ""N"": 2.0 }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Update from 09/18/19</strong></p>&#xA;&#xA;<p>I may have finally discovered the root of the problem: it seems that the way in which <code>expressionNames</code> are evaluated does not allow for a key to be a docpath. If I run either of the following filters (notice the use of a non-reserved DynamoDB keyword to illustrate the problem is with expression name substitution), I'll get the result I'm looking for:</p>&#xA;&#xA;<pre><code>""filter"" : {&#xA;    ""expression"" : ""filterData.beds = :beds"",  ## filter path parent.target = :target&#xA;        ""expressionValues"" : {&#xA;            "":beds"" : $util.dynamodb.toDynamoDBJson(${fv.eq}) ## :target : value to filter for&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>or</p>&#xA;&#xA;<pre><code>""filter"" : {&#xA;    ""expression"" : ""filterData.beds = :${fp}"",  ## filter path parent.target = :target&#xA;        ""expressionValues"" : {&#xA;            "":{fp}"" : $util.dynamodb.toDynamoDBJson(${fv.eq}) ## :target : value to filter for&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Now, if I make a minor change, only attempting to substitute with an expression name value</p>&#xA;&#xA;<pre><code>""filter"" : {&#xA;    ""expression"" : ""#filterData.beds = :${fp}"",  ## filter path parent.target = :target&#xA;        ""expressionNames"": {&#xA;            ""#filterData.beds"" : ""filterData.beds""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":{fp}"" : $util.dynamodb.toDynamoDBJson(${fv.eq}) ## :target : value to filter for&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>I get the following error message: </p>&#xA;&#xA;<pre><code>""ExpressionAttributeNames contains invalid key: Syntax error; key: \""#filterData.beds\"" (Service: AmazonDynamoDBv2; Status Code: 400; Error Code: ValidationException""&#xA;</code></pre>&#xA;&#xA;<p>Even with a hardcoded path substitution, VTL seems to read the path as a single key name. Same issue when swapping the values of the expressions dynamically so there're no hardcoded strings.</p>&#xA;",5989171,,5989171,2019-09-18 20:47:29,2019-09-18 21:09:48,How to Filter by Query on Nested Fields in AWS AppSync,<filter><nested><graphql><amazon-dynamodb><aws-appsync>,1,0,0,2019-09-16 19:06:47
58000759,2,,57963008,5,,"<p><strong>SOLVED</strong></p>&#xA;&#xA;<p>I happened upon this <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionAttributeNames.html#Expressions.ExpressionAttributeNames.AttributeNamesContainingDots"" rel=""noreferrer"">gem</a> by accident, and it gave me the little bit extra I needed to find a workable solution with dynamic key names!</p>&#xA;&#xA;<p>Here's what the filter expression looks like now:</p>&#xA;&#xA;<pre><code>""filter"" : {&#xA;        ""expression"" : ""#path.#filter = :${fp}"",  ## filter path parent.target = :target&#xA;        ""expressionNames"": {&#xA;            ""#path"" : ""${path}"",&#xA;            ""#filter"" : ""${fp}""&#xA;        },&#xA;        ""expressionValues"" : {&#xA;            "":${fp}"" : $util.dynamodb.toDynamoDBJson(${fv.eq}) ## :target : value to filter for&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>The hold up here was that while expression attribute names are generally interpreted as document paths, with the introduction of the substituted name, the interpreter treats the key name as a scalar attribute and NOT as a document path. You need to individually identify the path elements and substitute for each.</p>&#xA;",5989171,,,,2019-09-18 21:09:48,"",,0,2,0,2019-09-18 21:09:48
58002078,1,69392987,,17,12114,"<p>So I am trying to get safety on my client side GraphQL queries (so if there is a better approach to this let me know). </p>&#xA;&#xA;<p>But what I have been doing is defining my query like this. </p>&#xA;&#xA;<pre><code>export const tenantManagePageQuery = async (tenantId: string) =&gt;&#xA;    graphQLClient.request&lt;{&#xA;        tenants: TenantManagePageQueryTenant[];&#xA;    }&gt;(&#xA;        /* GraphQL */ `&#xA;            query tenants($tenantId: String!) {&#xA;                tenants(tenantIds: [$tenantId]) {&#xA;                    id&#xA;                    description&#xA;                    name&#xA;                    approvedUsers {&#xA;                        id&#xA;                        alias&#xA;                    }&#xA;                    pendingUsers {&#xA;                        id&#xA;                        alias&#xA;                    }&#xA;                }&#xA;            }&#xA;        `,&#xA;        { tenantId },&#xA;    );&#xA;&#xA;</code></pre>&#xA;&#xA;<p>in order to define the <code>TenantManagePageQueryTenant</code> type I do something like this </p>&#xA;&#xA;<pre><code>interface TenantManagePageQueryTenant&#xA;    extends Pick&lt;Tenant, 'id' | 'description' | 'name'&gt; {}&#xA;</code></pre>&#xA;&#xA;<p>Where the base Tenant model is my GQL model type. </p>&#xA;&#xA;<p>Is there anyway to do this kind of Pick statement but to also pick the nested properties. </p>&#xA;&#xA;<p>something like </p>&#xA;&#xA;<pre><code>interface TenantManagePageQueryTenant&#xA;    extends Pick&lt;Tenant, 'id' | 'description' | 'name' | Pick&lt;approvedUser| 'id' | 'alias'&gt; {}&#xA;</code></pre>&#xA;",1789684,,,,2021-09-30 13:20:37,Is there anyway to do nested Pick<> types in Typescript,<typescript><graphql>,3,2,0,2019-09-19 00:03:59
58026013,1,,,1,1067,"<p>I'm new to databases, but I feel what I am trying to do should be pretty commonplace... </p>&#xA;&#xA;<p>What I am trying to achieve is to allow a user to apply both a price range filter and a price sort to the results that my site fetches for them. So I want to find all prices within the specified price range, and then sort them by price.</p>&#xA;&#xA;<p>I have a Hasura DB running on Heroku. The DB has two tables, <code>seeds</code> and <code>prices</code>. One row in <code>seeds</code> table, i.e. one seed, can be related to multiple rows in the <code>prices</code> tables, i.e. many prices. They are joined by a foreign key constraint and a one-many relationship, or Object to Array.</p>&#xA;&#xA;<p>I am attempting to query <code>seeds</code> using the following GraphQL query:</p>&#xA;&#xA;<pre><code>{&#xA;  seeds(&#xA;    where: {prices: {price: {_gte: ""10"", _lte: ""200""}}}, &#xA;    order_by: {prices_aggregate: {min: {price: asc_nulls_last}}}&#xA;  ) {&#xA;    product_name&#xA;    prices {&#xA;      price&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What I want this query to do is to filter out all <code>prices.price</code> that are not within the valid range <code>(10, 200)</code>, and then sort them in order of <code>prices.price</code> ascending. However what happens is that the results are sorted by <code>prices.price</code> ascending INCLUDING values that are not within the range, then the results are filtered.</p>&#xA;&#xA;<p>I will give an example to clarify. Consider the following results from the above query:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""seeds"": [&#xA;      {&#xA;        ""product_name"": ""Northern Lights Auto Feminised Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.48&#xA;          },&#xA;          {&#xA;            ""price"": 6.79&#xA;          },&#xA;          {&#xA;            ""price"": 9.58&#xA;          },&#xA;          {&#xA;            ""price"": 104.5&#xA;          }&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""product_name"": ""The White OG Feminised Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.48&#xA;          },&#xA;          {&#xA;            ""price"": 6.79&#xA;          },&#xA;          {&#xA;            ""price"": 15.68&#xA;          }&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""product_name"": ""Special Kush #1 Feminised Seeds from Royal Queen Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.49&#xA;          },&#xA;          {&#xA;            ""price"": 13.53&#xA;          },&#xA;          {&#xA;            ""price"": 8.29&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The above results are correct, because there are valid values for <code>prices.price</code> within the range specified <code>(104.5, 15.68, 13.53)</code> respectively,  however the results are not in the right order. They are instead ordered by the lowest <code>price.prices</code>, regardless of the filter which was specified <code>(10, 200)</code>.</p>&#xA;&#xA;<p>The correct order for the results would be:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""seeds"": [&#xA;      {&#xA;        ""product_name"": ""Special Kush #1 Feminised Seeds from Royal Queen Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.49&#xA;          },&#xA;          {&#xA;            ""price"": 13.53&#xA;          },&#xA;          {&#xA;            ""price"": 8.29&#xA;          }&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""product_name"": ""The White OG Feminised Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.48&#xA;          },&#xA;          {&#xA;            ""price"": 6.79&#xA;          },&#xA;          {&#xA;            ""price"": 15.68&#xA;          }&#xA;        ]&#xA;      },&#xA;      {&#xA;        ""product_name"": ""Northern Lights Auto Feminised Seeds"",&#xA;        ""prices"": [&#xA;          {&#xA;            ""price"": 3.48&#xA;          },&#xA;          {&#xA;            ""price"": 6.79&#xA;          },&#xA;          {&#xA;            ""price"": 9.58&#xA;          },&#xA;          {&#xA;            ""price"": 104.5&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Can anyone help me, and explain how I can achieve these correct results? It is worth mentioning that it is not possible to sort the results after the query as there are thousands and the sort will definitely affect which results are returned from the DB.</p>&#xA;&#xA;<p>Thanks, in advance!</p>&#xA;",5640115,,,,2019-09-20 10:47:09,"Hasura: How to filter and THEN sort, with one-many relationship",<database><postgresql><database-design><graphql><hasura>,1,0,0,2019-09-20 09:55:23
58026899,2,,58026013,1,,"<p>The where clause you are applying to seeds will fetch all seeds that have atleast one price within the range you have specified. This will NOT filter the <code>price</code> data that you are fetching in the nested query. </p>&#xA;&#xA;<p>For filtering the price you need to apply the where clause inside prices array relationship.</p>&#xA;&#xA;<pre><code>{&#xA;  seeds(&#xA;    where: {prices: {price: {_gte: ""10"", _lte: ""200""}}}, -&gt; this filters seeds&#xA;    order_by: {prices_aggregate: {min: {price: asc_nulls_last}}}&#xA;  ) {&#xA;    product_name&#xA;    prices(where:{price:{_gte: ""10"", _lte: ""200""}}) { -&gt; this filters price&#xA;      price&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4951611,,,,2019-09-20 10:47:09,"",,0,3,0,2019-09-20 10:47:09
58030435,1,,,0,235,"<p>I have two models in my schema. 1) Tree - that uses ID as a primary key and 2) Attribute -that uses has a composite key. I would like to create a third table 3) TreeAttributes -  that will reference 1st and 2nd objects, but when mutating I would like to reference the second object with a composite key. </p>&#xA;&#xA;<p>I couldn't find anything like this in aws or Graphql documentations. I'm wondering if this is even possible? </p>&#xA;&#xA;<p>Current schema looks something like this:</p>&#xA;&#xA;<pre><code>type Tree @model {&#xA;  id: ID!&#xA;  address: String! &#xA;  description: String&#xA;  attributes: [TreeAttributes] @connection (name: ""treeAttributes"")&#xA;}&#xA;&#xA;type Attribute @model (subscriptions: null) @key(fields: [""name"", ""value""]) {&#xA;  name: String!&#xA;  value: [String]!&#xA;  description: String&#xA;  active: Boolean&#xA;  trees: [TreeAttributes] @connection (name: ""attributeTrees"")&#xA;  id: ID&#xA;}&#xA;&#xA;type TreeAttributes @model(queries: null)  {&#xA;  id: ID!&#xA;  tree: Tree! @connection (name: ""treeAttributes"")&#xA;  attribute: Attribute! @connection (name: ""attributeTrees"")&#xA;} &#xA;</code></pre>&#xA;&#xA;<p>Currently my input model looks like this:</p>&#xA;&#xA;<pre><code>input CreateTreeAttributesInput {&#xA;    treeAttributesTreeId: ID!&#xA;    treeAttributesAttributeId: ID!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but instead, i'd like it to look something like this:</p>&#xA;&#xA;<pre><code>input CreateTreeAttributesInput {&#xA;    treeAttributesTreeId: ID!&#xA;    treeAttributesAttribute: {&#xA;                                  name: String!&#xA;                                  value: String!}&#xA;}&#xA;</code></pre>&#xA;",7159483,,,,2020-09-10 00:10:36,Is it possible to modify a graphql input model to reference an object using a composite key instead of id?,<graphql><aws-appsync>,1,1,0,2019-09-20 14:34:55
58062478,1,,,3,546,"<p>I am using GraphQL for my backend to frontend communication and Elasticsearch as my DB. The problem is that whenever I call a query from the frontend, the size is always ten in spite of me specifying in the query the size as 1000. This behaviour is occurring when I am using the GraphQL playground which returns the correct number of hits.</p>&#xA;&#xA;<p>My ES search request is:</p>&#xA;&#xA;<pre><code>async rangeSessions(_, args) {&#xA;  const { dateFrom, dateTo } = args;      &#xA;&#xA;  const results = await client.search({&#xA;    index: 'logs-cdigm',&#xA;    size: 1000,&#xA;    body: {&#xA;      aggs: {&#xA;        sessions: {&#xA;          terms: {&#xA;            field: 'session_id.keyword',&#xA;            size: 1000&#xA;          },&#xA;          aggs: {&#xA;            start_time: { min: { field: 'ts' } },&#xA;            end_time: { max: { field: 'ts' } },&#xA;            events_count: { value_count: { field: 'sequence_id' } },&#xA;          },&#xA;        },&#xA;      },&#xA;      query: {&#xA;        range: {&#xA;          timestamp: {&#xA;            lte: dateTo * 1000000,&#xA;            gt: dateFrom * 1000000,&#xA;          },&#xA;        },&#xA;      },&#xA;    },&#xA;  });&#xA;&#xA;  const res = [];    &#xA;  console.log(results.body.aggregations.sessions.buckets.length);&#xA;&#xA;  results.body.aggregations.sessions.buckets.forEach((bucket) =&gt; {&#xA;    res.push({&#xA;      session_id: bucket.key,&#xA;      events_count: bucket.doc_count,&#xA;      start_time: bucket.start_time.value_as_string,&#xA;      end_time: bucket.end_time.value_as_string,&#xA;    });&#xA;  });&#xA;&#xA;  return res;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My GraphQL query is:</p>&#xA;&#xA;<pre><code>query sessionSearch ($from: Float!, $to: Float!) {&#xA;  rangeSessions(dateFrom: $from, dateTo: $to) {&#xA;    session_id&#xA;    start_time&#xA;    end_time&#xA;    events_count&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My request is:</p>&#xA;&#xA;<pre><code>// from frontend&#xA;{""operationName"":""sessionSearch"",""variables"":{""from"":1567555200000,""to"":1567728000000},""query"":""query sessionSearch($from: Float!, $to: Float!) {\n  rangeSessions(dateFrom: $from, dateTo: $to) {\n    session_id\n    start_time\n    end_time\n    events_count\n    __typename\n  }\n}\n""}&#xA;&#xA;&#xA;{&#xA;  body: null,&#xA;  statusCode: null,&#xA;  headers: null,&#xA;  warnings: null,&#xA;  meta: {&#xA;   context: null,&#xA;    request: { params: [Object], options: [Object], id: 2 },&#xA;    name: 'elasticsearch-js',&#xA;    connection: {&#xA;      url: 'http://localhost:9200/',&#xA;      id: 'http://localhost:9200/',&#xA;      headers: {},&#xA;      deadCount: 0,&#xA;      resurrectTimeout: 0,&#xA;      _openRequests: 0,&#xA;      status: 'alive',&#xA;      roles: [Object]&#xA;    },&#xA;    attempts: 0,&#xA;    aborted: false&#xA;  }&#xA;}&#xA;&#xA;// request object&#xA;{&#xA;  params: {&#xA;    method: 'POST',&#xA;    path: '/logs-cdigm/_search',&#xA;    body: '{""aggs"":{""sessions"":{""terms"":{""field"":""session_id.keyword"",""size"":1000},""aggs"":{""start_time"":{""min"":{""field"":""ts""}},""end_time"":{""max"":{""field"":""ts""}},""events_count"":{""value_count"":{""field"":""sequence_id""}}}}},""query"":{""range"":{""timestamp"":{""lte"":1567728000000000000,""gt"":1567555200000000000}}}}',&#xA;    querystring: 'size=1000',&#xA;    headers: {&#xA;      'User-Agent': 'elasticsearch-js/7.3.0 (linux 4.15.0-64-generic-x64; Node.js v12.10.0)',&#xA;      'Content-Type': 'application/json',&#xA;      'Content-Length': '293'&#xA;    }&#xA;  },&#xA;  options: { warnings: null },&#xA;  id: 2&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How do I get more than 10 results in my frontend?</p>&#xA;",1797689,,1797689,2019-09-23 13:35:30,2019-09-23 15:17:37,Size of Elasticsearch query from Apollo GraphQL client is always ten,<javascript><elasticsearch><graphql><apollo><react-apollo>,1,10,0,2019-09-23 12:29:27
58070284,2,,58070256,1,,"<p>Equals, not equals, in, not in, greater than, less than, greater than or equal. The docs have some examples: <a href=""https://docs.hasura.io/1.0/graphql/manual/queries/query-filters.html"" rel=""nofollow noreferrer"">https://docs.hasura.io/1.0/graphql/manual/queries/query-filters.html</a></p>&#xA;",1137755,,,,2019-09-23 21:15:03,"",,0,0,0,2019-09-23 21:15:03
58076780,1,,,0,201,"<p>How to make <strong>React Apollo</strong> automatically updates the cache with the data from response of a mutation that has partial errors?</p>&#xA;&#xA;<p>In the <strong>Query</strong>, I can pass the option <code>errorPolicy: 'all'</code> to make it work. However, both ""all"" and ""ignore"" policy does not help in the mutation, the cache isn't updated.</p>&#xA;&#xA;<p>Version: </p>&#xA;&#xA;<pre><code>apollo-client: 2.6.4&#xA;react-apollo: 3.1.1&#xA;</code></pre>&#xA;&#xA;<p>This is the first query to get set info:</p>&#xA;&#xA;<pre><code>fragment PurchasedCount on PurchasedCount {&#xA;  id&#xA;  purchased&#xA;}&#xA;&#xA;query getSet {&#xA;  id&#xA;  limit&#xA;  purchasedCount { ...PurchasedCount }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>After that, I use a mutation to purchase the set:</p>&#xA;&#xA;<pre><code>fragment Purchase on Purchase {&#xA;  createdAt&#xA;}&#xA;&#xA;mutation purchase {&#xA;  purchase {&#xA;    purchase { ...Purchase }&#xA;    purchasedCount { ...PurchasedCount }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Given someone else has purchased the set to the limit, the response will return limit exceeded error, together with the current purchased count value:</p>&#xA;&#xA;<pre><code>{&#xA;  data: {&#xA;    purchase: {&#xA;      purchasedCount: { id: 3, purchased: 10 },&#xA;      purchase: null&#xA;    }&#xA;  },&#xA;  errors: [{&#xA;    message: ""limit_exceeded""&#xA;    ...&#xA;  }]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I expected the cache value for <code>purchased</code> will be updated automatically to <code>10</code>. However it only be updated if there is no error in the responses. I have to manually <code>writeFragment</code> in this case.</p>&#xA;&#xA;<p>Is there any better way to do this?</p>&#xA;",2480539,,,,2019-09-24 09:21:02,How to automatically update cache with a mutation that responses partial error,<javascript><react-apollo>,1,0,0,2019-09-24 09:08:30
58085374,1,58145708,,1,3830,"<p>I am working with a sample of graphql query which I want to further bind to a FlatList object in a React-Native app. But I am still struggling to understand what I should pass on then nextToken parameter in order to get a slice of objects destined to a second page... </p>&#xA;&#xA;<p>Tried to pass the next or last id or index, but it didn't work - it asks me to provide a valid nextToken, which I don't know what kind of data it is.</p>&#xA;&#xA;<p>I'm running through AppSynch console.</p>&#xA;&#xA;<p>My query:</p>&#xA;&#xA;<pre><code>query ListResources(&#xA;  $nextTokenPlants: String = ""Orange Tree""&#xA;  $limitPlants: Int = 3&#xA;) {&#xA;  listResources {&#xA;    items {&#xA;      id&#xA;      name&#xA;      Plants(limit: $limitPlants, nextToken:$nextTokenPlants) {&#xA;        items {&#xA;          id&#xA;          name&#xA;          filterName&#xA;          description&#xA;          bath&#xA;          tea&#xA;          insence&#xA;          children&#xA;        }&#xA;        nextToken&#xA;      }&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is the result I get:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""listResources"": {&#xA;      ""items"": [&#xA;        {&#xA;          ""id"": ""361dee16-d567-41ed-b1d4-9baa4a7ffdcc"",&#xA;          ""name"": ""Plantas"",&#xA;          ""Plants"": null&#xA;        }&#xA;      ],&#xA;      ""nextToken"": null&#xA;    }&#xA;  },&#xA;  ""errors"": [&#xA;    {&#xA;      ""path"": [&#xA;        ""listResources"",&#xA;        ""items"",&#xA;        0,&#xA;        ""Plants""&#xA;      ],&#xA;      ""data"": null,&#xA;      ""errorType"": ""DynamoDB:UserIllegalArgumentException"",&#xA;      ""errorInfo"": null,&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 9,&#xA;          ""column"": 7,&#xA;          ""sourceName"": null&#xA;        }&#xA;      ],&#xA;      ""message"": ""com.amazonaws.deepdish.common.pagination.InvalidPaginationTokenException: Invalid pagination token given.""&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I expected to get a list of 3 of the itens stored on ""Plants"", starting from the ""Orange Tree"" onwards... Could anyone pls shed some light on it?</p>&#xA;",6466366,,,,2019-09-28 11:08:29,"How to use the ""nextToken"" parameter to test Pagination?",<graphql><amazon-dynamodb><aws-appsync><dynamodb-queries>,1,0,0,2019-09-24 17:22:49
58087124,2,,58086057,0,,"<p>Lines 17-19 in your <code>lib/community_web/schema.ex</code> don't belong. <code>field/3</code> can only be used in an absinthe object, and you have it outside your module. My guess is you meant to put the <code>do</code> block on the field on line 13.</p>&#xA;&#xA;<p>I would try replacing line 13 with lines 17-19 and see if that helps.</p>&#xA;",6510523,,,,2019-09-24 19:37:17,"",,0,2,0,2019-09-24 19:37:17
58100736,1,,,1,221,"<p>I have a following query:</p>&#xA;&#xA;<pre><code>query MyQuery($today: Date) {&#xA;        allMovies(&#xA;            filter: {&#xA;              info: { endDate: { gte: $today }, startDate: { lte: $today } }&#xA;            }&#xA;          ) {&#xA;        edges {&#xA;          node {&#xA;            info {&#xA;             startDate&#xA;             endDate&#xA;            }&#xA;          }&#xA;        }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm using ReactJS with GatsbyJS, can anyone explain me how to insert variable into graphql? I don't really understand how to pass and create $today to this query. Or maybe it is somehow possible to insert today date in proper format. </p>&#xA;&#xA;<p>All dates are YYYY-MM-DD  </p>&#xA;&#xA;<p>In mysql I could insert variable directly/ there was a function CURDATE() :(</p>&#xA;",10921793,,,,2019-09-25 14:38:17,GraphQL filtering by data,<reactjs><graphql><gatsby>,1,0,0,2019-09-25 14:27:29
58112693,2,,58112599,0,,"<p>Based on the error message, you forgot to add <code>children</code> props for <code>GetEvents</code> in <code>Queries.js</code>: </p>&#xA;&#xA;<pre><code>import React from'react';&#xA;import gql from 'graphql-tag';&#xA;import {Query} from 'react-apollo';&#xA;&#xA;export const GetEvents = ({children}) =&gt; {&#xA;    return (&#xA;    &lt;Query query={gql`&#xA;        {&#xA;            getAllEvents {&#xA;                id&#xA;                startDate&#xA;                startTime&#xA;                gps&#xA;                radius&#xA;                minAge&#xA;                maxAge&#xA;                gender&#xA;                runningPace&#xA;                distance&#xA;            }&#xA;        }&#xA;    `}&gt;&#xA;     {children} // here &#xA;    &lt;/Query&gt; &#xA;    )&#xA;}&#xA;</code></pre>&#xA;",8120827,,,,2019-09-26 08:33:39,"",,0,0,0,2019-09-26 08:33:39
58135229,1,,,2,447,"<p>I am currently working on a GraphQL project that is using Apollo Server / PostgresQL and Knex/Objection.</p>&#xA;&#xA;<p>The datasets I am working with could very easily go upwards to 100k items.</p>&#xA;&#xA;<p>So the question for pagination came up and I was trying to find a way to work with cursor based pagination since it seems to be the standard these days.</p>&#xA;&#xA;<p>But after checking out several implementations, such as:</p>&#xA;&#xA;<p><a href=""https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm"" rel=""nofollow noreferrer"">https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm</a>&#xA;<a href=""https://github.com/Terminal-Systems/apollo-cursor-pagination"" rel=""nofollow noreferrer"">https://github.com/Terminal-Systems/apollo-cursor-pagination</a></p>&#xA;&#xA;<p>I got the feeling that for all these implementations, before slicing based on the cursor, the whole dataset is fetched. Which got me confused because that seems like a huge performance issue when you're working with bigger datasets?</p>&#xA;&#xA;<p>Even in the Relay spec that I linked, it states that you start with <code>allEdges</code> before slicing depending on the before or after arguments.</p>&#xA;&#xA;<p>Is there something that I am missing? Because I don't see how this could be a better approach then offset based pagination but I would love to be proven wrong and shown where my reasoning is off.</p>&#xA;&#xA;<p>Cheers and happy Friday!</p>&#xA;",5829833,,,,2019-09-27 16:07:55,How does Relay cursor pagination handle big datasets when it always fetches the whole dataset?,<database><postgresql><graphql><database-cursor>,1,0,0,2019-09-27 13:07:47
58138076,2,,58135229,1,,"<p>The Relay spec does specify fetching all edges that satisfy the provided <code>before</code> and <code>after</code> argument and then slicing the data according to the <code>first</code> or <code>last</code> argument. And doing that can indeed be noticeably slower and more memory-intensive when working with larger tables.</p>&#xA;&#xA;<p>The main benefit of using cursor-based pagination over offset-based is that it works better with tables where rows are frequently added or deleted. It's possible for an edge to be added or deleted while paginating -- this can result in either skipping edges or getting duplicate ones when using offset-based pagination. </p>&#xA;&#xA;<p>Cursor-based pagination <em>can</em> be implemented in such a way that it doesn't require all rows to be fetched. There's libraries like <a href=""https://www.npmjs.com/package/objection-cursor"" rel=""nofollow noreferrer"">this one</a> that do that. I can't speak to whether or not doing so would technically make your server not ""up to spec"", but I imagine as long as the result is the same, your server would still be compliant with Relay clients. That said, if you're not worried about supporting Relay clients on the front end, it's not necessary to implement Relay-style connections or any other part of the Relay spec. You can have cursor-based pagination outside of a Relay-compliant server.</p>&#xA;",6024220,,,,2019-09-27 16:07:55,"",,0,0,0,2019-09-27 16:07:55
58142840,1,,,2,582,"<p>I'm getting this error in GraphQl (Apollo JS/ Graphql Ruby):&#xA;<code>Error Error: GraphQL error: Field 'pagination' doesn't accept argument 'pagination' GraphQL error: Variable $pagination is declared by Clients but not used. Reload the page and try again.</code></p>&#xA;&#xA;<p>I have this query:</p>&#xA;&#xA;<pre><code>query Clients($pagination: PaginationInput) {&#xA;  clients {&#xA;     data {&#xA;       ....Fragment&#xA;     }&#xA;     pagination(pagination: $pagination) {&#xA;       ....Fragment&#xA;     }&#xA;&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>And I have this as my input type:</p>&#xA;&#xA;<pre><code>class PaginatedClientsType &lt; Types::BaseObject&#xA;   field :data, ...&#xA;   field :pagination, PaginationType ... do &#xA;     argument :pagination, PaginationInput, required: false&#xA;   end&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>And this in my <code>query_type.rb</code> file:</p>&#xA;&#xA;<pre><code>field :clients, ::Types::Paginated::ClientsType, null: false do&#xA;   argument :pagination, PaginationInput, required: false&#xA;end&#xA;&#xA;def clients(pagination:)&#xA;  ...&#xA;end&#xA;&#xA;// and i've added to no avail:&#xA;field :pagination ... do&#xA;   argument :pagination, PaginationInput, required: false&#xA;end&#xA;def pagination(pagination:)&#xA;...&#xA;end&#xA;</code></pre>&#xA;&#xA;<p>Any ideas on how I can pass the argument to something other than this top level <code>client</code>? &#xA;I've read docs <a href=""https://github.com/rmosolgo/graphql-ruby/blob/master/guides/fields/introduction.md"" rel=""nofollow noreferrer"">here</a> but can't figure it out.</p>&#xA;&#xA;<p>Thanks!</p>&#xA;",3624671,,,,2019-09-28 02:11:20,How do I accept field arguments for a nested query in Graphql Ruby?,<graphql><apollo><react-apollo><apollo-client><graphql-ruby>,0,2,0,2019-09-28 02:11:20
58145708,2,,58085374,4,,"<p><code>nextToken</code> is a String that you get in the response when you send a request, looks like </p>&#xA;&#xA;<blockquote>&#xA;  <p>eyJ2ZXJzaW9uIjoxLCJ0b2tlbiI6IkFRSUNBSGdtYVZObHlaR3FSa3hDRnFVWWdFeEZDM0FMY1JRdE9UOEt2dWFLMExzcjJ3RlBPMGdpcC96bjQ5VjFOVElKUng1M0FBQUNlVENDQW5VR0NTcUdTSWIzRFFFSEJxQ0NBbVl3Z2dKaUFnRUFNSUlDV3dZSktvWklodmNOQVFjQk1CNEdDV0NHU0FGbEF3UUJMakFSQkF4VEt5Myt3RUJuSzVSU2hsUUNBUkNBZ2dJc1lmdDk2WVVmQ053Tms2WGkxc3Z2bUgzSGFQZTdNTm1DQWhDcWJ5RFlydXZwTmR6WUNBQ0pJS1RZQlVWdk1xbU9EV2s2SVdLTzlqNmRhenNWZGZYTmFTQmxseE9yUS9BZWY0c2NpL1duWVUweWEyNCthZGQxcVNaMGZEWDZUdkJDak1XQjQ4QmhTQmxLejk2TFpiZ3pDN3dJTzVPRStFbUxHdVhRcURXcUpNZDM3Rm0yNUdiQVU1Tlg1YWVtWE1PbnVKSkZpTzA3U3ZhdUVZMWZwaXZCVU9pMHlxTVlIYk5PMkQ4aDZRVmQ4eW4yTXl3YU9UUHYwWFJZNitrakgvNGlyOWtrdlVXK1pvNFdOeDFBL2h1MlF4Z0lSczQ3d0xTT2NsaXk1Y3o0eFFzM2xqREhYL3M0TTVwT2phTCt0TGpYOUlWcGZCVW45bUgwWEw4ZEFkR0VZRGdjeWpMUHlPdWFnREVNMWR4M09neTg4NGJPclJ3VVgrRmM0UHpGekRqSHZjcjBGSVVXNEM2ZUxzYVRtRjNFakhLRk9ERllDWWkrQ01QNFg0a0dCdTFJQ3BLQjNJdEx2VTZHcUxNVDRMd3NJbkk4SVBhZm1MRnYxRTZDbWxxMnFKZ2wxY1BEVmR6MVFDc0Ezby9vR0VHUkI2VkJtc3VFSUFuOW10OVJzaWpyaklqUm5DQzlSWHA3NnA0WlhWanBJY0dSVU9GTktvZGNnMVpNbGV0a200clhBUGJacFZ5TDdkcnQyTXlEVERQd1crcjZsRHJUUVJJZzI4MEl3Y3ZkQzB1RWRrb0hqTlZPR0kwSWxsSnZ5RjRWTCtNNzRuWXcwNVNSWllJODdGcGdzR21LZjRvWVA1VG9temRVUUR0YWkrZVRJcUxGRjlGYzk0UUNwZlYrVlpmeVU0Mk4yTnRtNi9MYUhrZ08zdGRTUHN1bGhQWVRuMGRQNU5aWG5pODU1eGZyL1N2dDQ2VU0xb3I2UEE9PSJ9</p>&#xA;</blockquote>&#xA;&#xA;<p>and it has nothing to do with your table keys.</p>&#xA;&#xA;<p>Let me explain now how does it work:</p>&#xA;&#xA;<ol>&#xA;<li><p>When you send the request for the first time, you don't send <code>nextToken</code> since you don't have it and then you get the first portion of your data.&#xA;When you receive that first portion, if there exist more data, you get <code>nextToken</code> in the response.</p></li>&#xA;<li><p>Now, you have <code>nextToken</code>, you send another request to get the 2nd portion of your data. You should send that token in the request, so your backend knows from where to start.</p></li>&#xA;<li><p>You get your 2nd portion of data and a new <code>nextToken</code> if there is still some data to fetch (then you need to repeat step 2) or <code>null</code> in <code>nextToken</code> if there is no more data.</p></li>&#xA;</ol>&#xA;&#xA;<p>I hope that it's clear now</p>&#xA;",4512924,,,,2019-09-28 11:08:29,"",,0,0,0,2019-09-28 11:08:29
58159867,1,,,1,151,"<p>With GraphQL, I like to query an entire array with all the fields that are found in only some of the array elements.</p>&#xA;&#xA;<p>Assume I have the following data and local client:</p>&#xA;&#xA;<pre><code>// data1.json&#xA;[&#xA;  {&#xA;    ""type"": ""title"",&#xA;    ""description"": ""Title!""&#xA;  },&#xA;  {&#xA;    ""type"": ""person"",&#xA;    ""description"": ""He has been working in this office for 10 years.""&#xA;    ""name"": ""Thomas""&#xA;    ""age"": ""35""&#xA;  },&#xA;  {&#xA;    ""type"": ""office"",&#xA;    ""description"": ""Engineering""&#xA;    ""size"": ""90""&#xA;    ""budget"": ""1500000""&#xA;  },&#xA;]&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import data1 from './data1.json'&#xA;import data2 from './data2.json' // same structure to data1&#xA;... // other imports&#xA;&#xA;const client = new ApolloClient({&#xA;  cache: new InMemoryCache()&#xA;});&#xA;&#xA;client.cache.writeData({&#xA;  data: {&#xA;    departments: [&#xA;      {&#xA;        name: 'departmentOne',&#xA;        data: data1.map(item =&gt; ({ ...item, __typename: 'element' })),&#xA;        __typename: 'department'&#xA;      },&#xA;      {&#xA;        name: 'departmentTwo',&#xA;        data: data2.map(item =&gt; ({ ...item, __typename: 'element' })),&#xA;        __typename: 'department'&#xA;      }&#xA;    ],&#xA;    __typename: 'departments'&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Then, in one of my component, how do I get all the elements in the departments?</p>&#xA;&#xA;<p>When I query this it just works:</p>&#xA;&#xA;<pre><code>{&#xA;  departments @client {&#xA;    name&#xA;    data {&#xA;      type&#xA;      description&#xA;      __typename&#xA;    }&#xA;    __typename&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But the following query will return nothing: </p>&#xA;&#xA;<pre><code>{&#xA;  departments @client {&#xA;    name&#xA;    data {&#xA;      type&#xA;      description&#xA;      name&#xA;      age&#xA;      size&#xA;      budget&#xA;      __typename&#xA;    }&#xA;    __typename&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I suppose I need to add a local resolver or typeDefs for this purpose, but how would it look like?</p>&#xA;&#xA;<p>In the first place, I am not sure if the cache has all the array. As some of the fields (i.e., ""name"", ""age"", and others) are missing in some element, might it omit the data automatically?</p>&#xA;",5734187,,,,2019-09-29 23:02:47,Querying optional local fields by graphql,<graphql><apollo><react-apollo><apollo-client>,0,0,0,2019-09-29 23:02:47
58173749,1,58174144,,0,5235,"<p>I have a function that is using <code>react-table</code> as a datagrid. It is being initially populated from Apollo in a parent component via local state with each line in the grid an object in an array. </p>&#xA;&#xA;<p>When changes occur in a cell in the grid the whole line object is written to state. </p>&#xA;&#xA;<p>I am trying to use useEffect to trigger a mutation that writes these changes in state back to the database, but I am struggling with two main things:</p>&#xA;&#xA;<ul>&#xA;<li>the mutation is not writing back to the database (the mutation does work in the graphql playground though)</li>&#xA;<li>understanding how to send only the changed row back to the mutation.</li>&#xA;</ul>&#xA;&#xA;<p><strong>The Main Function (part of)</strong></p>&#xA;&#xA;<pre><code>function Table2({ columns, data }) {&#xA;  const [lines, setLines] = useState(data);&#xA;  const [updateLine, {loading, error }] = useMutation(UPDATE_ITEM_MUTATION, {&#xA;  variables:{ ...lines}&#xA;  });&#xA;&#xA;  useEffect(() =&gt; {&#xA;    updateLine&#xA;  },[lines]);&#xA;&#xA;  const updateMyData = (rowIndex, columnID, value) =&gt; {&#xA;    setLines(getLines =&gt;&#xA;      getLines.map((row, index) =&gt; {&#xA;        if (index === rowIndex) {&#xA;          console.log(row)&#xA;          return {&#xA;            ...lines[rowIndex],&#xA;            [columnID]: value&#xA;          };&#xA;        }&#xA;        return row;&#xA;&#xA;      })&#xA;    );&#xA;  };&#xA;</code></pre>&#xA;&#xA;<p>and the mutation...</p>&#xA;&#xA;<pre><code>const UPDATE_ITEM_MUTATION = gql`&#xA;mutation UPDATE_LINE_MUTATION(&#xA;  $id: ID!, &#xA;  $description: String, &#xA;  $project:Int&#xA;  $category:Int&#xA;  $account:Int&#xA;  $amt:Int&#xA;  $units:String&#xA;  $multiple:Int&#xA;  $rate:Int&#xA;  ){&#xA;  updateLine(&#xA;    where:{id: $id},&#xA;    data: {&#xA;    description: $description&#xA;    project: $project&#xA;    category: $category&#xA;    account: $account&#xA;    amt: $amt&#xA;    units: $units&#xA;    multiple: $multiple&#xA;    rate: $rate&#xA;    }) {&#xA;    id&#xA;    description&#xA;    amt&#xA;  }&#xA;}&#xA;`&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I'd be really grateful for some advice.&#xA;Thanks</p>&#xA;",7302406,,7302406,2019-09-30 19:50:51,2019-09-30 19:50:51,"Problem with Hooks: useEffect, useMutation and useState working together",<reactjs><apollo><react-apollo><apollo-client>,1,2,0,2019-09-30 18:57:33
58187682,1,,,0,674,"<p>I want to implement simple pagination with <strong>skip</strong> and <strong>limit</strong> parameters</p>&#xA;&#xA;<p>In documentation ( <a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">https://graphql.org/learn/pagination/</a> ) I see:</p>&#xA;&#xA;<blockquote>&#xA;  <p>We could do something like friends(first:2 after:$friendId), to ask&#xA;  for the next two after the last friend we fetched.</p>&#xA;</blockquote>&#xA;&#xA;<p>But if I pass <em>first</em> parameter in my query I get error:</p>&#xA;&#xA;<blockquote>&#xA;  <p>""message"": ""Unknown argument \""first\"" on field \""documents\"" of type&#xA;  \""Query\""."",</p>&#xA;</blockquote>&#xA;&#xA;<p>My query typeDef:</p>&#xA;&#xA;<pre><code>  extend type Query {&#xA;   documents(search: String, paragraphSize: Int, filters: DocumentFilters, sort: DocumentSort): [Document]&#xA;</code></pre>&#xA;&#xA;<p>Question: should I add parameters <strong>first</strong> in my documents endpoint and handle all limits/skips/etc by myself on server side or I missed something and GraphQL handles by itself all limits etc?</p>&#xA;",8551679,,,,2019-10-02 12:10:40,Apollo GraphQl pagination - limit and skip,<graphql><apollo-server>,1,0,0,2019-10-01 15:05:25
58201249,2,,58187682,0,,"<p>From your typeDef there is no parameter stating first or skip. it is not a parameter that exists already, it has to be defined</p>&#xA;&#xA;<p>So something like this</p>&#xA;&#xA;<p><code>documents(search: String, paragraphSize: Int, filters: DocumentFilters, sort: DocumentSort, skip: Int, limit: Int): [Document]</code></p>&#xA;&#xA;<p>You could make another input to hold all these values if you wish</p>&#xA;",6770513,,,,2019-10-02 12:10:40,"",,0,0,0,2019-10-02 12:10:40
58203635,1,,,7,5530,"<pre><code>type Test @model @key(fields: [""id"", ""createdAt""]) {&#xA;  id: ID!&#xA;  name: String&#xA;  createdAt: String!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This model created queries: </p>&#xA;&#xA;<pre><code>getTest(createdAt: String!id: ID!): Test&#xA;&#xA;listTests(&#xA;  createdAt: ModelStringKeyConditionInput&#xA;  filter: ModelTestFilterInput&#xA;  id: ID&#xA;  limit: Int&#xA;  nextToken: String&#xA;  sortDirection: ModelSortDirection&#xA;): ModelTestConnection&#xA;</code></pre>&#xA;&#xA;<p>What should the scheme look like to request a list sorted by date?</p>&#xA;",12154308,,1377323,2019-10-02 22:13:00,2022-07-08 15:40:53,How to sort by date(createdAt) on a field in list query in aws-amplify?,<amazon-web-services><sorting><graphql><schema><aws-amplify>,2,1,0,2019-10-02 14:29:06
58240929,1,,,2,322,"<p>I'm trying to find a way to implement the relay-style cursor based pagingation using Postgresql. In this scheme, I would order my results based on certain criteria on a number of columns. After I get the results, I would use the columns values for each retrieved record to build a cursor for each record.</p>&#xA;&#xA;<p>My question is:</p>&#xA;&#xA;<p>If I have a record with column values such as this:</p>&#xA;&#xA;<pre><code>[ { lastName: ""Turing"", age: ""50"", id: ""100"" } ]&#xA;</code></pre>&#xA;&#xA;<p>and it was retrieved with an order such as this:</p>&#xA;&#xA;<pre><code>[ { lastName: ""asc"", age: ""desc"", id: ""asc"" } ]&#xA;</code></pre>&#xA;&#xA;<p>If I save this criteria and ordering by which a record was retrieved, is it possible to get all the results that would come after the record in this ordering even if the given record itself was deleted?</p>&#xA;&#xA;<p>I was thinking to use the rank(), but I think it breaks paging when records are deleted.</p>&#xA;",4100072,,,,2019-10-04 17:34:57,Is there a way to implement relay-style cursor based pagination in Posgresql?,<postgresql><pagination><graphql><typeorm><relay>,0,1,0,2019-10-04 17:34:57
58253618,1,58255813,,4,1741,"<p>I am trying to create an object with a relationship.</p>&#xA;&#xA;<p>I am using the auto generated amplify mutations</p>&#xA;&#xA;<p>When I create an object without the relationship the operation succeeds.&#xA;When I create an object with the relationship the operation fails.</p>&#xA;&#xA;<p>The error message I get is</p>&#xA;&#xA;<pre><code>""The variables input contains a field name 'customer' that is not defined for input object type 'CreateCreditcardInput' ""&#xA;</code></pre>&#xA;&#xA;<p>The auto generated mutation is below.</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>export const createCreditcard = `mutation CreateCreditcard($input: CreateCreditcardInput!) {&#xD;&#xA;  createCreditcard(input: $input) {&#xD;&#xA;    id&#xD;&#xA;    number&#xD;&#xA;    expiration&#xD;&#xA;    customer {&#xD;&#xA;      id&#xD;&#xA;      firstName&#xD;&#xA;      lastName&#xD;&#xA;      phone&#xD;&#xA;      address1&#xD;&#xA;      address2&#xD;&#xA;      city&#xD;&#xA;      state&#xD;&#xA;      postcode&#xD;&#xA;      email&#xD;&#xA;      creditcards {&#xD;&#xA;        nextToken&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    payment {&#xD;&#xA;      id&#xD;&#xA;      paymentType&#xD;&#xA;      creditcard {&#xD;&#xA;        id&#xD;&#xA;        number&#xD;&#xA;        expiration&#xD;&#xA;      }&#xD;&#xA;      orderAmount&#xD;&#xA;      order {&#xD;&#xA;        id&#xD;&#xA;        date&#xD;&#xA;        orderStatus&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;`;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",5051884,,,,2019-10-06 09:12:15,AWS Amplify Appsync solving error when creating object with relationship,<amazon-web-services><graphql><aws-amplify>,1,0,0,2019-10-06 01:40:48
58271819,1,58272117,,0,7314,"<p>I have a problem and I need to transform a query graphql to a json object. That is, I get a query in the following way and I would like to have a json of that query. How could I do it? I've been searching and I haven't found a way.</p>&#xA;&#xA;<p>Thank you.</p>&#xA;&#xA;<pre><code>query {&#xA;  Patient(id:4){&#xA;    id&#xA;    birthDate {&#xA;      year,&#xA;      day&#xA;    }&#xA;    name {&#xA;      text&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",11870274,,,,2022-08-02 10:50:44,How can I transform a query graphql to a json object?,<javascript><json><npm><graphql>,4,1,0,2019-10-07 14:37:58
58276080,1,,,1,297,"<p>I'm just doing the tutorial @ <a href=""https://docs.graphene-python.org/projects/django/en/latest/tutorial-plain/"" rel=""nofollow noreferrer"">https://docs.graphene-python.org/projects/django/en/latest/tutorial-plain/</a> to understand graphQL and graphene with Django 2.</p>&#xA;&#xA;<p>I haven't used Django in a while, and the tut seems to be for Django 11. I'm getting a CSRF_FAILURE_VIEW when I try a GraphQL query like so:</p>&#xA;&#xA;<pre><code>query {&#xA;  allIngredients {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The underlying json fixture looks like this:</p>&#xA;&#xA;<pre><code>[{""model"": ""ingredients.category"", ""pk"": 1, ""fields"": {""name"": ""Dairy""}}, {""model"": ""ingredients.category"", ""pk"": 2, ""fields"": {""name"": ""Meat""}}, {""model"": ""ingredients.ingredient"", ""pk"": 1, ""fields"": {""name"": ""Eggs"", ""notes"": ""Good old eggs"", ""category"": 1}}, {""model"": ""ingredients.ingredient"", ""pk"": 2, ""fields"": {""name"": ""Milk"", ""notes"": ""Comes from a cow"", ""category"": 1}}, {""model"": ""ingredients.ingredient"", ""pk"": 3, ""fields"": {""name"": ""Beef"", ""notes"": ""Much like milk, this comes from a cow"", ""category"": 2}}, {""model"": ""ingredients.ingredient"", ""pk"": 4, ""fields"": {""name"": ""Chicken"", ""notes"": ""Definitely doesn't come from a cow"", ""category"": 2}}]&#xA;</code></pre>&#xA;&#xA;<p>Forgive a noob, but there must be something that changed with Django 2? Is there another setting I need to apply?</p>&#xA;&#xA;<p>In settings.py I have:</p>&#xA;&#xA;<pre><code>GRAPHENE = {&#xA;    'SCHEMA': 'cookbook.schema.schema'&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My folder structure is slightly different to the tut in that I have my ingredients app not nested within my cookbook app. The cookbook app is the main app like so:</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/L1FNK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L1FNK.png"" alt=""enter image description here""></a></p>&#xA;",5053559,,,,2019-10-07 20:05:57,GraphiQL query returning CSRF_FAILURE_VIEW,<django><graphql><graphene-django>,1,0,0,2019-10-07 19:36:39
58289139,1,,,2,272,"<p>I was reading about GraphQL mutations and had to decide wether to use Relay mutations or not in graphql-ruby. I stumbled upon the <code>clientMutationId</code> here <a href=""https://graphql-ruby.org/api-doc/1.8.5/GraphQL/Schema/RelayClassicMutation.html"" rel=""nofollow noreferrer"">https://graphql-ruby.org/api-doc/1.8.5/GraphQL/Schema/RelayClassicMutation.html</a></p>&#xA;&#xA;<p><code>clientMutationId</code> apparently is used for optimistic updates (found here <a href=""https://stackoverflow.com/questions/33009657/what-is-optimistic-updates-in-front-end-development"">what is `optimistic updates` in front-end development</a>), but I'm unsure how this is intended to be used.</p>&#xA;&#xA;<p>It seems that you pass the <code>clientMutationId</code> along with your mutation, and the server returns this value in the response. But what's the purpose of this? Some kind of client-side idempotency?</p>&#xA;",228370,,,,2019-10-08 15:05:45,How is the clientMutationId used for optimistic updates in front ends?,<ruby><graphql><relay><graphql-ruby>,0,0,0,2019-10-08 15:05:45
58292310,1,,,2,922,"<p>I'm working on a project which stitches together multiple remote schemas in a gateway service and extends types from these schemas. This is achieved with <code>mergeSchemas</code> from <code>graphql-tools</code> where we specify required fragments and custom resolvers to delegate to the relevant schemas. Part of this implementation is:</p>&#xA;&#xA;<pre><code>const typeExtensions = `&#xA;extend type VsStatistics {&#xA;  commonCompetitors(filter: DateRangeFilter): [Player!]!&#xA;}&#xA;`&#xA;&#xA;const mergedSchema = mergeSchemas({&#xA;  schemas: [ playerSchema, resultsSchema, typeExtensions ],&#xA;  resolvers: {&#xA;    VsStatistics: {&#xA;      commonCompetitors: {&#xA;        fragment: `fragment CommonCompetitorsFragment on VsStatistics { commonCompetitorIds }`,&#xA;        resolve (parent, _args, context, info) {&#xA;          return info.mergeInfo.delegateToSchema({&#xA;            schema: playerSchema,&#xA;            operation: 'query',&#xA;            fieldName: 'players',&#xA;            args: { idArray: parent.commonCompetitorIds },&#xA;            context,&#xA;            info&#xA;          })&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>commonCompetitorIds is an array of IDs that is available on the VsStatistics object. This stitches fine when I don't need to pass any parameters to the fragment as shown above, but I've since added a filter argument of type <code>DateRangeFilter</code> to <code>commonCompetitorIds</code>. The <code>commonCompetitors</code> type extension takes this filter as an argument and I need to pass it to the fragment somehow in order to apply the filter to <code>commonCompetitorIds</code>.&#xA;I have tried the following...</p>&#xA;&#xA;<pre><code>      commonCompetitors: {&#xA;        fragment: `fragment CommonCompetitorsFragment on VsStatistics { commonCompetitorIds(filter: $filter) }`&#xA;        ...&#xA;</code></pre>&#xA;&#xA;<p>...in the hope that the parents arguments might be automatically available to the fragment but I get an error saying <code>Variable ""$filter"" is not defined</code>. How can I pass this filter into the fragment in order to get the filtered <code>commonCompetitorIds</code> which will then be used in the resolver? </p>&#xA;",7069992,,,,2020-07-19 17:55:58,How can I add a variable to a fragment while merging schemas with Apollo GraphQL,<javascript><typescript><graphql><apollo><apollo-server>,1,1,0,2019-10-08 18:43:47
58337364,1,66905300,,7,3080,"<p>I use <code>gql</code> from <a href=""https://github.com/apollographql/graphql-tag"" rel=""noreferrer"">graphql-tag</a>.&#xA;Let's say I have a <code>gql</code> object defined like this:</p>&#xA;&#xA;<pre><code>const QUERY_ACCOUNT_INFO = gql`&#xA;  query AccountInfo {&#xA;    viewer {&#xA;      lastname&#xA;      firstname&#xA;      email&#xA;      phone&#xA;      id&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>There must be a way to get <code>AccountInfo</code> from it. How can I do it? </p>&#xA;",4083045,,,,2021-04-01 13:19:58,How to get the name of a query from a `gql` object?,<graphql><apollo><graphql-tag>,2,0,0,2019-10-11 08:40:26
58358719,1,,,1,877,"<p>I just implemented Pagination in my iOS Application using AWS Amplify, DynamoDB, and GraphQL. What I would like to do is query users based on their score ranked from highest to lowest. In order to do that, I would need to sort my query when making the call. How can I make the sorted query based on a user's score? </p>&#xA;&#xA;<p>Below is my User Table</p>&#xA;&#xA;<pre><code>type User @model @key(fields: [""username""]) {&#xA;  name: String&#xA;  email: String!&#xA;  username: String!&#xA;  dateOfBirth: String&#xA;  university: String!&#xA;  phoneNumber: String!&#xA;  biography: String&#xA;  score: Int!&#xA;  deviceToken: String&#xA;  endpointArn: String&#xA;}&#xA;</code></pre>&#xA;",3914564,,91713,2019-10-13 08:21:33,2019-10-30 19:47:26,GraphQL: Sorted Query Based on User Attribute,<sorting><graphql><amazon-dynamodb><aws-amplify><aws-appsync>,1,0,0,2019-10-12 21:31:51
58361428,2,,58358719,1,,"<p>This is a use case for indexes. </p>&#xA;&#xA;<p>In terms of how to implement that data access pattern, when you use the <code>@key</code> directive, Amplify creates a Global Secondary Index for you. In this case, since you're just interested in high scores, you can create another GSI on the score field by adding the following directive to your User model:</p>&#xA;&#xA;<p><code>@key(name: ""UsersByScore"", fields: [""username"",""score""], queryField: ""UsersByScore"")</code></p>&#xA;&#xA;<p>Then, with a specified limit <code>n</code> and sort direction, use the UsersByScore query generated by Amplify to query for the <code>n</code> users with the highest (or lowest) scores. </p>&#xA;",91713,,91713,2019-10-30 19:47:26,2019-10-30 19:47:26,"",,0,7,0,2019-10-13 07:25:18
58362495,2,,34199982,7,,"<p><a href=""https://graphql.org/learn/queries/#fields"" rel=""noreferrer"">GraphQL query format</a> was designed in order to allow:</p>&#xA;&#xA;<ol>&#xA;<li>Both query and result shape be <strong>exactly the same</strong>.</li>&#xA;<li>The server knows <strong>exactly</strong> the requested fields, thus the client downloads <strong>only</strong> essential data.</li>&#xA;</ol>&#xA;&#xA;<p>However, according to <a href=""https://graphql.org/learn/queries/#fragments"" rel=""noreferrer"">GraphQL documentation</a>, you may create <a href=""https://graphql.org/learn/queries/#fragments"" rel=""noreferrer"">fragments</a> in order to make selection sets more reusable:</p>&#xA;&#xA;<pre><code># Only most used selection properties&#xA;&#xA;fragment UserDetails on User {&#xA;    id,&#xA;    username&#xA;} &#xA;</code></pre>&#xA;&#xA;<p>Then you could query all user details by:</p>&#xA;&#xA;<pre><code>FetchUsers {&#xA;    users() {&#xA;        ...UserDetails&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can also <a href=""https://egghead.io/lessons/graphql-reuse-graphql-selection-sets-with-fragments"" rel=""noreferrer"">add additional fields alongside your fragment</a>:</p>&#xA;&#xA;<pre><code>FetchUserById($id: ID!) {&#xA;    users(id: $id) {&#xA;        ...UserDetails&#xA;        count&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",2886392,,,,2019-10-13 10:01:45,"",,0,0,0,2019-10-13 10:01:45
58399006,1,,,0,177,"<p>I have a page in my SPA that shows a paginated list of results. This list can be filtered by using some checkbox in the sidebar.</p>&#xA;&#xA;<p>I would like to use Apollo cache to handle the filters state and then retrieve those data while I'm performing a query and use them as parameters for the query.</p>&#xA;&#xA;<p>I don't even know if such thing is possible, does anyone know how to do that?</p>&#xA;",7762473,,,,2019-10-16 11:40:21,Use apollo cache data as graphql query parameters,<apollo><apollo-cache-inmemory>,1,0,0,2019-10-15 16:25:12
58399225,2,,48715646,0,,"<p>I asked <a href=""https://github.community/t5/GitHub-API-Development-and/How-to-query-GraphQL-for-all-Issues-in-a-column-with-state/td-p/33464"" rel=""nofollow noreferrer"">the same question on the GitHub Community forum</a>. An admin wrote back:</p>&#xA;&#xA;<blockquote>&#xA;  <p>The way that the GraphQL API is currently built, no, you can't filter project cards on the state of the issue that they're representing using only the query language. You would have to query all cards in the column and then filter it yourself.</p>&#xA;</blockquote>&#xA;",40785,,,,2019-10-15 16:41:38,"",,0,1,0,2019-10-15 16:41:38
58414849,1,,,3,386,"<p>Let's say I have the following GraphQL schema:</p>&#xA;&#xA;<pre><code>type Cinema {&#xA;    name: String!    &#xA;    rooms: [Room]!&#xA;}&#xA;&#xA;type Room {&#xA;    name: String!&#xA;    seats: [Seat]!&#xA;}&#xA;&#xA;type Seat {&#xA;    number: Int!&#xA;    booked: Boolean!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In front view, I want to display a menu list on the left with collapsed navigation like:</p>&#xA;&#xA;<ul>&#xA;<li>cinema name&#xA;&#xA;<ul>&#xA;<li>room name 1&#xA;&#xA;<ul>&#xA;<li>seat 1 (booked)</li>&#xA;<li>seat 2 (booked)</li>&#xA;<li>...</li>&#xA;</ul></li>&#xA;<li>room name 2&#xA;&#xA;<ul>&#xA;<li>seat 1 (booked)</li>&#xA;<li>seat 2 (booked)</li>&#xA;<li>...</li>&#xA;</ul></li>&#xA;<li>...</li>&#xA;</ul></li>&#xA;</ul>&#xA;&#xA;<p>And on the right, I want to display a summary with the selected cinema name, the selected room name and a map with all seats.</p>&#xA;&#xA;<p>So, the menu component is a classic case in GraphQL with pagination for each connection (rooms, seats). But the summary component <strong>need all data before instanciation</strong> and is not a child of the menu component:</p>&#xA;&#xA;<pre><code>&lt;Page&gt;&#xA;  &lt;Menu /&gt;&#xA;  &lt;Summary /&gt;&#xA;&lt;Page /&gt;&#xA;</code></pre>&#xA;&#xA;<p><strong>Yep, it's possible to handle this with this schema!</strong></p>&#xA;&#xA;<p>Should I fragment my request according to my components, refetch until I have all data and save results in a dedicated state to send to the summary component?</p>&#xA;&#xA;<p><strong>Nope, it's not possible to handle this with this schema!</strong></p>&#xA;&#xA;<p>Should I make only one request without pagination and dispatch props manually to my components?</p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Note 1</strong>: I use Relay Modern as GraphQL client with <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay-style cursor pagination</a> but all suggestions are welcome.</p>&#xA;&#xA;<p><strong>Note 2</strong>: This example is simpler than my real use case. I have many nested pagination and my ""summary"" component need <strong>all</strong> data at initialization.</p>&#xA;",7369091,,1480391,2019-11-27 17:27:27,2019-11-28 16:23:35,What is the best way to fetch the whole GraphQL tree in React?,<reactjs><graphql><relayjs>,0,3,0,2019-10-16 13:44:25
58439642,1,,,0,215,"<p>While attempting a basic tutorial on Graphene, I have encountered an early problem that doesn't seem to be coming up for others, specifically the initial import fails.</p>&#xA;&#xA;<p>Python 2.7.16, Graphene 2.1.8, Six (1.12.0). I've updated all installed packages via pip.</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>python -m graphene&#xA;&#xA;Traceback (most recent call last):&#xA;File ""F:\Python27\lib\runpy.py"", line 163, in _run_module_as_main&#xA;    mod_name, _Error)&#xA;&#xA;File ""F:\Python27\lib\runpy.py"", line 111, in _get_module_details&#xA;    __import__(mod_name)  # Do not catch exceptions initializing package&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\__init__.py"", line 3, in &lt;module&gt;&#xA;    from .types import (&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\types\__init__.py"", line 12, in &lt;module&gt;&#xA;    from .schema import Schema&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\types\schema.py"", line 15, in &lt;module&gt;&#xA;    from .typemap import TypeMap, is_graphene_type&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\types\typemap.py"", line 33, in &lt;module&gt;&#xA;    from .enum import Enum&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\types\enum.py"", line 70, in &lt;module&gt;&#xA;    class Enum(six.with_metaclass(EnumMeta, UnmountedType, BaseType)):&#xA;&#xA;File ""F:\Python27\lib\site-packages\six.py"", line 827, in __new__&#xA;    return meta(name, bases, d)&#xA;&#xA;File ""F:\Python27\lib\site-packages\graphene\types\enum.py"", line 33, in __new__&#xA;    enum = PyEnum(cls.__name__, enum_members)&#xA;&#xA;File ""F:\Python27\lib\site-packages\enum.py"", line 199, in __init__&#xA;    raise EnumBadKeyError(key)&#xA;enum.EnumBadKeyError: Enumeration keys must be strings: OrderedDict([&#xA; ('__module__', 'graphene.types.enum'),&#xA; ('get_type', &lt;classmethod object at 0x031DADB0&gt;),&#xA; ('__doc__', '\n    Enum type definition\n\n    Defines a static set of values that can be provided as a Field, Argument or InputField.\n\n    .. code:: python\n\n        from graphene import Enum\n\n        class NameFormat(Enum):\n            FIRST_LAST = ""first_last""\n            LAST_FIRST = ""last_first""\n\n    Meta:\n        enum (optional, Enum): Python enum to use as a base for GraphQL Enum.\n\n        name (optional, str): Name of the GraphQL type (must be unique in schema). Defaults to class\n            name.\n        description (optional, str): Description of the GraphQL type in the schema. Defaults to class\n            docstring.\n        deprecation_reason (optional, str): Setting this value indicates that the enum is\n            depreciated and may provide instruction or reason on how for clients to proceed.\n    '),&#xA; ('__init_subclass_with_meta__', &lt;classmethod object at 0x031DAD90&gt;),&#xA; ('__eq__', &lt;function eq_enum at 0x031DBD70&gt;)]&#xA;</code></pre>&#xA;",1094933,,1513933,2019-10-17 19:44:29,2019-10-17 19:59:57,graphene fails on import with EnumBadKeyError,<python><python-2.7><graphql><graphene-python>,1,1,0,2019-10-17 19:37:31
58473512,2,,58473198,0,,"<p>To sort the data array by date :</p>&#xA;&#xA;<p>example of data array:</p>&#xA;&#xA;<pre><code>let myPosts = [&#xA;  { ...&#xA;   createdAt: ""2013/7/02""&#xA;   ...&#xA;   },&#xA;   { ...&#xA;     createdAt: ""2013/01/01""&#xA;     ...&#xA;     },&#xA;     { ...&#xA;       createdAt: ""2013/12/01""&#xA;       ...&#xA;       },&#xA;];&#xA;</code></pre>&#xA;&#xA;<p>sort function</p>&#xA;&#xA;<pre><code> function sortMe(a, b) {&#xA;    return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>//sorting all the posts by date</p>&#xA;&#xA;<pre><code>  myPosts.sort(sortMe);&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>to read more about sort function &#xA;  <a href=""https://www.w3schools.com/jsref/jsref_sort.asp"" rel=""nofollow noreferrer"">https://www.w3schools.com/jsref/jsref_sort.asp</a></p>&#xA;</blockquote>&#xA;",9055523,,,,2019-10-20 13:31:18,"",,0,1,0,2019-10-20 13:31:18
58506326,1,,,4,671,"<p>I have a graphql type with a one-to-many connection to another type. I want to filter the many using the one. So Amplify has generated the graphql schema but in the input for the list query there isn't a value for the connection to use.</p>&#xA;&#xA;<p>The type:</p>&#xA;&#xA;<pre><code>type Event @model @auth(rules: [{ allow: owner }]) {&#xA;  id: ID!&#xA;  name: String!&#xA;  date: AWSDateTime!&#xA;  user: User! @connection(name: ""EventsUser"", sortField: ""date"")&#xA;  isDeleted: Boolean!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The query:</p>&#xA;&#xA;<pre><code>type Query {&#xA;  listEvents(filter: ModelEventFilterInput, limit: Int, nextToken: String): modelEventConnection&#xA;</code></pre>&#xA;&#xA;<p>The list query input</p>&#xA;&#xA;<pre><code>input ModelEventFilterInput {&#xA;  id: ModelIDFilterInput&#xA;  name: ModelStringFilterInput&#xA;  date: ModelStringFilterInput&#xA;  isDeleted: ModelBooleanFilterInput&#xA;  and: [ModelEventFilterInput]&#xA;  or: [ModelEventFilterInput]&#xA;  not: ModelEventFilterInput&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I tried passing the id in the variables object using:</p>&#xA;&#xA;<pre><code>    variables: {&#xA;        filter: {&#xA;            eventUserId: {&#xA;                eq: props.id,&#xA;            },&#xA;</code></pre>&#xA;&#xA;<p>where eventUserId is the field name generated by amplify and used in the DynamoDB table, but this didn't work. How do you filter based on this value? Do I have to write this manually?</p>&#xA;&#xA;<p>Adam</p>&#xA;&#xA;<p><strong>Edit</strong></p>&#xA;&#xA;<p>I have some of this figured out. I've added:</p>&#xA;&#xA;<pre><code>eventUserId: ModelEventUserInput&#xA;</code></pre>&#xA;&#xA;<p>where ModelEventUserInput is</p>&#xA;&#xA;<pre><code>input ModelEventUserInput {&#xA;    eq: ID&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>to the ModelEventFilterInput input and then I use:</p>&#xA;&#xA;<pre><code>variables: {&#xA;    filter: {&#xA;        eventUserId: {&#xA;            eq: props.id,&#xA;        },&#xA;</code></pre>&#xA;&#xA;<p>This works to filter the correct Events when the app is loaded by the filtering doesn't apply with subscriptions. I've tried just adding the filter object to the subscription constructor: </p>&#xA;&#xA;<pre><code>this.props.subscribeToEvents(&#xA;      buildSubscription({&#xA;        query: gql(onCreateEvent),&#xA;        variables: {&#xA;          owner,&#xA;          filter: {&#xA;            eventUserId: {&#xA;              eq: id,&#xA;            },&#xA;            isDeleted: {&#xA;              eq: false,&#xA;            },&#xA;          }&#xA;        },&#xA;      }, gql(listEvents))&#xA;    );&#xA;</code></pre>&#xA;&#xA;<p>but without any luck. How can this filtering be achieved on subscriptions?</p>&#xA;&#xA;<p>Adam</p>&#xA;",5884661,,5884661,2019-10-23 20:28:54,2019-10-23 20:28:54,AppSync GraphQL @connection query,<apollo><react-apollo><aws-amplify><aws-appsync><appsync-apollo-client>,0,2,0,2019-10-22 14:17:52
58507793,2,,54744066,6,,"<p>Thanks to parameterized fragments you can take variables into account! Assuming <code>post</code> is a field of the root query type the combined query referring to the above example would be:</p>&#xA;<pre><code>fragment PostHeader on RootQueryType {&#xA;  post(id: $id) {&#xA;    tags&#xA;    author {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment PostMeta on RootQueryType {&#xA;  post(id: $id) {&#xA;    tags&#xA;    author {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# ID being the id type&#xA;query($id: ID! = 1234) {&#xA;  ...PostHeader&#xA;  ...PostMeta&#xA;}&#xA;</code></pre>&#xA;<p>or rather in a real-world scenario you'd be passing in the id dynamically (e.g. in your post request), see: <a href=""https://graphql.org/learn/queries/#variables"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#variables</a></p>&#xA;",7926354,,7926354,2022-03-17 15:17:28,2022-03-17 15:17:28,"",,0,0,0,2019-10-22 15:37:22
58508667,2,,58508607,0,,"<p>Assuming <code>|</code> isn't used ever in the data, you could do:</p>&#xA;&#xA;<pre><code>items.name.split('|').filter(data =&gt; /^(DATE:|TIME:|DURATION:|TYPE:)/.test(data));&#xA;</code></pre>&#xA;",2763250,,,,2019-10-22 16:31:18,"",,0,0,0,2019-10-22 16:31:18
58522094,2,,58502933,0,,"<p>You use a fragmentContainer to ensure what data you need in a component.</p>&#xA;&#xA;<p>For exemple:</p>&#xA;&#xA;<p>parent.js</p>&#xA;&#xA;<pre><code>const ParentComponent = ({list}) =&gt; (&#xA;   &lt;QueryRenderer&#xA;      query={graphql`&#xA;         query List {&#xA;            id&#xA;            ...childComponent_item&#xA;         }&#xA;      `}&#xA;      render={&#xA;         list.map(item =&gt; (&#xA;            &lt;ChildComponent item={item} key={item.id} /&gt;&#xA;         ))&#xA;      }&#xA;   /&gt;&#xA;);&#xA;export default ParentComponent;&#xA;// Here, in  the parent component&#xA;// I need the id of each item of the list but I don't need the others values.&#xA;</code></pre>&#xA;&#xA;<p>childComponent.js</p>&#xA;&#xA;<pre><code>const ChildComponent = item =&gt; (&#xA;   &lt;&gt;&#xA;      &lt;div&gt;{item.name}&lt;/div&gt;&#xA;      &lt;div&gt;{item.avatar}&lt;/div&gt;&#xA;      &lt;div&gt;{item.othervalue}&lt;/div&gt;&#xA;   &lt;/&gt;&#xA;)&#xA;const ChildComponentWithFragment = createFragmdentContainer(&#xA;   ChildComponent, &#xA;   {&#xA;      list: graphql`&#xA;         fragment childComponent_item on ItemType {&#xA;            name&#xA;            avatar&#xA;            othervalue&#xA;         }&#xA;      `&#xA;   };&#xA;export default ChildComponentWithFragment;&#xA;// Here in the child component&#xA;// I need the others data of the Item object so i have to get these values&#xA;// in my fragment&#xA;</code></pre>&#xA;",4611214,,,,2019-10-23 11:42:13,"",,0,0,0,2019-10-23 11:42:13
58533300,2,,58295407,1,,"<p>when you read/write the getBars query, you need to pass the location as a variable </p>&#xA;&#xA;<pre><code>  const [userGoes] = useMutation(GO_MUTATION, {&#xA;variables: { yelp_id: id },&#xA;update(proxy, result) {&#xA;  const data = proxy.readQuery({&#xA;    query: GET_BARS_QUERY,&#xA;    variables: {&#xA;        location: 'New York'&#xA;    }&#xA;  });&#xA;  data.getBars = [result.userGoes, ...data.getBars];&#xA;  proxy.writeQuery({ query: GET_BARS_QUERY, data,&#xA;    variables: {&#xA;        location: 'New York'&#xA;    }&#xA;   });&#xA;}&#xA;});&#xA;</code></pre>&#xA;",4272160,,,,2019-10-24 02:29:05,"",,0,3,0,2019-10-24 02:29:05
58563426,1,,,0,2031,"<p>I have a query in React</p>&#xA;&#xA;<p><code>const allQueries = await API.graphql(graphqlOperation(queries.listProcess));</code></p>&#xA;&#xA;<p>Then in my queries.js I have it defined as so.</p>&#xA;&#xA;<pre><code>```export const listProcess = `query ListProcess(&#xA;  $filter: ModelProcessFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listProcess(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      routine {&#xA;        id&#xA;        key&#xA;      }&#xA;      event {&#xA;        eventId&#xA;        detailType&#xA;        source&#xA;        account&#xA;        time&#xA;        region&#xA;        resources&#xA;        detail&#xA;      }&#xA;      tasks {&#xA;        key&#xA;        title&#xA;        status&#xA;        processId&#xA;        context&#xA;        eventId&#xA;        message&#xA;        export&#xA;        error&#xA;        output&#xA;      }&#xA;      workers {&#xA;        id&#xA;        type&#xA;      }&#xA;      status&#xA;      context&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;`;```&#xA;</code></pre>&#xA;&#xA;<p>When I go to query it I get this error in JS</p>&#xA;&#xA;<p>locations: null</p>&#xA;&#xA;<p>message: ""Can't resolve value (/listProcesss/items[1]/tasks) : type mismatch error, expected type LIST""</p>&#xA;&#xA;<p>path: Array(4)</p>&#xA;&#xA;<p>0: ""listProcesss""</p>&#xA;&#xA;<p>1: ""items""&#xA;2: 1&#xA;3: ""tasks""&#xA;length: 4</p>&#xA;",8942177,,,,2022-07-27 02:57:48,GraphQL AWS React Can't resolve value type mismatch expected type LIST,<reactjs><amazon-web-services><graphql><aws-appsync>,2,2,0,2019-10-25 17:51:44
58601633,1,,,0,2030,"<p>I am following this Apollo Pagination tutorial: </p>&#xA;&#xA;<p><a href=""https://www.apollographql.com/docs/react/data/pagination/#relay-style-cursor-pagination"" rel=""nofollow noreferrer"">Apollo Pagination Examples</a></p>&#xA;&#xA;<p><strong><em>Summary of my issue:</em></strong></p>&#xA;&#xA;<p>I have a known working GraphQL query that works in the playground. When I try to fetch data and use it in a React component, as outlined in that Apollo link above, I get the following error: </p>&#xA;&#xA;<p>""TypeError: Cannot read property 'errorlogsConnection' of undefined""</p>&#xA;&#xA;<p>However, when I check the response from the graphQL api in the web console, the query  <em>does</em> in fact return data. Picture attached below.</p>&#xA;&#xA;<p>I believe I'm probably trying to reference the object incorrectly but I can't spot what my mistake is.</p>&#xA;&#xA;<p><strong><em>Note:</em></strong> I have been able to query and use this same API endpoint in other React components for this very same project without issue.</p>&#xA;&#xA;<p><strong>Here is the code involved:</strong> </p>&#xA;&#xA;<p>I am using this query, which works in my GraphiQL playground: </p>&#xA;&#xA;<pre><code>query errorlogsConnection($cursor: String) {&#xA;  errorlogsConnection(orderBy: errorid_DESC, first: 4, after: $cursor) {&#xA;    edges {&#xA;      node {&#xA;        errorid&#xA;        errorlog&#xA;        entrydate&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasPreviousPage&#xA;      hasNextPage&#xA;      endCursor&#xA;      startCursor&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is the ReactJS code that I've adapted from their tutorial: </p>&#xA;&#xA;<pre><code>function ErrorLogsPagination() {&#xA;    const {data: {errorlogsConnection: errorLogs}, loading, fetchMore, error} = useQuery(&#xA;        ERROR_LOG_PAGINATION&#xA;    );&#xA;&#xA;    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;&#xA;    if (error) return &lt;p&gt;Error :(&lt;/p&gt;;&#xA;&#xA;&#xA;    return (&#xA;        &lt;ErrorLogs&#xA;            entries={errorLogs || []}&#xA;            onLoadMore={() =&gt;&#xA;                fetchMore({&#xA;                    variables: {&#xA;                        cursor: errorLogs.pageInfo.endCursor&#xA;                    },&#xA;                    updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;                        const newEdges = fetchMoreResult.errorLogs.edges;&#xA;                        const pageInfo = fetchMoreResult.errorLogs.pageInfo;&#xA;&#xA;                        return newEdges.length&#xA;                            ? {&#xA;                                // Put the new comments at the end of the list and update `pageInfo`&#xA;                                // so we have the new `endCursor` and `hasNextPage` values&#xA;                                comments: {&#xA;                                    __typename: previousResult.errorLogs.__typename,&#xA;                                    edges: [...previousResult.errorLogs.edges, ...newEdges],&#xA;                                    pageInfo&#xA;                                }&#xA;                            }&#xA;                            : previousResult;&#xA;                    }&#xA;                })&#xA;            }&#xA;        /&gt;&#xA;    );&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/V8mHw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/V8mHw.png"" alt=""enter image description here""></a></p>&#xA;",1248151,,,,2019-10-29 05:02:34,"JS TypeError: Cannot Read Property ""..."" of Undefined, Despite DATA being returned?",<reactjs><graphql><react-apollo>,1,2,0,2019-10-29 04:58:54
58601721,1,,,2,447,"<p>I would like to filter the sub query based on the result of the main query, my query is</p>&#xA;&#xA;<pre><code>{&#xA;  users(where: { id:""server1""  }) {&#xA;    id&#xA;    name&#xA;    lastMonthPaid  &lt;-----------I want to used this variable in sub query&#xA;    offers{&#xA;      books (where:{date: lastMonthPaid}){&lt;----------this is the sub query&#xA;        dealprice&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>By the way I use prisma&#xA;So, does Graphql provide mechanism to do this kind of Query? </p>&#xA;",1687645,,1687645,2019-10-29 09:12:31,2019-10-29 09:12:31,Could be filtered the subquery based on the main query? (Graphql),<graphql><prisma>,0,1,0,2019-10-29 05:10:47
58605106,1,,,1,91,"<p>Knowing the schema (fetched via <code>getIntrospectionQuery</code>), how could I get the type of a particular field?</p>&#xA;&#xA;<p>For example, say I run this query:</p>&#xA;&#xA;<pre><code>query {&#xA;  User {&#xA;    name&#xA;    lastUpdated&#xA;    friends {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and get this result:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""User"": [&#xA;      {&#xA;        ""name"": ""alice"",&#xA;        ""lastUpdated"": ""2018-02-03T17:22:49+00:00"",&#xA;        ""friends"": []&#xA;      },&#xA;      {&#xA;        ""name"": ""bob"",&#xA;        ""lastUpdated"": ""2017-09-01T17:08:49+00:00"",&#xA;        ""friends"": [&#xA;          {&#xA;            ""name"": ""eve""&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'd like to know the types of the fields and construct something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  ""name"": ""String"",&#xA;  ""lastUpdated"": ""timestamptz"",&#xA;  ""friends"": ""[Friend]""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How could I do that without extra requests to the server? </p>&#xA;",247243,,,,2019-10-31 21:49:13,GraphQL - How to get field types from the retrieved schema?,<graphql>,1,0,0,2019-10-29 10:00:04
58622225,2,,58615590,1,,"<p><code>where</code> doesn't exist in Gatsby. I'd highly recommend using GraphiQL (under localhost:8000/___graphql) to see what you can do. There is also this doc showing all possibilities: <a href=""https://www.gatsbyjs.org/docs/graphql-reference/"" rel=""nofollow noreferrer"">https://www.gatsbyjs.org/docs/graphql-reference/</a></p>&#xA;&#xA;<p>It'll probably will be in the end (untested):</p>&#xA;&#xA;<pre><code>filter: { system_category: { eq: $uid } }&#xA;</code></pre>&#xA;",10164092,,,,2019-10-30 09:30:03,"",,0,1,0,2019-10-30 09:30:03
58632921,2,,58626327,3,,"<p>The ruby Hash instances are not ordered (see <a href=""https://stackoverflow.com/questions/31418673/is-order-of-a-ruby-hash-literal-guaranteed"">Is order of a Ruby hash literal guaranteed?</a>)</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>To leverage the optional multi sorting options in GraphQL input types, I usually use the following structure:</p>&#xA;&#xA;<ul>&#xA;<li>1 enum to contain all filterable/sortable/searchable field of a resource (ex: <code>UserField</code>)</li>&#xA;<li>1 enum to contain the 2 sort directions (<code>asc</code> and <code>desc</code>)</li>&#xA;<li>1 field accepting an optional list of <code>{ field: UserField!, sortDir: SortDir! }</code> inputs.</li>&#xA;</ul>&#xA;&#xA;<p>This then enables the API consumers to simply do queries like:</p>&#xA;&#xA;<pre><code>allUsers(sort_by: [{field: username, sortDir: desc}, {field: id, sortDir: asc}]) {&#xA;  # ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And this pattern can be easily re-used for searching and filtering:</p>&#xA;&#xA;<pre><code>allUsers(search: [{field: username, comparator: like, value: 'bob'}]) {}&#xA;allUsers(search: [{field: age, comparator: greater_than, value: '22'}]) {} # type casting is done server-side&#xA;allUsers(search: [{field: username, comparator: equal, value: 'bob'}]) {} # equivalent of filtering&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<p>Eventually, with further deeper work you can allow complex <code>and</code>/<code>or</code> for the input:</p>&#xA;&#xA;<pre><code>allUsers(&#xA;  search: [&#xA;    {&#xA;      left: {field: username, comparator: like, value: 'bob'}&#xA;      operator: and&#xA;      right: {field: dateOfBirth, comparator: geater_than, value: '2001-01-01'}&#xA;    }&#xA;  ]&#xA;)&#xA;</code></pre>&#xA;&#xA;<p>Disclaimer: the last example above is one of the many things I want to implement in my GQL API but I haven't had the time to think it through yet, it's just a draft</p>&#xA;",976775,,,,2019-10-30 20:08:24,"",,0,5,0,2019-10-30 20:08:24
58666669,1,58681452,,0,171,"<p>Say I have the following query:</p>&#xA;&#xA;<pre><code>query Foo {&#xA;  foo {&#xA;    bar&#xA;    baz&#xA;    qux @client&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And these resolvers:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>Foo: {&#xA;  qux: () =&gt; {&#xA;    console.log(""qux"");&#xA;    return ""qux"";&#xA;  },&#xA;  bar: obj =&gt; {&#xA;    console.log(""bar"");&#xA;    return obj.bar;&#xA;  },&#xA;  baz: obj =&gt; {&#xA;    console.log(""baz"");&#xA;    return obj.baz;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is the execution order of the resolvers dependent on the order in the query - or the other way around?</p>&#xA;",3873510,,3873510,2019-11-03 15:01:12,2019-11-03 15:06:23,What is the execution order of local resolvers in React Apollo?,<graphql><apollo><react-apollo><apollo-client>,1,0,0,2019-11-01 22:40:19
58667660,2,,55717302,0,,"<p>Just tested the following code and it seems to work well:&#xA;<strong>i.e. possible to add ${nextToken} in order to be able to iterate over 1000 limit.</strong></p>&#xA;&#xA;<pre><code> query GetTasks(id:ID!, limit:Int) {&#xA;     getTask(input: {id: $id}) {&#xA;       id&#xA;       createdAt&#xA;       name&#xA;       comments (limit: $limit nextToken: ${nextToken}) {&#xA;         items {&#xA;           id&#xA;         }&#xA;       }&#xA;       status&#xA;     } }&#xA;</code></pre>&#xA;",12173587,,12173587,2019-11-02 13:33:39,2019-11-02 13:33:39,"",,0,3,0,2019-11-02 01:57:58
58675616,1,58903787,,0,1581,"<p>I'm trying to filter results based on the id of a child on graphql and receiving the following error:</p>&#xA;&#xA;<blockquote>&#xA;  <p>""Expected JSON object for '$[filter]' but got a 'STRING' instead.""</p>&#xA;</blockquote>&#xA;&#xA;<p>Most of the code was generated by aws amplify.</p>&#xA;&#xA;<p><strong>Schema</strong></p>&#xA;&#xA;<pre><code>type Company {&#xA;    id: ID!&#xA;    name: String!&#xA;    disabled: Int&#xA;}&#xA;&#xA;type Customer {&#xA;    id: ID!&#xA;    name: String!&#xA;    company: Company!&#xA;    disabled: Int&#xA;}&#xA;&#xA;input ModelCustomerFilterInput {&#xA;    id: ModelIDFilterInput&#xA;    name: ModelStringFilterInput&#xA;    disabled: ModelIntFilterInput&#xA;    company: ModelCompanyFilterInput #added by me&#xA;    and: [ModelCustomerFilterInput]&#xA;    or: [ModelCustomerFilterInput]&#xA;    not: ModelCustomerFilterInput&#xA;}&#xA;&#xA;input ModelCompanyFilterInput {&#xA;    id: ModelIDFilterInput&#xA;    name: ModelStringFilterInput&#xA;    disabled: ModelIntFilterInput&#xA;    and: [ModelCompanyFilterInput]&#xA;    or: [ModelCompanyFilterInput]&#xA;    not: ModelCompanyFilterInput&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Query</strong></p>&#xA;&#xA;<pre><code>query ListCustomers($filter: ModelCustomerFilterInput, $limit: Int, $nextToken: String) {&#xA;  listCustomers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    __typename&#xA;    items {&#xA;      __typename&#xA;      id&#xA;      name&#xA;      company {&#xA;        __typename&#xA;        id&#xA;        name&#xA;        disabled&#xA;      }&#xA;      disabled&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;&#xA;{""filter"": {""company"": {""id"": {""eq"": ""example""}}}}&#xA;</code></pre>&#xA;",4193927,,,,2019-11-17 18:30:16,"aws appsync graphql ""Expected JSON object for '$[filter]' but got a 'STRING' instead.""",<amazon-web-services><graphql><amazon-dynamodb><aws-appsync>,1,3,0,2019-11-02 21:52:08
58683303,1,58684070,,7,995,"<p>I get a TypeScript type autogenerated from AWS-Amplify GraphQL (which uses apollo-codegen I believe) like such:</p>&#xA;&#xA;<pre><code>export type GetNoteQuery = {&#xA;  getNote:  {&#xA;    __typename: ""Note"",&#xA;    id: string,&#xA;    createdAt: string | null,&#xA;    updatedAt: string | null,&#xA;    title: boolean | null,&#xA;    content: string | null,&#xA;  } | null,&#xA;</code></pre>&#xA;&#xA;<p>I want to generate a base type of ""Note"" to use as ""base"" type to use in my code when using the returned data. I.e. mapping notes onto a React component, etc.</p>&#xA;&#xA;<p>Is there a way to narrow this type that is auto generated, or to extend it in some way, to have it look like:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>type Note = {&#xA;    id: string,&#xA;    createdAt: string | null,&#xA;    updatedAt: string | null,&#xA;    title: boolean | null,&#xA;    content: string | null&#xA;}&#xA;&#xA;</code></pre>&#xA;",10070034,,,,2021-07-20 14:19:33,How to narrow Typescript Types autogenerated by graphQL codegen?,<typescript><graphql><aws-amplify><aws-appsync>,2,0,0,2019-11-03 18:24:43
58692369,1,,,0,81,"<p>Let me explain:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>type SecondType {&#xD;&#xA;  id: String&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type FirstType {&#xD;&#xA;  id: String&#xD;&#xA;  secondTypes: [SecondType]&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type Query {&#xD;&#xA;  firstTypes: [FirstType]&#xD;&#xA;  secondTypes: [SecondType]&#xD;&#xA;}&#xD;&#xA;//&#xD;&#xA;const resolver = {&#xD;&#xA;  Query: {&#xD;&#xA;    firstTypes: fetchFirstTypes,&#xD;&#xA;    secondTypes: fetchSecondTypes&#xD;&#xA;  }&#xD;&#xA;};</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>The idea is that if there's a parent-child relationship between <code>firstType</code> and <code>secondType</code>, for example <code>secondType</code> contains it's parent (<code>firstType</code>) id, through the result of the previous resolver, <code>secondTypes</code> inside query <code>firstTypes</code> can fetch <code>secondTypes</code> related to it's parent <code>firstType</code>. What I've experienced is that the resolver of <code>firstType</code> is looking for a key named <code>secondTypes</code> from the result of <code>fetchFirstTypes</code>. But I want to let GraphQL know that it needs to resolve <code>secondTypes</code> from the resolver of <code>Query.secondTypes</code>. How can I do that? Maybe is there a way to write ""fallback reducers"" of a field? So if it doesn't find a key from the result, it can look for a resolver?</p>&#xA;",9307392,,,,2019-11-04 13:59:27,How to let GraphQL know if I want to resolve a field from another rootQuery?,<javascript><graphql>,1,0,0,2019-11-04 11:19:09
58715563,2,,58713200,1,,"<p>Assuming gridsome supports fragments, you can do something like this:</p>&#xA;&#xA;<pre><code>&lt;page-query&gt;&#xA;query {&#xA;  data: pages(path: ""/pages"") {&#xA;    title,&#xA;    top_image,&#xA;    page_builder {&#xA;      ...A @include(if: $includeA)&#xA;      ...B @include(if: $includeB)&#xA;      ...C @include(if: $includeC)&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# Note: Replace PageBuilderType with appropriate type&#xA;fragment A on PageBuilderType {&#xA;  # your fields here&#xA;}&#xA;fragment B on PageBuilderType {&#xA;  # your fields here&#xA;}&#xA;fragment C on PageBuilderType {&#xA;  # your fields here&#xA;}&#xA;&lt;/page-query&gt;&#xA;</code></pre>&#xA;&#xA;<p>You can then define the variables when calling <code>createPage</code> as shown <a href=""https://gridsome.org/docs/pages-api/#createpageoptions"" rel=""nofollow noreferrer"">here</a>:</p>&#xA;&#xA;<pre><code>api.createPages(({ createPage }) =&gt; {&#xA;    createPage({&#xA;      path: '/my-page',&#xA;      component: './src/templates/MyPage.vue',&#xA;      queryVariables: {&#xA;        includeA: someCondition,&#xA;        includeB: someCondition,&#xA;        includeC: someCondition,&#xA;      },&#xA;    })&#xA;  })&#xA;}&#xA;</code></pre>&#xA;",6024220,,,,2019-11-05 16:27:04,"",,0,0,0,2019-11-05 16:27:04
58738676,1,58738886,,1,646,"<p>I have extended my graphql schema to add a totals resolver, but I can't seem to extend the filter to filter on this field. I can't figure out what can be wrong as it seems very simple, so maybe it's not supported? I am using Postgraphile with the makeExtendSchemaPlugin, but I believe the question is basic graphql syntax.</p>&#xA;&#xA;<pre><code>return {&#xA;  typeDefs: gql`&#xA;    extend type Note {&#xA;      lines: Int&#xA;    }&#xA;    extend type NoteFilter {&#xA;      lines: IntFilter&#xA;    }&#xA;  `,&#xA;  resolvers: {&#xA;    Note: {&#xA;      resolve: async(parent, args, ctx, info) =&gt; {&#xA;        // logic here&#xA;        return parent['@lines'].data.length;&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This seems so simple. The count resolver works, and gives me how many lines are in the note, yet I am not able to filter on it. I don't want to put the filter logic in the lines property itself. If I define a new query and give it a NoteFilter, the filter exists but doesn't include my extended property (lines). Anyone know what I'm doing wrong? This is the end goal I would like for a query:</p>&#xA;&#xA;<pre><code>gql`&#xA;  {&#xA;    allNotes(filter: {&#xA;      lines: {&#xA;        greaterThan: 10&#xA;      }&#xA;    }) {&#xA;      id&#xA;      lines&#xA;      line {&#xA;        content   &#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;",6780959,,,,2019-11-06 21:39:10,Extending a GraphQL Filter Definition,<javascript><node.js><graphql><graphql-js><postgraphile>,1,0,0,2019-11-06 21:22:13
58750804,1,,,1,85,"<p>Hey I am trying to display data from an API in a Flatlist but I keep getting the error message that says 'Invariant Violation: Element type is invalid:expected a string(for built-in components) or a class/function for composite components but got undefined....Check the render method of 'UsersScreen'</p>&#xA;&#xA;<p>I am not sure what part of my code is causing this error</p>&#xA;&#xA;<pre><code>import { API, graphqlOperation } from 'aws-amplify'&#xA;import { Text, View, Flatlist } from 'react-native'&#xA;&#xA;&#xA;const listUsers = `query listUsers {&#xA;  listUsers {&#xA;      username&#xA;&#xA;&#xA;  }&#xA;}`;&#xA;&#xA;class UsersScreen extends Component {&#xA;&#xA;  listQuery = async () =&gt; {&#xA;    console.log('listing Users');&#xA;    const allUsers = await API.graphql(graphqlOperation(listUsers));&#xA;    alert(JSON.stringify(allUsers));&#xA;  };&#xA; render() {&#xA;  return(&#xA;    &lt;Flatlist &#xA;    data={listUsers} &#xA;    renderItem={({ item }) =&gt; (&#xA;      &lt;View&gt;&#xA;        &lt;Text&gt;{item.username}&lt;/Text&gt;&#xA;      &lt;/View&gt;&#xA;    )}&#xA;    /&gt;&#xA;&#xA;  )&#xA;  }&#xA;}&#xA;&#xA;export default UsersScreen;&#xA;</code></pre>&#xA;",11771033,,,,2019-11-07 18:25:20,Trying to list data from an API is giving error message 'Invariant Violation: Element type is invalid:........',<react-native><graphql><expo><aws-amplify><aws-appsync>,1,0,0,2019-11-07 14:24:30
58799449,1,,,3,1480,"<p>I am using Apollo Android GraphQL (Gradle plug-in version 1.2.1) to post data to a server. I have downloaded the schema.json file from the server and written a .graphql file with a mutation. To pass objects from the App I defined some input objects as follows.</p>&#xA;&#xA;<pre><code>input Location {&#xA;    lat: Float!&#xA;    lon: Float!&#xA;}&#xA;&#xA;input SensorParams {&#xA;    sources: [Int]&#xA;    exposition: Float&#xA;    location: Location!&#xA;}&#xA;&#xA;mutation InsertSessionResults(&#xA;    $location: Location!) {&#xA;    insertSession(session: {&#xA;        name: $name&#xA;    }) {&#xA;        id&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However when I build the App, I get the following error: Failed to parse GraphQL file. Unsupported token '!'</p>&#xA;&#xA;<p>If I remove the '!' from Location, the process gives the same error for the '[' char.</p>&#xA;&#xA;<p>Reading the doc I understand that both characters are allowed in input definition to request a non-null value and to set a list type respectively, so what may cause the error?</p>&#xA;",1728319,,2649012,2019-11-11 12:10:47,2021-03-04 09:13:02,Apollo graphQL unsupported token in input,<android><graphql>,2,0,0,2019-11-11 10:16:54
58827923,2,,58827278,0,,"<p>You need to return the file too, which is the csv. The line below will make it downloadable.</p>&#xA;&#xA;<pre><code>response['Content-Disposition'] = 'attachment; filename=""yourfilename.csv""'&#xA;</code></pre>&#xA;",5448770,,,,2019-11-12 22:56:39,"",,0,0,0,2019-11-12 22:56:39
58858731,1,,,0,224,"<p>This is very interesting. I am not getting any errors but my data from GraphQL API is not being rendered into a FlatList. All that I am seeing in my UsersScreen is the Text component. I was getting errors before because my data was an object instead of an array but even after passing my object as an array, FlatList is not recognizing the data</p>&#xA;&#xA;<pre><code>import { API, graphqlOperation } from 'aws-amplify'&#xA;import { Text, View, FlatList } from 'react-native';&#xA;import { ListItem } from 'react-native-elements';&#xA;&#xA;&#xA;&#xA;const listUsers = `query listUsers {&#xA;  listUsers {&#xA;      username&#xA;&#xA;&#xA;  }&#xA;}`;&#xA;&#xA;&#xA;&#xA;export default function UsersScreen() {&#xA;&#xA;const [allUsers, setAllUsers] = useState([]);&#xA;&#xA;  listQuery = async () =&gt; {&#xA;    const allUsers = await API.graphql(graphqlOperation(listUsers));&#xA;    setAllUsers(allUsers);&#xA;    console.log(JSON.stringify(listUsers, null, 2));&#xA;&#xA;&#xA;  };&#xA;&#xA;  keyExtractor = (_item, index) =&gt; index.toString()&#xA;  renderItem = ({ item }) =&gt; (&#xA;    &lt;ListItem&#xA;      title={item.username}&#xA;    /&gt;&#xA;  )&#xA;&#xA;  return(&#xA;    &lt;View&gt; &#xA;      &lt;Text&gt;All Users&lt;/Text&gt;&#xA;      &lt;FlatList&#xA;        keyExtractor={keyExtractor}&#xA;        data={allUsers}&#xA;        renderItem={renderItem}&#xA;      /&gt; &#xA;    &lt;/View&gt;&#xA;  );&#xA;}&#xA;</code></pre>&#xA;",11771033,,,,2019-11-14 22:04:35,ListItem/FlatList is not rendering data from GraphQL API,<reactjs><react-native><graphql>,1,2,0,2019-11-14 14:10:53
58861626,2,,58842454,1,,"<p>As Storyblok has components as first class citizens resolving a attribute can be done via the resolve_relations api function. This lets you also resolve attributes in deeply nested components just by providing the component name and the attribute (YOUR_COMPONENT.YOUR_ATTRIBUTE).</p>&#xA;&#xA;<pre><code>{&#xA;  use: 'gridsome-source-storyblok',&#xA;  options: {&#xA;    ...&#xA;    params: {&#xA;      resolve_relations: 'article-post.authors,article-post.categories'&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2268090,,,,2019-11-14 16:36:07,"",,0,2,0,2019-11-14 16:36:07
58874939,1,58874940,,5,1932,"<p>Say you have fragment B, which depends on fragment A. I wonder whether you can plug-and-play fragment B in a query.</p>&#xA;",3873510,,,,2019-11-15 12:46:26,Can you nest fragments in GraphQL?,<graphql><graphql-fragments>,1,0,0,2019-11-15 10:22:02
58874940,2,,58874939,7,,"<p>Yes, you can!</p>&#xA;&#xA;<p>Take these queries:</p>&#xA;&#xA;<pre><code>fragment Bar on Foo {&#xA;  bar {&#xA;    id&#xA;  }&#xA;}&#xA;&#xA;fragment Baz on Foo {&#xA;  baz {&#xA;    id&#xA;  }&#xA;}&#xA;&#xA;&#xA;fragment MetaFoo on Foo {&#xA;  id&#xA;  ...Bar&#xA;  ...Baz&#xA;}&#xA;&#xA;query Qux {&#xA;  foo {&#xA;    ...MetaFoo&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>Qux</code> is a valid GraphQL query.</p>&#xA;",3873510,,3873510,2019-11-15 12:46:26,2019-11-15 12:46:26,"",,0,1,0,2019-11-15 10:22:02
58897831,1,,,0,256,"<p>I want to use cursor based pagination in Mongo DB. My cursor is an object id. When I run a find query with sort the final result is a list of documents that includes one with above mentioned cursor (object id).</p>&#xA;&#xA;<p>What I want is to be able to get only those documents that are later in the result than given cursor. Which is different from using Skip because I can't know the index of the specific document in the result matching the cursor (object id).</p>&#xA;&#xA;<p>Same goes for backward pagination which is to be able to get only those documents that are before in the result than given cursor.</p>&#xA;&#xA;<p>This is a blocker in my case because of efficiency requirement as the result can be huge list of documents. So I can't just iterate over the result and skip documents before the cursor. I've already tried that and it fails miserably when user keeps scrolling to later part of the result.</p>&#xA;&#xA;<p>Any help will be greatly appreciated.</p>&#xA;&#xA;<p>As a note, I'm using Go Mongo driver and gqlgen graphql server if it's relevant for your answer.</p>&#xA;",6409252,,,,2019-11-17 05:38:11,Cursor based pagination in Mongo DB where skip or limit is not known,<mongodb><go><pagination><graphql><cursor>,0,2,0,2019-11-17 05:38:11
58935734,1,,,2,110,"<p>I use ApolloClient 3 and webpack's <code>graphql-tag/loader</code>. The beginning of my file looks like:</p>&#xA;&#xA;<pre><code>#import '../../hooks/fragments/User/basicUserInfo.gql'&#xA;&#xA;fragment IsLeftSidebarOpen on Query {&#xA;  isLeftSidebarOpen @client&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>These 3 following snippets are in the same file that <code>IsLeftSidebarOpen</code> fragment is. Of course I test them one by one by changing file, not all at once.&#xA; Could you explain me why</p>&#xA;&#xA;<p>a) this works</p>&#xA;&#xA;<pre><code>query FetchData {&#xA;  me {&#xA;    ...BasicUserInfo&#xA;  }&#xA;  isLeftSidebarOpen @client&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>b) this also works</p>&#xA;&#xA;<pre><code>query FetchData {&#xA;  ...IsLeftSidebarOpen @client&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>c) but this throws the following error <code>Unknown fragment ""IsLeftSidebarOpen""</code></p>&#xA;&#xA;<pre><code>query FetchData {&#xA;  me {&#xA;    ...BasicUserInfo&#xA;  }&#xA;  ...IsLeftSidebarOpen @client&#xA;}&#xA;&#xA;</code></pre>&#xA;",7303770,,7303770,2019-11-19 14:27:42,2019-11-19 14:27:42,Mixing @client fragment with remote fragment doesn't work,<graphql><react-apollo><apollo-client>,0,3,0,2019-11-19 13:57:57
58942412,1,,,0,77,"<h2>Problem</h2>&#xA;&#xA;<p>Trying to infer the return type of several <strong>graphQL</strong> queries in <strong>TypeScript</strong>.  The main issue is that the queries return the objects wrapped in the names of the queries.  So a query for users could be named <code>listUsers</code>, and return <code>User[]</code>; however, in GraphQL/Apollo, it returns <code>Record&lt;'listUsers', User[]&gt;</code>.  I'm wondering how I can infer the <code>'list${queryName}'</code> key with TypeScript.</p>&#xA;&#xA;<h2>Example Request</h2>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const getUsers = () =&gt; apolloClient.query&lt;Record&lt;'listUsers', User[]&gt;&gt;({&#xA;  query: gql`&#xA;    query {&#xA;      listUsers {&#xA;        ...UserFragment&#xA;      }&#xA;    }&#xA;    ${USER_FRAGMENT}&#xA;  `&#xA;})&#xA;</code></pre>&#xA;&#xA;<h2>What I Want</h2>&#xA;&#xA;<p>I want to create a function to return these respective methods: list, details, create, update, delete.  I wondered if it were possible to pass a <code>string</code> for the GraphQL type, and a type for the return type.  Something like this:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const createResource = &lt;T, K extends string&gt;(name: K, fragment: string) =&gt; ({&#xA;  list() {&#xA;    // I want to concatenate 'list' and `name`, but I don't think I can!&#xA;    return apolloClient.query&lt;Record&lt;`list${name}s`, T[]&gt;&gt;({&#xA;      query: gql`&#xA;        query {&#xA;          list${name}s {&#xA;            ...${name}Fragment&#xA;          }&#xA;        }&#xA;        ${fragment}&#xA;      `&#xA;    })&#xA;  },&#xA;  // more methods here for `create`, `update`, `delete`, using the same name and fragment...&#xA;})&#xA;</code></pre>&#xA;&#xA;<h2>The Ask</h2>&#xA;&#xA;<p>Is there a way to create a type like this?</p>&#xA;&#xA;<pre><code>Record&lt;`list${name}`, T[]&gt;&#xA;</code></pre>&#xA;&#xA;<p>If not (and I assume there is not), what's a better solution to this problem?  I really do not want to have to copy-paste all these methods for each model.  I also do not want to have to reduce them all to:</p>&#xA;&#xA;<pre><code>Record&lt;string, T[]&gt;&#xA;</code></pre>&#xA;&#xA;<p>And then have to guess at what the key is: </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>const userReq = await getUsers()&#xA;&#xA;userReq.data.listUsers // ??? is this right?&#xA;</code></pre>&#xA;",488784,,,,2019-11-19 20:35:54,Concatenate or Infer string in Typescript / GraphQL,<typescript><graphql><apollo><apollo-client>,0,4,0,2019-11-19 20:35:54
58949061,1,58949448,,2,6606,"<p>Let's say we have this GraphQL Schema:</p>&#xA;&#xA;<pre><code>gql`&#xA;  type Department {&#xA;    id: ID!&#xA;    name: String!&#xA;    programs(programId: ID): [Program]! # filter if an ID is provided&#xA;  }&#xA;&#xA;  type Program {&#xA;    id: ID!&#xA;    name: String!&#xA;    department: Department&#xA;  }&#xA;&#xA;  extend type Query {&#xA;    getDepartments: [Department]&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>The [probable] issue here is that you can get into this loop: </p>&#xA;&#xA;<pre><code>{&#xA;  getDepartments {&#xA;    name&#xA;    programs(1) {&#xA;      name&#xA;      department {&#xA;        name&#xA;        program(1) {&#xA;          ...&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm new to GraphQL so, first I would like to know if this is a problem ? I have that feeling but it might be OK.</p>&#xA;&#xA;<p>I tried to use this alternative:</p>&#xA;&#xA;<pre><code>gql`&#xA;  type Department {&#xA;    id: ID!&#xA;    name: String!&#xA;    programs(programId: ID): [Program] # filter if an ID is provided&#xA;  }&#xA;&#xA;  type Program {&#xA;    id: ID!&#xA;    name: String!&#xA;  }&#xA;&#xA;  extend type Query {&#xA;    getDepartments: [Department]&#xA;    getDepartmentForProgram(programId: ID!): Department&#xA;  }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>With this, children can not get parents directly, it is now a top query. My second concern is to know if this is a good alternative, especially if the first one is a problem.</p>&#xA;&#xA;<p>Thanks in advance.</p>&#xA;",2814580,,2814580,2019-11-20 07:59:03,2019-11-20 08:06:57,How to manage GraphQL query loop?,<javascript><graphql><apollo-server><gql>,1,0,0,2019-11-20 07:40:56
58961607,2,,55662633,0,,"<p>Have you solved your issue? It seems like the dataframe is not properly loaded as you pointed out but I believe it is caused by this line <code>.load(""./people.csv"")\</code> which is not pointing to your csv file.</p>&#xA;&#xA;<p>Just in case, can you wrap your code in a try-except block to print out either the dataframe or the error response?</p>&#xA;&#xA;<p>Cheers!</p>&#xA;",12405220,,,,2019-11-20 19:03:38,"",,0,0,0,2019-11-20 19:03:38
58970760,1,,,0,533,"<p>I played with the API and was able to find all repositories I ever contributed to, but I struggle to find my very first commit.</p>&#xA;&#xA;<p>What I tried:</p>&#xA;&#xA;<pre><code>{&#xA;  viewer {&#xA;    repositoriesContributedTo(first: 100, privacy: PUBLIC, contributionTypes: COMMIT, before: ""2013-07-11T00:00:00"") {&#xA;      totalCount&#xA;      nodes {&#xA;        nameWithOwner&#xA;      }&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>What I got:</p>&#xA;&#xA;<pre><code>{&#xA;  ""errors"": [&#xA;    {&#xA;      ""type"": ""INVALID_CURSOR_ARGUMENTS"",&#xA;      ""path"": [&#xA;        ""viewer"",&#xA;        ""repositoriesContributedTo"",&#xA;        ""nodes""&#xA;      ],&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 5,&#xA;          ""column"": 7&#xA;        }&#xA;      ],&#xA;      ""message"": ""`2013-07-11T00:00:00` does not appear to be a valid cursor.""&#xA;    },&#xA;    {&#xA;      ""type"": ""INVALID_CURSOR_ARGUMENTS"",&#xA;      ""path"": [&#xA;        ""viewer"",&#xA;        ""repositoriesContributedTo"",&#xA;        ""pageInfo""&#xA;      ],&#xA;      ""locations"": [&#xA;        {&#xA;          ""line"": 8,&#xA;          ""column"": 7&#xA;        }&#xA;      ],&#xA;      ""message"": ""`2013-07-11T00:00:00` does not appear to be a valid cursor.""&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Link to GitHub's GraphQL explorer:&#xA;<a href=""https://developer.github.com/v4/explorer/"" rel=""nofollow noreferrer"">https://developer.github.com/v4/explorer/</a></p>&#xA;",672833,,,,2019-11-21 17:23:45,How to query the GraphQL GitHub API fo find my first git commit ever?,<github><graphql><github-api><github-api-v4>,1,0,0,2019-11-21 08:52:34
58980504,2,,58970760,0,,"<p>To find the first commit , you can order by the <code>CREATED_AT</code> in the ascending order:</p>&#xA;&#xA;<pre><code>{&#xA;  viewer {&#xA;    repositoriesContributedTo(&#xA;      first: 100&#xA;      orderBy: {&#xA;        field : CREATED_AT&#xA;        direction : ASC&#xA;      }&#xA;      privacy: PUBLIC&#xA;      contributionTypes: COMMIT) {&#xA;      totalCount&#xA;      nodes {&#xA;        nameWithOwner&#xA;      }&#xA;      pageInfo {&#xA;        startCursor&#xA;        endCursor&#xA;        hasNextPage&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>P.S. The <code>before</code> field in the input argument is supposed to be assigned with the cursor value which is get from the <code>startCursor</code> or <code>endCursor</code> in the <code>pageInfo</code> result but not a date string.</p>&#xA;",339637,,,,2019-11-21 17:23:45,"",,0,2,0,2019-11-21 17:23:45
59029714,1,59031239,,2,1335,"<h3>Intent:</h3>&#xA;&#xA;<p>I need graphql to return all records</p>&#xA;&#xA;<h3>Issue:</h3>&#xA;&#xA;<p><code>amountLimit</code> is implemented differently on the strapi plugin</p>&#xA;&#xA;<h3>Question:</h3>&#xA;&#xA;<p>Can somebody tell me why graphql <code>amountLimit</code> was implemented like this?</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>  amountLimiting: (params = {}) =&gt; {&#xA;    const { amountLimit } = strapi.plugins.graphql.config;&#xA;    if(!amountLimit) return params;&#xA;    if (!params.limit || params.limit === -1 || params.limit &gt; amountLimit) {&#xA;      params.limit = amountLimit;&#xA;    } else if (params.limit &lt; 0) {&#xA;      params.limit = 0;&#xA;    } &#xA;    return params;&#xA;  },&#xA;</code></pre>&#xA;&#xA;<h3>Explanation:</h3>&#xA;&#xA;<p>strapi has a <code>_limit = 0</code> for all records, but on graphql plugin they're adding a default limit of 100.&#xA;If I am to give <code>limit: -1</code> or <code>limit: 0</code> to the graphql query, it will put the default <code>limit</code> of <code>100</code>.&#xA;If I am to give (<code>else if (params.limit &lt; 0)</code>)  any other <code>nr</code> lower than <code>0</code>, but it's not <code>-1</code>, the plugin queries strapi with <code>limit: 0</code> (all records)</p>&#xA;&#xA;<h3>Workaround</h3>&#xA;&#xA;<p>I need a way of querying graphql for all records, yet setting the limit to <code>-2</code> seems a bit random to me (as setting the limit to any <code>-(2^31) &lt; nr &lt; -1</code> number) </p>&#xA;&#xA;<h3>Solution !?</h3>&#xA;&#xA;<p>Any thoughts?</p>&#xA;",1432385,,,,2019-11-25 11:52:51,strapi graphql plugin: how to get all records,<graphql><graphql-js><strapi>,1,0,0,2019-11-25 10:27:57
59043021,1,,,3,2618,"<p>I have a GraphQL backend implemented using <a href=""https://www.npmjs.com/package/express"" rel=""nofollow noreferrer"">express</a>, <a href=""https://www.npmjs.com/package/express-graphql"" rel=""nofollow noreferrer"">express-graphql</a>, <a href=""https://www.npmjs.com/package/graphql"" rel=""nofollow noreferrer"">graphql</a> and <a href=""https://www.npmjs.com/package/graphql-upload"" rel=""nofollow noreferrer"">graphql-upload</a>. My GraphQL schema declaration is as follows:</p>&#xA;&#xA;<pre><code>type OProject {&#xA;    _id: ID!&#xA;    title: String!&#xA;    theme: String!&#xA;    budget: Float!&#xA;    documentation: String!&#xA;    date: Date&#xA;}&#xA;&#xA;input IProject {&#xA;    title: String!&#xA;    theme: String!&#xA;    budget: Float!&#xA;    file: Upload!&#xA;}&#xA;&#xA;type Mutations {&#xA;    create(data: IProject): OProject&#xA;}&#xA;&#xA;type Mutation {&#xA;    Project: Mutations&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want to make a <code>create</code> request to my GraphQL API  at <em>/graphql</em> using <a href=""https://github.com/axios/axios"" rel=""nofollow noreferrer"">axios</a>. How go I go about it?</p>&#xA;",6335815,,,,2022-06-28 17:41:28,How do I upload files to a graphql backend implemented using graphql-upload using axios?,<express><graphql><axios>,2,0,0,2019-11-26 02:51:51
59056481,2,,59040451,4,,<p>Problem was solved by changing:</p>&#xA;&#xA;<pre><code>const FILTER_QUERY = gql`&#xA;  query getFilteredPhotos($filters: PhotoFilter!) { // not PhotoFilterType&#xA;    filteredPhotos(filters: $filters) {&#xA;      id&#xA;      title&#xA;      width&#xA;      height&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;,3833784,,,,2019-11-26 17:32:14,"",,0,0,0,2019-11-26 17:32:14
59100888,2,,59100255,1,,"<p>You can use <code>/api/v2</code> with the <code>MeshRestClient</code> by setting the base path when creating the client:</p>&#xA;&#xA;<pre class=""lang-java prettyprint-override""><code>MeshRestClient.create(MeshRestClientConfig.newConfig()&#xA;    .setHost(""demo.getmesh.io"")&#xA;    .setPort(80)&#xA;    .setSsl(true)&#xA;    .setBasePath(""/api/v2"")&#xA;    .build());&#xA;</code></pre>&#xA;",6887730,,,,2019-11-29 07:59:59,"",,0,1,0,2019-11-29 07:59:59
59136323,1,,,3,1189,"<p>I have next query </p>&#xA;&#xA;<pre><code>export const listCategorys = `query ListCategorys(&#xA;  $filter: ModelCategoryFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listCategorys(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      words {&#xA;        items {&#xA;          id&#xA;          en&#xA;          ru&#xA;          statusLearn&#xA;        }&#xA;        nextToken&#xA;      }&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>I want use limit for nested element <strong>words</strong> and try get result with help next query</p>&#xA;&#xA;<pre><code>const listCats = await API.graphql(graphqlOperation(listCategorys, {limit:10, words:{limit:100}}));&#xA;</code></pre>&#xA;&#xA;<p>but this query not work. How right build query?</p>&#xA;",4585187,,,,2019-12-02 18:59:15,How set limit for nested field in AWS amplify DynamoDB schema?,<reactjs><amazon-web-services><react-native><graphql><aws-amplify>,1,1,0,2019-12-02 09:52:44
59143625,1,59145561,,0,1839,<p>I have a schema where the json can have a list of Int and Strings as values. I am wondering how to define a type of resolver for my scenario. </p>&#xA;&#xA;<pre><code>type Total {&#xA;  key: String&#xA;  values: [Object]&#xA;}&#xA;&#xA;type Query {&#xA;  filter (key : String!) : Total&#xA;}&#xA;</code></pre>&#xA;,2174885,,5371168,2019-12-02 21:48:59,2019-12-03 15:14:15,How to define a type with list of java.util.objects in graphql-java,<graphql-java>,1,0,0,2019-12-02 17:07:43
59150552,2,,54289250,0,,"<p>DynamoDB needs a global secondary index. The <code>@key</code> transform (or directive) can be added to your <code>schema.graphql</code> file as a sibling to the already existing <code>@model</code> transform.</p>&#xA;&#xA;<p><a href=""https://aws-amplify.github.io/docs/cli-toolchain/graphql#key"" rel=""nofollow noreferrer"">Key Directive Documentation</a></p>&#xA;&#xA;<p>Regarding the definition below:</p>&#xA;&#xA;<p><code>directive @key(fields: [String!]!, name: String, queryField: String) on OBJECT</code></p>&#xA;&#xA;<p>The important thing is that the first element of the ""fields"" argument is the partition (or hash) key. Every subsequent element is a sort key. Together, the sort keys will determine the order or the returned results.</p>&#xA;&#xA;<p>(Doing so with cause <code>amplify push</code> to create an entirely new GraphQL field on the <code>Query</code> type. The value of <code>queryField</code> will be the new field name. The <code>name</code> argument is the global secondary index name.)</p>&#xA;",1964376,,1964376,2019-12-03 05:21:29,2019-12-03 05:21:29,"",,0,0,0,2019-12-03 05:14:43
59154394,1,59158024,,2,672,"<p>I have this GraphQL query:</p>&#xA;&#xA;<pre><code>mutation CreateBudget(&#xA;  $revenue: Float!,&#xA;  $hours: Int!,&#xA;  $projectId: Int!,&#xA;) {&#xA;  createBudget(&#xA;    revenue: $revenue,&#xA;    hours: $hours,&#xA;    projectId: $projectId,&#xA;  ) {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For best practices, I want to use camelcase here, but snake_case in my database. The table looks like this:</p>&#xA;&#xA;<pre><code>CREATE TABLE IF NOT EXISTS `budgets` (&#xA;  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,&#xA;  `revenue` double(8,2) NOT NULL,&#xA;  `hours` int(11) NOT NULL,&#xA;  `project_id` int(10) unsigned NOT NULL,&#xA;  `created_at` timestamp NULL DEFAULT NULL,&#xA;  `updated_at` timestamp NULL DEFAULT NULL,&#xA;  PRIMARY KEY (`id`),&#xA;  KEY `budgets_project_id_foreign` (`project_id`),&#xA;  CONSTRAINT `budgets_project_id_foreign` FOREIGN KEY (`project_id`) REFERENCES `projects` (`id`)&#xA;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#xA;</code></pre>&#xA;&#xA;<p>I use <a href=""https://lighthouse-php.com/4.4/api-reference/directives.html#rename"" rel=""nofollow noreferrer"">Lighthouse's @rename directive</a> in order to convert between the casings. When running the query however, when submitting my query, some part of the code doesn't seem to recognise the project id, resulting in the following SQL error:</p>&#xA;&#xA;<pre><code>SQLSTATE[HY000]: General error: 1364 Field 'project_id' doesn't have a default value (SQL: insert into `budgets` (`revenue`, `hours`, `updated_at`, `created_at`) values (1200, 12, 2019-12-03 09:12:13, 2019-12-03 09:12:13))&#xA;</code></pre>&#xA;&#xA;<p>The variables sent are</p>&#xA;&#xA;<pre><code>variables: {&#xA;    revenue: 1200,&#xA;    hours: 12,&#xA;    projectId: 1&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is how my schema.graphql looks, using the @rename directive on the Budget type:</p>&#xA;&#xA;<pre><code>type Budget {&#xA;  id: ID!&#xA;  revenue: Float!&#xA;  hours: Int!&#xA;  projectId: Int! @rename(attribute: ""project_id"")&#xA;  project: Project! @belongsTo&#xA;  created_at: DateTime&#xA;  updated_at: DateTime&#xA;}&#xA;&#xA;type Mutation {&#xA;    createBudget(&#xA;        revenue: Float!&#xA;        hours: Int!&#xA;        projectId: Int!&#xA;    ): Budget @create(model: ""App\\Models\\Budget\\Budget"")&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I must have overlooked something simple, but I can't seem to spot it. Anybody want to give it a shot?</p>&#xA;",1973005,,1973005,2019-12-03 13:13:33,2019-12-05 11:31:19,Why does the Laravel Lighthouse @rename directive not work for me?,<graphql><laravel-lighthouse>,1,2,0,2019-12-03 09:57:45
59175134,2,,59174474,1,,"<p>I am using the singular and plurals nouns to name the query field that return a single object and a list of object respectively. I think this naming style is very natural to most of the developers.</p>&#xA;&#xA;<p>So to return a single user, it is :</p>&#xA;&#xA;<pre><code>type Query {&#xA;   user(id:Int!) : User&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It always return a single user. Just make the <code>id</code> input parameter as mandatory such that it cannot accept <code>NULL</code>.</p>&#xA;&#xA;<p>And to return a list of user , normally it is:</p>&#xA;&#xA;<pre><code>type Query {&#xA;   users : [User]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But in case it can have many users , most probably you need to consider something like pagination that allows developers to get the user page by page. For the offset -based pagination , I am doing something like below :</p>&#xA;&#xA;<pre><code>type Query {&#xA;   users(offset:Int limit:Int) : UserPage&#xA;}&#xA;&#xA;type UserPage {&#xA;   data     : [User]&#xA;   pageInfo : PageInfo&#xA;}&#xA;&#xA;type PageInfo {&#xA;&#xA;    # When paginating forwards, are there more items?&#xA;    hasNextPage    : Boolean!&#xA;&#xA;    # When paginating backwards, are there more items?&#xA;    hasPreviousPage: Boolean!&#xA;&#xA;    # Total number of records in all page&#xA;    total : Long&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Depending on the requirements , you can consider to add an <code>orderBy</code> or a <code>filter</code> input parameter to the <code>users</code> query field to provide more options to the developers to get the result set that they are interested.</p>&#xA;&#xA;<p>If you want to return the user list in the cursor-based pagination style, you can take a look on <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay Specification</a>.</p>&#xA;",339637,,,,2019-12-04 11:37:04,"",,0,0,0,2019-12-04 11:37:04
59240266,2,,58733198,0,,"<p>The best way to do this is to use fragments when building the query. Types will be generated for each fragment and they can then be used directly.</p>&#xA;&#xA;<p>source: <a href=""https://github.com/dotansimha/graphql-code-generator/issues/2977"" rel=""nofollow noreferrer"">from the main contributor of graphql-codegen</a></p>&#xA;",3086912,,,,2019-12-08 21:56:49,"",,0,1,0,2019-12-08 21:56:49
59248795,2,,59231615,1,,"<p>In Gatsby there are two types of queries. Page queries that can be defined in page components only and accept arguments passed as <code>context</code> in <code>createdPage()</code>  and static queries which don't access variables and can be used in everywhere but are limited to one per file.</p>&#xA;&#xA;<p>If you <code>TimeToRead</code> component file is not a page component then you have 2 options:</p>&#xA;&#xA;<ol>&#xA;<li>Use <a href=""https://www.gatsbyjs.org/docs/static-query/"" rel=""nofollow noreferrer"">a static query</a> - you just can't have variables in it.</li>&#xA;<li>Define a graphql fragment to use into parent page component.</li>&#xA;</ol>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>// in child component &#xA;export const remarkTimeToReadFragment = graphql`&#xA;fragment RemarkTimeToRead on Query {&#xA;  postTimeToRead: markdownRemark(id: { eq: $id }) {&#xA;    timeToRead&#xA;  }&#xA;}`&#xA;</code></pre>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>// in page component&#xA;export const pageQuery = graphql`&#xA;query PageQuery($id: String!) {&#xA;  ...RemarkTimeToRead&#xA;}&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>This particular example may produce a warning because $id param is not used directly in the page query and the linter just won't account for it being used by the fragment.</p>&#xA;",157601,,,,2019-12-09 12:18:09,"",,0,0,0,2019-12-09 12:18:09
59308582,2,,59307127,2,,"<p>I am using the suggestion from <a href=""https://blog.apollographql.com/designing-graphql-mutations-e09de826ed97"" rel=""nofollow noreferrer"">here</a> which each mutation only has one input object argument which consolidate all the necessary fields rather than flattening these fields into many different input arguments. Also I tend to have one input object for each mutation (Github mutation API also use such design style) </p>&#xA;&#xA;<p>So for the <code>updateChild</code> mutation , I would have the following input type :</p>&#xA;&#xA;<pre><code>mutations {&#xA;    updateChild(input: UpdateChildInput): Child&#xA;} &#xA;&#xA;input UpdateChildInput {&#xA;    childId : ID!&#xA;    parentId: ID&#xA;    name:String &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What fields to be included in the <code>UpdateChildInput</code> depends on your API requirements. Include the fields that your API need to support. So if your API allows user to change the parent of a child , you have to include it in the input.</p>&#xA;&#xA;<p>Please note that parentID and the name are optional , which means if user does not specify them , they will not be updated.</p>&#xA;",339637,,339637,2019-12-12 16:20:51,2019-12-12 16:20:51,"",,0,0,0,2019-12-12 16:05:36
59341771,2,,59341471,5,,"<p>Someone proposed a <a href=""https://github.com/graphql/graphql-spec/issues/271"" rel=""noreferrer"">similar thing</a> before but it is <a href=""https://github.com/graphql/graphql-spec/issues/271#issuecomment-426167175"" rel=""noreferrer"">rejected</a>. That means GraphQL does not support it natively and you have to roll it out by yourself.</p>&#xA;&#xA;<p>Several ways to do it based on what I see :</p>&#xA;&#xA;<p>(1) Define your own query language such as what <a href=""https://stackoverflow.com/help/searching"">stackoverflow</a> or <a href=""https://help.shopify.com/en/api/getting-started/search-syntax"" rel=""noreferrer"">Shopify</a> does :</p>&#xA;&#xA;<pre><code>type Query{&#xA;    customers (query:String) : [Customer]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The query becomes :</p>&#xA;&#xA;<pre><code>{&#xA;  customers (query : ""GENDER == 'MALE' or 'AGE' &gt;= 20""){&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(2) Define your own input object models that can cover all the required searching requirement.<a href=""https://github.com/prisma/prisma"" rel=""noreferrer"">Prisma</a> try to define one in <a href=""https://www.opencrud.org/#sec-Data-types"" rel=""noreferrer"">OpenCRUD</a> specification .You may take a look on it for the idea . For example , you can define an input model like :</p>&#xA;&#xA;<pre><code>input CustomerFilter {&#xA;     AND        :  [CustomerFilter]&#xA;     OR         :  [CustomerFilter]&#xA;&#xA;    # Define the fields that you support to search&#xA;     gender     : String&#xA;     gender_not : String&#xA;     ....&#xA;     ....&#xA;     ...&#xA;     ...&#xA;     age        : Int&#xA;     age_gte    : Int&#xA;}&#xA;&#xA;type Query{&#xA;    customers (filter:CustomerFilter) : [Customer]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the query becomes :</p>&#xA;&#xA;<pre><code>{&#xA;  customers (filter : {&#xA;   OR: [&#xA;     { gender : 'MALE' } ,&#xA;     { age_gte: 20 }&#xA;    ]&#xA;  }){&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://spectrum.chat/graphql/general/list-filtering-api-examples~e1fc941e-1fdc-4b41-bb9d-89c9f3a8a596?m=MTUzNTEwNDEyNzM1NA=="" rel=""noreferrer"">This</a> is another filter model for reference. The idea is to tailor-made it such that it is just enough to handle all your application requirements without introducing any unnecessary filtering complexity. </p>&#xA;&#xA;<p>Also , you most probably need to consider something like pagination if it potentially will return many data. It means you have to add an offset and limit to the input arguments for each query to somehow limit the number of record returned if you are doing offset-based pagination or take a look on <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""noreferrer"">Relay Specification</a> if you want to do it in the cursor-based pagination style.</p>&#xA;",339637,,339637,2019-12-15 07:08:50,2019-12-15 07:08:50,"",,0,0,0,2019-12-15 06:48:15
59348817,1,59349421,,1,2347,"<p>I understand how dataLoader works with simple keys:</p>&#xA;&#xA;<pre><code>import DataLoader from 'dataloader';&#xA;import myService from './services/service';&#xA;&#xA;export default () =&gt; new DataLoader((keys: any) =&gt; Promise.all(keys.map((key: string) =&gt; myService(key))));&#xA;</code></pre>&#xA;&#xA;<p>Is there a good pattern for using composite keys? </p>&#xA;&#xA;<p>What if I need to call the google maps api using something like lat and long? My key would need to be a unique combination of the lat and long and I would need to split the lat and long when calling my service</p>&#xA;&#xA;<pre><code>const key = `${latitude}|${longitude}`;&#xA;</code></pre>&#xA;&#xA;<p>Thinking I could use a map to lookup the value to pass to my service based on the key, is there a good pattern for use cases like this?</p>&#xA;",2524749,,,,2019-12-16 00:57:38,DataLoader using Composite keys,<javascript><typescript><graphql><dataloader>,1,0,0,2019-12-15 23:00:30
59377110,1,59378469,,0,1447,"<p>I'm getting a GraphQL object with a 'children' field.&#xA;That field is of the type 'X' and has two different implementations, 'Y' and 'Z'.</p>&#xA;&#xA;<p>So when I'm doing my query I can do this :</p>&#xA;&#xA;<pre><code>{&#xA;    fieldOne&#xA;    fieldTwo&#xA;    children {&#xA;        ... on Y {&#xA;            fieldOne&#xA;            fieldTwo&#xA;        }&#xA;        ... on Z {&#xA;            fieldOne&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Is there a way for me to only get the children with the Y implementation ?</strong></p>&#xA;&#xA;<p>Because if I'm doing this :</p>&#xA;&#xA;<pre><code>{&#xA;    fieldOne&#xA;    fieldTwo&#xA;    children {&#xA;        ... on Y {&#xA;            fieldOne&#xA;            fieldTwo&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I will get and object that looks like this :</p>&#xA;&#xA;<pre><code>{&#xA;    fieldOne&#xA;    fieldTwo&#xA;    children [&#xA;        {}, // Z implementation&#xA;        {}, // Z implementation&#xA;        {&#xA;            fieldOne,&#xA;            fieldTwo&#xA;        }, // Y implementation&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Thank you :)</p>&#xA;",5139737,,,,2019-12-17 16:35:10,GraphQL : Get children of specific implementation,<graphql>,1,0,0,2019-12-17 15:12:47
59378469,2,,59377110,1,,"<p>What you are seeing is expected behavior. From the <a href=""https://graphql.github.io/graphql-spec/June2018/#sec-Inline-Fragments"" rel=""nofollow noreferrer"">spec</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Fragments can be defined inline within a selection set. This is done to conditionally include fields based on their runtime type.</p>&#xA;</blockquote>&#xA;&#xA;<p>Type conditions like <code>... on Y</code> are just a way to filter what fields are resolved based on the runtime type. They are not a way to filter the actual list of results. In fact, <strong>there is no built-in filtering in GraphQL</strong>.</p>&#xA;&#xA;<p>In order to filter a list to include only certain types (or based on any other condition), the field in question will need to have some kind of filter argument and resolver logic that uses it to actually do the filtering.</p>&#xA;&#xA;<p>If you're using a third-party API and the schema doesn't support filtering, then as a client there's not much you can do outside of processing the response after the fact.</p>&#xA;",6024220,,,,2019-12-17 16:35:10,"",,0,0,0,2019-12-17 16:35:10
59429014,1,59431353,,0,408,"<p>My query is find a company in the database, returns some basic information, and the financials information over the years. The result looks like:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""company"": {&#xA;      ""id"": 1,&#xA;      ""name"": ""test company"",&#xA;      ""companyType"": ""NH"",&#xA;      ""financials"": [&#xA;        {&#xA;          ""year"": 2018,&#xA;          ""netRevenue"": 0,&#xA;          ""costOfSales"": 0,&#xA;          ""grossProfit"": 0,&#xA;          ""financialIncome"": 0,&#xA;          ""financialExpenses"": 0,&#xA;          ""resultOfOtherActivities"": 0&#xA;        },&#xA;        {&#xA;          ""year"": 2017,&#xA;          ""netRevenue"": 0,&#xA;          ""costOfSales"": 0,&#xA;          ""grossProfit"": 0,&#xA;          ""financialIncome"": 0,&#xA;          ""financialExpenses"": 0,&#xA;          ""resultOfOtherActivities"": 0&#xA;        },&#xA;        {&#xA;          ""year"": 2016,&#xA;          ""netRevenue"": 0,&#xA;          ""costOfSales"": 0,&#xA;          ""grossProfit"": 0,&#xA;          ""financialIncome"": 0,&#xA;          ""financialExpenses"": 0,&#xA;          ""resultOfOtherActivities"": 0&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Very simple to write the query:</p>&#xA;&#xA;<pre><code>{&#xA;  company {&#xA;    id&#xA;    name&#xA;    companyType&#xA;    financials {&#xA;      year&#xA;      netRevenue&#xA;      costOfSales&#xA;      grossProfit&#xA;      financialIncome&#xA;      financialExpenses&#xA;      resultOfOtherActivities&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But my case is not so simple. I need a query just to retrieve some of the fields for each year. The result looks like:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""company"": {&#xA;      ""id"": 1,&#xA;      ""name"": ""test company"",&#xA;      ""companyType"": ""NH"",&#xA;      ""financials"": [&#xA;        {&#xA;          ""year"": 2018,&#xA;          ""netRevenue"": 0&#xA;        },&#xA;        {&#xA;          ""year"": 2017,&#xA;          ""grossProfit"": 0,&#xA;          ""financialIncome"": 0,&#xA;          ""financialExpenses"": 0&#xA;        },&#xA;        {&#xA;          ""year"": 2016,&#xA;          ""resultOfOtherActivities"": 0&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there any way that a query can achieve such a result?</p>&#xA;",2563503,,,,2019-12-20 21:08:13,Graphql query: how to create a query that returns different fields between items,<c#><asp.net-core><graphql><hotchocolate>,1,3,0,2019-12-20 17:09:12
59431353,2,,59429014,2,,"<p>No, there's no way to write a query like that.</p>&#xA;&#xA;<p>All the items returned in a particular list will have the same selection set. The only exception is when you're requesting a field with a union or interface type -- then you can use inline fragments to specify a selection set for each possible type.</p>&#xA;&#xA;<p>As already suggested in the comments, the only possible workaround is to utilize aliases. Assuming your schema allows you to filter the <code>financials</code> field by year, you'd do something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  company {&#xA;    id&#xA;    name&#xA;    companyType&#xA;    financials2007: financials(year: 2007) {&#xA;      ...FinancialsFields&#xA;    }&#xA;    financials2008: financials(year: 2008) {&#xA;      ...FinancialsFields&#xA;    }&#xA;    financials2009: financials(year: 2009) {&#xA;      ...FinancialsFields&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment FinancialsFields on Financials {&#xA;  year&#xA;  netRevenue&#xA;  costOfSales&#xA;  grossProfit&#xA;  financialIncome&#xA;  financialExpenses&#xA;  resultOfOtherActivities&#xA;}&#xA;</code></pre>&#xA;",6024220,,,,2019-12-20 21:08:13,"",,0,1,0,2019-12-20 21:08:13
59436118,2,,54328681,4,,"<p>I am not sure that you still want the answer or not, but at least let me try to answer to your question. Correct if my understanding is wrong. I just willing to help</p>&#xA;<p>Actually <code>pk</code> supposed to be <code>DetailView</code> not <code>ListView</code> that being used with <code>filter</code>.</p>&#xA;<p><code>requirements.txt</code></p>&#xA;<pre><code>graphene-django==2.7.1&#xA;django==3.0.1&#xA;django-filter==2.2.0&#xA;python==3.8.1&#xA;</code></pre>&#xA;<p><code>models.py</code></p>&#xA;<pre><code>from django.contrib.auth import get_user_model&#xA;from django.db import models&#xA;&#xA;User = get_user_model()&#xA;&#xA;&#xA;class Objection(models.Model):&#xA;    detail = models.TextField(null=True, blank=True)&#xA;    hidden = models.BooleanField(default=False)&#xA;    report = models.BooleanField(default=False)&#xA;    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='objections',&#xA;                                   related_query_name='objection')&#xA;</code></pre>&#xA;<p><code>nodes.py</code></p>&#xA;<pre><code>import django_filters&#xA;import graphene&#xA;from graphene import relay&#xA;from graphene_django import DjangoObjectType&#xA;&#xA;from multy_herr.objections.models import Objection&#xA;&#xA;&#xA;class ObjectionFilter(django_filters.FilterSet):&#xA;    pk = django_filters.NumberFilter(field_name='pk')&#xA;&#xA;    class Meta:&#xA;        model = Objection&#xA;        fields = [&#xA;            'pk',&#xA;        ]&#xA;&#xA;&#xA;class ObjectionNode(DjangoObjectType):&#xA;    pk = graphene.Field(type=graphene.Int, source='id')&#xA;&#xA;    class Meta:&#xA;        model = Objection&#xA;        fields = [&#xA;            'id',&#xA;            'pk',&#xA;            'detail',&#xA;            'hidden',&#xA;            'report',&#xA;        ]&#xA;        filter_fields = {&#xA;            'pk': ['exact'],&#xA;            'detail': ['icontains', 'istartswith'],&#xA;            'created_by__name': ['icontains', ],&#xA;            'hidden': ['exact'],&#xA;            'report': ['exact'],&#xA;        }&#xA;        interfaces = (relay.Node,)&#xA;&#xA;&#xA;</code></pre>&#xA;<p><code>queries.py</code></p>&#xA;<pre><code>import graphene&#xA;from graphene import relay&#xA;from graphene_django.filter import DjangoFilterConnectionField&#xA;&#xA;from multy_herr.objections.grapheql.nodes import ObjectionNode, ObjectionFilter&#xA;from multy_herr.objections.models import Objection&#xA;&#xA;&#xA;class ObjectionQuery(graphene.ObjectType):&#xA;    objection = relay.Node.Field(ObjectionNode)&#xA;    all_objections = DjangoFilterConnectionField(ObjectionNode,&#xA;                                                 filterset_class=ObjectionFilter)&#xA;&#xA;    def resolve_all_objections(self, info, **kwargs):&#xA;        if info.context.user.is_authenticated is False:&#xA;            return Objection.objects.none()&#xA;        return Objection.objects.filter(created_by=info.context.user)&#xA;&#xA;</code></pre>&#xA;<p>I leave comment in <code>query</code> here for analogy. With my hackish solution <code>Insomnia</code> application will warns me with <code>Unknown argument pk ...</code>. But works</p>&#xA;<p><code>query</code></p>&#xA;<pre><code>query{&#xA;#   objection(id: &quot;T2JqZWN0aW9uTm9kZTo1&quot;){&#xA;#     id&#xA;#     report&#xA;#     hidden&#xA;#   }&#xA;  allObjections(pk: 5){&#xA;    edges{&#xA;      node{&#xA;        id&#xA;        pk&#xA;        hidden&#xA;        report&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><code>response</code></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;allObjections&quot;: {&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;T2JqZWN0aW9uTm9kZTo1&quot;,&#xA;            &quot;pk&quot;: 5,&#xA;            &quot;hidden&quot;: false,&#xA;            &quot;report&quot;: false&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1019455,,13302,2020-08-14 16:16:08,2020-08-14 16:16:08,"",,0,0,0,2019-12-21 12:18:52
59447450,1,,,0,710,"<p>Im trying to compile my Relay app but Im getting the error when trying to compile:</p>&#xA;&#xA;<pre><code>yarn run relay-compiler --src ./src --schema ./src/schema.graphql --extensions=js --extensions=jsx&#xA;</code></pre>&#xA;&#xA;<p>Throws:</p>&#xA;&#xA;<pre><code>Writing js&#xA;ERROR:&#xA;Fragment ""ListPage_viewer"" cannot condition on unknown type ""Viewer"".&#xA;error Command failed with exit code 100.&#xA;</code></pre>&#xA;&#xA;<p>The component that Im trying to compile is the following:</p>&#xA;&#xA;<pre><code>import React from 'react'&#xA;import {&#xA;    createFragmentContainer,&#xA;    graphql&#xA;} from 'react-relay'&#xA;&#xA;const ListPage = ({&#xA;    viewer&#xA;}) =&gt; (&#xA;    &lt;div&gt;&#xA;        {JSON.stringify({viewer})}&#xA;    &lt;/div&gt;&#xA;)&#xA;&#xA;export default createFragmentContainer(ListPage, graphql`&#xA;    fragment ListPage_viewer on Viewer {&#xA;        posts(last:100) @connection(key: ""ListPage_posts"", filters: []){&#xA;            edges {&#xA;                node {&#xA;                    ...Post_post&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`)&#xA;</code></pre>&#xA;&#xA;<p>Info&#xA;Some dependencies Im using are:</p>&#xA;&#xA;<pre><code>""babel-plugin-relay"": ""^8.0.0"",&#xA;""relay-compiler"": ""^8.0.0""&#xA;""react-relay"": ""^8.0.0"",&#xA;</code></pre>&#xA;",6546440,,,,2019-12-22 19:32:48,"Relay: Fragment cannot condition on unknown type ""viewer""",<reactjs><graphql><relayjs>,0,2,0,2019-12-22 19:32:48
59479703,1,59479818,,2,2659,"<p>I have implement an Ant Design Table in a Gatsby site. I am pulling in the data from graphql. So far everything has worked just fine. The data is displaying properly, pagination works, etc.</p>&#xA;&#xA;<p>Now I want to add the ability to sort the columns. To do so, I set up the table and columns as follows:</p>&#xA;&#xA;<pre><code>&lt;Table&#xA;  dataSource={data.allNewsFeed.edges}&#xA;  onChange={onChange}&#xA;  rowSelection={rowSelection}&#xA;  rowKey=""id""&#xA;&gt;&#xA;  &lt;Column&#xA;    title=""Title""&#xA;    dataIndex=""node.title""&#xA;    key=""title""&#xA;    sorter={(a, b) =&gt; a.node.title - b.node.title}&#xA;    sortDirections={[""descend"", ""ascend""]}&#xA;  /&gt;&#xA;&lt;/Table&gt;&#xA;</code></pre>&#xA;&#xA;<p>Now, the icon for sorting the column does shows up, but nothing happens when I click on it.  </p>&#xA;&#xA;<p>Same thing happens if I remove <code>.node</code> from the sorter function:  <code>sorter={(a, b) =&gt; a.title - b.title}</code>.</p>&#xA;&#xA;<p>So, I am stuck -- any idea why this is not working and how to fix it?</p>&#xA;&#xA;<p>Thanks.</p>&#xA;",7477670,,7599510,2019-12-25 15:37:47,2019-12-25 15:41:29,Can't sort Column in Ant Design Table in Gatsby site,<javascript><reactjs><graphql><gatsby><antd>,2,1,0,2019-12-25 15:25:16
59479762,2,,59479703,3,,"<p>I guess you can use instead of <code>a.node.title - b.node.title</code> the <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare"" rel=""nofollow noreferrer""><code>String.prototype.localeCompare</code></a> for proper sorting. As the documentation states:</p>&#xA;&#xA;<blockquote>&#xA;  <p>The localeCompare() method returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.</p>&#xA;</blockquote>&#xA;&#xA;<p>Somehow this:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const values = ['random', 'something', 'else', 'text'];&#xD;&#xA;const result = values.sort((a,b) =&gt; {&#xD;&#xA;  return a.localeCompare(b);&#xD;&#xA;});&#xD;&#xA;&#xD;&#xA;console.log(result);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>So I guess in the mentioned case it would be:</p>&#xA;&#xA;<pre><code>&lt;Column title=""Title""&#xA;        dataIndex=""node.title""&#xA;        key=""title""&#xA;        sorter={(a, b) =&gt; a.node.title.localeCompare(b.node.title)}&#xA;        sortDirections={[""descend"", ""ascend""]} /&gt;&#xA;</code></pre>&#xA;&#xA;<p>I hope this helps!</p>&#xA;",7599510,,7599510,2019-12-25 15:38:23,2019-12-25 15:38:23,"",,0,2,0,2019-12-25 15:32:53
59510481,1,59513014,,1,184,"<p>I am working on a webapp with a nuxt/vuetify/apollo frontend. The backend is a <a href=""https://strapi.io"" rel=""nofollow noreferrer"">strapi</a> (v3.0.0-beta.18) server with a <a href=""https://strapi.io/documentation/3.0.0-beta.x/plugins/graphql.html"" rel=""nofollow noreferrer"">graphQL endpoint</a> and a mongoDB database (v4.2.2)</p>&#xA;&#xA;<p>It could be a newbie question since it's my first graphql project. I have a query for a collection called tags. It looks as follows:</p>&#xA;&#xA;<pre><code>query Tags($search: String, $selected: [ID], $limit: Int) {&#xA;  tags: tags(&#xA;    limit: $limit&#xA;    sort: ""score:desc""&#xA;    where: { name_contains: $search }&#xA;  ) {&#xA;    id&#xA;    name&#xA;    description&#xA;    type&#xA;  }&#xA;  selected: tags(where: { id_in: $selected }) {&#xA;    id&#xA;    name&#xA;    description&#xA;    type&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>That query is returning every result that should be filtered by the <code>where</code> object, while the <code>sort</code> and <code>limit</code> filters work. The behavior is the same in my frontend app and on the graphQL playground. Am I missing something?</p>&#xA;&#xA;<p>Note that strapi <a href=""https://strapi.io/documentation/3.0.0-beta.x/plugins/graphql.html#shadow-crud"" rel=""nofollow noreferrer"">Shadow CRUD</a> feature is enabled.</p>&#xA;",3793161,,,,2019-12-28 17:01:59,Why is my graphQL query returning results without `where` filters?,<graphql><nuxt.js><apollo><strapi>,1,3,0,2019-12-28 11:32:07
59535607,1,,,1,241,"<p>So I am trying to code a function which will allow sorting in multiple fields in either ascending or descending order. My code is below</p>&#xA;&#xA;<pre><code> //SortBy&#xA;    List&lt;SortField&gt; order = new ArrayList&lt;&gt;();&#xA;    for (String field:sortBy) {&#xA;        if ((ascending)) {&#xA;            order.add(DSL.field(field).asc());&#xA;        } else {&#xA;            order.add(DSL.field(field).desc());&#xA;        }&#xA;    }&#xA;&#xA;    return jooq.selectFrom(CAR)&#xA;        .orderBy(order.toArray(new SortField[order.size()]))&#xA;        .fetchInto(Car.class);&#xA;</code></pre>&#xA;&#xA;<p>The problem is if I give two fields as an input (e.g. [color, year]), it sorts only on second parameter but not on the first one (in both ascending and descending). When I didnt have SortField at all and just used Field, it was working perfectly, albeit just for ascending order</p>&#xA;&#xA;<pre><code> //SortBy&#xA;    List&lt;Field&gt; order = new ArrayList&lt;&gt;();&#xA;    for (String field:sortBy) {&#xA;        if ((ascending)) {&#xA;            order.add(DSL.field(field));&#xA;        } else {&#xA;            order.add(DSL.field(field));&#xA;        }&#xA;    }&#xA;&#xA;    return jooq.selectFrom(CAR)&#xA;        .orderBy(order.toArray(new Field[order.size()]))&#xA;        .fetchInto(Car.class);&#xA;</code></pre>&#xA;&#xA;<p>I have been stuck for a while and cant figure out why this is. Does anyone has any idea?</p>&#xA;&#xA;<p>Thanks </p>&#xA;",3390154,,,,2019-12-30 18:56:00,SortField in Jooq does not allow sorting on fields,<graphql><jooq><graphql-java>,0,1,0,2019-12-30 18:56:00
59581620,1,,,3,256,"<p>I'm working on a GraphQL API and am using Relay style cursor navigation.</p>&#xA;&#xA;<p>I have come across an issue that I can't seem to find anyone else with, which is strange as it seems to be a common UI pattern.</p>&#xA;&#xA;<p>That is if you fetch your item from the list you can retrieve its cursor and navigate forwards and backwards easily.</p>&#xA;&#xA;<p>For example, imagine you selected an item from a paginated list and are taken to that item's specific page, here I can easily determine which item comes before and after this and can show buttons to allow you to navigate forwards and backwards because I have the item's cursor.</p>&#xA;&#xA;<p>If you however where then to refresh that item's page, I would have to query the item by its unique ID (assuming that is all the URL contains) and I would not know its cursor within that connection, I would have to worst case enumerate the entire connection to find it to render a simple backwards or forwards button.</p>&#xA;&#xA;<p>Is there a suggested way in relay cursor navigation to allow you to find an item's position within that connection without having to enumerate the entire connection?</p>&#xA;&#xA;<p>Even if not suggested has anyone got a good solution to this problem?</p>&#xA;&#xA;<p>So far I have two possible solutions:</p>&#xA;&#xA;<ul>&#xA;<li><p>Generating the cursor from the item's ID so that someone is able to generate a cursor for it having only the item, I'm not sure what downsides that may bring though.</p></li>&#xA;<li><p>Adding separate previous and next fields to the node and allowing the backend to compute it separately when requested.</p></li>&#xA;</ul>&#xA;",718728,,718728,2020-01-03 16:08:43,2020-01-03 16:08:43,How to find an item's cursor in a GraphQL Relay connection?,<graphql><relay>,0,1,0,2020-01-03 16:00:45
59591698,2,,59590186,8,,"<p>Yes, you can nest fragments. Assuming <code>navigationLinkLeft</code> and <code>navigationLinkRight</code> have the same type, you can do something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  pageHomeCollection(limit: 1) {&#xA;    items {&#xA;    navigationLinkLeft {&#xA;      ...YourFragment&#xA;    }&#xA;    navigationLinkRight {&#xA;      ...YourFragment&#xA;    }&#xA;    title&#xA;  }&#xA;}&#xA;&#xA;fragment YourFragment on SomeInterfaceOrUnionType {&#xA;  ... on PageBasic {&#xA;    slug&#xA;    title&#xA;  }&#xA;  ... on PageShop {&#xA;    title&#xA;  }&#xA;  ... on PostCollection {&#xA;    slug&#xA;    title&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If <code>navigationLinkLeft</code> and <code>navigationLinkRight</code> do <strong>not</strong> have the same type, this won't work. At best, you can only avoid duplicating the fields themselves:</p>&#xA;&#xA;<pre><code>{&#xA;  pageHomeCollection(limit: 1) {&#xA;    items {&#xA;    navigationLinkLeft {&#xA;      ...NavigationLinkLeftFragment&#xA;    }&#xA;    navigationLinkRight {&#xA;      ...NavigationLinkRightFragment&#xA;    }&#xA;    title&#xA;  }&#xA;}&#xA;&#xA;fragment NavigationLinkLeftFragment on PageHomeNavigationLinkLeft {&#xA;  ...PageBasicFragment&#xA;  ...PageShopFragment&#xA;  ...PostCollectionFragment&#xA;}&#xA;&#xA;fragment NavigationLinkRightFragment on NavigationLinkRight {&#xA;  ...PageBasicFragment&#xA;  ...PageShopFragment&#xA;  ...PostCollectionFragment&#xA;}&#xA;&#xA;fragment PageBasicFragment on PageBasic {&#xA;  slug&#xA;  title&#xA;}&#xA;&#xA;fragment PageShopFragment on PageShop {&#xA;  title&#xA;}&#xA;&#xA;fragment PostCollectionFragment on PostCollection {&#xA;  slug&#xA;  title&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The above avoids using inline fragments, but you can always use an inline fragment if you don't need to reference a fragment by name elsewhere. So you can also just do:</p>&#xA;&#xA;<pre><code>navigationLinkLeft {&#xA;  ...PageBasicFragment&#xA;  ...PageShopFragment&#xA;  ...PostCollectionFragment&#xA;}&#xA;navigationLinkRight {&#xA;  ...PageBasicFragment&#xA;  ...PageShopFragment&#xA;  ...PostCollectionFragment&#xA;}&#xA;</code></pre>&#xA;",6024220,,6024220,2020-01-04 19:30:55,2020-01-04 19:30:55,"",,0,4,0,2020-01-04 14:38:10
59595642,2,,59595319,2,,"<p>I found it, i was overriding graphql reserved variable called <code>id</code> that is used for caching and pagination.&#xA;In models.py, i renamed column <code>id</code> to <code>uuid</code> and in table Event</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>user_id = db.Column(db.Integer, db.ForeignKey(""user.id""), nullable=False)&#xA;</code></pre>&#xA;&#xA;<p>to</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>user_uuid = db.Column(db.Integer, db.ForeignKey(""user.uuid""), nullable=False)&#xA;</code></pre>&#xA;&#xA;<p>and got this:</p>&#xA;&#xA;<pre><code>mutation{&#xA;  createUser(email:""saki1@saki.com"", fname:""saki"",surname:""sakal"",username:""saki709"", password:""sakisaki""){&#xA;    user{&#xA;      uuid&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Response:</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""createUser"": {&#xA;      ""user"": {&#xA;        ""uuid"": ""1"",&#xA;        ""id"": ""VXNlcjox""&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>TL;DR - renamed id to uuid because graphql has it's own variable id</p>&#xA;",10513667,,,,2020-01-04 23:12:15,"",,0,0,0,2020-01-04 23:12:15
59607387,1,,,0,1115,"<p>Suppose if we want to query multiple fields on GraphQL, how to do that ?</p>&#xA;&#xA;<pre><code>{&#xA;  book(id:""123"",name:""book1"") {&#xA;    id,&#xA;    name,&#xA;    authors{&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Also, how to filter out subfield, like author based on name??</p>&#xA;&#xA;<pre><code>{&#xA;  book(id:""123"",name:""book1"") {&#xA;    id,&#xA;    name,&#xA;    authors(name:""author1""){&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have found this article, but just wanted to know is there any better way .&#xA;<a href=""https://www.yld.io/blog/query-by-2-or-more-fields-on-graphql/"" rel=""nofollow noreferrer"">https://www.yld.io/blog/query-by-2-or-more-fields-on-graphql/</a></p>&#xA;",11323618,,757508,2020-01-07 06:35:37,2020-01-07 09:12:03,Query by 2 or more fields on GraphQL,<graphql><express-graphql>,1,0,0,2020-01-06 06:04:29
59610967,2,,56729851,0,,"<p>You can define a <code>fragment</code> with all the fields of the entity and then reuse it.&#xA;Like this</p>&#xA;&#xA;<pre class=""lang-json prettyprint-override""><code>fragment AllAlertFields on Alert {&#xA;  message&#xA;  type&#xA;  duration&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then in a query</p>&#xA;&#xA;<pre class=""lang-json prettyprint-override""><code>query {&#xA;  allAlerts {&#xA;    ...AllAlertFields&#xA;  }  &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>More details: <a href=""https://www.apollographql.com/docs/react/data/fragments/"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/data/fragments/</a></p>&#xA;",969507,,,,2020-01-06 11:05:40,"",,0,0,0,2020-01-06 11:05:40
59617344,1,,,0,408,"<p>The structure of my query looks like </p>&#xA;&#xA;<pre><code>{&#xA;  parent(filter...){&#xA;    edges{&#xA;      node{&#xA;        field1&#xA;        child(filter...){&#xA;          edges{&#xA;            node{&#xA;              field2&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In the frontend, I will join parent with child and display in a table. E.g., if parent has three child, it will display three rows (""field1 child1_field2"", ""field1 child2_field2"", ""field1 child3_field2""). But if there is no child for that parent, I do not want to display that row at all. I know I can filter them out in the frontend. But with relay pagination, if I load 50 more parents, after filtering on child, there might be less than 50 rows left. As a result, it will render different number of rows on each ""load more"". Is there a way to return data that satisfies both parent's filter and child's filter. If not, what is the best way to address this issue?</p>&#xA;",7749267,,7749267,2020-01-06 20:37:19,2020-01-06 20:46:13,"In graphql, is there a way to return data that satisfies all filters on parent and children?",<graphql><relayjs>,1,0,0,2020-01-06 18:44:31
59621188,1,59621408,,1,1970,"<p>need some help on nested mutations. </p>&#xA;&#xA;<p>Abstracted scenario is this:</p>&#xA;&#xA;<p>I want to combine 2 mutation calls on apollo-server to first create a a <code>Customer</code> then create an <code>Address</code> for that customer. The <code>Address</code> mutation needs a <code>customerID</code> to be able to do this but also has information from the original overall mutation that it needs access to. </p>&#xA;&#xA;<p>Here's the generic code:</p>&#xA;&#xA;<pre><code>makeExecutableSchema({&#xA;  typeDefs: gql`&#xA;    type Mutation {&#xA;      createCustomerWithAddress(customer: CustomerRequest!, address: AddressRequest!): Response&#xA;    }&#xA;    input CustomerRequest {&#xA;       name: String!&#xA;    }&#xA;&#xA;    input AddressRequest {&#xA;       address: String!&#xA;       city: String!&#xA;       state: String!&#xA;       country: String!&#xA;    }&#xA;&#xA;    type Response {&#xA;       customerID: Int!&#xA;       addressID: Int!&#xA;    }&#xA;  `,&#xA;  resolvers: {&#xA;    Mutation: {&#xA;      createCustomerWithAddress: async (_, {customer}, context, info) =&gt; {&#xA;        return await api.someAsyncCall(customer);&#xA;      }&#xA;    },&#xA;    Response: {&#xA;      addressID: async(customerID) =&gt; {&#xA;        // how do we get AddressRequest here?&#xA;        return await api.someAsyncCall(customerID, address);&#xA;      }&#xA;    }&#xA;  }&#xA;})&#xA;&#xA;&#xA;&#xA;</code></pre>&#xA;&#xA;<p>There's a lot of complexity I'm not showing from the original code, but what I wanted to get at is just at the root of how to access request params via sub mutations, if even possible. I don't really want to pass down <code>address</code> from the top mutation to the sub mutation. </p>&#xA;",7570966,,7570966,2020-01-07 07:09:56,2020-01-07 18:21:59,Apollo GraphQL Nested Mutation,<javascript><graphql><apollo>,1,1,0,2020-01-07 01:46:13
59632847,2,,59603233,1,,"<p>When your Model has ""visualisation mode"" of table, a property called <code>position</code> get's added.</p>&#xA;&#xA;<p><img src=""https://i.stack.imgur.com/gvuHS.png"" alt=""Records collection visualization mode &quot;Tabular view&quot;""></p>&#xA;&#xA;<p>We can use this <code>position</code> to sort the records like this:</p>&#xA;&#xA;<pre><code>allDatoCmsProject(sort: { fields: [position], order: ASC }){&#xA;...&#xA;}&#xA;</code></pre>&#xA;",2949184,,-1,2020-06-18 02:44:02,2020-06-18 02:44:02,"",,0,1,0,2020-01-07 16:57:41
59657091,1,,,5,3902,"<p>Is it possible in GraphQL or Hasura to group the results by month or year? I'm currently getting the result list back as a flat array, sorted by the <code>date</code> attribute of the model. However, I'd like to get back 12 subarrays corresponding to each month of the year.</p>&#xA;",5429504,,,,2020-01-09 10:41:27,Hasura GraphQL how to group query by month and year?,<graphql><hasura>,1,1,0,2020-01-09 04:04:56
59658290,2,,59649380,0,,"<p>Okay, I was doing it wrong.&#xA;I was giving fragment wrong id, I had to pass the object keys in cached data.&#xA;That is. <code>id: Group:${gid.toString()}</code></p>&#xA;&#xA;<p><a href=""https://www.apollographql.com/docs/react/caching/cache-configuration/#generating-unique-identifiers"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/caching/cache-configuration/#generating-unique-identifiers</a></p>&#xA;&#xA;<p>Hope this helps anyone in same situation.</p>&#xA;",10498621,,,,2020-01-09 06:24:52,"",,0,0,0,2020-01-09 06:24:52
59697424,1,,,0,929,"<p>After mutation when  I am updating the cache, changes are reflected in UI but getting the below error</p>&#xA;&#xA;<p>Invariant Violation: Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ItemCodeConnection for the object of id $ROOT_QUERY.itemCodes({""filter"":{""number"":10000001}}). The selectionSet that was trying to be written is:&#xA;{""kind"":""Field"",""name"":{""kind"":""Name"",""value"":""itemCodes""},""arguments"":[{""kind"":""Argument"",""name"":{""kind"":""Name"",""value"":""filter""},""value"":{""kind"":""Variable"",""name"":{""kind"":""Name"",""value"":""filter""}}}],""directives"":[],""selectionSet"":{""kind"":""SelectionSet"",""selections"":[{""kind"":""Field"",""name"":{""kind"":""Name"",""value"":""itemCodes""},""arguments"":[],""directives"":[],""selectionSet"":{""kind"":""SelectionSet"",""selections"":[{""kind"":""FragmentSpread"",""name"":{""kind"":""Name"",""value"":""itemCodeTile""},""directives"":[]},{""kind"":""Field"",""name"":{""kind"":""Name"",""value"":""__typename""}}]}},{""kind"":""Field"",""name"":{""kind"":""Name"",""value"":""__typename""}}]}}</p>&#xA;&#xA;<h2>GraphQL query:</h2>&#xA;&#xA;<pre><code>const CREATE_ITEM_CODE_SPEC = gql`&#xA;mutation createItemCodeSpec($input: createItemCodeSpecInput) {&#xA;    createItemCodeSpecification(input: $input){&#xA;        __typename&#xA;        id&#xA;        itemCode {&#xA;            number&#xA;        }&#xA;        product&#xA;        spec_class&#xA;        grade&#xA;    }&#xA;}&#xA;`&#xA;&#xA;const GET_ITEM_CODE  = gql`&#xA;    query itemCode($filter: filterInput){&#xA;        itemCodes(filter: $filter){&#xA;            itemCodes {&#xA;                number&#xA;                type&#xA;                description&#xA;                group &#xA;                item_code_spec {&#xA;                    id&#xA;                    itemCode {&#xA;                        number&#xA;                    }&#xA;                product&#xA;                spec_class&#xA;                grade&#xA;           }&#xA;             created_on&#xA;             created_by&#xA;             changed_on&#xA;             changed_by      &#xA;            }&#xA;        }&#xA;    }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Below is the mutation:</p>&#xA;&#xA;<pre><code>const [mutation, { data, loading, error}] = useMutation(&#xA;        CREATE_ITEM_CODE_SPEC,&#xA;        {&#xA;            update(cache, { data: { createItemCodeSpecification } }){&#xA;                const currentData  = cache.readQuery({&#xA;                    query: GET_ITEM_CODE,&#xA;                    variables: { filter : {number:itemCode} } &#xA;                })&#xA;                cache.writeQuery({&#xA;                    query: GET_ITEM_CODE,&#xA;                    variables: { filter : {number:itemCode} },&#xA;                    data: {&#xA;                        ...currentData,&#xA;                        itemCodes: {&#xA;                            itemCodes: currentData.itemCodes.itemCodes.map((itemCode, index) =&gt; {&#xA;                                return {&#xA;                                    ...itemCode,&#xA;                                    item_code_spec: index === 0? [&#xA;                                        ...itemCode.item_code_spec,&#xA;                                        createItemCodeSpecification&#xA;                                     ] : itemCode.item_code_spec&#xA;                                }&#xA;                            })&#xA;                        }&#xA;                    }&#xA;                }) &#xA;            }&#xA;        }&#xA;        );&#xA;</code></pre>&#xA;",11243364,,,,2020-09-04 21:15:30,Store error: the application attempted to write an object with no provided typename but the store already contains an object,<graphql><apollo><apollo-client>,2,0,0,2020-01-11 18:32:08
59717057,2,,59714204,1,,<p>You should use <code>float8</code> as your variable type instead of <code>Float</code> as the error indicates.</p>&#xA;,6024220,,,,2020-01-13 12:53:58,"",,0,0,0,2020-01-13 12:53:58
59717112,2,,59714052,0,,"<p>Fragments are just a way to specify the selection set (i.e. fields) by type at runtime. They are not a way to filter results. GraphQL does not provide any built-in way to filter, sort or otherwise mutate the results -- it's up to each individual service to implement those features. If the schema doesn't expose any argument on the <code>events</code>, <code>bag</code>, or <code>contentItems</code> fields to let you do the sort of filtering you're trying to do, then it's not possible to do so through a query.</p>&#xA;",6024220,,,,2020-01-13 12:57:11,"",,0,0,0,2020-01-13 12:57:11
59727581,1,,,-1,68,<p>I have list of options that needs to be stored as an ENUM. The issues is that the options are all alpha numeric.</p>&#xA;&#xA;<p>Example List</p>&#xA;&#xA;<pre><code> 1.134/2394 x 3-xyz&#xA; 2.123/234 y 3-ery &#xA; 3.345/99 t 4-red&#xA; 4.4.1hv 3 secondary&#xA; 5.2.51hv 3 secondary&#xA; 6.1.61hv 3 secondary&#xA;</code></pre>&#xA;&#xA;<p>How do we store this as options in Typescript. Any thoughts will be highly appreciated.</p>&#xA;,10427479,,,,2020-01-14 05:54:09,Typescript ENUM's,<javascript><typescript><enums><graphql>,2,2,0,2020-01-14 04:37:56
59728030,2,,59727581,0,,"<p>You can do some thing like this right?</p>&#xA;&#xA;<pre><code>enum x {&#xA;    '1.134/2394 x 3-xyz' = 2,&#xA;    '2.123/234 y 3-ery',&#xA;}&#xA;&#xA;console.log(x['2.123/234 y 3-ery'])&#xA;// this will print '3'&#xA;</code></pre>&#xA;",7899477,,,,2020-01-14 05:37:16,"",,0,0,0,2020-01-14 05:37:16
59730879,1,59736446,,2,2817,"<p>I'm using Gatsby as my static generator and Contentful as my datasource.</p>&#xA;&#xA;<p>We've got multiple contentTypes in Contentful (blog, event, whitepaper) and I want to return these in within one query and sorted by createdAt date. So far I have the following which returns each contentType in order of each contentType but not in order of date overall.</p>&#xA;&#xA;<p>Is there a way I can do a sort across the entire query?</p>&#xA;&#xA;<pre><code>{&#xA;    whitepapers: allContentfulWhitepaper(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;    blogs: allContentfulBlogPost(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;    events: allContentfulEventPage(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",911553,,,,2020-12-30 18:09:09,Sorting GraphQL query on multiple queries in Gatsby,<graphql><gatsby><contentful>,2,0,0,2020-01-14 09:30:16
59736446,2,,59730879,3,,"<p>I don't think GraphQL query is able to do the sorting across multiple fields, but you can sort in component</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import React from 'react';&#xA;import { graphql } from 'gatsby';&#xA;&#xA;const IndexPage = ({ data }) =&gt; {&#xA;  const { whitepapers, blogs, events } = data;&#xA;  const allDataInDesc = [&#xA;    ...whitepagers.edges.map(e =&gt; e.node),&#xA;    ...blogs.edges.map(e =&gt; e.node),&#xA;    ...events.edges.map(e =&gt; e.node),&#xA;  ].sort((a, b) =&gt; { return new Date(a.createdAt) &gt; new Date(b.createdAt) ? -1 : 1; });&#xA;&#xA;  return &lt;&gt;...&lt;/&gt;&#xA;}&#xA;&#xA;export const query = graphql`&#xA;  {&#xA;    whitepapers: allContentfulWhitepaper(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;          createdAt&#xA;        }&#xA;      }&#xA;    }&#xA;    blogs: allContentfulBlogPost(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;          createdAt&#xA;        }&#xA;      }&#xA;    }&#xA;    events: allContentfulEventPage(sort: { order: DESC, fields: createdAt }) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          slug&#xA;          title&#xA;          createdAt&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default IndexPage;&#xA;</code></pre>&#xA;",5454390,,,,2020-01-14 15:03:42,"",,0,0,0,2020-01-14 15:03:42
59748926,1,,,2,761,"<p>I have used AWS Appsync and I have been able to get auto-generated code for angular (an angular service was created for me with CRUD queries generated plus typescript types) based on a graphql schema file.</p>&#xA;&#xA;<p><a href=""https://aws-amplify.github.io/docs/js/api#angular"" rel=""nofollow noreferrer"">https://aws-amplify.github.io/docs/js/api#angular</a></p>&#xA;&#xA;<p>I have also found <a href=""https://graphql-code-generator.com/docs/plugins/typescript-apollo-angular"" rel=""nofollow noreferrer"">here</a> (thanks @Daniel Rearden) how you can generate angular services from existing graphql queries. This is nice but it is really the next part that is time consuming, writing graphql queries everytime you change you schema. As AWS has managed to do, it is possible to generate crud queries based on the schema. Sure they will generally return all fields and require all fields as input parameter but that is fine.</p>&#xA;&#xA;<p>My question is: is there some tool available to generate angular services with crud graphql queries and typescript types like the one AWS uses? Has anybody used this outside of AWS Appsync?</p>&#xA;&#xA;<p>Example on how it works with AWS Appsync:</p>&#xA;&#xA;<p>based on a schema like this:</p>&#xA;&#xA;<pre><code>type Todo @model { id: ID! name: String! description: String }&#xA;</code></pre>&#xA;&#xA;<p>It will generate an angular service like this:</p>&#xA;&#xA;<pre><code>import { Injectable } from ""@angular/core"";&#xA;import API, { graphqlOperation } from ""@aws-amplify/api"";&#xA;import { GraphQLResult } from ""@aws-amplify/api/lib/types"";&#xA;import * as Observable from ""zen-observable"";&#xA;&#xA;export type CreateTodoInput = {&#xA;  id?: string | null;&#xA;  name: string;&#xA;  description?: string | null;&#xA;};&#xA;&#xA;export type UpdateTodoInput = {&#xA;  id: string;&#xA;  name?: string | null;&#xA;  description?: string | null;&#xA;};&#xA;&#xA;export type DeleteTodoInput = {&#xA;  id?: string | null;&#xA;};&#xA;&#xA;export type ModelTodoFilterInput = {&#xA;  id?: ModelIDFilterInput | null;&#xA;  name?: ModelStringFilterInput | null;&#xA;  description?: ModelStringFilterInput | null;&#xA;  and?: Array&lt;ModelTodoFilterInput | null&gt; | null;&#xA;  or?: Array&lt;ModelTodoFilterInput | null&gt; | null;&#xA;  not?: ModelTodoFilterInput | null;&#xA;};&#xA;&#xA;export type ModelIDFilterInput = {&#xA;  ne?: string | null;&#xA;  eq?: string | null;&#xA;  le?: string | null;&#xA;  lt?: string | null;&#xA;  ge?: string | null;&#xA;  gt?: string | null;&#xA;  contains?: string | null;&#xA;  notContains?: string | null;&#xA;  between?: Array&lt;string | null&gt; | null;&#xA;  beginsWith?: string | null;&#xA;};&#xA;&#xA;export type ModelStringFilterInput = {&#xA;  ne?: string | null;&#xA;  eq?: string | null;&#xA;  le?: string | null;&#xA;  lt?: string | null;&#xA;  ge?: string | null;&#xA;  gt?: string | null;&#xA;  contains?: string | null;&#xA;  notContains?: string | null;&#xA;  between?: Array&lt;string | null&gt; | null;&#xA;  beginsWith?: string | null;&#xA;};&#xA;&#xA;export type CreateTodoMutation = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type UpdateTodoMutation = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type DeleteTodoMutation = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type GetTodoQuery = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type ListTodosQuery = {&#xA;  __typename: ""ModelTodoConnection"";&#xA;  items: Array&lt;{&#xA;    __typename: ""Todo"";&#xA;    id: string;&#xA;    name: string;&#xA;    description: string | null;&#xA;  } | null&gt; | null;&#xA;  nextToken: string | null;&#xA;};&#xA;&#xA;export type OnCreateTodoSubscription = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type OnUpdateTodoSubscription = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;export type OnDeleteTodoSubscription = {&#xA;  __typename: ""Todo"";&#xA;  id: string;&#xA;  name: string;&#xA;  description: string | null;&#xA;};&#xA;&#xA;@Injectable({&#xA;  providedIn: ""root""&#xA;})&#xA;export class APIService {&#xA;  async CreateTodo(input: CreateTodoInput): Promise&lt;CreateTodoMutation&gt; {&#xA;    const statement = `mutation CreateTodo($input: CreateTodoInput!) {&#xA;        createTodo(input: $input) {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`;&#xA;    const gqlAPIServiceArguments: any = {&#xA;      input&#xA;    };&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;CreateTodoMutation&gt;response.data.createTodo;&#xA;  }&#xA;  async UpdateTodo(input: UpdateTodoInput): Promise&lt;UpdateTodoMutation&gt; {&#xA;    const statement = `mutation UpdateTodo($input: UpdateTodoInput!) {&#xA;        updateTodo(input: $input) {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`;&#xA;    const gqlAPIServiceArguments: any = {&#xA;      input&#xA;    };&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;UpdateTodoMutation&gt;response.data.updateTodo;&#xA;  }&#xA;  async DeleteTodo(input: DeleteTodoInput): Promise&lt;DeleteTodoMutation&gt; {&#xA;    const statement = `mutation DeleteTodo($input: DeleteTodoInput!) {&#xA;        deleteTodo(input: $input) {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`;&#xA;    const gqlAPIServiceArguments: any = {&#xA;      input&#xA;    };&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;DeleteTodoMutation&gt;response.data.deleteTodo;&#xA;  }&#xA;  async GetTodo(id: string): Promise&lt;GetTodoQuery&gt; {&#xA;    const statement = `query GetTodo($id: ID!) {&#xA;        getTodo(id: $id) {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`;&#xA;    const gqlAPIServiceArguments: any = {&#xA;      id&#xA;    };&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;GetTodoQuery&gt;response.data.getTodo;&#xA;  }&#xA;  async ListTodos(&#xA;    filter?: ModelTodoFilterInput,&#xA;    limit?: number,&#xA;    nextToken?: string&#xA;  ): Promise&lt;ListTodosQuery&gt; {&#xA;    const statement = `query ListTodos($filter: ModelTodoFilterInput, $limit: Int, $nextToken: String) {&#xA;        listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;          __typename&#xA;          items {&#xA;            __typename&#xA;            id&#xA;            name&#xA;            description&#xA;          }&#xA;          nextToken&#xA;        }&#xA;      }`;&#xA;    const gqlAPIServiceArguments: any = {};&#xA;    if (filter) {&#xA;      gqlAPIServiceArguments.filter = filter;&#xA;    }&#xA;    if (limit) {&#xA;      gqlAPIServiceArguments.limit = limit;&#xA;    }&#xA;    if (nextToken) {&#xA;      gqlAPIServiceArguments.nextToken = nextToken;&#xA;    }&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;ListTodosQuery&gt;response.data.listTodos;&#xA;  }&#xA;  OnCreateTodoListener: Observable&lt;OnCreateTodoSubscription&gt; = API.graphql(&#xA;    graphqlOperation(&#xA;      `subscription OnCreateTodo {&#xA;        onCreateTodo {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`&#xA;    )&#xA;  ) as Observable&lt;OnCreateTodoSubscription&gt;;&#xA;&#xA;  OnUpdateTodoListener: Observable&lt;OnUpdateTodoSubscription&gt; = API.graphql(&#xA;    graphqlOperation(&#xA;      `subscription OnUpdateTodo {&#xA;        onUpdateTodo {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`&#xA;    )&#xA;  ) as Observable&lt;OnUpdateTodoSubscription&gt;;&#xA;&#xA;  OnDeleteTodoListener: Observable&lt;OnDeleteTodoSubscription&gt; = API.graphql(&#xA;    graphqlOperation(&#xA;      `subscription OnDeleteTodo {&#xA;        onDeleteTodo {&#xA;          __typename&#xA;          id&#xA;          name&#xA;          description&#xA;        }&#xA;      }`&#xA;    )&#xA;  ) as Observable&lt;OnDeleteTodoSubscription&gt;;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am using <a href=""https://grandstack.io/"" rel=""nofollow noreferrer"">neo4j, apollo and angular with the grandstack starter</a>. </p>&#xA;&#xA;<p>I have seen ways to write your own templates to generate these types of code <a href=""https://github.com/dotansimha/graphql-code-generator"" rel=""nofollow noreferrer"">here</a>. My hope is that somebody has created one of these templates for angular, similar to the one AWS has.</p>&#xA;",1987473,,1987473,2020-01-17 11:36:35,2020-01-17 11:36:35,Generate angular service based on graphql schema,<angular><neo4j><graphql><code-generation><apollo>,0,2,0,2020-01-15 09:57:08
59807548,1,59807798,,2,516,"<p>Why am I receiving null value when I'm trying to fetch data from an external API?</p>&#xA;&#xA;<p>This is my code</p>&#xA;&#xA;<p>resolvers.js</p>&#xA;&#xA;<pre><code>import fetch from 'node-fetch'&#xA;&#xA;export const resolvers = {&#xA;  Query: {&#xA;    getCrypto: async() =&gt; {&#xA;      const response = await fetch(`https://min-api.cryptocompare.com/data/top/totalvolfull?limit=10&amp;tsym=USD`)&#xA;      return response.json();&#xA;&#xA;    }&#xA;  },&#xA;};&#xA;&#xA;&#xA;</code></pre>&#xA;&#xA;<p>schema.grapqhl</p>&#xA;&#xA;<pre><code>type CryptoCurrency {&#xA;  Id: ID&#xA;  Name: String&#xA;  FullName: String&#xA;  PRICE: Float&#xA;  LASTUPDATE: Float&#xA;}&#xA;&#xA;type Query {&#xA;  getCrypto: CryptoCurrency&#xA;}&#xA;&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Screenshot of the error: <br>&#xA;<img src=""https://i.stack.imgur.com/UuEWx.png"" alt=""enter image description here""></p>&#xA;",12697392,,10273906,2020-01-19 07:35:30,2020-01-19 07:35:30,Null value in GraphQL when trying to fetch data,<javascript><node.js><graphql><graphql-js>,1,2,0,2020-01-19 05:57:10
59810960,1,,,2,19980,"<p>I receive LASTUPDATE: 1579443364 response from an external API, <br>&#xA;How can I define the data type in the schema in order to convert it to Date format? </p>&#xA;&#xA;<p>Like this format:&#xA; <strong>Mon Jan 19 2020 00:44:04</strong></p>&#xA;&#xA;<p>GraphQL schema language supports: <br></p>&#xA;&#xA;<p>Int <br>&#xA;Float <br>&#xA;String <br>&#xA;Id <br>&#xA;Boolean <br></p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/AUWrl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AUWrl.png"" alt=""enter image description here""></a></p>&#xA;",12697392,,12697392,2020-01-19 14:35:53,2022-04-12 13:49:11,How can I define Date data type in Graphql schema?,<javascript><node.js><graphql><graphql-js>,2,3,0,2020-01-19 14:26:10
59813132,2,,59812483,1,,"<p>I would suggest to refactor your filter logic as mentioned below:</p>&#xA;&#xA;<pre><code>package main&#xA;&#xA;import (&#xA;    ""fmt""&#xA;    ""strings""&#xA;)&#xA;&#xA;func getQuery(key, val string, filters *[]string) {&#xA;    if val != """" {&#xA;        *filters = append(*filters, fmt.Sprintf(`eq(""%s"", ""%s"")`, key, val))&#xA;    }&#xA;}&#xA;func main() {&#xA;    var filters []string&#xA;    email := ""demo@demo.com""&#xA;    mobileNumber := ""123456789""&#xA;&#xA;    getQuery(""email"", email, &amp;filters)&#xA;    getQuery(""mobileNumber"", mobileNumber, &amp;filters)&#xA;    filter := strings.Join(filters, "" OR "")&#xA;    fmt.Println(filter)&#xA;}&#xA;</code></pre>&#xA;",5133838,,5133838,2020-01-19 18:38:25,2020-01-19 18:38:25,"",,0,1,0,2020-01-19 18:33:11
59838038,1,,,2,600,"<p>The following two queries should return the same output, but they don't.&#xA;I am trying to load links between users on a map, since we have too much payload, I need to split the loading. Therefore I have to use this query to load the links that are necessary.</p>&#xA;&#xA;<p>As mentioned the issue I am having is that these two return different results, which in my opinion they shouldn't. We are using GraphQL with Amplify inside of an React application. The data is stored on AWS.</p>&#xA;&#xA;<p>entry in db:&#xA;source: ""b864749a-c4bf-4c93-93db-dfa868ffc31d""&#xA;target: ""cf7f4036-2df2-47ee-a3d7-96b77fc7fd1c""</p>&#xA;&#xA;<p>giving no result:</p>&#xA;&#xA;<pre><code>query ListLinks(&#xA;  $nextToken: String&#xA;) {&#xA;  listLinks(filter: {&#xA;    or: [{&#xA;      and: [{&#xA;          source: { eq: ""b864749a-c4bf-4c93-93db-dfa868ffc31d"" },&#xA;          target: { eq: ""cf7f4036-2df2-47ee-a3d7-96b77fc7fd1c"" }&#xA;      }],&#xA;      and: [{&#xA;          source: { eq: ""cf7f4036-2df2-47ee-a3d7-96b77fc7fd1c"" },&#xA;          target: { eq: ""b864749a-c4bf-4c93-93db-dfa868ffc31d"" }&#xA;        }]   &#xA;    }] &#xA;  }, limit: 999, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      source&#xA;      target&#xA;      relation&#xA;      verified&#xA;      talentMap {&#xA;        id&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>giving result:</p>&#xA;&#xA;<pre><code>query ListLinks(&#xA;  $nextToken: String&#xA;) {&#xA;  listLinks(filter: {&#xA;    or: [{&#xA;      and: [{&#xA;          target: { eq: ""b864749a-c4bf-4c93-93db-dfa868ffc31d"" },&#xA;          source: { eq: ""cf7f4036-2df2-47ee-a3d7-96b77fc7fd1c"" }&#xA;      }],&#xA;      and: [{&#xA;          target: { eq: ""cf7f4036-2df2-47ee-a3d7-96b77fc7fd1c"" },&#xA;          source: { eq: ""b864749a-c4bf-4c93-93db-dfa868ffc31d"" }&#xA;        }]   &#xA;    }] &#xA;  }, limit: 999, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      source&#xA;      target&#xA;      relation&#xA;      verified&#xA;      talentMap {&#xA;        id&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Any idea why this is the case?</p>&#xA;",10473697,,,,2020-01-21 09:36:04,Amplify GraphQL query filtering is not working as expected,<filter><graphql><aws-amplify>,0,0,0,2020-01-21 09:36:04
59839306,1,59842506,,0,75,"<p>I'm developing an Angular/Ionic4 mobile app and I run into this error when I do <code>ionic serve</code>.</p>&#xA;&#xA;<p>Error picture:&#xA;<img src=""https://i.stack.imgur.com/3PEsW.png"" alt=""Error picture""></p>&#xA;&#xA;<p>The first time, the error result is ""failed to compile"", but if I relaunch it by saving a <code>.ts</code> file, while the error is still there, I get ""compiled successfully"" feedback and my application can be launched in the browser. How can I fix it?</p>&#xA;&#xA;<p>Here is a part of my <code>.json</code> file.</p>&#xA;&#xA;<pre><code>{  &#xA;""data"" : {&#xA;""__schema"" : {&#xA;  ""queryType"" : {&#xA;    ""name"" : ""Query""&#xA;  },&#xA;  ""mutationType"" : {&#xA;    ""name"" : ""Mutation""&#xA;  },&#xA;  ""subscriptionType"" : {&#xA;    ""name"" : ""Subscription""&#xA;  },&#xA;  ""types"" : [ {&#xA;    ""kind"" : ""OBJECT"",&#xA;    ""name"" : ""Query"",&#xA;    ""description"" : null,&#xA;    ""fields"" : [ {&#xA;      ""name"" : ""getDelivery"",&#xA;      ""description"" : null,&#xA;      ""args"" : [ {&#xA;        ""name"" : ""id"",&#xA;        ""description"" : null,&#xA;        ""type"" : {&#xA;          ""kind"" : ""NON_NULL"",&#xA;          ""name"" : null,&#xA;          ""ofType"" : {&#xA;            ""kind"" : ""SCALAR"",&#xA;            ""name"" : ""ID"",&#xA;            ""ofType"" : null&#xA;          }&#xA;        },&#xA;        ""defaultValue"" : null&#xA;      } ],&#xA;      ""type"" : {&#xA;        ""kind"" : ""OBJECT"",&#xA;        ""name"" : ""Delivery"",&#xA;        ""ofType"" : null&#xA;      },&#xA;      ""isDeprecated"" : false,&#xA;      ""deprecationReason"" : null&#xA;    }, {&#xA;      ""name"" : ""listDeliveries"",&#xA;      ""description"" : null,&#xA;      ""args"" : [ {&#xA;        ""name"" : ""filter"",&#xA;        ""description"" : null,&#xA;        ""type"" : {&#xA;          ""kind"" : ""INPUT_OBJECT"",&#xA;          ""name"" : ""TableDeliveryFilterInput"",&#xA;          ""ofType"" : null&#xA;        },&#xA;        ""defaultValue"" : null&#xA;      },&#xA;</code></pre>&#xA;&#xA;<p>And there is the file where the error is raised.</p>&#xA;&#xA;<pre><code>import { Router } from '@angular/router';&#xA;import { AddressService } from './../../address.service';&#xA;import { Component, OnInit } from '@angular/core';&#xA;import { ConnexionService } from '../../connexion/connexion.service';&#xA;import { IonItemSliding } from '@ionic/angular';&#xA;import { Address } from '../../address.model';&#xA;&#xA;@Component({&#xA;  selector: 'app-address',&#xA;  templateUrl: './address.page.html',&#xA;  styleUrls: ['./address.page.scss'],&#xA;})&#xA;export class AddressPage implements OnInit {&#xA;  loadedAddress: Address[] = [];&#xA;  isLoading = false;&#xA;&#xA;  constructor(private addressService: AddressService, private connexionService: ConnexionService, private route: Router) { }&#xA;&#xA;  ngOnInit() {&#xA;  }&#xA;&#xA;  ionViewWillEnter() {&#xA;    this.loadedAddress.splice(0, this.loadedAddress.length);&#xA;    this.isLoading = true;&#xA;    this.addressService.getAddrByUser(this.connexionService.userConnected.sub)&#xA;    .then(add =&gt; {&#xA;      if (add.data.listAddresses.items.length &gt; 0) {&#xA;        add.data.listAddresses.items.forEach(item =&gt; {&#xA;          this.loadedAddress.push(item);&#xA;        });&#xA;      }&#xA;      this.isLoading = false;&#xA;    })&#xA;    .catch(err =&gt; {&#xA;      console.log(err);&#xA;      this.isLoading = false;&#xA;    });&#xA;  }&#xA;&#xA;  onDetail(id: string, slidingItem: IonItemSliding) {&#xA;    slidingItem.close();&#xA;    this.route.navigate(['/', 'detail-address', id]);&#xA;  }&#xA;&#xA;  onCreateAddress() {&#xA;    this.route.navigateByUrl('new-address');&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I tried most of the solutions proposed on StackOverflow but none worked yet.</p>&#xA;&#xA;<p>AddressService:</p>&#xA;&#xA;<pre><code>export class AddressService {&#xA;&#xA;  constructor() { }&#xA;&#xA;  async fetchAddress() {&#xA;    const del = await API.graphql(graphqlOperation(queries.listAddresses));&#xA;    return del;&#xA;  }&#xA;&#xA;  async addAddr(nam: string, roads: string, zipcodes: string, laT: number, lnG: number, idUsers: string, city: string, country: string) {&#xA;    const newAddr = {&#xA;      name: nam,&#xA;      streetName: roads,&#xA;      city,&#xA;      country,&#xA;      zipcode: zipcodes,&#xA;      lat: laT,&#xA;      lng: lnG,&#xA;      idUser: idUsers&#xA;    };&#xA;    const ad = await API.graphql(graphqlOperation(mutations.createAddress, { input: newAddr }));&#xA;    return ad;&#xA;  }&#xA;&#xA;  async getAddr(ID: string) {&#xA;    const oneAddr = await API.graphql(graphqlOperation(queries.listAddresses, {filter: {&#xA;      id: {eq: ID}&#xA;    }}));&#xA;    return oneAddr;&#xA;  }&#xA;&#xA;  async getAddrByUser(ID: string) {&#xA;    const oneAddr = await API.graphql(graphqlOperation(queries.listAddresses, {filter: {&#xA;      idUser: {eq: ID}&#xA;    }}));&#xA;    return oneAddr;&#xA;  }&#xA;&#xA;  async updateAddr(ID: string,&#xA;                   nam: string,&#xA;                   roads: string,&#xA;                   zipcodes: string,&#xA;                   laT: number,&#xA;                   lnG: number,&#xA;                   idUsers: string,&#xA;                   city: string,&#xA;                   country: string) {&#xA;    const upAddr = {&#xA;      id: ID,&#xA;      name: nam,&#xA;      streetName: roads,&#xA;      city,&#xA;      country,&#xA;      zipcode: zipcodes,&#xA;      lat: laT,&#xA;      lng: lnG,&#xA;      idUser: idUsers&#xA;    };&#xA;    const resp = await API.graphql(graphqlOperation(mutations.updateAddress, {input: upAddr}));&#xA;    return resp;&#xA;  }&#xA;&#xA;  async cancelAddress(addressId: string) {&#xA;    const ad = await API.graphql(graphqlOperation(mutations.deleteAddress, {input: {id: addressId}}));&#xA;    return ad;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12084233,,12084233,2020-01-21 13:30:53,2020-01-21 13:43:48,"Error after 'ionic serve' (property 'xxx' does not exist on type (xxx)) lead to ""compilation failed""",<angular><typescript><graphql><ionic4>,1,4,0,2020-01-21 10:43:09
59844059,1,59850337,,0,271,<p>Given the request with multiple queries:</p>&#xA;&#xA;<pre><code>query mainQuery(&#xA;    $paramOne: Int&#xA;    $paramTwo: Int&#xA;  ) {&#xA;    queryOne(&#xA;        paramOne: $paramOne&#xA;    ) {&#xA;      totalCount&#xA;    }&#xA;    queryTwo(&#xA;        paramOne: $paramOne&#xA;    ) {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>split these queries into two different queries as:</p>&#xA;&#xA;<pre><code>  query mainQuery(&#xA;    $paramOne: Int&#xA;  ) {&#xA;    queryOne(&#xA;        paramOne: $paramOne&#xA;    ) {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;  query mainQuery(&#xA;    $paramTwo: Int&#xA;  ) {&#xA;    queryTwo(&#xA;        paramTwo: $paramTwo&#xA;    ) {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Is it possible? Maybe i missed some utility function</p>&#xA;,4282114,,,,2020-01-21 22:48:02,How to split multiple graphql queries,<javascript><graphql>,1,1,0,2020-01-21 15:13:24
59888617,2,,58615590,0,,"<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>allPrismicModel(filter: { system_category : { eq: $uid } }) {  &#xD;&#xA;edges {&#xD;&#xA;        node {&#xD;&#xA;          data {&#xD;&#xA;            system_category {&#xD;&#xA;              uid&#xD;&#xA;            }&#xD;&#xA;            ...other fields here...&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  }</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>This is a more common way to run that query</p>&#xA;",8936547,,,,2020-01-23 23:43:47,"",,0,0,0,2020-01-23 23:43:47
59906164,1,59930249,,0,2114,"<p>How can I display two arrays of objects in Recharts ? </p>&#xA;&#xA;<p>I want to display data_Chart in one Line and the response from the subscription in a different Line element...</p>&#xA;&#xA;<p>How can this be achieved? </p>&#xA;&#xA;<blockquote>&#xA;  <p>Response from Subscription in Grapqhl</p>&#xA;</blockquote>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/Okvuo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Okvuo.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>I have tried with no success, thank you for the help!</p>&#xA;&#xA;<p>My code:</p>&#xA;&#xA;<pre><code>import React, { Fragment, useState } from 'react';&#xA;import { useSubscription } from '@apollo/react-hooks';&#xA;import Box from '@material-ui/core/Box';&#xA;import { CRYPTO_ADDED } from '../../subscriptions';&#xA;import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';&#xA;&#xA;const data_Chart = [&#xA;  { name: 'Page A', uv: 4000, pv: 2400, amt: 2400 },&#xA;  { name: 'Page B', uv: 3000, pv: 1398, amt: 2210 },&#xA;  { name: 'Page C', uv: 2000, pv: 9800, amt: 2290 },&#xA;  { name: 'Page D', uv: 2780, pv: 3908, amt: 2000 },&#xA;  { name: 'Page E', uv: 1890, pv: 4800, amt: 2181 },&#xA;  { name: 'Page F', uv: 2390, pv: 3800, amt: 2500 },&#xA;];&#xA;&#xA;const Dashboard = () =&gt; {&#xA;&#xA;  const [topCrypto, setTopCrypto] = useState([]);&#xA;  useSubscription(CRYPTO_ADDED, {&#xA;    onSubscriptionData: ({subscriptionData}) =&gt; {&#xA;      setTopCrypto(topCrypto.concat(subscriptionData.data.cryptoAdded));&#xA;      console.log('topCrypto',topCrypto)&#xA;    }&#xA;  });&#xA;&#xA;&#xA;  let currVal = '';&#xA;  Object.keys(topCrypto).map((obj, indx) =&gt; {&#xA;    currVal = topCrypto[obj].PRICE;&#xA;&#xA;  });&#xA;&#xA;  return (&#xA;    &lt;Fragment&gt;&#xA;      &lt;Box color=""text.primary""&gt;&#xA;        &lt;h2 className=""m-2""&gt; BTC price &lt;/h2&gt;&#xA;          &lt;h2&gt;$ {currVal} &lt;/h2&gt;&#xA;&#xA;      &lt;/Box&gt;&#xA;      &lt;LineChart width={1100} height={685} data={topCrypto} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}&gt;&#xA;        &lt;CartesianGrid strokeDasharray=""3 3"" /&gt;&#xA;        &lt;XAxis dataKey=""LASTUPDATE"" /&gt;&#xA;        &lt;YAxis /&gt;&#xA;        &lt;Tooltip /&gt;&#xA;        &lt;Legend /&gt;&#xA;        &lt;Line&#xA;          type=""monotone""&#xA;          label=""LASTUPDATE""&#xA;          dataKey=""PRICE""&#xA;          stroke=""#8884d8""&#xA;          activeDot={{ r: 8 }}&#xA;          strokeDasharray=""5 5""&#xA;        /&gt;&#xA;      &lt;/LineChart&gt;&#xA;    &lt;/Fragment&gt;&#xA;  );&#xA;};&#xA;&#xA;export default Dashboard;&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Something like this:&#xA;<a href=""https://i.stack.imgur.com/Zg4IM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Zg4IM.png"" alt=""enter image description here""></a></p>&#xA;",12697392,,12697392,2020-01-25 05:20:11,2020-01-27 11:28:23,How to display multiple arrays of objects in Recharts?,<javascript><reactjs><graphql><recharts>,1,5,0,2020-01-25 03:48:20
59930249,2,,59906164,1,,"<p>In recharts, you can add multiple <code>line</code> with different <code>dataKey</code></p>&#xA;&#xA;<pre><code>&lt;LineChart&#xA;        width={400}&#xA;        height={300}&#xA;        data={sample}&#xA;        margin={{ top: 5, right: 30, left: 20, bottom: 5 }}&#xA;      &gt;&#xA;        &lt;CartesianGrid strokeDasharray=""3 3"" /&gt;&#xA;        &lt;XAxis dataKey=""LASTUPDATE"" /&gt;&#xA;        &lt;YAxis  /&gt;&#xA;        &lt;Tooltip /&gt;&#xA;        &lt;Legend /&gt;&#xA;        &lt;Line //first line&#xA;          type=""monotone""&#xA;          dataKey=""PRICE1""&#xA;          stroke=""#ff84d8""&#xA;          activeDot={{ r: 8 }}&#xA;          strokeDasharray=""5 5""&#xA;        /&gt;&#xA;        &lt;Line //second line&#xA;          type=""monotone""&#xA;          dataKey=""PRICE2""&#xA;          stroke=""#8884d8""&#xA;          activeDot={{ r: 8 }}&#xA;          strokeDasharray=""5 5""&#xA;        /&gt;&#xA;      &lt;/LineChart&gt; &#xA;</code></pre>&#xA;&#xA;<p><a href=""https://codesandbox.io/s/frosty-waterfall-display-multiple-arrays-of-objects-in-recharts-mfg8z"" rel=""nofollow noreferrer"">temporary sample codesandbox</a></p>&#xA;&#xA;<p><br></p>&#xA;&#xA;<p>You need to identify and decide the shape of comparable data &#xA;<br>&#xA;one option could be like this</p>&#xA;&#xA;<pre><code>[  {PRICE1: 8310.45,PRICE2: 7800.45},{PRICE1: 8302.45,PRICE2: 7050.45},....]&#xA;</code></pre>&#xA;&#xA;<p>another one could be with two datasource</p>&#xA;&#xA;<pre><code> PRICE1=  [ 8310.45,8302.45,....]&#xA; PRICE2=  [7800.457050.45,....]&#xA;</code></pre>&#xA;&#xA;<p>or somethings else...</p>&#xA;",4855817,,,,2020-01-27 11:28:23,"",,0,0,0,2020-01-27 11:28:23
59933046,2,,59629200,1,,"<p>You need to filter manually after fetching from the database or use use a where condition to check if firstName and lastName:</p>&#xA;&#xA;<pre><code>const users = await prisma.users({ where: { firstName: 'any', lastName: 'value' } });&#xA;</code></pre>&#xA;",1398640,,,,2020-01-27 14:25:18,"",,0,0,0,2020-01-27 14:25:18
60035920,2,,57445294,2,,"<p>This can be solved by ;</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>npm install lodash.flowright&#xA;import * as compose from 'lodash.flowright';&#xA;</code></pre>&#xA;&#xA;<p>Because compose is literally the same as flowRight, the apollo team decided to reduce the bundle size by removing it.</p>&#xA;&#xA;<p>For more info read the breaking changes section here <a href=""https://github.com/apollographql/react-apollo/blob/e9190fac891dd7af3a1690a5d2a1305953fd5a6f/Changelog.md#breaking-changes"" rel=""nofollow noreferrer"">https://github.com/apollographql/react-apollo/blob/e9190fac891dd7af3a1690a5d2a1305953fd5a6f/Changelog.md#breaking-changes</a></p>&#xA;",8893322,,,,2020-02-03 08:59:44,"",,0,0,0,2020-02-03 08:59:44
60060784,1,60101391,,2,515,"<p>I'm using Python to make requests to Pipefy GraphQL API.&#xA;I already read the documentation and make search in pipefy forum, but&#xA;I could not figure what is wrong with the query bellow:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>pipeId = '171258'&#xA;query =""""""&#xA;        {&#xA;            ""query"": ""{allCards(pipeId: %s, first: 30, after: 'WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0'){pageInfo{endCursor hasNextPage}edges{node{id title}}}}""&#xA;        }&#xA;        """"""%(pipeid)&#xA;</code></pre>&#xA;&#xA;<p>The query worked pretty well until I added the <code>after</code> parameter.&#xA;I already tried variations like:</p>&#xA;&#xA;<p><code>after: ""WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0""</code></p>&#xA;&#xA;<p><code>after: \""WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0\""</code></p>&#xA;&#xA;<p><code>after: \n""WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0\n""</code></p>&#xA;&#xA;<p>I know the issue is related with the escaping, because the API return messages like this:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>'{""errors"":[{""locations"":[{""column"":45,""line"":1}],""message"":""token recognition error at: \'\'\'""},{""locations"":[{""column"":77,""line"":1}],""message"":""token recognition error at: \'\'\'""}]}\n'&#xA;</code></pre>&#xA;&#xA;<p>(this message is returned when the request is made with <code>after: 'WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0'</code>)</p>&#xA;&#xA;<p>Any help here would be immensely handful! &#xA;Thanks</p>&#xA;",12840021,,10552640,2020-02-04 17:40:01,2020-02-10 17:38:07,Python GraphQL query issue,<python><graphql>,3,0,0,2020-02-04 15:37:46
60078567,1,,,1,41,"<p>I am sending a query from a React component which appears like this (Apollo Client):</p>&#xA;&#xA;<pre><code> const { data, loading, error, fetchMore } = useQuery(&#xA;        item.GET_ITEMS_QUERY,&#xA;        {&#xA;            variables: {&#xA;                first: 15,&#xA;                offset: paginateOffset,&#xA;            },&#xA;            errorPolicy: 'all'&#xA;        });&#xA;</code></pre>&#xA;&#xA;<p>The GET_ITEMS_QUERY appears like this:</p>&#xA;&#xA;<pre><code>export const GET_ITEMS_QUERY = gql`&#xA;query GetItems($first: Float!, $offset: Float!){&#xA;    getItems(query: {}, first : $first, offset : $offset){&#xA;       attribute1&#xA;       attribute2&#xA;       attribute3&#xA;       attribute4            &#xA;    }&#xA;}`;&#xA;</code></pre>&#xA;&#xA;<p>I get the following error from the GraphQL server:</p>&#xA;&#xA;<pre><code>""Field ""getItems"" argument ""query"" of type ""ItemsQuery!"" is required, but it was not provided.""&#xA;</code></pre>&#xA;&#xA;<p>I can trace it down to this:</p>&#xA;&#xA;<p>The GraphQL Resolver takes in 3 arguments, first and offset for pagination, and a query object of type ItemsQuery:</p>&#xA;&#xA;<pre><code>    @InputType()&#xA;export class ItemsQuery{&#xA;    @Field({ nullable: true })&#xA;    attribute1?: number;&#xA;&#xA;    @Field({ nullable: true })&#xA;    attribute2?: string;&#xA;&#xA;    @Field({ nullable: true })&#xA;    attribute3?: string;&#xA;&#xA;    @Field({nullable: true})&#xA;    attribute4?: Date&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I conclude that having just ""query: {}"" in the Gql String is not enough on its own when sent from the frontend. However, <strong>if I go on playground and type in the exact same query, it works because there it's recognized as a ItemsQuery</strong>. Would anyone know of a solution?</p>&#xA;&#xA;<p>Thanks a bunch &lt;3</p>&#xA;",10553879,,10553879,2020-02-05 15:04:49,2020-02-06 12:45:31,InputType() doesn't translate from React Frontend to NodeJs backend,<reactjs><graphql><apollo-client><typegraphql>,0,1,0,2020-02-05 14:59:41
60080089,1,60082612,,0,319,"<p>I have the following query : </p>&#xA;&#xA;<pre><code>{&#xA;  allPeople {&#xA;    people {&#xA;      name&#xA;      filmConnection {&#xA;        films {&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would like to select all people that have a film connection with the title a new hope. How do i select this specific thing from the API. I could also just get it like this and handle it in the code. But surely there is a better way. </p>&#xA;&#xA;<p>What i'd expect : </p>&#xA;&#xA;<pre><code>{&#xA;  allPeople {&#xA;    people {&#xA;      name&#xA;      filmConnection {&#xA;        films {&#xA;          title : ""a new hope""&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That didnt work..</p>&#xA;&#xA;<p>Try out here in this playground :</p>&#xA;&#xA;<p><a href=""https://graphql.org/swapi-graphql?query=%7B%0A%20%20allPeople%20%7B%0A%20%20%20%20people%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20filmConnection%20%7B%0A%20%20%20%20%20%20%20%20films%20%7B%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A"" rel=""nofollow noreferrer"">https://graphql.org/swapi-graphql?query=%7B%0A%20%20allPeople%20%7B%0A%20%20%20%20people%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20filmConnection%20%7B%0A%20%20%20%20%20%20%20%20films%20%7B%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A</a></p>&#xA;",6787542,,,,2020-02-05 19:10:51,GraphQl API select specific values,<graphql>,1,4,0,2020-02-05 16:27:24
60082612,2,,60080089,1,,"<h1>graphql queries ... are not for building [sql] queries ;)</h1>&#xA;&#xA;<h2>this is more for defining shape of required data</h2>&#xA;&#xA;<p>parameter <strong>CAN BE passed to deeper child</strong> (f.e. can be used to filter films)</p>&#xA;&#xA;<pre><code>{&#xA;  allPeople {&#xA;    people {&#xA;      name {&#xA;        filmConnection {    &#xA;          films(title_eq:""a new hope"") { &#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>... <strong>if API supports this kind of filtering</strong> for <code>films</code></p>&#xA;&#xA;<p>... but <strong>it won't filter people</strong> - you'll have <strong>all people AND filtered films</strong> (for all people) because filters won't work on parents.</p>&#xA;&#xA;<p>You <strong>CAN have custom API</strong> that will be this kind of filtering aware, f.e.</p>&#xA;&#xA;<pre><code>{&#xA;  allPeople {&#xA;    people(connectedFilmTitle_eq:""a new hope"") {&#xA;      name {&#xA;        filmConnection {    &#xA;          films { &#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>customized (not automatically gnerated) <code>peolpe</code> resolver can make appriopriate query [on joined tables] and return structure you're asking for.  </p>&#xA;&#xA;<p>In that case probably you don't need deeper structures - <code>...filmConnection { films { title</code> - you know this data earlier (filter parameters).</p>&#xA;&#xA;<p>... <strong>but probably you have a many2many relation and cen reverse this query</strong>:</p>&#xA;&#xA;<pre><code>{&#xA;  allFilms {&#xA;    films(title_eq:""a new hope"") {&#xA;      title {&#xA;        peoleConnection {    &#xA;          people { &#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6124657,,,,2020-02-05 19:10:51,"",,0,2,0,2020-02-05 19:10:51
60101391,2,,60060784,1,,"<p>I had the same problem as you today (and saw your post on Pipefy's Support page). I personally entered in contact with Pipefy's developers but they weren't helpful at all.</p>&#xA;&#xA;<p>I solved it by escaping the query correctly.</p>&#xA;&#xA;<p>Try like this:</p>&#xA;&#xA;<pre><code>query = '{""query"": ""{ allCards(pipeId: %s, first: 30, after: \\""WyIxLjAiLCI1ODAuMCIsMzI0OTU0NF0\\""){ pageInfo{endCursor hasNextPage } edges { node { id title } } } }""}'&#xA;</code></pre>&#xA;&#xA;<p>Using single quotes to define the string and double-backslashes before the doublequotes included in the cursor.</p>&#xA;",9204831,,9204831,2020-02-06 20:23:35,2020-02-06 20:23:35,"",,0,1,0,2020-02-06 18:27:11
60105937,2,,59823014,0,,"<p>This is what your connections should look like. Given that your other types are:</p>&#xA;&#xA;<p>Friend</p>&#xA;&#xA;<p>BlockedUser</p>&#xA;&#xA;<p>FriendRequest</p>&#xA;&#xA;<pre><code>type User @model) {&#xA;id: ID!&#xA;email: String!&#xA;password: String!&#xA;friends: [Friend] @connection(name: ""UserFriendConn"")&#xA;blockedUsers: [BlockedUser] @connection(name: ""UserBlockedConn"")&#xA;friendRequests: [FriendRequest] @connection(name: ""UserFriendRequestConn"")&#xA;</code></pre>&#xA;&#xA;<p>}</p>&#xA;",2317649,,,,2020-02-07 01:31:38,"",,0,2,0,2020-02-07 01:31:38
60133832,2,,60023452,0,,"<p>First of all, I stripped the <code>NewsTypeFilter</code> from my schema, because it's returning the same as my <code>NewsType</code>. Then I added <code>country</code> with the other fields on my <code>NewsType</code>. That pretty much solved the problem. </p>&#xA;&#xA;<p>I guess adding the filterType created the problem at first.</p>&#xA;",7643958,,,,2020-02-09 05:47:06,"",,0,0,0,2020-02-09 05:47:06
60148075,1,60148273,,0,889,"<p>I've recently started learning GraphQL. I created a Mutation for a custom-defined model and it's working fine. But when I try to do the same for the Django built-in user model. I'm getting an error. Not able to resolve it.&#xA;I'm trying to create a new user by creating an object of get_user_model through GraphQL.</p>&#xA;&#xA;<pre><code>class CreateUser(graphene.Mutation):&#xA;user = graphene.Field(UserType)&#xA;&#xA;class Arguments:&#xA;    username = graphene.String(required=True)&#xA;    password = graphene.String(required=True)&#xA;    email = graphene.String(request=True)&#xA;&#xA;def mutate(self,info,username,password,email):&#xA;    user = get_user_model(username=username,email=email)&#xA;    user.set_password(password)&#xA;    user.save()&#xA;    return CreateUser(user=user)&#xA;&#xA;class Mutation(graphene.ObjectType):&#xA;    create_user = CreateUser.Field()&#xA;</code></pre>&#xA;&#xA;<p>Getting the above error. Not sure what's the problem. Please anyone explain.</p>&#xA;&#xA;<p>Traceback error:</p>&#xA;&#xA;<pre><code>Environment:&#xA;&#xA;&#xA;Request Method: GET&#xA;Request URL: http://127.0.0.1:8000/graphql/&#xA;&#xA;Django Version: 3.0.3&#xA;Python Version: 3.6.1&#xA;Installed Applications:&#xA;['django.contrib.admin',&#xA; 'django.contrib.auth',&#xA; 'django.contrib.contenttypes',&#xA; 'django.contrib.sessions',&#xA; 'django.contrib.messages',&#xA; 'django.contrib.staticfiles',&#xA; 'graphene_django',&#xA; 'links']&#xA;Installed Middleware:&#xA;['django.middleware.security.SecurityMiddleware',&#xA; 'django.contrib.sessions.middleware.SessionMiddleware',&#xA; 'django.middleware.common.CommonMiddleware',&#xA; 'django.middleware.csrf.CsrfViewMiddleware',&#xA; 'django.contrib.auth.middleware.AuthenticationMiddleware',&#xA; 'django.contrib.messages.middleware.MessageMiddleware',&#xA; 'django.middleware.clickjacking.XFrameOptionsMiddleware']&#xA;&#xA;&#xA;&#xA;Traceback (most recent call last):&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/django/core/handlers/exception.py"", line 34, in inner&#xA;    response = get_response(request)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/django/core/handlers/base.py"", line 115, in _get_response&#xA;    response = self.process_exception_by_middleware(e, request)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/django/core/handlers/base.py"", line 113, in _get_response&#xA;    response = wrapped_callback(request, *callback_args, **callback_kwargs)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/django/views/decorators/csrf.py"", line 54, in wrapped_view&#xA;    return view_func(*args, **kwargs)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/django/views/generic/base.py"", line 62, in view&#xA;    self = cls(**initkwargs)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene_django/views.py"", line 79, in __init__&#xA;    schema = graphene_settings.SCHEMA&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene_django/settings.py"", line 117, in __getattr__&#xA;    val = perform_import(val, attr)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene_django/settings.py"", line 56, in perform_import&#xA;    return import_from_string(val, setting_name)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene_django/settings.py"", line 70, in import_from_string&#xA;    module = importlib.import_module(module_path)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/importlib/__init__.py"", line 126, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 978, in _gcd_import&#xA;    &lt;source code not available&gt;&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 961, in _find_and_load&#xA;    &lt;source code not available&gt;&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 950, in _find_and_load_unlocked&#xA;    &lt;source code not available&gt;&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 655, in _load_unlocked&#xA;    &lt;source code not available&gt;&#xA;  File ""&lt;frozen importlib._bootstrap_external&gt;"", line 678, in exec_module&#xA;    &lt;source code not available&gt;&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 205, in _call_with_frames_removed&#xA;    &lt;source code not available&gt;&#xA;  File ""/Users/sunilhn/Documents/programming/django_fs/myDjangoProjects/graphqlhackernews/graphqlhackernews/schema.py"", line 3, in &lt;module&gt;&#xA;    import users.schema&#xA;  File ""/Users/sunilhn/Documents/programming/django_fs/myDjangoProjects/graphqlhackernews/users/schema.py"", line 29, in &lt;module&gt;&#xA;    class Mutation(graphene.ObjectType):&#xA;  File ""/Users/sunilhn/Documents/programming/django_fs/myDjangoProjects/graphqlhackernews/users/schema.py"", line 30, in Mutation&#xA;    create_user = CreateUser.Field()&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene/types/mutation.py"", line 146, in Field&#xA;    required=required,&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene/types/field.py"", line 103, in __init__&#xA;    self.args = to_arguments(args or OrderedDict(), extra_args)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene/types/argument.py"", line 94, in to_arguments&#xA;    arg = Argument.mounted(arg)&#xA;  File ""/Users/sunilhn/Documents/programming/Envs/graphenv/lib/python3.6/site-packages/graphene/types/mountedtype.py"", line 19, in mounted&#xA;    **unmounted.kwargs&#xA;&#xA;Exception Type: TypeError at /graphql/&#xA;Exception Value: __init__() got an unexpected keyword argument 'request'&#xA;</code></pre>&#xA;",6431944,,,,2020-02-10 10:20:10,Graphql trying to create an object of get_user_model : __init__() got an unexpected keyword argument 'request',<django><python-3.x><graphql><graphene-python><graphene-django>,1,2,0,2020-02-10 10:10:36
60155591,2,,60060784,1,,"<p>With the code snippet below you are able to call the function <code>get_card_list</code> passing the authentication token (as String) and the pipe_id (as integer) and retrieve the whole card list of your pipe.</p>&#xA;&#xA;<p>The <code>get_card_list</code> function will call the function <code>request_card_list</code> until the hasNextpage is set to False, updating the cursor in each call.</p>&#xA;&#xA;<pre><code># Function responsible to get cards from a pipe using Pipefy's GraphQL API&#xA;def request_card_list(auth_token, pipe_id, hasNextPage=False, endCursor=""""):    &#xA;    url = ""https://api.pipefy.com/graphql""&#xA;    headers = {&#xA;        'Content-Type': 'application/json',&#xA;        'Authorization': 'Bearer %s' %auth_token&#xA;    }&#xA;    if not hasNextPage:&#xA;        payload = '{""query"": ""{ allCards(pipeId: %i, first: 50) { edges { node { id title  phases_history { phase { name } firstTimeIn lastTimeOut } } cursor } pageInfo { endCursor hasNextPage } } }""}' %pipe_id&#xA;    else:&#xA;        payload = '{""query"": ""{ allCards(pipeId: %i, first: 50, after: \\""%s\\"") { edges { node { id title  phases_history { phase { name } firstTimeIn lastTimeOut } } cursor } pageInfo { endCursor hasNextPage } } }""}' % (pipe_id, endCursor)&#xA;&#xA;    response = requests.request(""POST"", url, data=payload, headers=headers)&#xA;    response_body = response.text&#xA;    response_body_dict = json.loads(response_body)&#xA;    response_dict_list = response_body_dict['data']['allCards']['edges']&#xA;&#xA;    card_list = []&#xA;    for d in response_dict_list:&#xA;        for h in d['node']['phases_history']:&#xA;            h['firstTimeIn'] = datetime.strptime(h['firstTimeIn'], date_format)&#xA;            if h['lastTimeOut']:&#xA;                h['lastTimeOut'] = datetime.strptime(h['lastTimeOut'], date_format)&#xA;        card_list.append(d['node'])&#xA;&#xA;    return_list = [card_list, response_body_dict['data']['allCards']['pageInfo']['hasNextPage'], response_body_dict['data']['allCards']['pageInfo']['endCursor']]&#xA;    return return_list&#xA;&#xA;# Function responsible to get all cards from a pipe using Pipefy's GraphQL API and pagination&#xA;def get_card_list(auth_token, pipe_id):&#xA;    card_list = []&#xA;    response = request_card_list(auth_token, pipe_id)&#xA;    card_list = card_list + response[0]&#xA;&#xA;    while response[1]:&#xA;        response = request_card_list(auth_token, pipe_id, response[1], response[2])&#xA;        card_list = card_list + response[0]&#xA;&#xA;    return(card_list)&#xA;</code></pre>&#xA;",9204831,,,,2020-02-10 17:38:07,"",,0,0,0,2020-02-10 17:38:07
60194991,1,60195734,,1,782,"<p>Considering the given schema declaration:</p>&#xA;&#xA;<pre><code>type Subject @model @key(fields: [""num"", ""type"", ""desc"", ""parent""])&#xA;{&#xA;    id:     ID!&#xA;    num :   String!&#xA;    ...&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How would I call <code>API.graphql</code> method in order to sort it by its 3rd key, for instance?</p>&#xA;",6466366,,,,2020-02-12 19:39:18,AWS GraphQL: Sort List by specific sort key,<reactjs><react-native><graphql><aws-appsync><dynamodb-queries>,1,0,0,2020-02-12 18:41:00
60195734,2,,60194991,1,,"<p>GraphQL doesn't inherently support sorting. To add sorting you need to modify your queries to accept one or more sort parameters and then do the sorting in your code. This article gives examples of <a href=""https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer"">Filtering, Pagination &amp; Sorting</a>.</p>&#xA;",2860032,,,,2020-02-12 19:39:18,"",,0,0,0,2020-02-12 19:39:18
60196179,2,,60195505,2,,"<p>GraphQL schemas that implement the <a href=""https://relay.dev/docs/en/graphql-server-specification.html"" rel=""nofollow noreferrer"">Relay specification</a> utilize <a href=""https://facebook.github.io/relay/graphql/connections.htm"" rel=""nofollow noreferrer"">Connection</a> types to model one-to-many or many-to-many relationships.</p>&#xA;&#xA;<p>Each connection includes a list of edges and a <code>PageInfo</code> object. Each edge includes a <code>node</code> and the <code>cursor</code> for that node. </p>&#xA;&#xA;<p>Edges may also contain additional fields -- for example, if we have a friends connection between User nodes, we might include the timestamps when the friendships were created. Normally, though, edges are only used for the <code>cursor</code> field they expose. The <code>cursor</code> value is used when paginating through the connection and exposing it for every edge means you can start your pagination from any arbitrary point in the results. The cursor is not included as part of the node because it's may be specific to the connection and not just the node itself (for example, some cursors encode sort criteria).</p>&#xA;&#xA;<p>However, if as a client you don't need to paginate the results of a connection and just want to fetch all the nodes, you probably don't care about cursors. In these scenarios, having edges doesn't add any value and just increases the depth of your query. As a result, as a convenience to the client, some GraphQL services have opted to exposing <em>just</em> the nodes for the connection in addition to the edges.</p>&#xA;",6024220,,,,2020-02-12 20:12:44,"",,0,0,0,2020-02-12 20:12:44
60214091,2,,60209463,0,,"<p>I just tried with last version of Strapi and the deep filter is working well.</p>&#xA;&#xA;<p>Here is a short video of what I did - <a href=""https://www.loom.com/share/cf8360252b1044128c9b07a2bb390638"" rel=""nofollow noreferrer"">https://www.loom.com/share/cf8360252b1044128c9b07a2bb390638</a></p>&#xA;",9208166,,,,2020-02-13 18:10:51,"",,0,3,0,2020-02-13 18:10:51
60232941,2,,60232484,4,,"<p>Yes. It is straightforward to do so . The query looks like :</p>&#xA;&#xA;<pre><code>{&#xA;  repository(owner: ""gatsbyjs"", name: ""gatsby"") {&#xA;    description&#xA;    url&#xA;    milestones(states: [OPEN],first:2) {&#xA;      nodes{&#xA;        title&#xA;        description&#xA;        url&#xA;        issues(states:[OPEN,CLOSED], first:2){&#xA;          nodes{&#xA;            title&#xA;            state&#xA;            url&#xA;            comments(first:2){&#xA;              nodes{&#xA;                url&#xA;                body&#xA;                createdAt&#xA;              }&#xA;              pageInfo{&#xA;                hasNextPage&#xA;                endCursor&#xA;              }&#xA;            }&#xA;          }&#xA;          pageInfo{&#xA;             endCursor&#xA;             hasNextPage&#xA;          }&#xA;        }&#xA;      }&#xA;      pageInfo{&#xA;        endCursor&#xA;        hasNextPage&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note:</p>&#xA;&#xA;<ul>&#xA;<li><p>For the repository which the url is <code>https://github.com/gatsbyjs/gatsby</code> , its owner is <code>gatsbyjs</code> and its name is  <code>gatsby</code></p></li>&#xA;<li><p>Go to its <a href=""https://developer.github.com/v4/explorer/"" rel=""nofollow noreferrer"">API Explorer</a> to try and fine tune the query.Click <kbd>Ctrl</kbd>+<kbd>Space</kbd> will auto-suggest the available fields that can be retrieved.</p></li>&#xA;<li><p>Do the paginating by yourself to loop through all records by adjusting the starting cursor and the number of records to be returned in <code>first</code> , <code>after</code>.</p></li>&#xA;</ul>&#xA;&#xA;<p>It gives you the following : </p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""repository"": {&#xA;      ""description"": ""Build blazing fast, modern apps and websites with React"",&#xA;      ""url"": ""https://github.com/gatsbyjs/gatsby"",&#xA;      ""milestones"": {&#xA;        ""nodes"": [&#xA;          {&#xA;            ""title"": ""Next Major"",&#xA;            ""description"": ""Issues that will require a breaking change, and which would constitute being done in the next major version of Gatsby."",&#xA;            ""url"": ""https://github.com/gatsbyjs/gatsby/milestone/5"",&#xA;            ""issues"": {&#xA;              ""nodes"": [&#xA;                {&#xA;                  ""title"": ""Make accessibility warnings errors"",&#xA;                  ""state"": ""OPEN"",&#xA;                  ""url"": ""https://github.com/gatsbyjs/gatsby/issues/19945"",&#xA;                  ""comments"": {&#xA;                    ""nodes"": [&#xA;                      {&#xA;                        ""url"": ""https://github.com/gatsbyjs/gatsby/issues/19945#issuecomment-568891716"",&#xA;                        ""body"": ""Hiya!\n\nThis issue has gone quiet. Spooky quiet. \n\nWe get a lot of issues, so we currently close issues after 30 days of inactivity. It’s been at least 20 days since the last update here.\nIf we missed this issue or if you want to keep it open, please reply here. You can also add the label \""not stale\"" to keep this issue open!\nAs a friendly reminder: the best way to see this issue, or any other, fixed is to open a Pull Request. Check out [gatsby.dev/contribute](https://www.gatsbyjs.org/contributing/how-to-contribute/) for more information about opening PRs, triaging issues, and contributing!\n\nThanks for being a part of the Gatsby community! "",&#xA;                        ""createdAt"": ""2019-12-25T12:02:26Z""&#xA;                      },&#xA;                      {&#xA;                        ""url"": ""https://github.com/gatsbyjs/gatsby/issues/19945#issuecomment-570779866"",&#xA;                        ""body"": ""Hey again!\n\nIt’s been 30 days since anything happened on this issue, so our friendly neighborhood robot (that’s me!) is going to close it.\nPlease keep in mind that I’m only a robot, so if I’ve closed this issue in error, I’m `HUMAN_EMOTION_SORRY`. Please feel free to reopen this issue or create a new one if you need anything else.\nAs a friendly reminder: the best way to see this issue, or any other, fixed is to open a Pull Request. Check out [gatsby.dev/contribute](https://www.gatsbyjs.org/contributing/how-to-contribute/) for more information about opening PRs, triaging issues, and contributing!\n\nThanks again for being part of the Gatsby community! "",&#xA;                        ""createdAt"": ""2020-01-04T12:02:28Z""&#xA;                      }&#xA;                    ],&#xA;                    ""pageInfo"": {&#xA;                      ""hasNextPage"": false,&#xA;                      ""endCursor"": ""Y3Vyc29yOnYyOpHOIgVo2g==""&#xA;                    }&#xA;                  }&#xA;                },&#xA;                {&#xA;                  ""title"": ""Configurable output folder"",&#xA;                  ""state"": ""OPEN"",&#xA;                  ""url"": ""https://github.com/gatsbyjs/gatsby/issues/1878"",&#xA;                  ""comments"": {&#xA;                    ""nodes"": [&#xA;                      {&#xA;                        ""url"": ""https://github.com/gatsbyjs/gatsby/issues/1878#issuecomment-324062470"",&#xA;                        ""body"": ""Do you have a specific use case in mind? This has been discussed before but no one has come up with a concrete use case that justified adding a new option.\r\n\r\nEvery option we add to Gatsby makes the project more complex which has all sorts of long-term costs so unless something is really valuable, I'd rather people handle this sort of thing themselves e.g. just copy the files to the output directory you want or create a symlink. This could easily be turned into a plugin that people could install, etc."",&#xA;                        ""createdAt"": ""2017-08-22T15:27:41Z""&#xA;                      },&#xA;                      {&#xA;                        ""url"": ""https://github.com/gatsbyjs/gatsby/issues/1878#issuecomment-324074853"",&#xA;                        ""body"": ""Yes, I have a use-case. I am going to use Gatsby for a documentation part as a part of complex project. All static files (Gatsby output, plus some others) should be placed into one folder `build`, that will be deployed somehow later. In other words, the Gatsby output is only one subfolder in my setup.\r\n\r\nSo far I have worked this around in `postbuild` step, but it looks hacky:\r\n\r\n```\r\n\""build\"": \""gatsby build\"",\r\n\""postbuild\"": \""mv public build/gatsby-subsite\""\r\n```\r\nAdding configurable output folder will reduce this complexity and will help me not to move files around one more time."",&#xA;                        ""createdAt"": ""2017-08-22T16:08:21Z""&#xA;                      }&#xA;                    ],&#xA;                    ""pageInfo"": {&#xA;                      ""hasNextPage"": true,&#xA;                      ""endCursor"": ""Y3Vyc29yOnYyOpHOE1D9ZQ==""&#xA;                    }&#xA;                  }&#xA;                }&#xA;              ],&#xA;              ""pageInfo"": {&#xA;                ""endCursor"": ""Y3Vyc29yOnYyOpLPgAAAAAAAArvODwULXA=="",&#xA;                ""hasNextPage"": true&#xA;              }&#xA;            }&#xA;          }&#xA;        ],&#xA;        ""pageInfo"": {&#xA;          ""endCursor"": ""Y3Vyc29yOnYyOpHOAEEbsw=="",&#xA;          ""hasNextPage"": false&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",339637,,339637,2020-02-14 20:47:15,2020-02-14 20:47:15,"",,0,2,0,2020-02-14 20:14:34
60246510,2,,60211296,1,,"<p>From the <a href=""https://lacinia.readthedocs.io/en/latest/resolve/selections.html"" rel=""nofollow noreferrer"">docs</a>:  </p>&#xA;&#xA;<blockquote>&#xA;  <p>It is also possible to get all the fields that will be selected, using&#xA;  selections-seq. This a lazy, breadth-first navigation of all fields in&#xA;  the selection tree.</p>&#xA;</blockquote>&#xA;&#xA;<p>So you can use: <code>(executor/selections-seq context)</code> to get all fields that were sent by the query.</p>&#xA;",1116068,,,,2020-02-16 07:54:01,"",,0,0,0,2020-02-16 07:54:01
60250180,1,,,0,253,"<p>I've an AWS AppSync API that subscribes to a <code>createVisitorRecord</code> mutation. This mutation  writes a new record to dynamodb. Th primary key is a combo of a partition key <code>location_id</code> and sort key <code>visit_time</code> where <code>visit_time</code> is a timestamp. </p>&#xA;&#xA;<p>Here's the <code>VisitorRecord</code> that get's written to Dynamodb:</p>&#xA;&#xA;<pre><code>type VisitorRecord {&#xA;    location_id: String!&#xA;    visit_time: AWSDateTime!&#xA;    email: AWSEmail!&#xA;    name: String!&#xA;    avatar: S3Object&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there a way to subscribe solely to the creation of new records between a timestamp range? e.g. records for a specific day between a date range? I can't find any documentation on passing arguments to subscriptions that act as filters. Any advice appreciated, or even a different approach. </p>&#xA;",2958185,,,,2020-04-29 19:51:35,AWS Appsync subscription filter between timestamp range,<amazon-web-services><graphql><aws-appsync><graphql-subscriptions>,1,0,0,2020-02-16 15:41:22
60295875,2,,47211778,4,,"<p>If you want to wipe up <code>__typename</code> from GraphQL response (from the root and its children), you can use <a href=""https://www.npmjs.com/package/graphql-anywhere"" rel=""nofollow noreferrer"">graphql-anywhere</a> package.</p>&#xA;&#xA;<p>Something like:&#xA;<code>const wipedData = filter(inputFragment, rcvData);</code></p>&#xA;&#xA;<ul>&#xA;<li><code>inputFragment</code> is a fragment defines the fields (You can see details <a href=""https://www.apollographql.com/docs/react/data/fragments/"" rel=""nofollow noreferrer"">here</a>)</li>&#xA;<li><code>rcvData</code> is the received data from GraphQL query</li>&#xA;</ul>&#xA;&#xA;<p>By using the <code>filter</code> function, the <code>wipedData</code> includes only required fields you need to pass as mutation input.</p>&#xA;",10571578,,10571578,2020-02-19 11:21:04,2020-02-19 11:21:04,"",,0,0,0,2020-02-19 08:27:01
60297310,1,60301112,,2,5226,"<p>So i just started using graphql recently (last week to be precise). I get the concept of being able to filter queries with the 'where' argument and all but i noticed when i try to get objects from a deep nested query it becomes somewhat impossible. So say i have 'domestic_worker_nextofkin' query that should get fullname, mobile_phone1, and relationship where 'archived' _is_null equals true as given below:</p>&#xA;&#xA;<pre><code>domestic_workers_nextofkin(where: {archived:{_is_null: true}}){&#xA;    full_name&#xA;    mobile_phone1&#xA;    domestic_workers_relationships{&#xA;      relationship&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The query above does it's intended job and gets the full_name, mobile_phone1 and relationship.</p>&#xA;&#xA;<p>But my current problem is that when this query is deeply nested as shown below (the asterisked code):</p>&#xA;&#xA;<pre><code>query User($userId: Int) {&#xA;     domestic_workers_news{&#xA;          title&#xA;          date_created&#xA;          summary&#xA;          url&#xA;        }&#xA;    users_user(where: {id: {_eq: $userId}}) {&#xA;      domestic_workers_pictures(order_by: {id: desc}, limit: 1) {&#xA;        id&#xA;      }&#xA;      id&#xA;      password&#xA;      username&#xA;      first_name&#xA;      last_name&#xA;      email&#xA;      gender&#xA;      birth_date&#xA;      mobile_phone1&#xA;      mobile_phone2&#xA;      home_address_street&#xA;      home_address_town&#xA;      home_address_lga&#xA;      home_address_state&#xA;      home_address_country&#xA;      home_address_postal_code&#xA;      job_title&#xA;      workplace&#xA;      verified&#xA;      agreed_terms&#xA;      date_joined&#xA;      last_modified&#xA;      domestic_workers_workers {&#xA;        domestic_workers_pictures(order_by: {id: desc}, limit: 1) {&#xA;          id&#xA;        }&#xA;        id&#xA;        first_name&#xA;        last_name&#xA;        other_name&#xA;        email&#xA;        mobile_phone1&#xA;        mobile_phone2&#xA;        home_town&#xA;        home_state&#xA;        service&#xA;        birth_date&#xA;        gender&#xA;        date_created&#xA;        current_employer_id&#xA;        domestic_workers_relationships{&#xA;          id&#xA;          payment&#xA;          payment_currency&#xA;          start_date&#xA;          relationship&#xA;          domestic_workers_agent {&#xA;            full_name&#xA;            mobile_phone1&#xA;            domestic_workers_relationships{&#xA;              relationship&#xA;            }&#xA;            domestic_workers_pictures(order_by: {id: desc}, limit: 1) {&#xA;              id&#xA;            }&#xA;          }&#xA;&#xA;&#xA;**domestic_workers_nextofkin (where: {archived:{_is_null: true}}) {&#xA;        full_name&#xA;        mobile_phone1&#xA;         domestic_workers_relationships{&#xA;          relationship&#xA;        }&#xA;      }&#xA;    }**&#xA;        domestic_workers_reviews {&#xA;          id&#xA;          score&#xA;          summary&#xA;          date_created&#xA;          users_user {&#xA;            first_name&#xA;            last_name&#xA;            domestic_workers_pictures(order_by: {id: desc}, limit: 1) {&#xA;              id&#xA;            }&#xA;          }&#xA;        }&#xA;        employerRelationships: domestic_workers_relationships(order_by: {id: desc}, limit: 1, where: {relationship: {_eq: ""Employer""}}) {&#xA;         end_date&#xA;         relationship&#xA;        }&#xA;      }&#xA;    }&#xA;   }&#xA;</code></pre>&#xA;&#xA;<p>It shows the 'where' argument highlighted as red, which possibly means that the 'where' argument shouldnt be placed there which seems rather confusing to me. Can anyone explain why this happens and show me a workaround to pull off the task i'm trying to perform? Thanks.</p>&#xA;",11998047,,,,2020-02-19 13:08:42,Why can't i filter a Deep nested query in graphql?,<graphql><hasura>,1,0,0,2020-02-19 09:46:52
60359563,1,60359718,,0,528,"<p>My Apollo Server have following definition.</p>&#xA;&#xA;<pre><code>input MinMax{&#xA;  min:Float&#xA;  max:Float&#xA;}&#xA;input ScreenerInput{&#xA;  fy:Int!&#xA;  quarter:Int!&#xA;  ltp:MinMax&#xA;  eps:MinMax&#xA;  pe:MinMax&#xA;  netWorth:MinMax&#xA;  paidUp:MinMax&#xA;  reserve:MinMax&#xA;  netProfit:MinMax&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I define <code>MinMax</code> type in Apollo client to send variables for the <code>MinMax</code> type. Till now I was doing scalar types only so my query were simple. </p>&#xA;&#xA;<p>My query type is <code>screeenedCompanies(criteria:ScreenerInput!):[ScreenedCompanies]</code></p>&#xA;&#xA;<p>if I query directly like below it works.</p>&#xA;&#xA;<pre><code>{&#xA;  screeenedCompanies(criteria:{&#xA;    fy:2075&#xA;    quarter:2&#xA;    eps:{&#xA;      min:30&#xA;      max:40&#xA;    }&#xA;  }){&#xA;    sector&#xA;    symbol&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What I want is to query like this so that variables can be changed</p>&#xA;&#xA;<pre><code>query getScreenedCompanies($criteria:&lt;What type should be here ?&gt;){  &#xA;&#xA;{&#xA;  screeenedCompanies(criteria:$criteria){&#xA;    sector&#xA;    symbol&#xA;  }&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>After giving <code>ScreenerInput</code> as type my query looks like below</p>&#xA;&#xA;<pre><code>query getScreenedCompanies($criteria:ScreenerInput!){  &#xA;  screeenedCompanies(criteria:$criteria){&#xA;    sector&#xA;    symbol&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>my variables in apolloplayground look like below</p>&#xA;&#xA;<pre><code>{&#xA;  ""criteria"": {&#xA;    ""fy"": 2075&#xA;    ""quarter"": 4&#xA;    ""ltp"": {&#xA;      ""min"": 345&#xA;      ""max"": 400&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I am receiving the following error</p>&#xA;&#xA;<pre><code>  ""error"": {&#xA;    ""errors"": [&#xA;      {&#xA;        ""message"": ""Variable \""$criteria\"" of required type \""ScreenerInput!\"" was not provided.""&#xA;</code></pre>&#xA;",1273407,,1273407,2020-02-23 09:12:20,2020-02-23 09:12:20,How can I define type in gql query in Apollo Client?,<graphql><apollo><apollo-client>,1,0,0,2020-02-23 05:49:21
60366424,1,60367065,,1,801,"<p>If we have todos items like array of objects inside apollo client state cache - todos: [{name: 'First', id: 1}, {name: 'Second', id: 2}]. Is there is a way to query by id only the object that we need. Something like reselect - selector in redux. I want to subscribe by id.</p>&#xA;",9587213,,,,2020-02-25 03:51:26,Apollo local state - how to query by id,<reactjs><graphql><react-apollo><apollo-client>,1,0,0,2020-02-23 20:15:53
60389096,1,61198373,,4,939,"<p>In the relay documentation <a href=""https://relay.dev/docs/en/graphql-server-specification#mutations"" rel=""nofollow noreferrer"">here</a>, it says that:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Relay uses a common pattern for mutations, where there are root fields on the mutation type with a single argument, input, and <strong>where the input and output both contain a client mutation identifier</strong> used to reconcile requests and responses.</p>&#xA;</blockquote>&#xA;&#xA;<p>But in the example they provided, the input and output looked like this respectively:</p>&#xA;&#xA;<pre><code>// IntroducedShipInput&#xA;{&#xA;  ""input"": {&#xA;    ""shipName"": ""B-Wing"",&#xA;    ""factionId"": ""1""&#xA;  }&#xA;}&#xA;&#xA;// IntroducedShipPayload&#xA;{&#xA;  ""introduceShip"": {&#xA;    ""ship"": {&#xA;      ""id"": ""U2hpcDo5"",&#xA;      ""name"": ""B-Wing""&#xA;    },&#xA;    ""faction"": {&#xA;      ""name"": ""Alliance to Restore the Republic""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So what is the <code>client mutation</code> identifier? And why, and how does it get used to reconcile requests and responses?</p>&#xA;",1008340,,,,2020-04-13 23:25:13,"In Relay.js, what is the `Client Mutation Identifier`?",<graphql><graphql-js><relayjs><relay><relaymodern>,1,3,0,2020-02-25 07:01:37
60390419,1,60403599,,1,1842,"<p>After successfully executing a query, I can see the following (image attached) using Apollo Dev Tools.</p>&#xA;&#xA;<p>However, I'm unable to query for a <code>filter</code> object directly with the ID, say, 2025. I'm getting an <code>Uncaught Invariant Violation: Can't find field filters on ROOT_QUERY object</code>.</p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/IHQdG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IHQdG.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>Here's how I'm trying to query:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>client.cache.readQuery({&#xD;&#xA;  query: gql`&#xD;&#xA;    query Filter {&#xD;&#xA;      filters {&#xD;&#xA;        key&#xD;&#xA;        value&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  `&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>I also tried with fragment as follows:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>client.readFragment({&#xD;&#xA;  id: '2025',&#xD;&#xA;  fragment: gql`&#xD;&#xA;    fragment filter on filters {&#xD;&#xA;      id&#xD;&#xA;      key&#xD;&#xA;      value&#xD;&#xA;    }&#xD;&#xA;  `&#xD;&#xA;});</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>But that gives me null.</p>&#xA;",243302,,2980607,2020-02-26 02:16:43,2020-02-26 02:16:43,Reading a Fragment from the Apollo Cache with client.readFragment(),<apollo><react-apollo><apollo-client>,1,0,0,2020-02-25 08:34:14
60398294,2,,60350528,0,,"<p>I resolved the issue by editing the generated resolvers;</p>&#xA;&#xA;<p>by replacing</p>&#xA;&#xA;<pre><code>t.crud.addresses({filtering: true, ordering: true});&#xA;</code></pre>&#xA;&#xA;<p>with</p>&#xA;&#xA;<pre><code>t.list.field('addresses', {&#xA;      type: 'Address',&#xA;      resolve: (_parent, _args, ctx) =&gt; {&#xA;        return ctx.prisma.address.findMany({&#xA;          where: {&#xA;            user: {&#xA;              id: ctx.userId&#xA;            }&#xA;          }&#xA;        })&#xA;      }&#xA;    });&#xA;</code></pre>&#xA;",10387735,,,,2020-02-25 15:41:31,"",,0,0,0,2020-02-25 15:41:31
60403599,2,,60390419,3,,"<p>You need to specify the object with the<code>__typename</code> and id that you are querying out of the cache. Notice that the id of the <code>filters</code> object is <code>filters:[id]</code> inside the Apollo Cache, that is the format you need to use to access that fragment in the cache, <code>[__typename]:[key]</code>. You can read more about assigning cache identifiers in the <a href=""https://www.apollographql.com/docs/react/caching/cache-configuration/#assigning-unique-identifiers"" rel=""nofollow noreferrer"">docs</a>.</p>&#xA;&#xA;<p>You access your fragment using the following:</p>&#xA;&#xA;<pre><code>const filter = client.readFragment({&#xA;  fragment: gql`&#xA;    fragment filter on filters {&#xA;      id&#xA;      key&#xA;      value&#xA;    }&#xA;  `,&#xA;  fragmentName: 'filter',&#xA;  id: 'filter:2025'&#xA;})&#xA;</code></pre>&#xA;",2980607,,2980607,2020-02-25 21:47:55,2020-02-25 21:47:55,"",,0,0,0,2020-02-25 21:42:51
60404681,2,,60403402,1,,"<p>By using the <code>@paginate</code> directive, you transform the type of your field to a Paginator type specific to the original field's type. This is explained in <a href=""https://lighthouse-php.com/master/api-reference/directives.html#paginate"" rel=""nofollow noreferrer"">the docs</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>This directive is meant to be used on root query fields:</p>&#xA;&#xA;<pre><code>type Query {&#xA;   posts: [Post!]! @paginate&#xA;}&#xA;</code></pre>&#xA;  &#xA;  <p>The schema definition is automatically transformed to this:</p>&#xA;&#xA;<pre><code>type Query {&#xA;   posts(first: Int!, page: Int): PostPaginator&#xA;}&#xA;&#xA;""A paginated list of Post items.""&#xA;type PostPaginator {&#xA;   ""A list of Post items.""&#xA;   data: [Post!]!&#xA;&#xA;   ""Pagination information about the list of items.""&#xA;   paginatorInfo: PaginatorInfo!&#xA;}&#xA;</code></pre>&#xA;  &#xA;  <p>And can be queried like this:</p>&#xA;&#xA;<pre><code>{&#xA;   posts(first: 10) {&#xA;       data {&#xA;           id&#xA;           title&#xA;       }&#xA;       paginatorInfo {&#xA;           currentPage&#xA;           lastPage&#xA;       }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;</blockquote>&#xA;",6024220,,,,2020-02-25 23:33:44,"",,0,3,0,2020-02-25 23:33:44
60424908,1,60425760,,0,36,"<p>Hi Everyone I am just trying to learn graphql as I am using Gatsby. I want to know does each field in graphql take an argument or does it need to be defined somehow before. So for example if you visit this link <a href=""https://i.stack.imgur.com/Tnjpa.png"" rel=""nofollow noreferrer"">graphql search results</a></p>&#xA;&#xA;<p><a href=""https://graphql.org/swapi-graphql?query=%7B%0A%09allPeople%20%7B%0A%09%20%20people%20%7B%0A%09%20%20%20%20id%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20birthYear%0A%20%20%20%20%20%20eyeColor%0A%09%20%20%7D%0A%09%7D%0A%7D%0A"" rel=""nofollow noreferrer"">https://graphql.org/swapi-graphql?query=%7B%0A%09allPeople%20%7B%0A%09%20%20people%20%7B%0A%09%20%20%20%20id%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20birthYear%0A%20%20%20%20%20%20eyeColor%0A%09%20%20%7D%0A%09%7D%0A%7D%0A</a></p>&#xA;&#xA;<p>If i wanted to limit people by eye color how would I do that. In the docs it seems easy as you would just do something like <code>people(eyecolor: 'brown')</code> but that doesn't seem possible. Am I missing something? I basically want to do a SQL style search for all people where eye color is brown. </p>&#xA;&#xA;<p>Thanks.</p>&#xA;",6506712,,,,2020-02-27 03:16:11,"How are arguments added to GraphQL, do they need to be defined before?",<graphql><arguments>,2,0,0,2020-02-27 01:07:48
60425693,2,,60424908,0,,"<p>When you start developing in Gatsby and actually pull your data into Gatsby, there will be a <em>filter</em> query option that automatically becomes available in the query arguments.</p>&#xA;&#xA;<p><a href=""https://www.gatsbyjs.org/docs/graphql-reference/#filter"" rel=""nofollow noreferrer"">https://www.gatsbyjs.org/docs/graphql-reference/#filter</a></p>&#xA;&#xA;<p>You can expect to be able to filter your <strong>people</strong> by <strong>eyeColor</strong> by using the below query:</p>&#xA;&#xA;<pre><code>{&#xA;  allPeople(filter: { eyeColor: { eq: ""brown"" } }) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        birthYear&#xA;        eyeColor&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",9984918,,,,2020-02-27 03:05:40,"",,0,0,0,2020-02-27 03:05:40
60425994,2,,56423226,4,,"<p>There are a number of places you can <code>import graphql from</code>. I see above you are importing from react-relay.</p>&#xA;&#xA;<p>I found that if I changed from </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import { graphql, QueryRenderer } from ""react-relay"";&#xA;</code></pre>&#xA;&#xA;<p>to</p>&#xA;&#xA;<pre><code>import { QueryRenderer } from ""react-relay"";&#xA;import graphql from 'babel-plugin-relay/macro';&#xA;</code></pre>&#xA;&#xA;<p>it fixed my problem. I think this is because the presets determined by the <code>""babel"":</code> key in the package.json apply to the babel plugin's graphql and not react-relay's graphql.</p>&#xA;",1978448,,,,2020-02-27 03:51:34,"",,0,1,0,2020-02-27 03:51:34
60482861,1,,,0,111,"<p>I have a django model like this...</p>&#xA;&#xA;<pre><code>class ConversionResults(models.Model):&#xA;conversion_results_id = models.AutoField(primary_key=True)&#xA;conversion_rate_a = models.DecimalField(max_digits=4, decimal_places=2)&#xA;clicks_a = models.IntegerField()&#xA;conversion_rate_b = models.DecimalField(max_digits=4, decimal_places=2)&#xA;clicks_b = models.IntegerField()&#xA;week = models.IntegerField()&#xA;date = models.DateField()&#xA;time = models.TimeField()&#xA;&#xA;objects = models.Manager()&#xA;&#xA;class Meta:&#xA;    db_table = 'conversion_results'&#xA;&#xA;def __int__(self):&#xA;    return self. conversion_results_id&#xA;</code></pre>&#xA;&#xA;<p>When I try to add data to the model, like below</p>&#xA;&#xA;<pre><code>ConversionResults(&#xA;                conversion_rate_a=conversion_rate_today_a,&#xA;                conversion_rate_b=conversion_rate_today_b,&#xA;                clicks_a=ctc_today_a,&#xA;                clicks_b=ctc_today_b,&#xA;                week=week,&#xA;                date=today_date,&#xA;                time=datetime.datetime.today().time()   # the error is here&#xA;            ).save()&#xA;</code></pre>&#xA;&#xA;<p>I am getting error with the time field as shown below</p>&#xA;&#xA;<pre><code>graphql.error.located_error.GraphQLLocatedError: [&lt;class 'decimal.InvalidOperation'&gt;]&#xA;</code></pre>&#xA;&#xA;<p>I don't get how this is even related to decimal, the model contains a TimeField. Any help will be appreciated</p>&#xA;&#xA;<p>Below is the full Traceback</p>&#xA;&#xA;<pre><code>    Traceback (most recent call last):&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/promise/promise.py"", line 487, in _resolve_from_executor&#xA;    executor(resolve, reject)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/promise/promise.py"", line 754, in executor&#xA;    return resolve(f(*args, **kwargs))&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/graphql/execution/middleware.py"", line 75, in make_it_promise&#xA;    return next(*args, **kwargs)&#xA;  File ""/home/shashank/project/server/data_distribution/query.py"", line 416, in resolve_daily_updates&#xA;    time=datetime.datetime.today().time()  # the error is here &#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/base.py"", line 741, in save&#xA;    force_update=force_update, update_fields=update_fields)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/base.py"", line 779, in save_base&#xA;    force_update, using, update_fields,&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/base.py"", line 870, in _save_table&#xA;    result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/base.py"", line 908, in _do_insert&#xA;    using=using, raw=raw)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/manager.py"", line 82, in manager_method&#xA;    return getattr(self.get_queryset(), name)(*args, **kwargs)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/query.py"", line 1186, in _insert&#xA;    return query.get_compiler(using=using).execute_sql(return_id)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/sql/compiler.py"", line 1331, in execute_sql&#xA;    for sql, params in self.as_sql():&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/sql/compiler.py"", line 1275, in as_sql&#xA;    for obj in self.query.objs&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/sql/compiler.py"", line 1275, in &lt;listcomp&gt;&#xA;    for obj in self.query.objs&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/sql/compiler.py"", line 1274, in &lt;listcomp&gt;&#xA;    [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/sql/compiler.py"", line 1215, in prepare_value&#xA;    value = field.get_db_prep_save(value, connection=self.connection)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/models/fields/__init__.py"", line 1563, in get_db_prep_save&#xA;    return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/backends/base/operations.py"", line 516, in adapt_decimalfield_value&#xA;    return utils.format_number(value, max_digits, decimal_places)&#xA;  File ""/home/shashank/anaconda3/lib/python3.6/site-packages/django/db/backends/utils.py"", line 238, in format_number&#xA;    value = value.quantize(decimal.Decimal(1).scaleb(-decimal_places), context=context)&#xA;graphql.error.located_error.GraphQLLocatedError: [&lt;class 'decimal.InvalidOperation'&gt;]&#xA;</code></pre>&#xA;",9066431,,9066431,2020-03-02 10:44:32,2020-03-02 10:44:32,Unable to add time to TimeField in django model [<class 'decimal.InvalidOperation'>],<django><django-models><graphql>,0,9,0,2020-03-02 05:12:12
60521170,2,,60506575,0,,"<p>I was able to achieve by using <strong>graphQL</strong> <strong>fragments</strong></p>&#xA;&#xA;<p><em>Fragment</em></p>&#xA;&#xA;<pre><code>const docFragment = `&#xA;    fragment DocWithDetails on Doc {&#xA;        name&#xA;        teams{&#xA;            id&#xA;            role&#xA;          }&#xA;    }`&#xA;</code></pre>&#xA;&#xA;<p>Then I passed the graphQL fragment into the resolver. This was I was able to retrieve the nested relations </p>&#xA;&#xA;<pre><code>const singleDoc = async (_parent, args, context, info) =&gt; {&#xA;    try {&#xA;        return await context.prisma.doc({ id: args.docId }).$fragment(docFragment)&#xA;    } catch (error) {&#xA;        console.log(error)&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",11444142,,,,2020-03-04 07:42:22,"",,0,0,0,2020-03-04 07:42:22
60567357,1,,,-1,32,"<p>I am writing a function in which one of the parameters is and INT weekday for the current day. If the day is Sunday, it will be 1, and a Monday will be a 2, etc. </p>&#xA;&#xA;<p>Inside of my database, there is a table for each item on an order sheet. They have many columns and 7 of them are isSunday, isMonday, isTuesday, etc. They have a boolean value for if the item is buyable on that given day. </p>&#xA;&#xA;<p>So I need to take that INT of 1 or whatever and figure out what day of the week that is. Then compare it to the isSunday or watever column to see if the value is true. If it is, it will return the entire row for that item. If the value is 0 for that given day, it will not return that item. </p>&#xA;&#xA;<p>PS another parameter I am getting is the time of day. This figures out if the time is between the starttime and endtime because some items are only sold in the morning like breakfast. </p>&#xA;&#xA;<p>I was thinking that instead of getting 2 different parameters for INT weekday and TIME timeofday, i just got one large calendar value that had the date and time in it. And then split it up to compare it to the columns, but I dont know if that is making it too complex. </p>&#xA;&#xA;<p>this is the schema </p>&#xA;&#xA;<pre><code>getLocationLiveMenu(p_locationID: Int!, p_timeofday: time, p_dayofweek: int): [LocationMenu]&#xA;</code></pre>&#xA;&#xA;<p>[LocationMenu]</p>&#xA;&#xA;<p>it would be stored here. an array within an array.</p>&#xA;&#xA;<pre><code>type LocationMenu {&#xA;    locationID: Int&#xA;    menucategoryID: Int&#xA;    name: String&#xA;    menuItems: [LocationMenuItem]&#xA;}&#xA;&#xA;type LocationMenuItem {&#xA;    locationMenuItemID: Int&#xA;    locationID: Int&#xA;    name: String&#xA;    description: String&#xA;    price: Float&#xA;    photo: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this livemenuget needs to be one function. 2 separate is not acceptable</p>&#xA;&#xA;<p>this is calling on a stored procedure in the sql server which i also have to create</p>&#xA;&#xA;<pre><code>SELECT  s.startTime, s.endTime, s.description, s.locationID, s.onSunday, s.onMonday, s.onTuesday, s.onWednesday, s.onThursday, s.onFriday, s.onSaturday, l.locationMenuItemID, l.menuCategoryID, l.name, l.description, l.price, l.photo, l.isAllDay, l.scheduleID&#xA;  FROM company.menuschedules s left join company.locationmenuitem l on l.locationID = s.locationID where p_locationID = l.locationID and p_currentTime BETWEEN s.startTime AND s.endTime &#xA;  and if(&#xA;        p_weekday = 1&#xA;        then check isMonday&#xA;        or if p_weekday = 2&#xA;        then check isTuesday&#xA;        ...&#xA;        ...&#xA;&#xA;        )&#xA;&#xA;       if booleanvalue = true then return locationmenuitem&#xA;;&#xA;</code></pre>&#xA;",13019725,,1529673,2020-03-06 16:27:24,2020-03-06 16:31:30,"I am receiving an int from 1-7 for the day of the week, and I need to compare it to 7 weekday columns?",<mysql><amazon-web-services><datetime><graphql><schema>,1,5,0,2020-03-06 15:42:00
60568115,2,,60567357,0,,"<p>Instead of a column for each day of the week, consider either: </p>&#xA;&#xA;<p>a) storing a bitwise value for weekdays, whereby 1 = Sunday, 2 = Monday, 4 = Tuesday, and 128 = Every day.</p>&#xA;&#xA;<p>or </p>&#xA;&#xA;<p>b) storing the week days in a separate table, with a separate row for each location/weekday pairing.</p>&#xA;",1529673,,,,2020-03-06 16:31:30,"",,0,0,0,2020-03-06 16:31:30
60577601,1,,,4,1775,"<p>I am using `` query:</p>&#xA;&#xA;<pre><code>const GET_COMMENTS = gql`&#xA;    query getComments {&#xA;        getComments (where: {code: ""/about-us"" }) {&#xA;            id&#xA;            text&#xA;            createdAt&#xA;        }&#xA;    }&#xA;`&#xA;....&#xA;const { loading, error, data } = useQuery(GET_COMMENTS);&#xA;</code></pre>&#xA;&#xA;<p>in my code...</p>&#xA;&#xA;<p>The code is fetching comments from the server in comment object is a <code>date: string!</code> property, I would like to transform this <code>date: string!</code> into javascript date (<code>new Date(comment.date)</code>) how can I do it directly after data fetch?</p>&#xA;&#xA;<p>I don't want to transform every render is called.</p>&#xA;&#xA;<p>Is there any something like this?:</p>&#xA;&#xA;<pre><code>const { loading, error, data } = &#xA;   useQuery(&#xA;      GET_COMMENTS, &#xA;      {&#xA;         transform: (data) =&gt; data.map(comment =&gt; ({...comment , date: new Date(comment.date)}) )&#xA;      }&#xA;   );&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Thank you for your help!</p>&#xA;",13021304,,,,2022-07-20 07:31:30,How to transform received data from @apollo/react-hooks,<graphql><react-hooks><react-apollo>,3,0,0,2020-03-07 12:37:46
60578268,2,,60252084,0,,"<p>filter returns a new list that satisfy the given condition, so you're returning a list than an item(object) of the list</p>&#xA;",10521453,,,,2020-03-07 13:56:07,"",,0,0,0,2020-03-07 13:56:07
60639335,2,,60639186,2,,"<p>Use <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"" rel=""nofollow noreferrer""><code>Array.protoype.sort()</code></a> to sort the 'choices' with a custom function;</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const data = [&#xD;&#xA;    {&#xD;&#xA;        ""label"": ""No"",&#xD;&#xA;        ""value"": ""{\""value\"":\""0\""}"",&#xD;&#xA;        ""dataUID"": null,&#xD;&#xA;        ""description"": ""No"",&#xD;&#xA;        ""order"": 1,&#xD;&#xA;        ""goto"": null&#xD;&#xA;    },&#xD;&#xA;    {&#xD;&#xA;        ""label"": ""Yes"",&#xD;&#xA;        ""value"": ""{\""value\"":\""1\""}"",&#xD;&#xA;        ""dataUID"": null,&#xD;&#xA;        ""description"": ""Yes"",&#xD;&#xA;        ""order"": 0,&#xD;&#xA;        ""goto"": null&#xD;&#xA;    }&#xD;&#xA;];&#xD;&#xA;&#xD;&#xA;// Full function for readability&#xD;&#xA;function orderByOrderValue( a, b ) {&#xD;&#xA;  if ( a.order &lt; b.order ){&#xD;&#xA;    return -1;&#xD;&#xA;  }&#xD;&#xA;  if ( a.order &gt; b.order ){&#xD;&#xA;    return 1;&#xD;&#xA;  }&#xD;&#xA;  return 0;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;console.log(data.sort(orderByOrderValue));&#xD;&#xA;&#xD;&#xA;// Or use the one-liner&#xD;&#xA;// data.sort((a,b) =&gt; (a.id &gt; b.id) ? 1 : ((b.id &gt; a.id) ? -1 : 0)); </code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",5625547,,5625547,2020-03-11 15:27:28,2020-03-11 15:27:28,"",,0,1,0,2020-03-11 15:22:04
60640540,2,,52046495,0,,"<p>You don't need the extra brackets. And the correct syntax is ""beginsWith"".&#xA;So your example should look like this:</p>&#xA;&#xA;<pre><code>{&#xA;    ""version"": ""2017-02-28"",&#xA;    ""operation"": ""Scan"",&#xA;    ""filter"" : $util.transform.toDynamoDBFilterExpression({&#xA;        PartitionKey:{&#xA;            beginsWith:""Model""&#xA;        }&#xA;      })&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For other comparisons use:</p>&#xA;&#xA;<p>ne: Not equals&#xA;  eq: Equals&#xA;  le: Lower or equal&#xA;  lt: Lower than&#xA;  ge: Greater or equal&#xA;  gt: Greater than&#xA;  contains: Contains (For array or string)&#xA;  notContains: Not contains (Same, array or string) &#xA;  between: Between (Needs two arguments)&#xA;  beginsWith: Begins with</p>&#xA;",2734484,,,,2020-03-11 16:26:42,"",,0,0,0,2020-03-11 16:26:42
60641202,2,,60639186,0,,"<p>You can easily implement a <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"" rel=""nofollow noreferrer"">sort</a> function:</p>&#xA;&#xA;<pre><code>data.sort((a, b) =&gt; a.order - b.order);&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>If compareFunction(a, b) returns less than 0, sort a to an index    lower than b (i.e. a comes first).</p>&#xA;  &#xA;  <p>If compareFunction(a, b) returns 0, leave a and b unchanged with    respect to each other, but sorted with respect to all different<br>&#xA;  elements. Note: the ECMAscript standard does not guarantee this<br>&#xA;  behavior, thus, not all browsers (e.g. Mozilla versions dating back<br>&#xA;  to at least 2003) respect this.</p>&#xA;  &#xA;  <p>If compareFunction(a, b) returns greater than 0, sort b to an index    lower than a (i.e. b comes first).</p>&#xA;</blockquote>&#xA;&#xA;<p>Following those rules, if you subtract the first appearing element's order with the following one you get the correct output for the sort function.</p>&#xA;",3154167,,,,2020-03-11 17:08:12,"",,0,0,0,2020-03-11 17:08:12
60671066,2,,60488408,0,,<p>Try to use TypeORM QueryBuilder and make some inner joins to filter projects that does not belong to selected user.</p>&#xA;,5472617,,,,2020-03-13 13:08:39,"",,0,0,0,2020-03-13 13:08:39
60674478,1,,,0,1019,"<p>I'm trying a mutation query in Android using ApolloClient below is my <code>.graphql</code> file</p>&#xA;&#xA;<pre><code>mutation insertAddress($city: String, $landmark: String, $postcode: Int, $state: String, $type: String, $userUuid: String) {&#xA;    __typename&#xA;    insert_addresses(objects: {city: $city, landmark: $landmark, postcode: $postcode, state: $state, type: $type, userUuid: $userUuid}) {&#xA;      returning {&#xA;          uuid&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm getting the error as <code>com.sample.app\InsertAddress.graphql (3:30) Can't parse `Array` value, expected array</code>&#xA;Please help me to solve this error.</p>&#xA;",7490886,,,,2020-03-13 19:25:42,"Graphql is returing the error as ""Can't parse `Array` value, expected array"" when I'm trying to run gradle",<android><kotlin><graphql><apollo-client><hasura>,1,0,0,2020-03-13 16:58:19
60676195,2,,60674478,4,,"<p>Can you try </p>&#xA;&#xA;<pre><code>    mutation insertAddress($city: String, $landmark: String, $postcode: Int, $state: String, $type: String, $userUuid: String) {&#xA;    __typename&#xA;    insert_addresses(objects: [{city: $city, landmark: $landmark, postcode: $postcode, state: $state, type: $type, userUuid: $userUuid}]) {&#xA;      returning {&#xA;          uuid&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;",13058701,,,,2020-03-13 19:25:42,"",,0,1,0,2020-03-13 19:25:42
60708968,1,,,-1,1545,"<p>I have an interface, for detail input value:</p>&#xA;&#xA;<pre><code>input DocumentDetailInput {&#xA;  vat: Float!&#xA;  isSaleWithPrescription: Boolean!&#xA;  valueCountRound: Float!&#xA;  paymentType: String!&#xA;  exportNoBill: Boolean!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then, i want add only 2 value:</p>&#xA;&#xA;<pre><code>      detail: {&#xA;        vat: input.vat,&#xA;        exportNoBill: input.exportNobill&#xA;      },&#xA;</code></pre>&#xA;&#xA;<p>error:</p>&#xA;&#xA;<pre><code>is missing the following properties from type 'DocumentDetail': valueCountRound, isSaleWithPrescription, paymentType.ts(2740)&#xA;</code></pre>&#xA;",12489942,,,,2020-03-19 03:30:02,"TS2740 is missing the following properties from type, Typescript, NestJS",<javascript><mongodb><types><graphql><nestjs>,1,2,0,2020-03-16 15:41:28
60720764,1,60721013,,0,348,"<p>I'm using Symfony 5 with the latest version of api-platform. Running PHP 7.3.</p>&#xA;&#xA;<p>I'm using the graphql api and trying to achieve a number based pagination.&#xA;In the <a href=""https://api-platform.com/docs/core/graphql/#pagination"" rel=""nofollow noreferrer"">current documentation</a> only cursor based pagination is explained. OR is there a way to paginate like [1][2][3][4][5] based on the cursor? AFAIK not.</p>&#xA;&#xA;<p>I've also read the <code>ApiPlatform\Core\DataProvider\Pagination</code> class and looked into the <code>getOffset</code> and <code>getLimit</code> functions. So I tried in my query to pass numeric values but it resulted in ""Cursor 0 is invalid"".</p>&#xA;&#xA;<p>The query:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>`before: ""0"", after: ""10""`&#xA;query SearchOrders($first: Int!) {&#xA;  orders(first: $first, before: ""1"", after: ""10"") {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2535171,,,,2020-03-17 11:01:04,Pagination using numbers instead of cursor,<php><symfony><graphql><api-platform.com>,1,0,0,2020-03-17 10:47:03
60725636,2,,60709951,3,,"<p>The <code>OR</code> condition in the search filter is not handled by default in API Platform, you need a custom filter to do this (<a href=""https://api-platform.com/docs/core/filters/#creating-custom-filters"" rel=""nofollow noreferrer"">https://api-platform.com/docs/core/filters/#creating-custom-filters</a>).</p>&#xA;&#xA;<p>See also: <a href=""https://github.com/api-platform/core/issues/2400"" rel=""nofollow noreferrer"">https://github.com/api-platform/core/issues/2400</a>.</p>&#xA;",5049897,,,,2020-03-17 15:40:28,"",,0,0,0,2020-03-17 15:40:28
60726745,2,,60683060,1,,"<p>You need something like this to work with components:    </p>&#xA;&#xA;<pre><code>mutation($text: String!) {&#xA;  updateImpressum {&#xA;    impressum {&#xA;      inhalt {&#xA;        __typename&#xA;        ... on MyComponentName {&#xA;            text: $text&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<blockquote>&#xA;  <p>Tip: use the /graphql client to autocomplete component types by typing&#xA;  ""... on ""</p>&#xA;  &#xA;  <p>Tip2: Use fragments</p>&#xA;</blockquote>&#xA;",2755733,,,,2020-03-17 16:47:39,"",,0,1,0,2020-03-17 16:47:39
60744053,1,,,13,1896,"<p>I am working on a application in which a ship can be configured using rudders and other stuff. The database structure is sort of nested, and so far I have been keeping my GraphQL queries in correspondence with the database.</p>&#xA;&#xA;<p>That means: I could fetch a ship using some query ship(projectId, shipId), but instead I am using a nested query:</p>&#xA;&#xA;<pre><code>query {&#xA;    project(id:1) {&#xA;        id&#xA;        title&#xA;        ship(id:1) {&#xA;            id&#xA;            name&#xA;            rudders {&#xA;                id&#xA;                position&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Such a structure of course leads to a lot of nested arrays. For example, if I have just added a new rudder, I would have to retrieve using cache.readQuery, which gives me the project object rather than the rudder list. To add the rudder to the cache, I'd get a long line with nested, destructured objects, making the code hard to read.</p>&#xA;&#xA;<p>So I thought of using GraphQL fragments. On the internet, I see them being used a lot to prevent having to re-type several fields on extensive objects (which I personally find very useful as well!). However, there are not so many examples where a fragment is used for an array. </p>&#xA;&#xA;<p>Fragments for arrays could save all the object destructuring when appending some data to an array that is nested in some cached query. Using Apollo's readFragment and writeFragment, I managed to get something working.</p>&#xA;&#xA;<p>The fragment:</p>&#xA;&#xA;<pre><code>export const FRAGMENT_RUDDER_ARRAY = gql`&#xA;    fragment rudderArray on ShipObject {&#xA;        rudders {&#xA;            id&#xA;            position&#xA;        }&#xA;    }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Used in the main ship query:</p>&#xA;&#xA;<pre><code>query {&#xA;    project(id: ...) {&#xA;        id&#xA;        title&#xA;        ship(id: ...) {&#xA;            id&#xA;            name&#xA;            ...rudderArray&#xA;        }&#xA;    }&#xA;}&#xA;${RUDDER_FRAGMENT_ARRAY}&#xA;</code></pre>&#xA;&#xA;<p>Using this, I can write a much clearer update() function to update Apollo's cache after a mutation. See below:</p>&#xA;&#xA;<pre><code>const [ createRudder ] = useMutation(CREATE_RUDDER_MUTATION, {&#xA;    onError: (error) =&gt; { console.log(JSON.stringify(error))},&#xA;    update(cache, {data: {createRudder}}) {&#xA;        const {rudders} = cache.readFragment({&#xA;            id: `ShipObject:${shipId}`,&#xA;            fragment: FRAGMENT_RUDDER_ARRAY,&#xA;            fragmentName: 'rudderArray'&#xA;        });&#xA;&#xA;        cache.writeFragment({&#xA;            id: `ShipObject:${shipId}`,&#xA;            fragment: FRAGMENT_RUDDER_ARRAY,&#xA;            fragmentName: 'rudderArray',&#xA;            data: {rudders: rudders.concat(createRudder.rudder)}&#xA;        });&#xA;    }&#xA;});&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Now what is my question? Well, since I almost never see fragments being used for this end, I find this working well, but I am wondering if there's any drawbacks to this.</p>&#xA;&#xA;<p>On the other hand, I also decided to share this because I could not find any examples. So if this is a good idea, feel free to use the pattern!</p>&#xA;",10830219,,5421321,2020-03-18 17:25:14,2020-03-18 17:25:14,Using Apollo's writeFragment to update nested list,<javascript><reactjs><graphql><react-apollo>,0,0,0,2020-03-18 16:52:14
60745188,1,,,2,2346,"<p>I want to bulk update list of entries with graphQL  mutation in faunaDB.&#xA;The input data is list of coronavirus cases from external source. It will be updated frequently. The mutation should update existing entries if the entry name is present in collectio and create new ones if not present.</p>&#xA;&#xA;<p>Current GRAPHQL MUTATION</p>&#xA;&#xA;<pre><code>mutation UpdateList($data: ListInput!) {&#xA;  updateList(id: ""260351229231628818"", data: $data) {&#xA;    title&#xA;    cities {&#xA;      data {&#xA;        name&#xA;        infected&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>GRAPHQL VARIABLES</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""title"": ""COVID-19"",&#xA;    ""cities"": {&#xA;      ""create"": [&#xA;        {&#xA;          ""id"": 22,&#xA;          ""name"": ""Warsaw"",&#xA;          ""location"": {&#xA;            ""create"": {&#xA;              ""lat"": 52.229832,&#xA;              ""lng"": 21.011689&#xA;            }&#xA;          },&#xA;          ""deaths"": 0,&#xA;          ""cured"": 0,&#xA;          ""infected"": 37,&#xA;          ""type"": ""ACTIVE"",&#xA;          ""created_timestamp"": 1583671445,&#xA;          ""last_modified_timestamp"": 1584389018&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>SCHEMA</p>&#xA;&#xA;<pre><code>type cityEntry {&#xA;  id: Int!&#xA;  name: String!&#xA;  deaths: Int!&#xA;  cured: Int!&#xA;  infected: Int!&#xA;  type: String!&#xA;  created_timestamp: Int!&#xA;  last_modified_timestamp: Int!&#xA;  location: LatLng!&#xA;  list: List&#xA;}&#xA;&#xA;type LatLng {&#xA;  lat: Float!&#xA;  lng: Float!&#xA;}&#xA;&#xA;type List {&#xA;  title: String!&#xA;  cities: [cityEntry] @relation&#xA;}&#xA;&#xA;type Query {&#xA;  items: [cityEntry!]&#xA;  allCities: [cityEntry!]&#xA;  cityEntriesByDeathFlag(deaths: Int!): [cityEntry!]&#xA;  cityEntriesByCuredFlag(cured: Int!): [cityEntry!]&#xA;  allLists: [List!]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Everytime the mutation runs it creates new duplicates.&#xA;What is the best way to update the list within single mutation?</p>&#xA;",1276919,,1276919,2020-03-19 08:38:46,2020-05-12 12:47:59,FaunaDB - How to bulk update list of entries within single graphQL mutation?,<graphql><bulk><mutation><faunadb>,1,5,0,2020-03-18 18:06:05
60758881,1,60759062,,0,1113,"<p>I am following the <a href=""https://www.apollographql.com/docs/react/data/pagination/#cursor-based"" rel=""nofollow noreferrer"">official docs</a> for cursor based Apollo Client implementation. I have already done the offset based pagination but cursor based seemed to be better fit in my case. The very first line is giving an error</p>&#xA;&#xA;<p><code>const { data: { comments, cursor }, loading, fetchMore } = useQuery(&#xA;    MORE_COMMENTS_QUERY&#xA;  );</code></p>&#xA;&#xA;<p><code>cannot read property 'comments' of undefined</code>. This must be because data is still undefined. Is the documentation missing something or am I missing something ?</p>&#xA;",1273407,,,,2020-05-17 07:52:53,How to implement cursor based pagination in graphql Apollo client?,<react-native><graphql><apollo-client>,1,0,0,2020-03-19 14:08:42
60759254,1,60760227,,0,743,"<p>I'm trying to achieve something equivalent to a conditional JOIN query, but then with GraphQL.&#xA;I'm using Mongoose for my db model and MongoDB as database.</p>&#xA;&#xA;<p>I'll illustrate my problem with the following graphQL schema:</p>&#xA;&#xA;<pre><code>type Booking {&#xA;    _id: ID!&#xA;    client: Client!&#xA;    rooms: Room!&#xA;    activities: Activity!&#xA;    nrOfAdults: Int!&#xA;    arrivalDate: String!&#xA;    departureDate: String!&#xA;}&#xA;&#xA;type Room {&#xA;  _id: ID!&#xA;  name: String!&#xA;  contents: String&#xA;  priceNight: Float!&#xA;  maxAdults: Int!&#xA;  reservations: [Booking]&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>The Mongoose schema:</p>&#xA;&#xA;<pre><code>const bookingSchema = new Schema(&#xA;  {&#xA;    client: {&#xA;      type: Schema.Types.ObjectId,&#xA;      ref: 'Client'&#xA;    },&#xA;    rooms: [{&#xA;      type: Schema.Types.ObjectId,&#xA;      ref: 'Rooms'&#xA;    }],&#xA;    nrOfAdults: {&#xA;      type: Number,&#xA;      required: true&#xA;    },&#xA;    arrivalDate: {&#xA;      type: Date,&#xA;      required: true&#xA;    },&#xA;    departureDate: {&#xA;      type: Date,&#xA;      required: true&#xA;    }&#xA;  },&#xA;  { timestamps: true }&#xA;);&#xA;&#xA;const roomSchema = new Schema({&#xA;  name: {&#xA;    type: String,&#xA;    required: true&#xA;  },&#xA;  priceNight: {&#xA;    type: Number,&#xA;    required: true&#xA;  },&#xA;  maxAdults: {&#xA;    type: Number,&#xA;    required: true&#xA;  },&#xA;  reservations: [&#xA;    {&#xA;      type: Schema.Types.ObjectId,&#xA;      ref: 'Booking'&#xA;    }&#xA;  ]&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>I can query rooms, for example, if I want to get the rooms for 3 or more adults I run:</p>&#xA;&#xA;<pre><code>       Room.find({&#xA;         maxAdults: { $gte: 3 }&#xA;       });&#xA;</code></pre>&#xA;&#xA;<p>This works fine.</p>&#xA;&#xA;<p>However, I'd also like to show the <strong>available</strong> rooms, which means I need to impose a condition on the booking objects which are hold in <em>reservation</em>.&#xA;I thought this would be fairly easy, using something like:</p>&#xA;&#xA;<pre><code>       Room.find({&#xA;         maxAdults: { $gte: 3 },&#xA;         reservations: { $elemMatch: { arrivalDate: { $gte: *some date*}}}&#xA;       });&#xA;</code></pre>&#xA;&#xA;<p>But it returns an empty array, while it should return some value, based on the data in mongodb:</p>&#xA;&#xA;<p>To make things a little more clear, I'd like to achieve the same outcome as the following SQL query would give me:</p>&#xA;&#xA;<pre><code>SELECT *&#xA;FROM room&#xA;JOIN booking ON room.id = booking.roomId&#xA;WHERE&#xA;room.maxAdults &gt;= 3&#xA;AND&#xA;(&#xA;booking.arrivalDate &gt; CAST('2020-05-15' AS DATE)&#xA;OR&#xA;booking.departureDare &lt; CAST(2020-05-06' AS DATE)&#xA;)&#xA;</code></pre>&#xA;",13089058,,13089058,2020-03-19 15:08:36,2020-03-24 12:30:43,How to select parent based on children's value using mongoose and GraphQL?,<node.js><mongodb><mongoose><graphql><non-relational-database>,1,2,0,2020-03-19 14:31:55
60784676,2,,54218505,6,,"<p><code>GlobalIDMultipleChoiceFilter</code> from django-graphene kinda solves this issue, if you put ""in"" in the field name. You can create filters like</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>from django_filters import FilterSet&#xA;from graphene_django.filter import GlobalIDMultipleChoiceFilter&#xA;&#xA;class BookFilter(FilterSet):&#xA;    author = GlobalIDMultipleChoiceFilter()&#xA;</code></pre>&#xA;&#xA;<p>and use it by </p>&#xA;&#xA;<pre><code>{&#xA;  books(author: [""&lt;GlobalID1&gt;"", ""&lt;GlobalID2&gt;""]) {&#xA;    edges {&#xA;      nodes {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Still not perfect, but the need for custom code is minimized.</p>&#xA;",1726238,,,,2020-03-21 05:11:17,"",,0,0,0,2020-03-21 05:11:17
60850526,1,,,0,30,"<p>I'm trying to structure my database and backend in a way that would need the less amount of calculation and queries when one object updates. I'm using Apollo-server, Mongoose and MongoDB.</p>&#xA;&#xA;<p>I have </p>&#xA;&#xA;<p><code>FoodPack MANY---MANY Food</code></p>&#xA;&#xA;<p><code>Food MANY---MANY Ingredient</code></p>&#xA;&#xA;<p>Every object there has a <code>kcal</code> property. Right now if I make query allFoodPacks I need to populate all Foods and within Foods all Ingredients so I can calculate a FoodPack's <code>kcal</code> column. </p>&#xA;&#xA;<p>I made the structure like so because when I update one Ingredient's <code>kcal</code>, I don't need to update every Food and FoodPack fields too, as they get calculated with the queries with population.</p>&#xA;&#xA;<p>ANOTHER solution would be to calculate the FoodPack's <code>kcal</code> during creation of the FoodPack object. That way querying FoodPack and it's <code>kcal</code> column wouldn't need deep population, BUT if Ingredient's <code>kcal</code> in the FoodPack's Foods would change, I would need to update all the objects that reference that Ingredient.</p>&#xA;&#xA;<p>Which one would be better solution, assuming the app has decent amount of users?</p>&#xA;",0,user11126091,13302,2020-03-28 12:31:47,2020-03-28 12:31:47,Which one is better - calculate object field with deep population OR calculate field when saving object and update it when necessary?,<database><mongodb><data-structures><apollo-server><population>,0,2,0,2020-03-25 14:07:36
60853978,1,60854311,,16,6718,"<p>I am new to using AWS Amplify and GraphQL.&#xA;Also just started building out React Native App - which is a lot of fun! </p>&#xA;&#xA;<p>I have a table called TimePeriods schema for it looks like this</p>&#xA;&#xA;<pre><code>type TimePeriod @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  startYear: String!&#xA;  endYear: String!,&#xA;  artworks: [ArtWorkTimePeriod] @connection (name: ""TimePeriodArtWorks"") #Many to Many Relationship&#xA;  artists: [ArtistTimePeriod] @connection (name: ""TimePeriodArtists"") #Many to Many Relationship&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In the queries file generated by amplify I have a function called listTimePeriods. </p>&#xA;&#xA;<pre><code>export const listTimePeriods = /* GraphQL */ `&#xA;  query ListTimePeriods(&#xA;    $filter: ModelTimePeriodFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTimePeriods(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        startYear&#xA;        endYear&#xA;        artworks {&#xA;          nextToken&#xA;        }&#xA;        artists {&#xA;          nextToken&#xA;        }&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>What I am trying to do is filter this by condition for example I'd like to get list of all Time Periods where IDs equal 1, 2 or 3. &#xA;I was assuming it could be done in a following manner</p>&#xA;&#xA;<pre><code>export async function GetTimePeriodsByIds(idArr=[]){&#xA;    let filter = {&#xA;        id: {&#xA;            eq: [1,2,3]&#xA;        }&#xA;    };&#xA;    return await API.graphql(graphqlOperation(listTimePeriods, {limit: 20, filter:filter}));&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but I do not think you can do that. If you have any kinds of solution regarding this, it would mean a lot - even just the insight like</p>&#xA;&#xA;<ol>&#xA;<li>If it does not work at all - is there any reason why they decided not to implement it? </li>&#xA;<li><p>Would it be better in the case to use a for loop and call </p>&#xA;&#xA;<p>await API.graphql(graphqlOperation(getTimePeriod, {id: id}));</p></li>&#xA;</ol>&#xA;&#xA;<p>or would it be better to get the whole list and filter it out myself? And by better I mean efficiency - maybe it depends on the number of data that will be listed in the TimePeriod table (if many entries then get one by one from DB, if small number of entries get all and filter it out?)  </p>&#xA;",0,user4770804,,2020-03-25 17:39:06,2021-10-24 08:59:04,How to Filter List/Queries With AND/OR operators AWS Amplify JavaScript GraphQL,<react-native><graphql><aws-amplify><graphql-js><aws-amplify-cli>,2,0,0,2020-03-25 17:18:02
60854311,2,,60853978,24,,"<p>Hello to everyone looking into this question - after a lot of research I found out that it can be achieved like this:</p>&#xA;&#xA;<pre><code>     let filter = {&#xA;            or: [&#xA;                {&#xA;                    id: {eq:1}&#xA;                },&#xA;                {&#xA;                    id: {eq:2}&#xA;                }]&#xA;        };&#xA;return await API.graphql(graphqlOperation(listTimePeriods, {limit: 20, filter:filter}));&#xA;</code></pre>&#xA;&#xA;<p>in order to find out what you can do with AND and OR operations with GraphQL List you need to similar definition in your files</p>&#xA;&#xA;<pre><code>input ModelTimePeriodFilterInput {&#xA;  id: ModelIDInput&#xA;  name: ModelStringInput&#xA;  startYear: ModelStringInput&#xA;  endYear: ModelStringInput&#xA;  and: [ModelTimePeriodFilterInput]&#xA;  or: [ModelTimePeriodFilterInput]&#xA;  not: ModelTimePeriodFilterInput&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which should be located in backend/api/projectname/build/schema.graphql</p>&#xA;&#xA;<p>This means that in a similar manner you can write AND and OR filters.&#xA;Hope this helps - I wish AWS Documentation made this easier to understand </p>&#xA;&#xA;<p>If you have a similar question but cannot find your answer here maybe this post will help - <a href=""https://stackoverflow.com/questions/41515226/graphql-filter-data-in-an-array"">GraphQL: Filter data in an array</a> </p>&#xA;",0,user4770804,,,2020-03-25 17:38:12,"",,0,1,0,2020-03-25 17:38:12
60870546,2,,40381998,5,,"<p>If you're in my case and don't want to use Relay, you can also handle filtering directly in you resolvers using Django orm filtering. Example here: <a href=""https://www.howtographql.com/graphql-python/7-filtering/"" rel=""noreferrer"">Filter graphql query in django</a></p>&#xA;",5524298,,,,2020-03-26 15:21:36,"",,0,1,0,2020-03-26 15:21:36
60876566,1,,,2,287,"<p>I am trying to hit a graphQl query where I want to get the data available in a certain period using below query:</p>&#xA;&#xA;<p>Requirement is to pull the data where eventDates endTime value is >= 1583831471000 OR recurrence endTime value is >= 1583831471000. These two conditions work if specified separately but don't work together.</p>&#xA;&#xA;<pre><code>{Events(where:{&#xA;widgetId: {EQ: ""3585""},&#xA;category: {&#xA;        deleted: {EQ: false}&#xA;},&#xA; OR:[{eventDates: {&#xA;   endTime: { NE: null } AND: {endTime: { GE: 1583831471000 }} }},&#xA;  {recurrence:{&#xA;  endTime: { NE: null } AND: {endTime: { GE: 1583831471000 }}}}]&#xA;}page:{start:1 limit: 10}) {&#xA;&#xA;&#xA;Also tried,&#xA;&#xA;OR: [{eventDates: { endTime: { GE: 1583831471000 } }, recurrence: {endTime: {GE: 1583831471000}}}]&#xA;</code></pre>&#xA;&#xA;<p>Schema looks like below:</p>&#xA;&#xA;<pre><code>eventDates:&#xA;input ONEDatesCriteriaExpression {&#xA;  OR: [ONEDatesCriteriaExpression]&#xA;  AND: [ONEDatesCriteriaExpression]&#xA;  EXISTS: [ONEDatesSubqueryCriteriaExpression]&#xA;  NOT_EXISTS: [ONEDatesSubqueryCriteriaExpression]&#xA;  contentType: contentTypeONEDateCriteria&#xA;  createdBy: createdByBaseEntityCriteria&#xA;  lastModifiedBy: lastModifiedByBaseEntityCriteria&#xA;  startTime: startTimeONEDateCriteria&#xA;  deleted: deletedBaseEntityCriteria&#xA;  id: idBaseEntityCriteria&#xA;  endTime: endTimeONEDateCriteria&#xA;  creationTime: creationTimeBaseEntityCriteria&#xA;  modificationTime: modificationTimeBaseEntityCriteria&#xA;}&#xA;&#xA;endTime :&#xA;input endTimeONEDateCriteria {&#xA;  OR: [endTimeONEDateCriteria]&#xA;  AND: [endTimeONEDateCriteria]&#xA;  EQ: Long&#xA;  NE: Long&#xA;  LE: Long&#xA;  GE: Long&#xA;  GT: Long&#xA;  LT: Long&#xA;  IS_NULL: Boolean&#xA;  NOT_NULL: Boolean&#xA;  IN: [Long]&#xA;  NIN: [Long]&#xA;  BETWEEN: [Long]&#xA;  NOT_BETWEEN: [Long]&#xA;}&#xA;&#xA;recurrence Object:&#xA;input EventRecurrencesCriteriaExpression {&#xA;  OR: [EventRecurrencesCriteriaExpression]&#xA;  AND: [EventRecurrencesCriteriaExpression]&#xA;  EXISTS: [EventRecurrencesSubqueryCriteriaExpression]&#xA;  NOT_EXISTS: [EventRecurrencesSubqueryCriteriaExpression]&#xA;  frequency: frequencyEventRecurrenceCriteria&#xA;  lastModifiedBy: lastModifiedByBaseEntityCriteria&#xA;  endDateType: endDateTypeEventRecurrenceCriteria&#xA;  onSubType: onSubTypeEventRecurrenceCriteria&#xA;  onType: onTypeEventRecurrenceCriteria&#xA;  modificationTime: modificationTimeBaseEntityCriteria&#xA;  createdBy: createdByBaseEntityCriteria&#xA;  endTime: endTimeEventRecurrenceCriteria&#xA;  repeatType: repeatTypeEventRecurrenceCriteria&#xA;  onDay: onDayEventRecurrenceCriteria&#xA;  deleted: deletedBaseEntityCriteria&#xA;  id: idBaseEntityCriteria&#xA;  startTime: startTimeEventRecurrenceCriteria&#xA;  creationTime: creationTimeBaseEntityCriteria&#xA;  endAfterNumberOfOccurrences: endAfterNumberOfOccurrencesEventRecurrenceCriteria&#xA;  weekDays: EventRecurrenceDaysRelationCriteriaExpression&#xA;}&#xA;&#xA;endTime:&#xA;&#xA;input endTimeEventRecurrenceCriteria {&#xA;  OR: [endTimeEventRecurrenceCriteria]&#xA;  AND: [endTimeEventRecurrenceCriteria]&#xA;  EQ: Long&#xA;  NE: Long&#xA;  LE: Long&#xA;  GE: Long&#xA;  GT: Long&#xA;  LT: Long&#xA;  IS_NULL: Boolean&#xA;  NOT_NULL: Boolean&#xA;  IN: [Long]&#xA;  NIN: [Long]&#xA;  BETWEEN: [Long]&#xA;  NOT_BETWEEN: [Long]&#xA;}&#xA;</code></pre>&#xA;",6282985,,6282985,2020-04-10 12:15:49,2020-04-10 12:15:49,Graph QL Logical AND operation on Different Objects in an entity,<graphql><logical-operators><apollo-client>,0,2,0,2020-03-26 21:39:39
60877460,1,,,8,4618,"<p>I am using AppSync for my APP. Here is a quick look of my Schema.graphql file</p>&#xA;&#xA;<pre><code>type Item @model&#xA;  @auth(rules: [&#xA;    { allow: public, provider: apiKey, operations: [read] },&#xA;    { allow: groups, groups: [""admin""] }&#xA;  ]) {&#xA;  id: ID!&#xA;  name: String!&#xA;  soldUnits: String!&#xA;  soldAs: [Float!]&#xA;  price: Float!&#xA;  isAvailable: Boolean!&#xA;  availableAmount: Float!&#xA;  category: String!&#xA;  isVeg: Boolean!&#xA;  offer: [String!]&#xA;  about: String&#xA;  storage: String&#xA;  benifits: String&#xA;  otherInfo: String&#xA;  rating: Int&#xA;  keywords: [String!]&#xA;  reviews: [String]&#xA;  images: [String]&#xA;  updatedBy: String&#xA;  addedBy: String&#xA;  qty: Int&#xA;  inventroy: Inventory @connection(name: ""ItemInventory"")&#xA;}&#xA;&#xA;type User @model {&#xA;  id: ID!&#xA;  firstName: String!&#xA;  lastName: String!&#xA;  about: String&#xA;  phoneNumber: String&#xA;  email: String&#xA;  countryCode: String&#xA;  addresses: [Address] @connection&#xA;  orders: [Order] @connection(name: ""OwnOrder"")&#xA;}&#xA;&#xA;type CartItem {&#xA;    id: ID!&#xA;    count: Int!&#xA;    name: String!&#xA;    price: Float&#xA;}&#xA;&#xA;type Address @model {&#xA;  id: ID!&#xA;  lat: Float!&#xA;  long: Float!&#xA;  fullAddress: String!&#xA;  apartment: String!&#xA;  street: String&#xA;  area: String!&#xA;  district: String!&#xA;  city: String&#xA;  state: String!&#xA;  zip: Int!&#xA;  country: String!&#xA;  phoneNumber: String!&#xA;}&#xA;&#xA;type InventoryAddress @model {&#xA;  id: ID!&#xA;  address: Address @connection&#xA;  inventroy: Inventory! @connection(name: ""InventoryAddress"")&#xA;}&#xA;&#xA;type Order @model {&#xA;  id: ID!&#xA;  orderdate: AWSDate!&#xA;  ordertime: AWSTime!&#xA;  deliverySlot: String!&#xA;  deliveryDate: AWSDate!&#xA;  deliveryInput: String!&#xA;  deliveryPhoneNumber: String!&#xA;  deliveryPhoneCountryCode: String!&#xA;  deliveryAddress: String!&#xA;  deliveredTime: AWSDate&#xA;  deliveredDate: AWSDate&#xA;  deliveryCharges: Float!&#xA;  totalAmount: Float!&#xA;  paidAmount: Float!&#xA;  discount: Float!&#xA;  unpaidAmount: Float!&#xA;  status: String!&#xA;  paymentMethod: String!&#xA;  paymentId: String!&#xA;  itemsCount: Int!&#xA;  items: [CartItem]&#xA;  deliverAssignedTo: Patron @connection(name: ""PatronOrder"")&#xA;  owner: User @connection(name: ""OwnOrder"")&#xA;  inventroyDetails: Inventory @connection(name: ""InventoryOrder"")&#xA;}&#xA;&#xA;type Patron @model {&#xA;  id: ID!&#xA;  age: Int!&#xA;  firstName: String!&#xA;  lastName: String!&#xA;  about: String&#xA;  workTime: String&#xA;  rating: Int!&#xA;  reviews: [String]&#xA;  addressProof: String!&#xA;  role: String&#xA;  workArea: Address @connection&#xA;  address: Address @connection&#xA;  deliveries: [Order] @connection(name: ""PatronOrder"")&#xA;  inventroyDetails: Inventory! @connection(name: ""PatronInventory"")&#xA;  addedItems: [Item] @connection&#xA;}&#xA;&#xA;type Inventory @model {&#xA;  id: ID!&#xA;  address: InventoryAddress @connection(name: ""InventoryAddress"")&#xA;  patron: [Patron] @connection(name: ""PatronInventory"")&#xA;  items: [Item] @connection(name: ""ItemInventory"")&#xA;  orders: [Order] @connection(name: ""InventoryOrder"")&#xA;  manager: Patron @connection&#xA;  admins: [Patron] @connection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is my GraphQL Schema generated in AppSync. &#xA;I am able to query the data and do create mutation, but update and delete mutation is not working.</p>&#xA;&#xA;<pre><code>mutation UpdateAddressInput {&#xA;  updateAddress(input:{&#xA;    id:""af5cd7e6-8213-48b6-aa8e-9d2d6999742c"",&#xA;   area:""New Delhi""&#xA;  }){&#xA;    id,&#xA;    area&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is an example query , as you can see the return data below, it's not reflecting in dynamoDB</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""updateAddress"": {&#xA;      ""id"": ""af5cd7e6-8213-48b6-aa8e-9d2d6999742c"",&#xA;      ""area"": ""Electronic City""&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12780860,,7393155,2020-03-27 13:22:54,2020-10-19 15:35:43,Appsync Update and Delete mutation not working,<reactjs><amazon-web-services><graphql><aws-amplify><aws-appsync>,2,1,0,2020-03-26 22:57:06
60890208,1,61208882,,2,607,"<p>Let's say I've got a models.py with two tables:</p>&#xA;&#xA;<pre><code>class Category(models.Model):&#xA;    cat = models.CharField(max_length=100)&#xA;&#xA;&#xA;class Thing(models.Model):&#xA;    desc = models.CharField(max_length=100)&#xA;    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True)&#xA;</code></pre>&#xA;&#xA;<p>and my schemas as follows:</p>&#xA;&#xA;<pre><code>class ThingType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Thing&#xA;&#xA;&#xA;class FindThing(graphene.ObjectType):&#xA;    things = graphene.List(&#xA;        ThingType,&#xA;        search=graphene.String(),&#xA;        thing=graphene.ID(),&#xA;    )&#xA;&#xA;    def resolve_things(self, info, thing=None, search=None, **kwargs):&#xA;        qs = Thing.objects.all()&#xA;&#xA;        if search:&#xA;            filter = (&#xA;                Q(desc__icontains=search)&#xA;            )&#xA;            qs = qs.filter(filter)&#xA;        if thing:&#xA;            qs = qs.filter(id=thing)&#xA;&#xA;        return qs&#xA;&#xA;&#xA;class CreateThing(graphene.Mutation):&#xA;    id = graphene.Int()&#xA;    desc = graphene.String()&#xA;    category = graphene.Field(FindCategory)&#xA;&#xA;    class Arguments:&#xA;        desc = graphene.String()&#xA;        category = graphene.Int()&#xA;&#xA;    def mutate(self, info, desc, category):&#xA;        thing = Thing(&#xA;            desc=desc,&#xA;            category=Category.objects.get(id=category)&#xA;        )&#xA;        thing.save()&#xA;&#xA;        return CreateThing(&#xA;            id=thing.id,&#xA;            desc=thing.desc,&#xA;            category=thing.category_id&#xA;        )&#xA;</code></pre>&#xA;&#xA;<pre><code>class CategoryType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Category&#xA;&#xA;&#xA;class GetCategory(graphene.ObjectType):&#xA;    category = graphene.List(&#xA;        CategoryType,&#xA;        category=graphene.String(),&#xA;    )&#xA;&#xA;    def resolve_category(self, info, category=None, **kwargs):&#xA;        qs = Category.objects.all()&#xA;&#xA;        if category:&#xA;            get = (&#xA;                Q(category__contains=category)&#xA;            )&#xA;            qs = qs.get(get)&#xA;&#xA;        return qs&#xA;&#xA;&#xA;class FindCategory(graphene.ObjectType):&#xA;    categories = graphene.List(&#xA;        CategoryType,&#xA;        search=graphene.String(),&#xA;        cat=graphene.ID(),&#xA;    )&#xA;&#xA;    def resolve_categories(self, info, cat=None, search=None, **kwargs):&#xA;        qs = Category.objects.all()&#xA;&#xA;        if search:&#xA;            filter = (&#xA;                Q(cat__icontains=search)&#xA;            )&#xA;            qs = qs.filter(filter)&#xA;        if cat:&#xA;            qs = qs.filter(id=cat)&#xA;&#xA;        return qs&#xA;&#xA;&#xA;class CreateCategory(graphene.Mutation):&#xA;    id = graphene.Int()&#xA;    cat = graphene.String()&#xA;    desc = graphene.String()&#xA;&#xA;    class Arguments:&#xA;        cat = graphene.String()&#xA;        desc = graphene.String()&#xA;&#xA;    def mutate(self, info, cat, desc):&#xA;        category = Category(&#xA;            cat=cat&#xA;        )&#xA;        category.save()&#xA;        thing = Thing(&#xA;            desc=desc,&#xA;            category_id=category.id&#xA;        )&#xA;        thing.save()&#xA;&#xA;        return CreateCategory(&#xA;            id=category.id,&#xA;            cat=category.cat,&#xA;            desc=thing.desc,&#xA;        )&#xA;&#xA;</code></pre>&#xA;&#xA;<p>I've managed to create a schema where one can create a new category that already links to a newly created single thing:</p>&#xA;&#xA;<pre><code>mutation createCategory{&#xA;  createCategory(cat:""cat7"", desc:""defg""){&#xA;    id&#xA;    cat&#xA;    desc&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to create a CreateCategory django-graphene schema where one can create a category with multiple additional new things?</p>&#xA;",6330207,,2756409,2020-04-03 19:29:28,2020-04-14 13:28:13,Graphene-Django create multiple instances,<graphql><graphene-django>,1,0,0,2020-03-27 16:32:21
60948329,1,60949989,,0,684,<p>I want to be able to paginate with <code>https://api-platform.com/</code> and the graphql support.</p>&#xA;&#xA;<p>I enabled pagination and I only can use those params : </p>&#xA;&#xA;<blockquote>&#xA;  <p>first: Int Returns the first n elements from the list.</p>&#xA;  &#xA;  <p>last: Int     Returns the last n elements from the list.</p>&#xA;  &#xA;  <p>before: String     Returns the elements in the list that come before&#xA;  the specified cursor.</p>&#xA;  &#xA;  <p>after: String     Returns the elements in the list that come after the&#xA;  specified cursor.</p>&#xA;</blockquote>&#xA;&#xA;<p>The thing is that with those params I cannot access to a page 5 from the first page for example. For that I would need to know the cursor of the last element of the 4th page.</p>&#xA;&#xA;<p>Do I missunderstand the possibilities of that system ?</p>&#xA;&#xA;<p>Is there a way to use a param such as <code>offset</code> with which I could easily start after the N first elements ?</p>&#xA;,1361124,,,,2020-03-31 11:54:57,How to use page based pagination In API Platform in graphql,<symfony><graphql><api-platform.com>,1,0,0,2020-03-31 10:22:07
60956694,1,60956887,,0,696,"<p>I'm trying out GraphQL for the first time and I'm trying to <code>POST</code> some data and create a new document in a MongoDB database.</p>&#xA;&#xA;<p>I've defined an ""Office"" model. Here is what a document looks like:</p>&#xA;&#xA;<pre><code>{&#xA;  fax: 4161234567,&#xA;  image: {&#xA;    full: 'http://placehold.it/1400x800',&#xA;    large: 'http://placehold.it/1000x600',&#xA;    medium: 'http://placehold.it/700x400',&#xA;    small: 'http://placehold.it/400x200'&#xA;  },&#xA;  location: {&#xA;    address: '123 Street Name',&#xA;    city: 'Toronto',&#xA;    country: 'Canada',&#xA;    countryCode: 'CA',&#xA;    state: 'ON',&#xA;    suite: null,&#xA;    zip: 'H6L 1C8'&#xA;  },&#xA;  phone: 4161234567,&#xA;  slug: 'office-name',&#xA;  title: 'Office Name' &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm using Node and Express on the server. Here is my mutation:</p>&#xA;&#xA;<pre><code>const schema = buildSchema(`&#xA;  type Image {&#xA;    full: String&#xA;    large: String&#xA;    medium: String&#xA;    small: String&#xA;  }&#xA;&#xA;  type Location {&#xA;    address: String&#xA;    city: String&#xA;    country: String&#xA;    countryCode: String&#xA;    state: String&#xA;    suite: String&#xA;    zip: String&#xA;  }&#xA;&#xA;  input ImageInput {&#xA;    full: String&#xA;    large: String&#xA;    medium: String&#xA;    small: String&#xA;  }&#xA;&#xA;  input LocationInput {&#xA;    address: String&#xA;    city: String&#xA;    country: String&#xA;    countryCode: String&#xA;    state: String&#xA;    suite: String&#xA;    zip: String&#xA;  }&#xA;&#xA;  type Office {&#xA;    _id: String&#xA;    fax: Float&#xA;    image: Image&#xA;    location: Location&#xA;    phone: Float&#xA;    slug: String&#xA;    title: String&#xA;  }&#xA;&#xA;  type Mutation {&#xA;    createOffice(fax: Float, image: ImageInput, location: LocationInput, phone: Float, slug: String, title: String): Office&#xA;  }&#xA;`);&#xA;</code></pre>&#xA;&#xA;<p>Client side, I have this:</p>&#xA;&#xA;<pre><code>fetch('http://localhost:4300/graphql', {&#xA;  method: 'POST',&#xA;  headers: {&#xA;    'Content-Type': 'application/json'&#xA;  },&#xA;  body: JSON.stringify({&#xA;    query: 'mutation { createOffice(fax: 5041234567, image: {full: ""http://placehold.it/1400x800"", large: ""http://placehold.it/1000x600"", medium: ""http://placehold.it/700x400"", small: ""http://placehold.it/400x200""}, location: {address: ""456 Wilcox Ave."", city: ""Montreal"", country: ""Canada"", countryCode: ""CA"", state: ""QC"", suite: 2300, zip: ""H3A 0A8""}, phone: 5047654321, slug: ""my-office"", title: ""My Office"" { phone }  }'&#xA;  }),&#xA;})&#xA;.then((res) =&gt; {&#xA;  return res.json();&#xA;})&#xA;.then((res) =&gt; {&#xA;  console.log(res.data);&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>I get these errors:</p>&#xA;&#xA;<pre><code>Syntax Error: Expected Name, found {""&#xA;</code></pre>&#xA;&#xA;<p>I assume it is an issue with my syntax here:</p>&#xA;&#xA;<pre><code>body: JSON.stringify({&#xA;  query: 'mutation { createOffice(fax: 5041234567, image: {full: ""http://placehold.it/1400x800"", large: ""http://placehold.it/1000x600"", medium: ""http://placehold.it/700x400"", small: ""http://placehold.it/400x200""}, location: {address: ""456 Wilcox Ave."", city: ""Montreal"", country: ""Canada"", countryCode: ""CA"", state: ""QC"", suite: 2300, zip: ""H3A 0A8""}, phone: 5047654321, slug: ""my-office"", title: ""My Office"" { phone }  }'&#xA;})&#xA;</code></pre>&#xA;&#xA;<p>What am I doing wrong?</p>&#xA;",2262604,,,,2020-03-31 17:53:39,How do you format your body in a fetch request for a GraphQL mutation?,<graphql><fetch><graphql-mutation>,1,3,0,2020-03-31 17:41:37
60969974,1,,,0,71,"<p>I'm creating a questionnaire where the values of the select inputs are collected and averaged to produce a score. Seems easy enough, but I'm struggling to get them. Currently my goal is just to get the values to begin with, but it seems like I can only get the value for the last select input when I click the submit button, calling the <code>handleClick()</code> event.</p>&#xA;&#xA;<p>I'm not sure if I'm doing it right. Through some guides I've seen others use the <code>useRef()</code> function, but I've seen the <code>createRef()</code> as well.</p>&#xA;&#xA;<p>I'm using Gatsby JS and GraphQL for the data query. I appreciate any advice.</p>&#xA;&#xA;<pre><code>const Questionnaire = (props: Props) =&gt; {&#xA;  const data = props.data!&#xA;  const questionnaire = data.allContentfulQuestionnaire.edges&#xA;  let i = 0&#xA;&#xA;  const selectInput = useRef()&#xA;&#xA;  const handleClick = () =&gt; {&#xA;    for (const r in selectInput) {&#xA;      console.log(""foo: "", selectInput.current.value)&#xA;      console.log(""bar: "", r.valueOf())&#xA;    }&#xA;  }&#xA;&#xA;  return (&#xA;    &lt;Layout&gt;&#xA;      &lt;Container&gt;&#xA;        {questionnaire?.map(({ node }: any) =&gt; (&#xA;          &lt;&gt;&#xA;            &lt;h2&gt;{node?.title}&lt;/h2&gt;&#xA;            {node?.questions?.map(({ answers, question }: any) =&gt; (&#xA;              &lt;Question key={question?.id}&gt;&#xA;                &lt;P&gt;&#xA;                  {++i}. {question?.question}&#xA;                &lt;/P&gt;&#xA;&#xA;                &lt;select key={question?.id} ref={selectInput}&gt;&#xA;                  &lt;option&gt;Select Response&lt;/option&gt;&#xA;                  {answers.map(({ title, id, score }: any) =&gt; (&#xA;                    &lt;option key={id} value={score}&gt;&#xA;                      {title}&#xA;                    &lt;/option&gt;&#xA;                  ))}&#xA;                &lt;/select&gt;&#xA;              &lt;/Question&gt;&#xA;            ))}&#xA;          &lt;/&gt;&#xA;        ))}&#xA;&#xA;        &lt;Submit onClick={handleClick}&gt;Submit&lt;/Submit&gt;&#xA;      &lt;/Container&gt;&#xA;    &lt;/Layout&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;",5204802,,,,2020-04-01 11:56:59,How can I get all the values from multiple select inputs on a button click? React,<javascript><reactjs><graphql><gatsby><ref>,1,4,0,2020-04-01 11:37:24
60993249,1,,,0,748,"<p>Can anyone please help or direct me towards the reference,</p>&#xA;&#xA;<p>how can we implement <strong>GraphQL Fragments in Flutter</strong>?</p>&#xA;&#xA;<p>GraphQL Fragments Reference:&#xA;<a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#fragments</a></p>&#xA;",2145844,,,,2020-05-26 00:56:59,How to use GraphQL Fragments in Flutter?,<flutter><graphql>,1,0,0,2020-04-02 13:55:29
60995800,2,,60988032,0,,<p>I dont think mm.dd.yyyy is valid date format in SQL...try to use  a valid date format</p>&#xA;,13200672,,,,2020-04-02 15:56:28,"",,0,1,0,2020-04-02 15:56:28
61046329,1,61046467,,0,883,"<p>I am currently building a React application with Amplify Cli. </p>&#xA;&#xA;<p><strong>The schema.graphql</strong></p>&#xA;&#xA;<pre><code>type Ticket @auth(rules: [{ allow: owner, operations: [create, update, delete] }]) @model @searchable  {&#xA;  id: ID!&#xA;  location: String&#xA;  city: String&#xA;  comment: String&#xA;  owner: String&#xA;  startDate: String&#xA;  endDate: String&#xA;  status: String&#xA;  request: [Request] @connection(keyName: ""byRequest"", fields: [""id""])&#xA;}&#xA;&#xA;type Request @auth(rules: [{ allow: owner, operations: [create, update, delete] }]) @model @searchable @key(name: ""byRequest"", fields: [""ticketID""]) {&#xA;  id: ID!&#xA;  ticketID: ID!&#xA;  requester: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The generated code from amplify for the relevant searchTickets query</p>&#xA;&#xA;<pre><code>export const searchTickets = /* GraphQL */ `&#xA;  query SearchTickets(&#xA;    $filter: SearchableTicketFilterInput&#xA;    $sort: SearchableTicketSortInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    searchTickets(&#xA;      filter: $filter&#xA;      sort: $sort&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        location&#xA;        city&#xA;        comment&#xA;        owner&#xA;        startDate&#xA;        endDate&#xA;        status&#xA;        request {&#xA;          nextToken &#xA;        }&#xA;      }&#xA;      nextToken&#xA;      total&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>When I am trying to query the data in Appsync, the result includes the requester's array, as expected. </p>&#xA;&#xA;<pre><code>query {&#xA;  searchTickets {&#xA;     items{&#xA;      location&#xA;      owner&#xA;      request {&#xA;        items{&#xA;          requester&#xA;        } &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I am struggling with the React code because the requester's array is not included. The rest of the code is working fine and I get all data from Ticket (location, city...) but not the data from the ""Request"" type.</p>&#xA;&#xA;<p>React query code:</p>&#xA;&#xA;<pre><code> await API.graphql(&#xA;        graphqlOperation(queries.searchTickets, {&#xA;          limit, // limit is set in a const&#xA;          sort: {&#xA;            field: 'startDate',&#xA;            direction: 'asc'&#xA;          },&#xA;          filter: {&#xA;            location: {&#xA;              eq: location&#xA;            },&#xA;            city: {&#xA;              eq: city&#xA;            }&#xA;          }&#xA;        })&#xA;      )&#xA;        .then(payload =&gt; {&#xA;          const data = payload.data.searchTickets.items;&#xA;          setTickets(tickets =&gt; tickets.concat(data)); &#xA;        })&#xA;        .catch(err =&gt; {&#xA;          console.log('error: ', err);&#xA;        });&#xA;</code></pre>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/LBjrZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LBjrZ.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>Any idea why the ""Request"" array is empty or how I can access the ""Request"" type data via the searchTickets query?</p>&#xA;&#xA;<p>THX!</p>&#xA;&#xA;<p>PS: I am happy to provide more if code/information if needed. </p>&#xA;",987773,,,,2020-06-27 04:09:28,React Amplify query with connection,<reactjs><graphql><aws-amplify><aws-appsync>,2,0,0,2020-04-05 17:07:32
61051595,2,,60555874,0,,"<p>This should do it for you:</p>&#xA;&#xA;<pre><code>query UserPhotos ($userId: ID) {&#xA; user(input: { id: $userId }) {&#xA;     id&#xA;     imageUrl&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The Query you wrote is used for pagination and Ideally you should not want to create an edge with a node unless you want an opaque cursor for the purpose of pagination.</p>&#xA;&#xA;<p>The Query I provided does not try to paginate and thus, would provide you with all your <code>image</code> Objects. </p>&#xA;&#xA;<p>you can refer this page for better understanding: &#xA;<a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">https://graphql.org/learn/pagination/</a></p>&#xA;",7258827,,,,2020-04-06 01:13:38,"",,0,0,0,2020-04-06 01:13:38
61054976,1,,,0,55,"<p>I  have a data structure like below</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  ""MyAsset"": {&#xA;    ""Code"": ""Cod123"",&#xA;    ""MyAssetLocation"": [{&#xA;        ""Location"": {&#xA;          ""LocationName"": ""Location 1""&#xA;        }&#xA;      },{&#xA;        ""Location"": {&#xA;          ""LocationName"": ""Location 2""&#xA;        }&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;&#xA;&#xA;<p>I wanted to write a graphql query against the entity MyAsset in such a way that it should return the data like below.</p>&#xA;&#xA;<p>First record</p>&#xA;&#xA;<pre><code>{code:""Cod123"",MyAssetLocation.Location:""Location 1""}&#xA;</code></pre>&#xA;&#xA;<p>Second Record</p>&#xA;&#xA;<pre><code>{code:""Cod123"",MyAssetLocation.Location:""Location 2""}&#xA;</code></pre>&#xA;&#xA;<p>Basically I wanted to flatten the result by duplicating MyAsset details with <code>MyAssetLocation.Location</code> Items.</p>&#xA;",3444906,,3444906,2020-04-06 08:54:19,2020-04-06 08:54:19,Is it really possible to flatten the data returned from a graphql query?,<reactjs><elasticsearch><graphql><graphql-js>,0,9,0,2020-04-06 07:36:33
61080857,1,,,0,296,"<p>I am using amplify graphql apis. I have added a few <code>@key</code> for my search and sort of the events data. Then I have added a custom <code>Query</code> to search nearby events by lat and long. Now if had to search the nearby events by <code>creatorId</code> or <code>status</code> with <code>location</code>, how do I do it?</p>&#xA;&#xA;<pre><code>type Event @model&#xA;  @key(name: ""byOwnerUser"", fields: [""creatorId""])&#xA;  @searchable&#xA;{&#xA;  id:  ID!&#xA;  name: String!&#xA;  location: Location&#xA;  date: AWSDate!&#xA;  creatorId: ID!&#xA;  status: Boolean&#xA;  createdAt: AWSTimestamp&#xA;  updatedAt: AWSTimestamp&#xA;  users: [UserEvents] @connection(name: ""EventsUser"")&#xA;}&#xA;&#xA;type Location {&#xA;  lat: Float!&#xA;  lon: Float!&#xA;}&#xA;&#xA;input LocationInput {&#xA;  lat: Float&#xA;  lon: Float&#xA;}&#xA;&#xA;type Query {&#xA;  nearbyEvents(location: LocationInput!, km: Int): EventConnection&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Do I have to write custom resolvers? Is there a way to do this without custom resolvers? Thank you in advance</p>&#xA;",7393155,,7393155,2020-04-07 14:16:28,2020-04-07 14:16:28,How to combine key with custom resolvers with amplify or appsync graphql queries?,<graphql><amazon-cloudfront><aws-amplify><aws-appsync><aws-elasticsearch>,0,2,0,2020-04-07 13:14:17
61107374,2,,61107176,4,,"<p>Figured it out.</p>&#xA;&#xA;<p>GraphQL allows us to set it like so:</p>&#xA;&#xA;<pre><code>export const ARTICLES_QUERY = gql`&#xA;  query Articles($today: String!) {&#xA;    articles(where: { display: true, publish_lt: $today }) {&#xA;      id&#xA;      slug&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>Using <code>_lt</code> or <code>_gt</code> on the field name indicates that we want to filter the list for dates before (_lt) or after (_gt) the set date.</p>&#xA;",2699489,,2699489,2020-04-08 18:31:33,2020-04-08 18:31:33,"",,0,0,0,2020-04-08 18:18:10
61117102,2,,61074321,1,,<p>So I found a solution for this. The issue is lies is with the data to be filtered are an entry of the content object. Which means they have no NodeId and are not filterable. The solution is to add a <code>action.createNode</code> foreach entry coming from the API instead just putting in the bulk.</p>&#xA;,13238090,,,,2020-04-09 08:36:46,"",,0,0,0,2020-04-09 08:36:46
61155394,2,,61153737,0,,<p>Just added this line to my <code>Model</code> and it got fixed!</p>&#xA;&#xA;<pre><code>public $incrementing = false;&#xA;</code></pre>&#xA;&#xA;<p>It was weird that I couldn't find any similar problem anywhere else.</p>&#xA;,11671686,,,,2020-04-11 10:34:58,"",,0,0,0,2020-04-11 10:34:58
61220805,2,,61214493,0,,"<p>Further dissecting the resolver code, issue resolved by setting both <code>serviceSessionsId</code> and <code>sessionServiceId</code> to Id1 when creating child record <code>createSession()</code></p>&#xA;",6126081,,,,2020-04-15 03:23:33,"",,0,0,0,2020-04-15 03:23:33
61231579,1,,,1,117,"<p>I have an edge case in which my <code>apollo-graphql</code> react mutation doesn't update the UI properly, but only if the <code>edges</code> array is initially empty.</p>&#xA;&#xA;<p>I am trying to add a new comment reply to a parent comment and have the new one appear in the list once the mutation has been made. This works when there is already at least one existing comment reply, but adding the first one never updates after the mutation unless I refresh the page.</p>&#xA;&#xA;<p>Here is the mutation function</p>&#xA;&#xA;<pre><code>...&#xA;&#xA;const queryVariables = {&#xA;  last: 2,&#xA;  parentId: comment.id,&#xA;  sortBy: ""MODIFIED_AT_ASC"",&#xA;};&#xA;&#xA;const [createPostComment] = useMutation(CREATE_POST_COMMENT, {&#xA;  update(cache, { data: { createComment } }) {&#xA;    const { allComments } = cache.readQuery({&#xA;      query: GET_COMMENT_CHILDREN,&#xA;      variables: queryVariables,&#xA;    });&#xA;&#xA;    cache.writeQuery({&#xA;      query: GET_COMMENT_CHILDREN,&#xA;      variables: queryVariables,&#xA;      data: {&#xA;        allComments: {&#xA;          ...allComments,&#xA;          edges: allComments.edges.concat({ // if this is empty, it doesn't update&#xA;            node: createComment.comment,&#xA;            __typename: ""CommentEdge"",&#xA;          }),&#xA;        },&#xA;      },&#xA;    });&#xA;  },&#xA;});&#xA;&#xA;createPostComment({&#xA;    variables: {&#xA;    input: {&#xA;      parentId: comment.id,&#xA;      userPostId: comment.userPost.id,&#xA;      appUserId: 1,&#xA;      content: content,&#xA;    },&#xA;  },&#xA;});&#xA;&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>Here is the <code>CREATE_POST_COMMENT</code> mutation</p>&#xA;&#xA;<pre><code>import gql from ""graphql-tag"";&#xA;&#xA;import { CommentFragment } from ""gql/fragments"";&#xA;&#xA;export const CREATE_POST_COMMENT = gql`&#xA;  mutation CreatePostComment($input: CommentInput!) {&#xA;    createComment(input: $input) {&#xA;      comment {&#xA;        ...CommentFragment&#xA;        userPost {&#xA;          id&#xA;        }&#xA;        children {&#xA;          edges {&#xA;            node {&#xA;              ...CommentFragment&#xA;              userPost {&#xA;                id&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;  ${CommentFragment}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>And the <code>GET_COMMENT_CHILDREN</code> query</p>&#xA;&#xA;<pre><code>import gql from ""graphql-tag"";&#xA;&#xA;import { CommentFragment } from ""gql/fragments"";&#xA;&#xA;export const GET_COMMENT_CHILDREN = gql`&#xA;  query allCommentChildren(&#xA;    $last: Int!&#xA;    $before: String&#xA;    $sortBy: [CommentObjectSortEnum]!&#xA;    $parentId: Int!&#xA;  ) {&#xA;    allComments(&#xA;      last: $last&#xA;      before: $before&#xA;      sort: $sortBy&#xA;      filters: { parentId: $parentId }&#xA;    ) {&#xA;      pageInfo {&#xA;        startCursor&#xA;        hasPreviousPage&#xA;      }&#xA;      edges {&#xA;        node {&#xA;          ...CommentFragment&#xA;          userPost {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;  ${CommentFragment}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Comment fragment</p>&#xA;&#xA;<pre><code>export const CommentFragment = gql`&#xA;  fragment CommentFragment on CommentObject {&#xA;    id&#xA;    content&#xA;    createdAt&#xA;    parentId&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>Why does this work fine when a comment reply already exists but not when the <code>edges</code> is initially empty?</p>&#xA;",3590686,,,,2020-04-15 14:42:16,Apollo GraphQL react mutation not updating UI properly,<reactjs><graphql><react-apollo><apollo-client><graphql-js>,0,2,0,2020-04-15 14:42:16
61233900,1,,,1,467,"<p>Before describing a problem and the question, based on this problem, I need to say, that it is architectural problem firstly and I've searched an answer or something like it many times with different keywords, but always got guides and articles like ""Your first GraphQL app with Vue and Typescript"". Seems like I have a more complex question, that requires more complex way to answer, and I believe, that by asking it there I can receive at least a first minimal clue of answer, that I need.</p>&#xA;&#xA;<p>Also I'm very apologize, if I duplicated or asked the question, that had been answered before. Basic search through stackoverflow gave me no results. </p>&#xA;&#xA;<p>So, let's say we have a GraphQL schema, that contains following types</p>&#xA;&#xA;<pre><code>type Company {&#xA;  id: ID!&#xA;  name: String!&#xA;  code: String&#xA;  address: Address&#xA;}&#xA;&#xA;type Address {&#xA;  id: ID!&#xA;  city: String!&#xA;  # here might be many other fields, but provided ones are enough to ask&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>We also have query in schema</p>&#xA;&#xA;<pre><code>type Query {&#xA;  companies (input: FindCompaniesInput!): [Company!]!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And its frontend wrapper</p>&#xA;&#xA;<pre><code>query Company ($input: FindCompaniesInput!, $withAddress: Boolean, $withCode: Boolean) {&#xA;  companies(input) {&#xA;    ...CompanyItem&#xA;    code @include(if: $withCode)&#xA;    address @include(if: $withAddress) {&#xA;      id&#xA;      city&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And query <em>input</em> type looks like this</p>&#xA;&#xA;<pre><code>type FindCompaniesInput {&#xA;  ids: [ID!]&#xA;  take: Int&#xA;  offset: Int&#xA;  nameLike: String&#xA;  cityLike: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In 7 different Vue components I need to load one of 4 fragments, based on type <code>Company</code> using query <code>companies</code>. For example, for dropdown input component, I need this</p>&#xA;&#xA;<pre><code>fragment CompanyItem on Company {&#xA;  id&#xA;  name&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>but for company card component I need</p>&#xA;&#xA;<pre><code>fragment CompanyCard on Company {&#xA;  id&#xA;  name&#xA;  address {&#xA;    city&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and so on.</p>&#xA;&#xA;<p>Now, about Vue app. I use Vue with Typescript, and related packages, such as <code>vue-class-component</code> and <code>vue-property-decorator</code>. For generating types from schema, I use <code>apollo-graphql</code>. I designed the app without storing graphql entity objects in Vuex. I use mixins for that purpose. I understand, that use of pattern, based on mixins is risky, but I minimized risks (or I think that I did that) using following approach </p>&#xA;&#xA;<p>I declare <em>mixin contexts</em></p>&#xA;&#xA;<pre><code>import { CompanyItem } from '@/api/graphql/generated/fragments'&#xA;&#xA;type CompanyMixinContext = {&#xA;  items: CompanyItem&#xA;  isPageLoading: boolean&#xA;}&#xA;&#xA;&#xA;@Component&#xA;export class CompanyMixin extends Vue {&#xA;  // I swap place of 'mixin' suffix in name, to easily access it in vue-dev-tools&#xA;  // component properties are sorted, so all inherited mixins display grouped&#xA;  protected mixinCompany: CompanyMixinContext = {&#xA;    items: null&#xA;    isPageLoading: false&#xA;  }&#xA;&#xA;  protected async queryCompaniesPage(input: FindCompaniesInput) {&#xA;    // ...here I query companies chunk and wrap it in try/catch/finally&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then, when it needs, I extend my component with mixin.</p>&#xA;&#xA;<pre><code>&lt;script lang=""ts""&gt;&#xA;// omit imports...&#xA;&#xA;@Component&#xA;export default MyComponent extends CompanyItemMixin {&#xA;  // To use mixin context in template I declare a getter,&#xA;  // omitting in its name a 'mixin' suffix&#xA;  private get company () { return this.mixinCompany } &#xA;&#xA;  // The rest code of the component...&#xA;}&#xA;&lt;/script&gt;&#xA;</code></pre>&#xA;&#xA;<p>Finally, when I showed a code, that in use now in my app, I can now ask a question.</p>&#xA;&#xA;<p>Is there a way to use single query with parameters for entity, even without mixins, but with reusable vue+typescript code, that able to return proper type based on variables?</p>&#xA;&#xA;<p>I don't want to write 7 functions, or, in my case 7 mixins, that have 99% identic code and work with same GQL entity but still differs in types they working with.</p>&#xA;&#xA;<p>p.s. The main feature of using GraphQL is that you can query different entity structure in different ways, but how can I reduce similar code to handle query and work with it using some universal approach (vuex/mixins) is still a mystery for me. I'm sure there are a lot of high-quality frontend engineers, who can answer that, I'll start here in search for it.</p>&#xA;&#xA;<p>Thank you in advance.</p>&#xA;",12896970,,,,2020-04-15 16:34:46,GraphQL fragments in Vue,<typescript><vue.js><graphql><vuex><vue-mixin>,0,1,0,2020-04-15 16:34:46
61236481,1,61238989,,0,2075,"<p>I've created a GraphQL resolver which searches for Company objects using TypeORM, I would like the to allow the client to (optionality) query with pagination or order objects so I wrote this resolver:</p>&#xA;&#xA;<pre><code>@ArgsType()&#xA;class CompanyProductArgs {&#xA;  @Field()&#xA;  OrderBy?: {&#xA;    fieldName: string;&#xA;    direction: DirectionEnum;&#xA;  };&#xA;&#xA;  @Field()&#xA;  Pagination?: {&#xA;    take: number;&#xA;    skip: number;&#xA;  };&#xA;}&#xA;&#xA;@Resolver()&#xA;export class CompanyProductResolver {&#xA;  @Query(() =&gt; [CompanyProduct])&#xA;  companyProducts(@Args() { OrderBy, Pagination }: CompanyProductArgs) {&#xA;    let args = {};&#xA;&#xA;    if (OrderBy) {&#xA;      args = {&#xA;        ...args,&#xA;        order: {&#xA;          [OrderBy.fieldName]: OrderBy.direction,&#xA;        },&#xA;      };&#xA;    }&#xA;&#xA;    if (Pagination) {&#xA;      args = {&#xA;        ...args,&#xA;        skip: Pagination.skip,&#xA;        take: Pagination.take,&#xA;      };&#xA;    }&#xA;&#xA;    return CompanyProduct.find(args);&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But running this returns: </p>&#xA;&#xA;<blockquote>&#xA;  <p>Error: You need to provide explicit type for CompanyProductArgs#OrderBy</p>&#xA;</blockquote>&#xA;&#xA;<p>The way to solve this would be using a Custom Scalers (I think), but the type-GraphQL <a href=""https://github.com/MichalLytek/type-graphql/blob/master/docs/scalars.md"" rel=""nofollow noreferrer"">documentation</a> only provide one example in which only one variable gets accepted, but I want to accept an object with 2 keys (take and skip in this case). How would I write a scaller that accepts object such as a pagination object like this:</p>&#xA;&#xA;<pre><code>{&#xA;   take: 10&#xA;   skip: 5&#xA;}&#xA;</code></pre>&#xA;",9615506,,,,2020-04-15 21:33:29,Type-GraphQL adding pagination object to resolver,<typescript><graphql><typegraphql>,1,0,0,2020-04-15 18:56:20
61248142,1,,,1,879,"<p>I have a GraphQL query similar to this: </p>&#xA;&#xA;<pre><code>query {&#xA;  getPosts {    &#xA;      ...PostFragment&#xA;  }&#xA;}&#xA;&#xA;fragment SpecificPostFragment on SpecificPost {&#xA;  owner {&#xA;    id&#xA;    name&#xA;  }&#xA;}&#xA;&#xA;fragment PostFragment on Post {&#xA;  id&#xA;  object&#xA;  ... on SpecificPost {&#xA;    ...SpecificPostFragment &#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I try to know if:</p>&#xA;&#xA;<ol>&#xA;<li>the field object is requested </li>&#xA;<li>the field owner is requested</li>&#xA;</ol>&#xA;&#xA;<p>I try to apply what is written here:&#xA;<a href=""https://www.graphql-java.com/documentation/v11/fieldselection/"" rel=""nofollow noreferrer"">https://www.graphql-java.com/documentation/v11/fieldselection/</a></p>&#xA;&#xA;<p>But <code>dataFetchingEnvironment.getSelectionSet().contains(""XXX"")</code> does not seem to work well with fragments.&#xA;How to do that ?</p>&#xA;",500821,,,,2020-04-18 08:42:17,How to check requested GraphQL fields in Java with fragments?,<java><graphql><field><graphql-fragments>,1,0,0,2020-04-16 10:34:51
61257771,2,,44383522,0,,"<p>If you're using Mongo and Mongoose with Apollo Express GraphQL I have found three ways to do pagination:</p>&#xA;&#xA;<ol>&#xA;<li><p>You can create a <code>cursor</code> field on your schema and implement your resolver with the pagination logic, but I don't recommend this method if you have a complex schema that contain unions, interfaces and different nested objects on the type, but if you want to implement it by yourself here's the <a href=""https://www.apollographql.com/blog/tutorial-pagination-d1c3b3ee2823"" rel=""nofollow noreferrer"">reference</a></p></li>&#xA;<li><p>You can use a <a href=""https://github.com/limit-zero/mongoose-graphql-pagination"" rel=""nofollow noreferrer"">module</a> which will nest your Mongoose model and provide you an pagination interface, but this requires a few changes on your schema and resolvers, more work then the third method</p></li>&#xA;<li><p>You can use <code>sort</code>, <code>skip</code> and <code>limit</code> from Mongo / Mongoose, but if you do this by yourself you can find some <a href=""https://stackoverflow.com/questions/5539955/how-to-paginate-with-mongoose-in-node-js"">issues</a>, e.g if the document was sorted by a date key which can have different documents with the same date it can duplicate documents and mess up with your pagination, so I recommend that you install a pagination plugin on your Mongoose schema and use it like any other method from Mongoose</p></li>&#xA;</ol>&#xA;",0,user7075574,,,2020-04-16 18:47:37,"",,0,0,0,2020-04-16 18:47:37
61262195,1,,,0,217,"<p>Let's say I have the following list of objects:</p>&#xA;&#xA;<pre><code>[{id: 1}, {id: 2}, {id: 3}, {id: 4}]&#xA;</code></pre>&#xA;&#xA;<p>and for the sake of simplicity, let's assume I want to show 2 elements per page.</p>&#xA;&#xA;<p>I can query the first page by providing the following arguments: <code>myQuery(first: 2)</code><br>&#xA;The second page by using the <code>endCursor</code> of the first page (which is the id <code>2</code>): <code>myQuery(first:2, after:2)</code>  </p>&#xA;&#xA;<p>Now let's say I am on the second page, and the element with the id <code>2</code> gets removed. I want to move to the previous page, by executing: <code>myQuery(last:2, before:3)</code><br>&#xA;This would lead to the first page having only one element (the one with the id <code>1</code>), which for me seems as a bad user experience.  </p>&#xA;&#xA;<p>Is cursor based pagination not well suited for offset pagination, or how do you handle things? The only thing I can think of, is not refetching the data. In this case the user would still think the object with the id <code>2</code> is there.</p>&#xA;",3125470,,,,2020-04-17 00:41:53,How to handle removal of previous elements in cursor based pagination?,<pagination><graphql><relay>,1,0,0,2020-04-17 00:18:08
61314336,1,61315445,,8,1519,"<p>As I understand in Gatsby, a page query would be made at the parent level and would be passed down as props to the children components. And a <code>&lt;StatiQuery /&gt;</code> or the <code>useStaticQuery</code> hook when you are inside a component and want to obtain some data to pass into it. What is the best practice and when should I use one over another?</p>&#xA;&#xA;<p>I'm guessing this comes down to React itself and if for example, we have components that need data at a deep level we would use <code>Context</code> and pass that down so you do not have to pass down props at deeper levels. Is it the same as this? Also if anyone has any patterns they use.</p>&#xA;",1753861,,,,2020-04-20 05:05:45,When to use <StaticQuery /> vs page query in Gatsby?,<reactjs><graphql><gatsby>,1,0,0,2020-04-20 02:40:09
61316490,1,,,0,319,"<p>I want to create 2 related objects, e.g. 1 Location and 1 Place where Place has a reference to Location like so:</p>&#xA;&#xA;<pre><code>type Location {&#xA;    id: String&#xA;    name: String&#xA;}&#xA;&#xA;type Place {&#xA;    id: String&#xA;    locationId: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to do this with 1 mutation request? Currently I'm doing this with 2 separate mutation requests like below:</p>&#xA;&#xA;<pre><code>mutation ($locationName: String!) {&#xA;  insert_Location(objects: {name: $locationName}) {&#xA;    returning {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;//in another request, use the id returned from the request above&#xA;mutation ($locationId: String!) {&#xA;  insert_Place(objects: {locationId: $locationId}) {&#xA;    returning {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm aware it's possible to have multiple fields in a mutation so I could create 2 <em>Locations</em> in 1 mutation request like below.</p>&#xA;&#xA;<pre><code>mutation ($locationName: String!) {&#xA;  location1: insert_Location(objects: {name: $locationName}) {&#xA;    returning {&#xA;      id&#xA;    }&#xA;  }&#xA;&#xA;  location2: insert_Location(objects: {name: $locationName}) {&#xA;    returning {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However if I wanted to do this to create 1 Location and 1 Place, is there a way to retrieve the created Location Id and pass it to the 2nd field to create the Place?</p>&#xA;",8656126,,,,2020-04-22 12:53:32,graphql - Refer to other fields in mutation,<graphql><apollo><hasura>,1,2,0,2020-04-20 06:40:51
61318907,1,,,0,2053,"<p>Please help me with this. In my strapi graphql. How can I filter data based in nested data. I want to filter data base in relationship under tours -> tour_itineraries -> itineraries -> country -> Name.&#xA;I want to filter it by country name. So I try this.</p>&#xA;&#xA;<p><strong>tours( where: { tour_itineraries: { itineraries: {  country: ""Japan"" } } } )</strong></p>&#xA;&#xA;<p>but it gives me error</p>&#xA;&#xA;<blockquote>&#xA;  <p>Your filters contain a field 'tour_itineraries.itineraries.country' that doesn't appear on your model definition nor it's relations</p>&#xA;</blockquote>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/kEPvx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kEPvx.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/4NgJO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4NgJO.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>Thank you.</p>&#xA;",8015333,,6463558,2020-04-20 13:05:13,2020-04-20 13:05:13,Doesn't appear on your model definition nor it's relations (Strapi),<graphql><strapi>,0,1,0,2020-04-20 09:15:01
61319773,1,,,2,1329,"<p>I have two tables <code>tire</code> and <code>brand</code>. They have one-to-many relationship.&#xA;So when I try following query </p>&#xA;&#xA;<pre><code>  getTireListing (sortBy: ""title"") {&#xA;&#xA;    edges {&#xA;      node {&#xA;        title&#xA;        description1&#xA;        description2&#xA;&#xA;        brand  {&#xA;          ... on object_brand {&#xA;            brandName&#xA;          }&#xA;        }&#xA;&#xA;      }&#xA;    }&#xA;    totalCount&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>I am getting following result.</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""getTireListing"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""title"": ""Continental-ContieCocontact 5"",&#xA;            ""description1"": ""&lt;p&gt;test&lt;/p&gt;\n"",&#xA;            ""description2"": ""&lt;p&gt;test 2&lt;/p&gt;\n"",&#xA;            ""brand"": {&#xA;              ""brandName"": ""Continental""&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""title"": ""PremiumContact TM 6"",&#xA;            ""description1"": ""&lt;p&gt;test&lt;/p&gt;\n"",&#xA;            ""description2"": ""&lt;p&gt;test&lt;/p&gt;\n"",&#xA;            ""brand"": {&#xA;              ""brandName"": ""Continental""&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""title"": ""Tire name"",&#xA;            ""description1"": ""&lt;p&gt;fgafd&lt;/p&gt;\n"",&#xA;            ""description2"": ""&lt;p&gt;asfasdf&lt;/p&gt;\n"",&#xA;            ""brand"": {&#xA;              ""brandName"": ""Abc Brand""&#xA;            }&#xA;          }&#xA;        }&#xA;      ],&#xA;      ""totalCount"": 3&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now I need to filter tire with brand name, so I tried </p>&#xA;&#xA;<pre><code>getTireListing (&#xA; sortBy: ""title"",&#xA; filter: ""{\""brand\"" :  {\""brandName\"": \""Continental\"" } }""&#xA;) &#xA;</code></pre>&#xA;&#xA;<p>but I am getting error <code>Column not found: 1054 Unknown column 'brandName' in 'where clause'</code></p>&#xA;&#xA;<p>I am a newbie to GraphQL. Can anybody please help?</p>&#xA;",2067148,,576746,2020-05-13 13:10:19,2020-11-10 10:35:41,How to filter query in graphQL one to many relation?,<graphql><pimcore>,1,10,0,2020-04-20 10:01:58
61328946,1,,,2,4099,"<p>So I've been trying to query GraphQL from PowerShell. Everything looks perfect in a cmd, but I cannot make it work in PS, see, I have this code so far:</p>&#xA;&#xA;<pre><code>$oAuth2TokenUrl = ""https://api.cloudflare.com/client/v4/zones/0000/analytics/dashboard""&#xA;$accessKey = '1111' &#xA;&#xA;$Cloudflare_Oauth_Header = @{&#xA;    ""Authorization"" = ""Bearer $accessKey"";&#xA;}&#xA;&#xA;$query = @'&#xA;{ ""query"": ""query { viewer {&#xA;zones(filter: {zoneTag: 0000}) {&#xA;  httpRequests1mGroups(orderBy: [datetimeMinute_ASC], limit: 1000, filter: {datetime_geq: ""2019-09-08T20:00:00Z"", datetime_lt: ""2019-09-08T20:02:00Z""}) {&#xA;    dimensions {datetimeMinute}&#xA;    sum {&#xA;      browserMap {&#xA;        pageViews&#xA;        uaBrowserFamily&#xA;      }&#xA;      bytes&#xA;      cachedBytes&#xA;      cachedRequests&#xA;      contentTypeMap {&#xA;        bytes&#xA;        requests&#xA;        edgeResponseContentTypeName&#xA;      }&#xA;      clientSSLMap {&#xA;        requests&#xA;        clientSSLProtocol&#xA;      }&#xA;      countryMap {&#xA;        bytes&#xA;        requests&#xA;        threats&#xA;        clientCountryName&#xA;      }&#xA;      encryptedBytes&#xA;      encryptedRequests&#xA;      ipClassMap {&#xA;        requests&#xA;        ipType&#xA;      }&#xA;      pageViews&#xA;      requests&#xA;      responseStatusMap {&#xA;        requests&#xA;        edgeResponseStatus&#xA;      }&#xA;      threats&#xA;      threatPathingMap {&#xA;        requests&#xA;        threatPathingName&#xA;      }&#xA;    }&#xA;    uniq {&#xA;      uniques&#xA;    }&#xA;  }&#xA;}&#xA;  } }"" }&#xA;'@&#xA;&#xA;&#xA;$Cloudflare_zone = Invoke-RestMethod -Method Post -Headers $Cloudflare_Oauth_Header -ContentType ""application/json; charset=utf-8"" -Uri $oAuth2TokenUrl -Body $query &#xA;</code></pre>&#xA;&#xA;<p>And I keep getting the error <code>Invoke-RestMethod : The remote server returned an error: (501) Not Implemented.</code> &#xA;But if I curl in cmd it returns what is expected and no error is shown. </p>&#xA;&#xA;<p>Please let me know if you need more details.</p>&#xA;",8891380,,,,2021-04-01 02:21:58,Querying GraphQL with PowerShell,<powershell><curl><graphql><cloudflare>,2,1,0,2020-04-20 17:57:03
61329027,2,,61328500,2,,"<p>Not, it's standard behaviour - response format defined in specs.</p>&#xA;&#xA;<ul>&#xA;<li>not needed as usually [react] components works on <code>data</code> prop or <code>useQuery</code> (apollo) returns <code>data</code></li>&#xA;<li>response can contain <code>error</code> property beside to <code>data</code> (sibling)</li>&#xA;</ul>&#xA;&#xA;<p>You can always assign shortcut </p>&#xA;&#xA;<pre><code>const data=response.data.data;&#xA;</code></pre>&#xA;&#xA;<p>... and later use only <code>data.users</code> or</p>&#xA;&#xA;<pre><code>const users=response.data.data.users;&#xA;</code></pre>&#xA;&#xA;<p>... if you really need this.</p>&#xA;",6124657,,,,2020-04-20 18:01:51,"",,0,0,0,2020-04-20 18:01:51
61378344,1,61399551,,0,59,"<p>I'm working with two API endpoints.  The first one returns a list of dates in a string format for which data is available.  The date can then be added to the second endpoint and renders additional data. On the Graphql Playground I have been able to make it all work.  On the front-end I have a select option drop down for the dates, but I have not been able to fire off the second API call when I click on any given date.  It's the first time I'm using graphql mutation and I haven't been able to get the second API request to return any data when I select a date.  Thank you.</p>&#xA;&#xA;<p>Front-end code:</p>&#xA;&#xA;<p><strong><em>app.tsx</em></strong></p>&#xA;&#xA;<pre><code>&#xA;import * as React from 'react'&#xA;import { useState } from 'react'&#xA;import { useMutation } from '@apollo/react-hooks'&#xA;import { IrriSatQuery } from '../../generated/graphql'&#xA;import { MAP_LAYER } from './query'&#xA;&#xA;interface Props {&#xA;  data: IrriSatQuery;&#xA;}&#xA;&#xA;const IrriSat: React.FC&lt;Props&gt; = ({ data }) =&gt; {&#xA;  const [option, setOption] = useState((data?.mapDates as any)[0].date!)&#xA;  const [getLayer] = useMutation(MAP_LAYER)&#xA;&#xA;  return (&#xA;    &lt;&gt;&#xA;&#xA;    &lt;ContentWrapper&gt;&#xA;      &lt;select value={option} onChange={( e: React.ChangeEvent&lt;HTMLSelectElement&gt;, ): void =&gt; {setOption(e.target.value, getLayer(e.target.value)}} onSelect={() =&gt; getLayer({variables: {type: option}})}&gt;&#xA;        {data?.mapDates?.slice(0,52).map(res =&gt; &#xA;          &lt;option key={res?.date!} value={res?.date!}&gt;{res?.date}&lt;/option&gt;&#xA;          )&#xA;        }&#xA;      &lt;/select&gt;&#xA;    &lt;/ContentWrapper&gt;&#xA;    &lt;/&gt;&#xA;  )&#xA;}&#xA;&#xA;export default IrriSat&#xA;</code></pre>&#xA;&#xA;<p><strong><em>query.ts</em></strong></p>&#xA;&#xA;<pre><code>&#xA;export const QUERY_IRR_SAT = gql`&#xA; query IrriSat {&#xA;   mapDates {&#xA;     date&#xA;     dateurl&#xA;   }&#xA; }&#xA;`&#xA;&#xA;export const MAP_LAYER = gql`&#xA;  mutation MapLayer($date: String!) {&#xA;     mapDate(date: $date) {&#xA;       token&#xA;       mapid&#xA;       name&#xA;     }&#xA;&#xA;   }&#xA;`&#xA;</code></pre>&#xA;&#xA;<p>Back-end code:</p>&#xA;&#xA;<p><strong>server.js</strong></p>&#xA;&#xA;<pre><code>class IrriSatAPI extends RESTDataSource {&#xA;  constructor() {&#xA;    super();&#xA;    this.baseURL = 'https://irrisat-cloud.appspot.com/_ah/api/irrisat/v1/services/'&#xA;  }&#xA;&#xA;  async getMapsDates() {&#xA;    const response = await this.get('maps/dates')&#xA;    return Array.isArray(response.items) ? response.items.map(response =&gt; this.mapsDatesReducer(response)) : []&#xA;  }&#xA;&#xA;  mapsDatesReducer(response) {&#xA;    return {&#xA;      date: response.date,&#xA;      dateurl: response.dateurl,&#xA;    }&#xA;  }&#xA;&#xA;  async getMapsLayer(date) {&#xA;&#xA;    const response = await this.get(`maps/layers/${date}`)&#xA;    return Array.isArray(response.items) ? response.items.map(response =&gt; this.mapsLayerReducer(response)) : []&#xA;  }&#xA;&#xA;  mapsLayerReducer(response) {&#xA;    return {&#xA;      token: response.token,&#xA;      mapid: response.mapid,&#xA;      name: response.name&#xA;    }&#xA;  }&#xA;&#xA;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>schema.js</strong></p>&#xA;&#xA;<pre><code>  type MapDates {&#xA;    date: String&#xA;    dateurl: String&#xA;  }&#xA;&#xA;  type Mutation {&#xA;    mapDate(date: String): [MapsLayers]&#xA;  }&#xA;&#xA;  type Query {&#xA;    mapDates: [MapDates]&#xA;</code></pre>&#xA;&#xA;<p><strong>resolver.js</strong></p>&#xA;&#xA;<pre><code>module.exports = {&#xA;  Query: {&#xA;    mapDates: (_, __, { dataSources }) =&gt; dataSources.irriSatAPI.getMapsDates(),&#xA;  },&#xA;  Mutation: {&#xA;    mapDate: (_, { date }, { dataSources }) =&gt; dataSources.irriSatAPI.getMapsLayer(date)&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6531235,,,,2020-04-24 01:22:23,How do you submit an API request from the front-end based on the result of a previous API request on an Apollo graphql server?,<reactjs><graphql><apollo-server><graphql-mutation>,1,1,0,2020-04-23 02:27:27
61394632,1,,,3,538,"<p>I'm sending a query to an apollo server to get a list of users. I'm using mongoose-aggregate-paginate-v2 library (documentation: <a href=""https://www.npmjs.com/package/mongoose-aggregate-paginate-v2"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/mongoose-aggregate-paginate-v2</a>)</p>&#xA;&#xA;<p>This is my options object</p>&#xA;&#xA;<pre><code>const options = {&#xA;            page: parseInt(page),&#xA;            limit: 15,&#xA;            lean: true,&#xA;            pagination: true,&#xA;            sort:{ lastUpdate: ""descending"", creationDateTime:""descending""}&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>Sometimes when I resend the request the result changes even though my data is the same.</p>&#xA;",11251010,,,,2021-01-11 16:49:34,Sort in mongoose-aggregate-paginate-v2 changes order,<javascript><node.js><mongodb><mongoose><graphql>,1,0,0,2020-04-23 18:39:24
61445019,1,,,3,612,"<p>I’m using the <code>data hub</code> function with <code>GraphQL</code> to fetch data for external systems, but I have problems with filters for nested objects.</p>&#xA;&#xA;<p>Taking the example of docs, in the products endpoint of the demo, I make this call and I get all cars called E-Type.</p>&#xA;&#xA;<pre><code>{&#xA;    getCarListing(filter: ""{'name' : 'E-Type'}""){&#xA;        edges{&#xA;            node{&#xA;                name&#xA;                    manufacturer{&#xA;                        … on object_Manufacturer{&#xA;                        name&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How can I filter on manufacturer name? I was thinking to this filter:</p>&#xA;&#xA;<pre><code>filter : ""{'manufacturer' : {'name' : 'Jaguar'}}"". &#xA;</code></pre>&#xA;&#xA;<p>This return me column_name <code>name</code> not found response.</p>&#xA;&#xA;<p>Can anybody please help me solve this?</p>&#xA;",2067148,,2067148,2020-04-27 03:12:49,2020-12-14 14:46:01,How to filter in datahub graphql?,<graphql><pimcore-v5><ads-data-hub>,1,1,0,2020-04-26 17:24:28
61469346,1,61469589,,1,1773,"<p><strong>Details</strong></p>&#xA;&#xA;<p>I am trying out react experimental with concurrent mode and relay. I have never used relay before and are having a bit of a hard time getting everything working but, I am almost there. When using the react-relay hook <code>useLazyLoadQuery</code> without any fragments everything is working fine and I get the results I want. But, when adding in fragments I get into some problems.</p>&#xA;&#xA;<p><strong>Problem</strong></p>&#xA;&#xA;<p>When I set up the react-relay hook <code>useLazyLoadQuery</code> in a parent component and include the child components fragments I get the following error  </p>&#xA;&#xA;<blockquote>&#xA;  <p>Property '"" $fragmentRefs""' is missing in type 'readonly { readonly ""&#xA;  $fragmentRefs"": FragmentRefs&lt;""HomeView_getAllUsers"">; }[]' but&#xA;  required in type 'HomeView_getAllUsers$key'.</p>&#xA;</blockquote>&#xA;&#xA;<p>As far as I can see I have done everything according to the relay docs and are kind of stuck on why I get this error.</p>&#xA;&#xA;<p><strong>Question</strong></p>&#xA;&#xA;<p>Why can it not find the <code>$fragmentRefs</code> property according to the relay generated type its there. Does anyone have a solution for this?</p>&#xA;&#xA;<p><strong>Code</strong></p>&#xA;&#xA;<p>Home.tsx</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import React from ""react"";&#xA;import { useLazyLoadQuery } from ""react-relay/hooks"";&#xA;import graphql from ""babel-plugin-relay/macro"";&#xA;&#xA;import { HomeGetAllUsersQuery } from ""./__generated__/HomeGetAllUsersQuery.graphql"";&#xA;import HomeView from ""./HomeView"";&#xA;&#xA;const Home: React.FC = (): React.ReactElement =&gt; {&#xA;    const data = useLazyLoadQuery&lt;HomeGetAllUsersQuery&gt;(&#xA;        graphql`&#xA;            query HomeGetAllUsersQuery {&#xA;                getAllUsers {&#xA;                    ...HomeView_getAllUsers&#xA;                }&#xA;            }&#xA;        `,&#xA;        {},&#xA;        { fetchPolicy: ""store-or-network"" }&#xA;    );&#xA;&#xA;    return &lt;HomeView getAllUsers={data.getAllUsers} /&gt;;&#xA;};&#xA;&#xA;export default Home;&#xA;</code></pre>&#xA;&#xA;<p>HomeView.tsx</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>import React from ""react"";&#xA;import graphql from ""babel-plugin-relay/macro"";&#xA;import { useFragment } from ""react-relay/hooks"";&#xA;&#xA;import { HomeView_getAllUsers$key } from ""./__generated__/HomeView_getAllUsers.graphql"";&#xA;&#xA;type Props = {&#xA;    getAllUsers: HomeView_getAllUsers$key;&#xA;};&#xA;&#xA;const HomeView: React.FC&lt;Props&gt; = (props: React.PropsWithChildren&lt;Props&gt;): React.ReactElement =&gt; {&#xA;    const data = useFragment&lt;HomeView_getAllUsers$key&gt;(&#xA;        graphql`&#xA;            fragment HomeView_getAllUsers on UserType {&#xA;                username&#xA;            }&#xA;        `,&#xA;        props.getAllUsers&#xA;    );&#xA;&#xA;    return &lt;div&gt;{data.username}&lt;/div&gt;;&#xA;};&#xA;&#xA;export default HomeView;&#xA;</code></pre>&#xA;&#xA;<p>GraphQL</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>@ObjectType({ description: ""Object representing a user"" })&#xA;class UserType {&#xA;    @Field(() =&gt; ID)&#xA;    id!: number;&#xA;&#xA;    @Field()&#xA;    username!: string;&#xA;}&#xA;&#xA;@Query(() =&gt; [UserType], { description: ""Returns all users"" })&#xA;    async getAllUsers(): Promise&lt;User[]&gt; {&#xA;        const users = await User.findAll({});&#xA;&#xA;        if (!users) {&#xA;            throw new Error(""No users could be found"");&#xA;        }&#xA;&#xA;        return users;&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Relay generated type</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>export type HomeView_getAllUsers$key = {&#xA;    readonly "" $data""?: HomeView_getAllUsers$data;&#xA;    readonly "" $fragmentRefs"": FragmentRefs&lt;""HomeView_getAllUsers""&gt;;&#xA;};&#xA;</code></pre>&#xA;",9225753,,,,2020-04-28 00:10:43,"Relay fragments with React experimental: Property '"" $fragmentRefs""' is missing",<reactjs><typescript><graphql><relay>,1,0,0,2020-04-27 22:13:31
61490139,1,,,1,115,"<p>I'm reading the Apollo client documentation but I am still confused as per how data is cached.</p>&#xA;&#xA;<p>Let's say I have 2 queries that I use at a different hierarchy level in an app. Query <strong>A</strong> is used at the very top, while query <strong>B</strong> feeds a component several levels below.</p>&#xA;&#xA;<p>If Apollo cache is configured <code>cache: new InMemoryCache()</code>, will <strong>query B</strong> use Apollo cached data from <strong>Query A</strong>, or not?</p>&#xA;&#xA;<p>Same question if I were to use <strong>Query A</strong> for the top component and the bottom one.</p>&#xA;&#xA;<p><strong>Query A</strong></p>&#xA;&#xA;<pre><code>  query MyProjectA {&#xA;    Project {&#xA;      id&#xA;      title&#xA;      budget&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p><strong>Query B</strong></p>&#xA;&#xA;<pre><code>  query MyProjectB {&#xA;    Project {&#xA;      id&#xA;      title&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",6712212,,,,2020-04-28 21:18:33,How are 2 very similar Graphql queries cached in Apollo client?,<caching><graphql><apollo-client><apollo-cache-inmemory>,0,2,0,2020-04-28 21:18:33
61526823,1,61527915,,7,1246,"<p>I am trying to mimic what some GraphQL does, but I do not have access to be able to run the original. It is of the form:</p>&#xA;&#xA;<pre><code>query {&#xA;  dataSources(dataType: Ais) {&#xA;    ... on AisDataSource {&#xA;      messages(filter: {broadcastType: Static}) {&#xA;        ... on AisStaticBroadcast {&#xA;          field1&#xA;          field2&#xA;</code></pre>&#xA;&#xA;<p>(I have ommitted the closing parentheses).</p>&#xA;&#xA;<p>It is my understanding that <code>... on</code> is either to include a fragment (none here), or to choose between alternatives (but these are nested). So is this query wrong, or is there more to <code>... on</code>?</p>&#xA;",1773592,,,,2020-04-30 16:12:27,What is `... on` doing in this GraphQL?,<graphql>,1,0,0,2020-04-30 15:15:52
61527915,2,,61526823,7,,"<p>This</p>&#xA;&#xA;<pre><code>{&#xA;  user {&#xA;    ... on User {&#xA;      id&#xA;      username&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and this</p>&#xA;&#xA;<pre><code>{&#xA;  user {&#xA;    ...UserFragment&#xA;  }&#xA;}&#xA;&#xA;fragment UserFragment on User {&#xA;  id&#xA;  username&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>are equivalent. In both cases, you are using a fragment. In the first example, we simply refer to the fragment as an <a href=""http://spec.graphql.org/June2018/#sec-Inline-Fragments"" rel=""noreferrer"">inline fragment</a>.</p>&#xA;&#xA;<p>When requesting a field that return a <em>composite type</em> (an object, interface or union), you must specify a <em>selection set</em>, or one or more fields for the return type. Since fragments must include a <em>type condition</em> (the <code>on</code> keyword plus the type name), they can be used to specify different selection sets depending on the type that's actually returned at runtime.</p>&#xA;&#xA;<pre><code>{&#xA;  user {&#xA;    ...RegularUserFragment&#xA;    ...AdminFragment&#xA;  }&#xA;}&#xA;&#xA;fragment RegularFragment on RegularUser {&#xA;  id&#xA;  username&#xA;}&#xA;fragment AdminFragment on Admin {&#xA;  id&#xA;  username&#xA;  accessLevel&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>All we're saying is ""if the type at runtime is this, then return this set of fields"". If any of the fields inside the fragment also return a composite type, then those fields also have to specify a selection set for -- that means additional fragments can be used inside <em>those</em> selection sets.</p>&#xA;",6024220,,,,2020-04-30 16:12:27,"",,0,1,0,2020-04-30 16:12:27
61530280,1,,,0,693,"<p>I've created a basic Gatsby site with the default starter.  I'm now trying to add some custom data (the people array) to gatsby-config.json like so:</p>&#xA;&#xA;<pre><code>module.exports = {&#xA;  siteMetadata: {&#xA;    title: `Gatsby Default Starter`,&#xA;    description: `XXX`,&#xA;    author: `@gatsbyjs`,&#xA;    people : [&#xA;      { id : 1234, name : ""Bill Smith"", sales : 143, birthdate : ""2233-03-22"" },&#xA;      { id : 5678, name : ""Roger Miller"", sales : 281, birthdate : ""2230-01-06"" }&#xA;    ]&#xA;  },&#xA;  plugins: [&#xA;    `gatsby-plugin-react-helmet`,&#xA;    { resolve: `gatsby-source-filesystem`,&#xA;      options: { name: `images`, path: `${__dirname}/src/images`, }&#xA;    },&#xA;    `gatsby-transformer-sharp`,&#xA;    `gatsby-plugin-sharp`,&#xA;    { resolve: `gatsby-plugin-manifest`,&#xA;      options: {&#xA;        name: `gatsby-starter-default`, short_name: `starter`, start_url: `/`,&#xA;        background_color: `#663399`, theme_color: `#663399`, display: `minimal-ui`,&#xA;        icon: `src/images/gatsby-icon.png`&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then, in GraphiQL, what I'm trying to do is a query to get a list of people, but limit it to just those with sales above 200, that's my end goal. So first, I did a basic test:</p>&#xA;&#xA;<pre><code>{&#xA;  site {&#xA;    siteMetadata {&#xA;      people {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That works, I get all people back.  Then, I tried:</p>&#xA;&#xA;<pre><code>{&#xA;  site {&#xA;    siteMetadata {&#xA;      people(sales: { gt: 200 }) {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That gets me an error ""Unknown argument sales on field people of type SiteSiteMetadata"".  That kinda seems to be telling me that Sift underneath Gatsby doesn't have any notion of my custom fields in its schema, which would kind of make sense to me.  So, as a test, I try this:</p>&#xA;&#xA;<pre><code>{&#xA;  site {&#xA;    siteMetadata(author: { eq: ""none"" }) {&#xA;      author&#xA;      title&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My expectation is the query runs successfully but returns an empty result set since the author element's value isn't ""none"".  But instead, I get the same basic error but now telling me ""Unknown argument author on field siteMetadata of type Site"" and now I'm confused because it seems like it should know about THOSE fields even if it doesn't know about arbitrary ones I add.  Then again, maybe that query won't ever work because there's only a single siteMetaData object versus trying to query an array.  I'm not sure.</p>&#xA;&#xA;<p>So then I do some research and I see some reference to 'filter', so I try this now:</p>&#xA;&#xA;<pre><code>{&#xA;  site {&#xA;    siteMetadata(filter: { eq: ""none"" }) {&#xA;      author&#xA;      title&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That gets me ""Unknown argument filter on field siteMetadata of type Site.""</p>&#xA;&#xA;<p>And now I'm kind of out of ideas.</p>&#xA;&#xA;<p>I did find one post that seemed to possibly imply that you can't query custom data elements like this at all, but some replies seem to imply you, in fact, can (and clearly that first test worked, so the data is found, I just can't get the filtering to work).  Maybe I'm using the wrong syntax, but if so then I can't seem to find what the correct syntax looks like (and what's worse is that in the Gatsby docs, the ONE example that MIGHT provide me an answer is error'ing out in the playground and I can't see the code).</p>&#xA;&#xA;<p>It seems like such a simple thing, but I'm at a loss.  Any help would be greatly appreciated.  Thanks!</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>EDIT: After I wrote this, I tried putting the data in a separate file that get loaded with the gatsby-transformer-json plugin and tried to query that.  The data gets loaded, but I still can't filter the query.  I can do:</p>&#xA;&#xA;<pre><code>{&#xA;  testData {&#xA;    people {&#xA;      name&#xA;      sales&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>...and that works, returns my data fine.  But if I try:</p>&#xA;&#xA;<pre><code>{&#xA;  testData {&#xA;    people(sales:{gt:200}) {&#xA;      name&#xA;      sales&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>...or...</p>&#xA;&#xA;<pre><code>{&#xA;  testData {&#xA;    people(filter:{sales:{gt:200}}) {&#xA;      name&#xA;      sales&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>...I get the same types of errors.  So, I think that at least proves this isn't an issue of querying it from siteMetaData specifically, but I still don't know how to make it do what I want.</p>&#xA;&#xA;<p>For anyone who wants to reproduce this, just add the file data.json in the root of the project with this content:</p>&#xA;&#xA;<pre><code>{&#xA;  ""people"" : [&#xA;    { ""id"" : 1234, ""name"" : ""Bill Smith"", ""sales"" : 143, ""birthdate"" : ""2233-03-22"" },&#xA;    { ""id"" : 5678, ""name"" : ""Roger Miller"", ""sales"" : 281, ""birthdate"" : ""2230-01-06"" }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then, add this to the plugins array in gatsby-config.json:</p>&#xA;&#xA;<pre><code>{&#xA;  resolve: `gatsby-transformer-json`,&#xA;  options: { typeName: `testData` }&#xA;},&#xA;{&#xA;  resolve: `gatsby-source-filesystem`,&#xA;  options: { name: `data`, path: `${__dirname}/data.json` }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>No other changes from the initially-generated project are needed.  Then, just hop into GraphiQL and try to execute the queries above.</p>&#xA;&#xA;<p>Or, to make things easier, I've created a codesandbox instance that demonstrates this:</p>&#xA;&#xA;<p><a href=""https://codesandbox.io/s/gatsby-graphql-querying-json-issue-47km4"" rel=""nofollow noreferrer"">https://codesandbox.io/s/gatsby-graphql-querying-json-issue-47km4</a></p>&#xA;&#xA;<hr>&#xA;&#xA;<p>EDIT2: I had the thought that maybe this is an issue with GraphiQL itself.  So, I created a simple component:</p>&#xA;&#xA;<pre><code>import React from ""react""&#xA;import { useStaticQuery, graphql } from ""gatsby""&#xA;&#xA;const Test = () =&gt; {&#xA;&#xA;const testData = useStaticQuery(graphql`&#xA;  query TestDateQuery {&#xA;    testData(filter: {sales: {gte:200}}) {&#xA;      people {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;`)&#xA;console.log(""testData"", testData);&#xA;&#xA;  return (&#xA;    &lt;div /&gt;&#xA;  )&#xA;}&#xA;&#xA;export default Test&#xA;</code></pre>&#xA;&#xA;<p>I then dropped that into my main Layout component.  I get the same sort of error (about filter being an unknown argument) rather than seeing my data.  If I remove the filter, I DO see ALL the data.  So, again, I can't figure out why just filter isn't working, but that's what I've narrowed it down to.</p>&#xA;",213268,,213268,2020-05-07 04:07:14,2020-05-07 04:07:14,Unable to filter custom data in siteMetaData in Gatsby using GraphQL in GraphiQL,<graphql><gatsby><graphiql>,0,13,0,2020-04-30 18:27:38
61540128,1,61542397,,0,1170,"<p>Currently i use graphql default pagination, that is by using limit offset (code given below) . which is working fine. but instead of the team list  how can we include pagination metadata. and return the pagination metadata along with this. I use sequalize to fetch the data</p>&#xA;&#xA;<pre><code>            type Query {&#xA;            allTeams(page:Int, pageSize:Int): [Team]&#xA;        }&#xA;        type Team {&#xA;            id: Int&#xA;            name: String  &#xA;        }&#xA;&#xA;        //resolver with pagination   &#xA;&#xA;        const paginate = ( page, pageSize ) =&gt; { &#xA;          var offset = page * pageSize;&#xA;          var limit =  pageSize;  &#xA;          return {&#xA;            offset,&#xA;            limit,&#xA;          };&#xA;        };&#xA;&#xA;        export const resolvers = {&#xA;            Query: {     &#xA;                  allTeams: async (obj, args, context, info ) =&gt;  Teams.findAll(           &#xA;                  paginate( args.page, args.pageSize ),         &#xA;                ),&#xA;            },&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>The above code will only return the list of teams .&#xA;Is there any way i can return a the output as which contains team list and pagination details</p>&#xA;&#xA;<pre><code>         {&#xA;          ""data"": {&#xA;            ""allTeams"": [&#xA;              {&#xA;                ""id"": 4,&#xA;                ""name"": ""Team created from postman"",&#xA;&#xA;              },&#xA;              {&#xA;                ""id"": 5,&#xA;                ""name"": ""Team created from postman"",&#xA;&#xA;              }&#xA;              ]&#xA;            },&#xA;               ""pageInfo"": {&#xA;                ""currentPage"": 2,&#xA;                ""perPage"": 2,&#xA;                ""itemCount"": 4,&#xA;                ""pageCount"": 2,&#xA;                ""hasPreviousPage"": true,&#xA;                ""hasNextPage"": false&#xA;              }&#xA;        }&#xA;</code></pre>&#xA;",13359622,,13359622,2020-05-01 09:55:07,2022-11-20 06:28:25,How to implement pagination in graphql which returns pagination metadata along with dataset,<node.js><pagination><graphql><sequelize.js><apollo>,1,0,0,2020-05-01 09:45:19
61542397,2,,61540128,0,,"<p>Yep, you'll just need to add the pagination metadata to your schema and provide the data in your resolvers. So for the output you're looking to achieve, the schema would look like:</p>&#xA;<pre><code>type Query {&#xA;  teams(page:Int, pageSize:Int): TeamsConnection&#xA;}&#xA;&#xA;type TeamsConnection {&#xA;  results: [Team]&#xA;  pageInfo: PageInfo&#xA;}&#xA;&#xA;type Team {&#xA;  id: Int&#xA;  name: String  &#xA;}&#xA;&#xA;type PageInfo {&#xA;  currentPage: Int&#xA;  perPage: Int&#xA;  itemCount: Int&#xA;  pageCount: Int&#xA;  hasPreviousPage: Boolean&#xA;  hasNextPage: Boolean&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Your resolver would then need to return the new shape of the response data. So something like:</p>&#xA;<pre><code>export const resolvers = {&#xA;  Query: {     &#xA;    allTeams: async (obj, args, context, info ) =&gt; {&#xA;      const results = await Teams.findAll(           &#xA;        paginate(args.page, args.pageSize),         &#xA;      );&#xA;      return {&#xA;        results,&#xA;        pageInfo: {...}&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3071332,,2044417,2022-11-20 06:28:25,2022-11-20 06:28:25,"",,0,0,0,2020-05-01 12:21:12
61545338,2,,58203635,6,,"<p>When @key specifies multiple fields, the first field is used as the HASH key and subsequent fields as the SORT key.</p>&#xA;&#xA;<p><a href=""https://aws-amplify.github.io/docs/cli-toolchain/graphql#key"" rel=""noreferrer"">https://aws-amplify.github.io/docs/cli-toolchain/graphql#key</a></p>&#xA;&#xA;<p>It is possible to list sorted items which have the same HASH key. For example, listing all comments by a user:</p>&#xA;&#xA;<pre><code>type Comment&#xA;  @model&#xA;  @key(fields: [""userId"", ""createdAt""]) {&#xA;    userId: ID!&#xA;    createdAt: String!&#xA;    text: String&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Assuming you're using AWS Amplify's GraphQL client, this will list all comments by a user, sorted newest first:</p>&#xA;&#xA;<pre><code>import { API, graphqlOperation } from 'aws-amplify';&#xA;import { listComments } from '@/graphql/queries';&#xA;&#xA;export default async function listCommentsForUser(userId) {&#xA;  const queryParams = {&#xA;    userId,&#xA;    sortDirection: 'DESC',&#xA;  };&#xA;&#xA;  const operation = graphqlOperation(listComments, queryParams);&#xA;&#xA;  return API.graphql(operation);&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>To list comments since a specified date, newest first, change the query params to include a range query:</p>&#xA;&#xA;<pre><code>const queryParams = {&#xA;    userId,&#xA;    sortDirection: 'DESC',&#xA;    createdAt: { gt: timestamp },&#xA;  };&#xA;</code></pre>&#xA;",353957,,,,2020-05-01 15:20:00,"",,0,2,0,2020-05-01 15:20:00
61569463,2,,54218505,3,,"<p>You can easily use a Filter just put this with your nodes.</p>&#xA;&#xA;<pre><code>class ReportFileFilter(FilterSet):&#xA;    id = GlobalIDMultipleChoiceFilter()&#xA;</code></pre>&#xA;&#xA;<p>Then in your query just use -</p>&#xA;&#xA;<pre><code>class Query(graphene.ObjectType):&#xA;    all_report_files = DjangoFilterConnectionField(ReportFileNode, filterset_class=ReportFileFilter)&#xA;</code></pre>&#xA;&#xA;<p>This is for relay implementation of graphql django.</p>&#xA;",7099572,,,,2020-05-03 03:58:35,"",,0,0,0,2020-05-03 03:58:35
61583375,1,61590943,,1,13605,"<p>I have this function which works:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const tagsByLabel = async (params) =&gt; {&#xA;  const findManyParams = {&#xA;    where: { userId: userIdFromSession },&#xA;    orderBy: { title: &quot;asc&quot; },&#xA;  };&#xA;  if (params) {&#xA;    const { searchTerm } = params;&#xA;    findManyParams.where.title = { contains: searchTerm };&#xA;  }&#xA;  console.log(&quot;findManyParams&quot;, findManyParams);&#xA;  const tagsByLabelResult = await db.tag.findMany(findManyParams);&#xA;  console.log(&quot;tagsByLabelResult&quot;, tagsByLabelResult);&#xA;  return tagsByLabelResult;&#xA;};&#xA;</code></pre>&#xA;<p>If I search for 'mex', I see:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>    findManyParams {&#xA;      where: { userId: 1, title: { contains: 'mex' } },&#xA;      orderBy: { title: 'asc' }&#xA;    }&#xA;    tagsByLabelResult [&#xA;      {&#xA;        id: 9,&#xA;        title: 'mex',&#xA;        description: 'Mexican food',&#xA;        userId: 1,&#xA;        createdAt: 2020-05-03T22:16:09.134Z,&#xA;        modifiedAt: 2020-05-03T22:16:09.134Z&#xA;      }&#xA;    ]&#xA;</code></pre>&#xA;<p>And for an empty query, <code>tagsByLabelResult</code> contains all tag records.</p>&#xA;<p><strong>How can I adjust my <code>tagsByLabel</code> function to aggregate (using &quot;group by&quot;) the records and output a &quot;count&quot; for each record of <code>tagsByLabelResult</code> in order by count descending?</strong></p>&#xA;<pre class=""lang-json prettyprint-override""><code>    tagsByLabelResult [&#xA;      {&#xA;        id: 9,&#xA;        title: 'mex',&#xA;        description: 'Mexican food',&#xA;        count: 25,&#xA;        userId: 1,&#xA;        createdAt: 2020-05-03T22:16:09.134Z,&#xA;        modifiedAt: 2020-05-03T22:16:09.134Z&#xA;      }&#xA;    ]&#xA;</code></pre>&#xA;<p>I see the <a href=""https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud#count"" rel=""nofollow noreferrer"">docs example</a> of <code>prisma.user.count()</code>, but that seems to retrieve a simple count of the result of the whole query rather than a count as a field with a &quot;group by&quot;.</p>&#xA;<p>I'm using RedwoodJs, Prisma 2, Apollo, GraphQL.</p>&#xA;",470749,,7910641,2021-06-22 12:26:29,2021-06-22 12:26:29,"How can I use ""count"" and ""group by"" in Prisma 2?",<react-apollo><prisma><prisma-graphql><redwoodjs>,2,0,0,2020-05-04 00:25:00
61586076,2,,60716044,0,,"<p>Make sure you have an entry for every content type in contenful. Including an asset. This seems to be many peoples problem in <a href=""https://github.com/gatsbyjs/gatsby/issues/16455"" rel=""nofollow noreferrer"">this thread</a>.</p>&#xA;",1910673,,,,2020-05-04 06:06:54,"",,0,0,0,2020-05-04 06:06:54
61605203,1,61614611,,3,4888,"<p>I am new to using aws-amplify and have a function similar to this which hits a query called <code>listItems</code> and returns items where <code>isEnbled</code> is true (from a DynamoDB).&#xA;I want this to filter the entire table which may be huge. I am therefore unable to simply set a limit like 1000 and leave it at that. Is there a way to specify limitless query and scan everything in the table? Or is there a different property I should be using instead?</p>&#xA;&#xA;<pre><code> import { API } from 'aws-amplify'&#xA;&#xA; export async function getAllEnabledListItems() {&#xA;      const { data } = await API.graphql({&#xA;      query: queries.listItems,&#xA;      variables: { filter: { isEnabled: { eq: true } }, limit: 10000 },&#xA;      authMode: 'AMAZON_COGNITO_USER_POOLS' &#xA;    })&#xA; return data&#xA; }&#xA;</code></pre>&#xA;",1429792,,,,2020-05-05 13:41:51,How to use graphQL limit in aws amplify,<javascript><graphql><amazon-dynamodb><aws-amplify>,1,0,0,2020-05-05 03:22:41
61612918,1,,,0,26,"<p>I am working on retrieving data from an API with graphql-yoga and node-fetch (in node.js). This is how my code looks like:</p>&#xA;&#xA;<pre><code>const {GraphQLServer} = require('graphql-yoga');&#xA;const fetch = require('node-fetch');&#xA;&#xA;const typeDefs = `&#xA;&#xA;    type Query {&#xA;        getTimeseries: Timeseries&#xA;    }&#xA;&#xA;    type Timeseries {&#xA;        end_date: String&#xA;        start_date: String&#xA;    }&#xA;`;&#xA;&#xA;const resolvers = {&#xA;&#xA;    Query: {&#xA;&#xA;        getTimeseries: async (_, {}) =&gt; {&#xA;            const response = await fetch(`https://fxmarketapi.com/apitimeseries?api_key=48Ki5q0sTKFQR3fuTvHw&amp;currency=EURUSD,GBPUSD&amp;interval=daily&amp;start_date=2020-04-30&amp;end_date=2020-05-01&amp;format=ohlc`);&#xA;            return response.json();&#xA;        },&#xA;    },&#xA;};&#xA;&#xA;const server = new GraphQLServer({&#xA;    typeDefs,&#xA;    resolvers&#xA;});&#xA;server.start(() =&gt; console.log('Server is running on localhost:4000'));&#xA;</code></pre>&#xA;&#xA;<p>The data you get when you run the data from the API endpoint I am using is as shown below:</p>&#xA;&#xA;<pre><code>{&#xA;    ""end_date"": ""2020-05-01"",&#xA;    ""price"": {&#xA;        ""2020-04-30"": {&#xA;            ""EURUSD"": {&#xA;                ""close"": 1.09528,&#xA;                ""high"": 1.09726,&#xA;                ""low"": 1.08331,&#xA;                ""open"": 1.08735&#xA;            },&#xA;            ""GBPUSD"": {&#xA;                ""close"": 1.25951,&#xA;                ""high"": 1.26432,&#xA;                ""low"": 1.24292,&#xA;                ""open"": 1.24671&#xA;            }&#xA;        },&#xA;        ""2020-05-03"": {&#xA;            ""EURUSD"": {&#xA;                ""close"": 1.09802,&#xA;                ""high"": 1.10152,&#xA;                ""low"": 1.09348,&#xA;                ""open"": 1.09528&#xA;            },&#xA;            ""GBPUSD"": {&#xA;                ""close"": 1.24941,&#xA;                ""high"": 1.25993,&#xA;                ""low"": 1.24859,&#xA;                ""open"": 1.25918&#xA;            }&#xA;        }&#xA;    },&#xA;    ""start_date"": ""2020-04-30""&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>At the moment based on my code above, I can only retrieve the values held by the <code>start_date</code> and <code>end_date</code> fields when I run my query. However, I don't know how to create a type definition to retrieve the object under <code>price</code> because the field names are dates and they change every day. Please help me write a type definition and resolver for the query we will use to retrieve this data.</p>&#xA;&#xA;<p>Ps: When running your tests you may come across some error codes. This should help you understand which error it is:</p>&#xA;&#xA;<pre><code>202 -   Requested currency code invalid or not in plan for Live and Convert Endpoints&#xA;203 -   Requested currency code invalid or not in plan for the Historical, Change, Timeseries and Pandas Endpoints&#xA;301 -   Invalid date type&#xA;302 -   Requested date is a weekend applicable to Historical, Change, Timeseries and Pandas Endpoints&#xA;401 -   Api_Key is invalid&#xA;501 -   Requestout of Range&#xA;502 -   Interval Parameters invalid&#xA;</code></pre>&#xA;",10288222,,,,2020-05-05 12:15:51,Is there a way to define a type definition for an object with changing property names in GraphQL?,<node.js><graphql><trading><forex><node-fetch>,0,4,0,2020-05-05 12:15:51
61614456,1,,,0,88,"<p>I'm trying to get some data using Apollo. Here's the simple query: </p>&#xA;&#xA;<pre><code>export const CurrentUserForProfile = gql`&#xA;&#xA;    query getGroupDetails($groupId: Long, $groupType: String, $tags: [Tag]) {&#xA;        nodes: NodesRelay (&#xA;          first: 50&#xA;          where: {&#xA;            tags: { CONTAINS: $tags },&#xA;            OR: {&#xA;              AND: {&#xA;                nsParentId: { EQ: $groupId }&#xA;                nsParentType: { EQ: $groupType }&#xA;              }&#xA;              superGroupNodeLinks: {&#xA;                groupId: { EQ: $groupId }&#xA;                groupType: { EQ: $groupType }&#xA;              }&#xA;            }&#xA;          }&#xA;        ) {&#xA;          elements {&#xA;            data {&#xA;              ...nodeFields&#xA;              ext {&#xA;                ...nodeExtFields&#xA;              }&#xA;            }&#xA;          }&#xA;          pageInfo {&#xA;            ...pageInfoFields&#xA;          }&#xA;        }&#xA;      }&#xA;&#xA;      fragment nodeFields on Node {&#xA;        id {&#xA;          id&#xA;          type&#xA;        }&#xA;        subtype&#xA;        internalId&#xA;        businessId&#xA;        scadaId&#xA;        isGroup&#xA;        isTemporary&#xA;        nsParentId&#xA;        nsParentType&#xA;        ouId&#xA;        description&#xA;        shortDescription&#xA;        status&#xA;        isNsPowered&#xA;        tags&#xA;        owners&#xA;        notes&#xA;        version&#xA;      }&#xA;&#xA;      fragment nodeExtFields on NodeExt {&#xA;        id {&#xA;          id&#xA;          type&#xA;        }&#xA;        asParentId&#xA;        asParentType&#xA;        isAsPowered&#xA;        isAsInconsistent&#xA;        isAsPoweredInParallel&#xA;        isAsPoweredByExtSource&#xA;        isAsPoweredByDiffSource&#xA;        maneuverId&#xA;        entityStatusMap&#xA;        createdAt&#xA;        createdBy&#xA;        updatedAt&#xA;        updatedBy&#xA;        version&#xA;      }&#xA;&#xA;      fragment pageInfoFields on PageInfo {&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;        startCursor&#xA;        endCursor&#xA;      }&#xA;    `;&#xA;</code></pre>&#xA;&#xA;<p>and the way i'm using it is as the tutorial say: </p>&#xA;&#xA;<pre><code>this.data = this.apollo&#xA;            .watchQuery({&#xA;                query: CurrentUserForProfile,&#xA;                variables: {&#xA;                    ""groupId"": 15,&#xA;                    ""groupType"": ""sec_subst"",&#xA;                    ""tags"": [""GIS""]&#xA;                },&#xA;                fetchResults: true,&#xA;                returnPartialData: false,&#xA;            }).valueChanges&#xA;            .pipe(&#xA;                map((res: any) =&gt; res.data.nodes.elements)&#xA;            )&#xA;</code></pre>&#xA;&#xA;<p>the HTML: </p>&#xA;&#xA;<pre><code>&lt;ng-container *ngFor=""let a of data | async""&gt;&#xA;    {{a.data.id.type}} &lt;br&gt;&#xA;  &lt;/ng-container&gt;&#xA;</code></pre>&#xA;&#xA;<p>What I'm getting is just 10 lines of <code>""lv_line""</code>.&#xA;If I change the logic, subscribing in the component and doing a <code>console.log(data)</code> I see the same things. This could be correct, but is not. The data I'm getting is totally wrong, and If I check in the network tab, no matter what the logic in my application is, the data is correct and is not just an array of 10 elements with a property <code>type</code> always being ""lv_line"".</p>&#xA;&#xA;<p>Here's the network result: </p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/16iNi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/16iNi.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>while the HTML result looks like this: </p>&#xA;&#xA;<p><a href=""https://i.stack.imgur.com/tATLA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tATLA.png"" alt=""enter image description here""></a></p>&#xA;&#xA;<p>What am I doing wrong? I've tried everything I could possibly think of without any success, getting the same wrong result try after try.</p>&#xA;",9890873,,,,2020-05-06 07:21:43,Getting wrong data using Apollo,<angular><apollo>,1,0,0,2020-05-05 13:34:21
61614611,2,,61605203,11,,"<h3>DynamoDB Scan vs Query</h3>&#xA;&#xA;<p>Rather than scanning every item and then filtering, you should consider adding a GSI to the ""enabled"" items in the table and then querying that. This will be much more efficient (i.e. faster and cheaper) at querying, at the expense of slightly higher write and storage costs. Usually it's a good trade off.</p>&#xA;&#xA;<h3>Pagination</h3>&#xA;&#xA;<p>Regardless of whether you query or scan though, you're going to have to deal with DynamoDB pagination once the size of the result set grows too large (max 1MB). If the result set hits the threshold then you'll get that first page of results and a <code>LastEvaluatedKey</code>. You'll then need to query again, passing the <code>LastEvaluatedKey</code> value as <code>ExclusiveStartKey</code>. You keep doing this until you get no <code>LastEvaluatedKey</code> back.</p>&#xA;&#xA;<p>If you update your AppSync schema and resolver to pass this <code>LastEvaluatedKey</code> back as a <code>paginationToken</code> (or whatever you want to call it), then you can requery repeatedly from your app passing the latest token to get the next page of results. If you don't need all the results at once you might consider lazily calling these to only ask for another page or results once you need it.</p>&#xA;&#xA;<h3>Other considerations</h3>&#xA;&#xA;<p>There are some other approaches.</p>&#xA;&#xA;<p>If you know the filtered set of results will always be &lt;1MB, one approach would be to swap out your DynamoDB datasource for a Lambda, and  progressively scan and filter (or query) DynamoDB pages in a loop inside your lambda before returning the filtered results to your AppSync resolver, and from there return to your app.</p>&#xA;&#xA;<p>The problems include:</p>&#xA;&#xA;<ul>&#xA;<li>How to guarantee that the filtered results set will always be under 1MB (AppSync's limit)</li>&#xA;<li>How to guarantee that the lambda will return in time (AppSync time limit)</li>&#xA;<li>You're scanning the whole table (if you scan rather than query) but you're only interested in a subset of those items (the ""isEnabled"" items)</li>&#xA;</ul>&#xA;&#xA;<p>Alternatively, if you can segment your items (or your ""isEnabled"" items) into multiple groups you can fan out your scan (or query) to implement parallel scans (or queries) before accumulating results as before. This may enable faster scans, but you'll still be limited in time and payload size so it's still problematic for huge table scans.</p>&#xA;&#xA;<h3>Summary</h3>&#xA;&#xA;<ul>&#xA;<li>DynamoDB enforces paginating results (max 1MB)</li>&#xA;<li>AppSync limits payload size (max 1MB, less if you're going to use subscriptions too)</li>&#xA;<li>DynamoDB Scans are less efficient than queries. Consider adding a GSI so that you can query instead of Scan / Filter.</li>&#xA;<li>Hacks to accumulate the pages of results inside Lambda or AppSync VTLs are fragile, and probably won't work for huge tables</li>&#xA;<li>Implementing pagination in your app will require updates to your AppSync schema to pass DynamoDB ""pagination tokens"" (<code>LastEvaluatedKey</code> / <code>ExclusiveStartKey</code>) in and out.</li>&#xA;</ul>&#xA;&#xA;<p>Adding a GSI, querying it (rather than scanning), and then adding pagination to your AppSync schema and app is the most robust solution.</p>&#xA;",1443106,,,,2020-05-05 13:41:51,"",,0,3,0,2020-05-05 13:41:51
61616776,1,,,2,669,"<p>I wanted to explore the pattern of fetching all the needed data for a page in one request.  So let's say I have a user config page, which needs a list of teams to assign a user to, and a list of roles a user can have.  I'm using the following query to get the first page of users as well as all available roles and teams.</p>&#xA;&#xA;<pre><code>import { gql } from ""@apollo/client"";&#xA;&#xA;const listUser = gql`&#xA;  fragment listUser on Query {&#xA;    users(page: $page, per: $per) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          name&#xA;          title&#xA;          avatar&#xA;        }&#xA;      }&#xA;      pageInfo {&#xA;        count&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const roleFragment = gql`&#xA;  fragment roleFragment on Query {&#xA;    roles {&#xA;      name&#xA;      id&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const teamsFragment = gql`&#xA;  fragment teamsFragment on Query {&#xA;    teams {&#xA;      nodes {&#xA;        id&#xA;        name&#xA;        manager {&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export const getUserConfig = gql`&#xA;  query getUserConfig($page: Int, $per: Int) {&#xA;    ...listUser&#xA;    ...roleFragment&#xA;    ...teamsFragment&#xA;  }&#xA;  ${listUser}&#xA;  ${roleFragment}&#xA;  ${teamsFragment}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>And I'm using it like this (generated using graphql-codegen):</p>&#xA;&#xA;<pre><code>const { loading, error, data, refetch } = useGetUserConfigQuery({&#xA; variables: {&#xA;   page: 1,&#xA;   per: 7,&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>This works really well and allows me to grab the data I need for the page in one round trip.  However, whenever I change the page variable for users (to go to the next page obviously), it's going to refetch <strong>everything</strong>.  Is there a way of doing this so that it only refetches the fragment that's variables changed?  Or is there a better pattern for what I'm trying to accomplish? Thanks!</p>&#xA;",5041876,,,,2020-05-09 09:35:39,Apollo Client - Possible to refetch only a fragment of a larger query when it's variables change?,<javascript><reactjs><graphql><apollo>,1,0,0,2020-05-05 15:26:22
61618600,2,,61615633,0,,"<p>You have a few options for importing data from a CSV file.</p>&#xA;&#xA;<p>This <a href=""https://neo4j.com/developer/guide-import-csv/"" rel=""nofollow noreferrer"">CSV import guide</a> is a good intro.</p>&#xA;&#xA;<p>If you want to import (using the Cypher <code>LOAD CVS</code> approach) from within your Javascript program, you should also read up on the official <a href=""https://neo4j.com/developer/language-guides/"" rel=""nofollow noreferrer"">Drivers</a>.</p>&#xA;",974731,,,,2020-05-05 16:55:54,"",,0,0,0,2020-05-05 16:55:54
61629175,2,,61628995,0,,"<p>Assuming the underlying types of both <code>One</code> &amp; <code>Two</code> are the same, you can use <a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">Fragments</a></p>&#xA;&#xA;<pre><code>query {&#xA;  fileJson {&#xA;    MAIN_ARRAY {&#xA;      One {&#xA;        ...MyFragment&#xA;      }&#xA;      Two {&#xA;        ...MyFragment&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment MyFragment on MyType {&#xA;  title&#xA;  description&#xA;  avatar&#xA;}&#xA;</code></pre>&#xA;",10687857,,,,2020-05-06 06:58:37,"",,0,0,0,2020-05-06 06:58:37
61640022,1,,,3,884,"<p>I'm using Apollo Federation for 2 months but I'm actually stuck. I've no idea how to pass a variable between my two graphql services. </p>&#xA;&#xA;<p>I've got a website (website graphql service) which have orders (orders graphql service).&#xA;I have a query to find websites and for these websites I want some stats of orders for a date range. Here the typedef (website) :</p>&#xA;&#xA;<pre><code>type Query {&#xA;  websites(orderFilter: OrderFilterInput): [Website!]&#xA;}&#xA;&#xA;type Website @key(fields: ""id"") {&#xA;  id: ID!&#xA;  name: String!&#xA;  url: String!&#xA;  orderSummary(orderFilter: OrderSummaryFilterInput): OrderSummary&#xA;}&#xA;&#xA;input OrderSummaryFilterInput {&#xA;  beginDate: Date&#xA;  endDate: Date&#xA;}&#xA;&#xA;extend type OrderSummary @key(fields: ""websiteId"") {&#xA;  websiteId: String! @external&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The resolver : </p>&#xA;&#xA;<pre><code>orderSummary: (website, { orderSummaryFilter }) =&gt; {                &#xA;  console.log(""orderSummaryFilter"", orderSummaryFilter); // filters are OK&#xA;  // HOW CAN I PASS orderFilterSummary to my order graphql service here ????&#xA;  return { __typename: ""OrderSummary"", websiteId: website.id }; &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And Order graphql service </p>&#xA;&#xA;<p>Typedef part :</p>&#xA;&#xA;<pre><code>type OrderSummary @key(fields: ""websiteId"") {&#xA;    websiteId: String!&#xA;    count: Int&#xA;    amount: Int&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Resolver part :</p>&#xA;&#xA;<pre><code>// order gql service&#xA;&#xA;OrderSummary: {&#xA;  __resolveReference(website, args, info) {&#xA;    console.log(""website id :"", website.id); // I ve got my website ID&#xA;    // HOW TO GET OrderSummaryFilter here ????&#xA;  },&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>How can I access to order summary filter variable in order graphql resolver ? Thank you.</p>&#xA;",7807547,,2312051,2020-05-12 13:18:37,2020-07-07 00:32:52,Passing variables to an external resolve reference,<apollo><apollo-federation>,2,0,0,2020-05-06 16:14:53
61651207,1,61664936,,0,230,"<p>I am working on a project where I have to create one to many relationships which will get all the list of records referenced by id in another table and I have to display all the selected data in the multi-select field <code>(selectArrayInput)</code>. Please help me out in this, if you help with an example that would be great.&#xA;Thanks in advance.</p>&#xA;&#xA;<pre><code>Example:&#xA;district&#xA;id    name&#xA;1     A&#xA;2     B&#xA;3     C&#xA;&#xA;block&#xA;id    district_id    name&#xA;1     1              ABC&#xA;2     1              XYZ&#xA;3     2              DEF&#xA;</code></pre>&#xA;&#xA;<p>I am using <code>https://github.com/Steams/ra-data-hasura-graphql</code> <strong><em>hasura-graphql dataprovider</em></strong> for my application.</p>&#xA;",5727081,,,,2020-05-07 18:18:29,ReferenceManyFields (One to Many Relationship),<graphql><react-admin><hasura>,1,0,0,2020-05-07 06:24:39
61664031,1,61673927,,-1,577,"<p>I'm trying to use a Rest API, but when I query, I receive the following error that I don't understand, I've tried to look at similar questions here but they are very particular cases. &#xA;This is the code I use</p>&#xA;&#xA;<pre><code>$oAuth2TokenUrl = ""https://api.cloudflare.com/client/v4/graphql""&#xA;$accessKey = '1234'&#xA;&#xA;$Cloudflare_Oauth_Header = @{&#xA;    ""X-AUTH-EMAIL"" = ""bryan"";&#xA;    ""X-AUTH-KEY"" = ""$accessKey"";&#xA;    ""Content-type"" = ""application/json""&#xA;}&#xA;&#xA;$query = '\""query\"": \""{&#xA;  viewer {&#xA;zones(filter: {zoneTag: \""1234\""}) {&#xA;  httpRequests1mGroups(orderBy: [datetimeMinute_ASC], limit: 1000, filter: {datetime_geq: \""2020-05-07T10:00:00Z\"", datetime_lt: \""2020-05-07T10:10:00Z\""}) {&#xA;    dimensions {&#xA;      datetimeMinute&#xA;    }&#xA;    sum {&#xA;      browserMap {&#xA;        pageViews&#xA;        uaBrowserFamily&#xA;      }&#xA;    }&#xA;    uniq {&#xA;      uniques&#xA;    }&#xA;  }&#xA;}&#xA;  }&#xA;    } \""' | ConvertTo-Json    &#xA;&#xA;$Cloudflare_zone = Invoke-RestMethod -Uri $oAuth2TokenUrl -Method POST -Headers $Cloudflare_Oauth_Header -Body $query -ContentType 'application/json'&#xA;</code></pre>&#xA;&#xA;<p>So once I check the content of <code>$Cloudflare_zone</code> the following is printed </p>&#xA;&#xA;<p><code>{@{message=failed to recognize JSON request: 'json: cannot unmarshal string into Go value of type graphql.httpPostBody'; path=; extensions=}}</code></p>&#xA;",8891380,,1427878,2020-05-08 06:49:05,2020-05-08 07:19:25,JSON: cannot unmarshal string,<json><powershell><graphql>,1,1,0,2020-05-07 17:28:51
61693630,1,,,0,110,<p>If you have a graphql query like this</p>&#xA;&#xA;<pre><code>query findAllNotes() {&#xA;    comments: [Comment]!&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>How do you paginate and filter the notes and comments without having ugly looking and lengthy argument lists?<br>&#xA;This problem worsens as the nest level increases.</p>&#xA;,8008763,,,,2020-05-09 08:13:08,GraphQL query looks ugly and has too arguments many with paginate and filter on many nested fields,<graphql>,1,0,0,2020-05-09 08:07:13
61743194,2,,61721416,0,,<p>I found the correct type for <code>$orderId</code>.&#xA;I changed the <code>String</code> to <code>ID!</code></p>&#xA;&#xA;<p>Here is my fixed code.</p>&#xA;&#xA;<pre><code>const GET_ORDER_DETAIL = gql`&#xA;query getOrderDetail($orderId: ID!) {&#xA; ...&#xA;}&#xA;`;&#xA;</code></pre>&#xA;&#xA;<pre><code>...&#xA;&lt;Query key={index} query={GET_ORDER_DETAIL} variables={{ orderId }}&gt;&#xA;...&#xA;</code></pre>&#xA;,12241587,,,,2020-05-12 03:16:53,"",,0,0,0,2020-05-12 03:16:53
61758703,2,,61754335,0,,<p>That LOAD CSV command will just invoke <code>CREATE (n)</code> once per line which will create a node with no label or properties. Try changing it to something like <code>CREATE (n:CsvNode) SET n.prop_1 = csvLine.header1</code> (where <code>header1</code> is one of the headers from your CSV) and see if nodes labelled :CsvNode get created.</p>&#xA;,8226114,,,,2020-05-12 17:56:33,"",,0,0,0,2020-05-12 17:56:33
61772485,2,,61772382,1,,"<p>You need to use a slice of <strong>pointers</strong>:</p>&#xA;&#xA;<pre><code>users := make([]*model.User, 0, 2)&#xA;if err := r.DB.Find(&amp;users).Error; err != nil {&#xA;    log.Fatal(err)&#xA;}&#xA;</code></pre>&#xA;",9524541,,5766794,2020-05-13 10:55:37,2020-05-13 10:55:37,"",,0,0,0,2020-05-13 10:40:17
61790790,2,,61776137,0,,"<p>You can simplify the code a bit more, returning null when none of the conditions are matched:</p>&#xA;&#xA;<pre><code>const renderIcon = () =&gt; {&#xA;  if (!condition1 || !condition2 || (icon_name === 'add' &amp;&amp; count === 0)) {&#xA;    return null;&#xA;  }&#xA;  return renderAnother();&#xA;}&#xA;</code></pre>&#xA;",4468021,,,,2020-05-14 06:34:48,"",,0,0,0,2020-05-14 06:34:48
61799558,1,68543600,,0,515,"<p>Is it possible to add a look up to a mutation in GraphQL? Let's say something like an input type where one property is the result of another query.</p>&#xA;&#xA;<pre><code>createPerson(name: ""Steve"", gender: genders ( name: { eq: ""mail"" } ) { id } )&#xA;</code></pre>&#xA;&#xA;<p>where <code>genders ( name: { eq: ""mail"" } ) { id }</code> would return exactly one result value</p>&#xA;",66907,,6124657,2021-07-27 10:56:08,2021-07-27 10:56:08,GraphQL mutation with subquery for parameter - update/convert DB on write?,<graphql><hotchocolate>,1,5,0,2020-05-14 14:13:17
61802389,1,61805864,,1,1328,"<p>i want to Query only selected fields using Apollo graphql in java.</p>&#xA;&#xA;<p>Dont find any article which shows how we can achieve that</p>&#xA;&#xA;<p>I define my query in .graphql file like this,</p>&#xA;&#xA;<pre><code>query getResources{&#xA;   resources(filterBy: {} ) {&#xA;      edges{&#xA;         cursor&#xA;         node   {&#xA;                id&#xA;                name&#xA;                canonicalName&#xA;                description&#xA;                createdAt&#xA;                updatedAt&#xA;                createdBy&#xA;                updatedBy&#xA;         }&#xA;      }&#xA;      pageInfo{&#xA;          hasPreviousPage&#xA;          hasNextPage&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>while making the query request &#xA; execute = apolloClient.query(getResourcesQuery).execute();</p>&#xA;&#xA;<p>i want to change the getResourcesQuery object to only query certain fields.&#xA; how can we do that ?</p>&#xA;",6414385,,6124657,2020-05-14 17:15:36,2020-05-16 16:07:48,How to dynamically adjust Query shape (fields) using Apollo graphql?,<java><graphql><apollo><apollo-client>,2,9,0,2020-05-14 16:23:29
61805864,2,,61802389,2,,"<p>Apollo Android is not really a query builder -- you can't specify individual fields to add to a selection set. Instead, your provided query is sent as-is. If you're looking for that sort of functionality, you may want to look into a different client (like <a href=""https://github.com/americanexpress/nodes"" rel=""nofollow noreferrer"">nodes</a>).</p>&#xA;&#xA;<p>That said, you can utilize the <code>@skip</code> and <code>@include</code> directives, combined with some variables, to dynamically control what's included in your request's selection set. For example:</p>&#xA;&#xA;<pre><code>query getResources(&#xA;  $includeEdges: Boolean = true&#xA;  $includePageInfo: Boolean = true&#xA;) {&#xA;  resources(filterBy: {}) {&#xA;    edges @include(if: $includeEdges) {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        name&#xA;        canonicalName&#xA;        description&#xA;        createdAt&#xA;        updatedAt&#xA;        createdBy&#xA;        updatedBy&#xA;      }&#xA;    }&#xA;    pageInfo @include(if: $includePageInfo) {&#xA;      hasPreviousPage&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then just add the variables:</p>&#xA;&#xA;<pre><code>GetResources getResourcesQuery = GetResources.builder()&#xA;    .includePageInfo(false)&#xA;    .build();&#xA;&#xA;apolloClient().query(getResourcesQuery).execute();&#xA;</code></pre>&#xA;",6024220,,,,2020-05-14 19:28:43,"",,0,0,0,2020-05-14 19:28:43
61816259,2,,61758484,1,,"<p>You will have to update the sort on the ID to fetch from the end </p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>query Articles {&#xA;    articles(limit: 10, sort: ""id:desc"") {&#xA;      id&#xA;      title&#xA;      category {&#xA;        id&#xA;        name&#xA;      }&#xA;      Image&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",9208166,,,,2020-05-15 09:42:25,"",,0,0,0,2020-05-15 09:42:25
61860681,1,61861346,,0,549,"<p>I've got a certain set of GraphQL fields that I would like to re-use across a bunch of different types.</p>&#xA;&#xA;<p>The current type looks like this, and it pertains to my Pagination information:</p>&#xA;&#xA;<pre><code>  type Pagination {&#xA;    totalDocs: Int!&#xA;    limit: Int!&#xA;    totalPages: Int!&#xA;    page: Int!&#xA;    offset: Int!&#xA;    pagingCounter: Int!&#xA;    hasPrevPage: Boolean!&#xA;    hasNextPage: Boolean!&#xA;    prevPage: Int&#xA;    nextPage: Int&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>There are several types which should include this information. I'm aware that I could nest the information in a sub-field, and then have that subfield point to this type. Like this:</p>&#xA;&#xA;<pre><code>type House {&#xA;    cost: Int!&#xA;    size: Int!&#xA;    pagination: Pagination&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, I'd rather not nest the information if that's possible. For example, the completed types might look </p>&#xA;&#xA;<pre><code>type House {&#xA;    cost: Int!&#xA;    size: Int!&#xA;    totalDocs: Int!&#xA;    limit: Int!&#xA;    totalPages: Int!&#xA;    page: Int!&#xA;    offset: Int!&#xA;    pagingCounter: Int!&#xA;    hasPrevPage: Boolean!&#xA;    hasNextPage: Boolean!&#xA;    prevPage: Int&#xA;    nextPage: Int&#xA;  }&#xA;&#xA;&#xA;type Car {&#xA;    speed: Int!&#xA;    color: String!&#xA;    totalDocs: Int!&#xA;    limit: Int!&#xA;    totalPages: Int!&#xA;    page: Int!&#xA;    offset: Int!&#xA;    pagingCounter: Int!&#xA;    hasPrevPage: Boolean!&#xA;    hasNextPage: Boolean!&#xA;    prevPage: Int&#xA;    nextPage: Int&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Is it possible to extract the repetitive fields into another common chunk and share it across multiple types, without nesting the data inside of another field. With objects, for example, something similar would be possible with the spread (<code>...</code>) operator.</p>&#xA;&#xA;<p>Something like this?</p>&#xA;&#xA;<pre><code>type Car {&#xA;        cost: Int!&#xA;        size: Int!&#xA;        ...pagination&#xA;      }&#xA;</code></pre>&#xA;",7860026,,,,2020-05-18 02:08:09,Reusing Group of Fields in GraphQL Schema,<javascript><graphql>,1,2,0,2020-05-18 00:39:16
61861346,2,,61860681,1,,"<p>If you're forming them with gql tag or some other string-based system, you can abstract them out into a common type and Template-literal them in.</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>&#xA;const Pagination = `&#xA;    totalDocs: Int!&#xA;    limit: Int!&#xA;    totalPages: Int!&#xA;    page: Int!&#xA;    offset: Int!&#xA;    pagingCounter: Int!&#xA;    hasPrevPage: Boolean!&#xA;    hasNextPage: Boolean!&#xA;    prevPage: Int&#xA;    nextPage: Int&#xA;`;&#xA;&#xA;module.exports = `&#xA;  type Car {&#xA;    cost: Int!&#xA;    size: Int!&#xA;    ${Pagination}&#xA;  }&#xA;&#xA;  type House {&#xA;    cost: Int!&#xA;    size: Int!&#xA;    ${Pagination}&#xA;  }&#xA;`;&#xA;&#xA;</code></pre>&#xA;",12022691,,,,2020-05-18 02:08:09,"",,0,0,0,2020-05-18 02:08:09
61871410,1,61871765,,0,171,"<p>this query in GraphiQL works perfect:</p>&#xA;&#xA;<pre><code>{&#xA;  getSubContentListing(filter: ""{\""contentSection\"": \""home\""}"") {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        contentSection&#xA;        contentTitle&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But if I include it in my Axios-query:</p>&#xA;&#xA;<pre><code>  let query = {&#xA;    query: `query {&#xA;      getSubContentListing(&#xA;        filter: ""{\""contentSection\"": \""home\""}"") {&#xA;        edges {&#xA;          node {&#xA;            contentSection&#xA;            contentTitle&#xA;          }&#xA;        },&#xA;      }&#xA;    }`&#xA;  }&#xA;  axios({&#xA;    method: 'post',&#xA;    url: '/subcontent?apikey=abcdef',&#xA;    data: {&#xA;      query: query&#xA;    }&#xA;  })&#xA;</code></pre>&#xA;&#xA;<p>ESLint give an Error ""error: Unnecessary escape character: \"" (no-useless-escape) ""</p>&#xA;&#xA;<p>If I build it as a variable like this: </p>&#xA;&#xA;<pre><code>  let query = {&#xA;    query: `query($filterSearch: String) {&#xA;      getSubContentListing(&#xA;        filter: $filterSearch) {&#xA;        edges {&#xA;          node {&#xA;            contentSection&#xA;            contentTitle&#xA;          }&#xA;        },&#xA;      }&#xA;    }`&#xA;  }&#xA;  axios({&#xA;    method: 'post',&#xA;    url: '/subcontent?apikey=abcdef',&#xA;    data: {&#xA;      query: query,&#xA;      variables: {&#xA;        filterSearch: JSON.stringify(""{'contentSection': 'home'}"")&#xA;      }&#xA;    }&#xA;  })&#xA;</code></pre>&#xA;&#xA;<p>for ESLint it is OK, but the query didn't work.&#xA;Where is my mistake?</p>&#xA;&#xA;<p>awant</p>&#xA;",1921688,,,,2020-05-18 14:40:42,graphiQL-query in Axios,<javascript><graphql><axios>,1,0,0,2020-05-18 14:04:49
61882316,1,,,0,267,"<p>I'm trying to inject variables into a GQL query in a functional way like this</p>&#xA;&#xA;<pre><code>const ALL_PEOPLE_QUERY = gql`&#xA;  query All_People_Query {&#xA;    allPeople {&#xA;      people {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;interface Data {&#xA;  allPeople: {&#xA;    people: Array&lt;{ id: string; name: string }&gt;;&#xA;  };&#xA;};&#xA;&#xA;interface Variables {&#xA;  first: number;&#xA;};&#xA;&#xA;const AllPeopleComponent = &lt;Query&lt;Data, Variables&gt; query={ALL_PEOPLE_QUERY}&gt;&#xA;  {({ loading, error, data }) =&gt; { ... }}&#xA;&lt;/Query&gt;&#xA;</code></pre>&#xA;&#xA;<p>from <a href=""https://www.apollographql.com/docs/react/development-testing/static-typing/"" rel=""nofollow noreferrer"">here</a> </p>&#xA;&#xA;<p>doing something like this</p>&#xA;&#xA;<pre><code>&#xA;export const AllPeopleComponent = () =&gt; (&lt;Query&lt;Data, Variables&gt; query={ALL_PEOPLE_QUERY}&gt;&#xA;  {({ loading, error, data }) =&gt; { ... }}&#xA;&lt;/Query&gt;&#xA;);&#xA;&#xA;&#xA;ReactDOM.render(&lt;ApolloProvider client={client}&gt;&lt;AllPeopleComponent/&gt;&lt;/ApolloProvider&gt;, document.getElementById('list'));&#xA;</code></pre>&#xA;&#xA;<p>But how do I inject variables into the query in the reactDom call?</p>&#xA;",1213907,,3001761,2020-05-29 11:24:56,2020-05-29 11:24:56,typescript apollo gql react pass in variables to functional composition,<reactjs><typescript><graphql><apollo>,1,0,0,2020-05-19 02:36:49
61917923,1,,,0,744,"<p>Im using GraphQL and DynamoDB with the adjacency list pattern, in that I am only using one table.</p>&#xA;&#xA;<p>Say I have the schema - </p>&#xA;&#xA;<pre><code>type GrandParent {&#xA;   id: ID!&#xA;   children: [Parent]&#xA;}&#xA;&#xA;type Parent {&#xA;   id: ID!&#xA;   children: [Child]&#xA;}&#xA;&#xA;type Child {&#xA;   id: ID!&#xA;}&#xA;&#xA;type Query {&#xA;   getGrandParent(id: ID): GrandParent&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For dynamodb I have the following primary key structure - </p>&#xA;&#xA;<p>for Grandparent&#xA;<code>pk = GRANDPARENT_&lt;id&gt;, sk = GRANDPARENT</code></p>&#xA;&#xA;<p>for Parent&#xA;<code>pk = PARENT_&lt;ID&gt;, sk = GRANDPARENT_&lt;id&gt;</code></p>&#xA;&#xA;<p>for Child&#xA;<code>pk = CHILD_&lt;id&gt;, sk = PARENT_&lt;id&gt;</code></p>&#xA;&#xA;<p>with a GSI that will invert the keys.</p>&#xA;&#xA;<p>So, given a Grandparent ID, I can find all the Parents using the GSI, as I know the Grandparent ID, so I can do - <code>where sk = GRANDPARENT_&lt;id&gt; and pk begins with PARENT_ID</code> which will bring me back all the Parents, but then how can I get the IDs of these parents and now go and get all the Child records?  Is it possible to do multiple trips to the DB in one graphql request?</p>&#xA;",1849358,,,,2020-05-21 11:08:06,AWS AppSync get child results based on parent result,<graphql><amazon-dynamodb><aws-appsync>,1,10,0,2020-05-20 16:18:32
61928688,2,,61772827,0,,"<p>The <code>id</code> is not properly defined, it should be:</p>&#xA;&#xA;<pre><code>food(id: [String]): [Food]&#xA;</code></pre>&#xA;&#xA;<p>In this case I'd name the argument in plural form too, so <code>ids</code> instead of <code>id</code>.</p>&#xA;",12507062,,,,2020-05-21 06:38:19,"",,0,1,0,2020-05-21 06:38:19
61936127,2,,61892594,0,,"<p>When you don't the know the structure in advance in graphQL, you can use a list structure as a workaround.  A CSV file is a list of rows, and a row is a key value pairs.</p>&#xA;&#xA;<p>First define the value of each cell in a structure something like this:</p>&#xA;&#xA;<pre><code>class ColumnValueType(graphene.ObjectType):&#xA;    column_name = graphene.String(required=True)  #  this is column heading&#xA;    value = graphene.String(required=True)  #  you don't know the value type you have to assume string&#xA;</code></pre>&#xA;&#xA;<p>Then define your row as a list of column values</p>&#xA;&#xA;<pre><code>class RowType(graphene.ObjectType):&#xA;    row = graphene.List(ColumnValueType)&#xA;</code></pre>&#xA;&#xA;<p>and CSV data as a list of rows:</p>&#xA;&#xA;<pre><code>class CSVDataType(graphene.ObjectType):&#xA;    rows = graphene.List(RowType)&#xA;</code></pre>&#xA;&#xA;<p>This is all a bit clunky but something like this should be able to hold the entire contents of a CSV file.  Hopefully this points you in the right direction of how to populate a structure like this for query results.</p>&#xA;",178800,,,,2020-05-21 13:53:45,"",,0,0,0,2020-05-21 13:53:45
61948728,2,,61940478,6,,"<p>You should <code>import { CardFields } from ""../fragments/cardFragments.js""</code> and then use this fragment in your mutation like this: <br/></p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {gql} from ""apollo-boost"";&#xD;&#xA;import { CARD_FEILDS } from ""../fragments/cardFragments.js""&#xD;&#xA;&#xD;&#xA;export const ADD_CARD = gql`&#xD;&#xA;    mutation AddCard {&#xD;&#xA;        createCard(input: {&#xD;&#xA;            private: true,&#xD;&#xA;            section: ""school"",&#xD;&#xA;            createdBy: ""api/users/1""&#xD;&#xA;        }) {&#xD;&#xA;            card {&#xD;&#xA;                ...CardFields&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    ${CARD_FEILDS}&#xD;&#xA;`;&#xD;&#xA;&#xD;&#xA;export default {ADD_CARD}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>In cardFragments.js:&#xA;<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {gql} from ""apollo-boost""&#xD;&#xA;export const CARD_FEILDS = gql `&#xD;&#xA;  fragment CardFields on card {&#xD;&#xA;    id&#xD;&#xA;    private&#xD;&#xA;    section&#xD;&#xA;    createdBy {&#xD;&#xA;        id&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;`</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",9548285,,,,2020-05-22 05:57:46,"",,0,4,0,2020-05-22 05:57:46
61955916,1,,,1,2830,"<p>I want to make a query on the dynamodb using graphql </p>&#xA;&#xA;<p><code>&#xA;    TableName: ""JobInfo"",&#xA;    IndexName: ""tableauGSI"",&#xA;    KeyConditionExpression: ""tableauGSI_Tableau = tableau AND #D BETWEEN :startDate AND :endDate"",&#xA;    ExpressionAttributeNames: { ""#D"": ""date"" },&#xA;    ExpressionAttributeValues: {&#xA;      "":startDate"": startDate,&#xA;      "":endDate"": days&#xA;    },&#xA;    ReturnConsumedCapacity: ""TOTAL""</code></p>&#xA;&#xA;<p>But when I execute the query I receive the error: ""<em>Invalid condition in KeyConditionExpression: Multiple attribute names used in one condition</em>""</p>&#xA;",4370184,,,,2020-05-22 13:29:54,Invalid condition in KeyConditionExpression: Multiple attribute names used in one condition,<typescript><amazon-web-services><graphql><amazon-dynamodb>,1,1,0,2020-05-22 13:13:35
61978278,2,,61962277,0,,"<p>I think it is possible to filter by optional fields.&#xA;for example, this snippet works for me.</p>&#xA;&#xA;<pre><code>const [user] = await prisma.user.findMany({&#xA;      where: {&#xA;        emailToken: args.emailToken,&#xA;        emailTokenExpiry: {&#xA;          gte: Date.now() - 3600000,&#xA;        },&#xA;      },&#xA;    });&#xA;</code></pre>&#xA;",5534469,,,,2020-05-23 20:37:03,"",,0,0,0,2020-05-23 20:37:03
61978707,2,,61977854,0,,"<p>The solution here was to not wrap the <code>AudioData</code> type into <code>Response</code>, despite the fact that they use that pattern in the documentation. I updated the following lines:</p>&#xA;&#xA;<pre><code>class ConnectedWorkspaceAudio extends React.Component&lt;&#xA;  ChildProps&lt;{}, AudioData&gt;&#xA;{&#xA;...&#xA;&#xA;const WorkspaceAudio = graphql&lt;{}, AudioData&gt;(WORKSPACE_AUDIO_QUERY)(&#xA;  ConnectedWorkspaceAudio&#xA;);&#xA;</code></pre>&#xA;",1245581,,,,2020-05-23 21:21:00,"",,0,0,0,2020-05-23 21:21:00
62008654,2,,50177814,0,,"<p>As Hemant mentioned already, the @compose annotation in Apollo 2.1 is the ""correct"" / conventional way to solve this problem. If that doesn't work for you for whatever reason, there is possibly another cruder/hacky way to accomplish this:</p>&#xA;&#xA;<p>If your <code>Item</code> model has a parent model, you can mutate multiple nodes with one mutation by passing the children in as the array values to the <code>connect</code> / <code>create</code> / <code>update</code> actions.</p>&#xA;&#xA;<p>The unfortunate limitation here is that there is no way to individually identify child nodes to be updated. What I mean is that you can filter child <code>Items</code> to be mutated based on a criteria (like <code>postition</code> = 2) but that will only allow you to mutate the filtered items to the same state; you won't be able to update them differently from one another this way.</p>&#xA;&#xA;<p>If we allow ourselves one more crude step, you can delete the Item nodes that you wish to update before calling the update mutation - this will allow you to call the mutation with all of the updated items under the <code>create:</code> key in the mutation, which will allow you to specify each item to be created. In this way, the number of items you can create is only limited by the size of your request payload.</p>&#xA;&#xA;<p>There are many cases where deleting and creating nodes is unacceptable (as opposed to updating them)...if you use this method then be sure there are no negative side effects to your use case(s) from deleting item data in this way.</p>&#xA;",3067789,,,,2020-05-25 18:39:09,"",,0,0,0,2020-05-25 18:39:09
62033388,2,,62031840,1,,"<p>The <a href=""https://github.com/graphql-go/graphql/issues/322"" rel=""nofollow noreferrer"">recommended way</a> of handling this is using <code>AddFieldConfig</code>:</p>&#xA;&#xA;<pre><code>houseType := &amp;graphql.Object{...}&#xA;residentType := &amp;graphql.Object{...}&#xA;&#xA;houseType.AddFieldConfig(""residents"", &amp;graphql.Field{Type: graphql.NewList(residentType)})&#xA;residentType.AddFieldConfig(""houses"",  &amp;graphql.Field{Type: graphql.NewList(houseType)})&#xA;</code></pre>&#xA;",6024220,,,,2020-05-27 00:05:18,"",,0,0,0,2020-05-27 00:05:18
62039112,1,63230892,,2,2989,"<p>How can I create an array of arrays as inputs in <a href=""https://www.apollographql.com/"" rel=""nofollow noreferrer"">ApolloGraphQL</a>?</p>&#xA;&#xA;<p>For instance, how should be the Schema for a query like this:</p>&#xA;&#xA;<pre><code>{&#xA;    Users(Id:1, Filters:[[""Id"",""&gt;"", ""1""], [""Id"",""&lt;"",""3""]]) {&#xA;      Id&#xA;      Name&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I have tried the following schema but no luck:</p>&#xA;&#xA;<pre><code>const typeDefs = gql`&#xA;  type Query{&#xA;      Users(&#xA;        Id: ID,&#xA;        Filters: [[String, String, String]]&#xA;      )&#xA;   }&#xA; `;&#xA;</code></pre>&#xA;&#xA;<p>What I am trying to achieve here is an Input type which is a <strong>List of Lists</strong>, with each of the child lists containing exactly 3 strings. So it can be called like this within the function: <code>Filters:[[""Id"",""&gt;"", ""1""], ..]</code></p>&#xA;",3876830,,3876830,2020-05-28 11:45:29,2020-08-03 14:02:02,How to create an array of arrays as input in ApolloGraphQL,<graphql><apollo><apollo-client><graphql-js><apollo-server>,2,3,0,2020-05-27 08:53:49
62040145,1,,,0,241,"<p>I'm very new to GraphQL, and struggling with searching. I need to do a keyword search that could appear in any of the <strong>address</strong> fields or the <strong>name</strong> of either the <strong>location</strong> or <strong>topLevelItem</strong>. (So an OR relationship between individual fields). How would I alter the query to do that? All the examples I can find are only for searching a single field.</p>&#xA;&#xA;<pre><code>query {&#xA;  topLevelItems {&#xA;    elements {&#xA;      id&#xA;      name&#xA;      location {&#xA;        id&#xA;        name&#xA;        address {&#xA;          houseNumber&#xA;          houseNumberAddition&#xA;          street&#xA;          city&#xA;          postalCode&#xA;          countryCode&#xA;          phone&#xA;        }&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      numberOfElements&#xA;      totalElements&#xA;      totalPages&#xA;      hasPrevious&#xA;      hasNext&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8830486,,,,2020-05-27 09:45:19,GraphQL - How to search multiple fields?,<graphql>,0,2,0,2020-05-27 09:45:19
62063782,2,,62039112,1,,"<p>Hi Ander I also tried to achieve something like that, but not luck either. I ended up using list of objects instead:</p>&#xA;&#xA;<pre><code>const typeDefs = gql`&#xA;  type Query{&#xA;      Users(&#xA;        Id: ID,&#xA;        Filters: [Filter]&#xA;      )&#xA;  }&#xA;&#xA;  input Filter{&#xA;    A: String!&#xA;    B: String!&#xA;    C: String!&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;&#xA;<p>It will look like this at the end:</p>&#xA;&#xA;<pre><code>{&#xA;    Users(Id:1, Filters:[{A:""Id"",B:""&gt;"", C:""1""}, ..]) {&#xA;      Id&#xA;      Name&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",11194047,,11194047,2020-05-28 11:49:41,2020-05-28 11:49:41,"",,0,1,0,2020-05-28 11:40:56
62071746,2,,62071238,0,,"<p><strong>Why do you ever expected sorting?</strong></p>&#xA;&#xA;<p>You're using a <strong>low level access</strong> to cache then <strong>you're responsible for providing data in the same shape</strong> as expected from remote source. </p>&#xA;&#xA;<p>In this case <strong>if source data was sorted you have to pass sorted data to be written</strong>. Just get <code>getProducts</code>, push <code>newProduct</code> into the array, sort it and finally use sorted array in <code>writeQuery</code>.</p>&#xA;",6124657,,,,2020-05-28 18:17:01,"",,0,0,0,2020-05-28 18:17:01
62084970,2,,44079618,3,,"<p>Try this: </p>&#xA;&#xA;<pre><code> query ListQuery($filter: String!) {&#xA;       items(filter: $filter) {&#xA;         id&#xA;         name&#xA;       }&#xA;    },&#xA;    fetchPolicy: 'no-cache'&#xA;</code></pre>&#xA;&#xA;<p>More here:&#xA;<a href=""https://www.apollographql.com/docs/react/caching/cache-interaction/#bypassing-the-cache"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/caching/cache-interaction/#bypassing-the-cache</a></p>&#xA;",13641330,,,,2020-05-29 11:31:03,"",,0,0,0,2020-05-29 11:31:03
62095065,1,,,0,236,"<p>I'm trying to set up user authentication on my Gatsby site, but allow for the GraphQL api.</p>&#xA;&#xA;<p>Here's what I have now:</p>&#xA;&#xA;<pre><code>location / {&#xA;    try_files $uri $uri/ @rewrites;&#xA;    auth_basic ""Restricted"";&#xA;    auth_basic_user_file /etc/nginx/.htpasswd;&#xA;&#xA;    location ""^~ /api/.*"" {&#xA;       auth_basic ""off"";&#xA;    }&#xA;} &#xA;</code></pre>&#xA;&#xA;<p>EDIT, based on comments below</p>&#xA;&#xA;<p>I tried to add what's in location ~ .php$ as well as what's in rewrites, but got the same error.</p>&#xA;&#xA;<pre><code>location / {&#xA;    try_files $uri $uri/ @rewrites;&#xA;&#xA;    auth_basic ""Restricted"";&#xA;    auth_basic_user_file /etc/nginx/.htpasswd;&#xA;&#xA;    location ^~ /api/ {&#xA;        rewrite ^(.*) /index.php?p=$1 last;&#xA;        auth_basic off;&#xA;    }&#xA;}&#xA;&#xA;location @rewrites {&#xA;    rewrite ^(.*) /index.php?p=$1 last;&#xA;}&#xA;&#xA;# PHP&#xA;location ~ \.php$ {&#xA;     fastcgi_read_timeout 1200;&#xA;&#xA;     fastcgi_split_path_info ^(.+\.php)(/.+)$;&#xA;     fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;&#xA;&#xA;     # below for some setups on php 7.4&#xA;     #include snippets/fastcgi-php.conf;&#xA;     include /etc/nginx/fastcgi_params;&#xA;     fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;&#xA;}&#xA;</code></pre>&#xA;",6457214,,6457214,2020-05-30 00:10:20,2020-05-30 08:28:53,Turning user authentication off in nginx for GraphQL api for Gatsby site,<nginx><graphql><gatsby>,1,0,0,2020-05-29 21:48:45
62095311,2,,62095065,0,,"<p>One mistake is quoting <code>off</code>.</p>&#xA;&#xA;<p>Just remove the quotes: change <code>""off""</code> to <code>off</code>. Then it will be an actual <code>off</code> configuration as opposed to the quoted string.</p>&#xA;&#xA;<p>The other is the non-regex location (<code>^~</code>) for <code>/api/</code>.&#xA;The <code>location ^~</code> best to be explained as a prefix location with the highest priority.&#xA;It is not a regular expression type of location.</p>&#xA;&#xA;<pre><code>location / {&#xA;    try_files $uri $uri/ @rewrites;&#xA;    auth_basic ""Restricted"";&#xA;    auth_basic_user_file /etc/nginx/.htpasswd;&#xA;}&#xA;&#xA;location ^~ /api/ {&#xA;   auth_basic off;&#xA;   fastcgi_read_timeout 1200;&#xA;&#xA;   fastcgi_split_path_info ^(.+\.php)(/.+)$;&#xA;   fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;&#xA;&#xA;   # below for some setups on php 7.4&#xA;   #include snippets/fastcgi-php.conf;&#xA;   include /etc/nginx/fastcgi_params;&#xA;   fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;&#xA;}&#xA;&#xA;location @rewrites {&#xA;    rewrite ^(.*) /index.php?p=$1 last;&#xA;}&#xA;&#xA;# PHP&#xA;location ~ \.php$ {&#xA;     fastcgi_read_timeout 1200;&#xA;&#xA;     fastcgi_split_path_info ^(.+\.php)(/.+)$;&#xA;     fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;&#xA;&#xA;     # below for some setups on php 7.4&#xA;     #include snippets/fastcgi-php.conf;&#xA;     include /etc/nginx/fastcgi_params;&#xA;     fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;&#xA;} &#xA;</code></pre>&#xA;",285069,,285069,2020-05-30 08:28:53,2020-05-30 08:28:53,"",,0,4,0,2020-05-29 22:09:51
62097011,2,,56075076,2,,"<p><a href=""http://spec.graphql.org/draft/#sec-Response-Format"" rel=""nofollow noreferrer"">from graphql.org:</a>&#xA;A response to a GraphQL operation must be a map.</p>&#xA;&#xA;<p>If the operation encountered any errors, the response map must contain an entry with key errors. The value of this entry is described in the “Errors” section. If the operation completed without encountering any errors, this entry must not be present.</p>&#xA;&#xA;<p>If the operation included execution, the response map must contain an entry with key data. The value of this entry is described in the “Data” section. If the operation failed before execution, due to a syntax error, missing information, or validation error, this entry must not be present.</p>&#xA;&#xA;<p>The response map may also contain an entry with key extensions. This entry, if set, must have a map as its value. This entry is reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents.</p>&#xA;&#xA;<p>To ensure future changes to the protocol do not break existing servers and clients, <strong>the top level response map must not contain any entries other than the three described above.</strong></p>&#xA;",11784926,,,,2020-05-30 02:16:19,"",,0,0,0,2020-05-30 02:16:19
62108869,2,,60799495,0,,"<p>If you use pure apollo client you will loose some features from apollo. There is no need to move graphql call into redux action, you can use selectors in Redux to prevent components from reloading or making unnecessary calls to a server.</p>&#xA;&#xA;<p><a href=""https://www.youtube.com/watch?v=frT3to2ACCw&amp;t=437s"" rel=""nofollow noreferrer"">Selectors in Redux</a></p>&#xA;",11023340,,,,2020-05-30 21:27:15,"",,0,0,0,2020-05-30 21:27:15
62119331,1,,,2,2385,"<p>I'm using Contentful as a CMS, wherein I have the content models ""Category"" and ""Subcategory"". Each subcategory has a category as its parent. Both models have a property called <code>order</code> which I set within the CMS to decide the order in which they will appear on the navigation.</p>&#xA;&#xA;<p>Here's my GraphQL query:</p>&#xA;&#xA;<pre><code>query {&#xA;  allContentfulCategory(sort: {fields: [order, subcategory___order]}) {&#xA;    edges {&#xA;      node {&#xA;        order&#xA;        title&#xA;        subcategory {&#xA;          order&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The first sort works correctly and the query outputs my categories by the order field, rather than in reverse-creation order which seems to be the default output from Contentful (the newest categories show first).</p>&#xA;&#xA;<p>However, my second sort of <code>subcategory___order</code>, which was inspired by <a href=""https://stephencharlesweiss.com/blog/2020-01-30/graphql-multi-field-sorting/"" rel=""nofollow noreferrer"">this blog post</a>, does not evaluate. In other words, the subcategories (per Category) show up in reverse order so that the top item has an order of 8, and it decreases to 7, and 6, and so on.</p>&#xA;&#xA;<p>For example, say I had category ""Animals"" with order 2, and ""Trees"" with order 1. My content in reverse-creation order: ""Cat"" (order 3), ""Dog"" (order 1), ""Chicken"" (order 2), ""Birch"" (order 2), ""Oak"" (order 3), and ""Willow"" (order 1).</p>&#xA;&#xA;<p>These will come through the query like so:</p>&#xA;&#xA;<pre><code>Trees (1):&#xA;  Birch (2)&#xA;  Oak (3)&#xA;  Willow (1)&#xA;Animals (2):&#xA;  Cat (3)&#xA;  Dog (1)&#xA;  Chicken (2)&#xA;</code></pre>&#xA;&#xA;<p>I can't find a way to make the GraphQL query perform both sort commands simultaneously so that my data is ordered according to the order I set in the CMS.</p>&#xA;&#xA;<p>So many thanks in advance!</p>&#xA;&#xA;<p><strong>Edit: Here's a component solution:</strong></p>&#xA;&#xA;<p>Within each category node that comes from my query, I can access the subcategories and their order in an array.</p>&#xA;&#xA;<pre><code>const categories = data.allContentfulCategory.edges&#xA;    {categories.map((category) =&gt; {&#xA;        return (&#xA;            &lt;div&gt;&#xA;                {category.node.subcategory &amp;&amp; category.node.subcategory.sort((a, b) =&gt; {return a.order - b.order}).map((subcategory) =&gt; {&#xA;                    return (&#xA;                        &lt;div&gt;&#xA;                            &lt;p&gt;{subcategory.title}&lt;/p&gt;&#xA;                        &lt;/div&gt;&#xA;                    )&#xA;                })}&#xA;            &lt;/div&gt;&#xA;         )&#xA;      })}&#xA;</code></pre>&#xA;&#xA;<p>The key element here is how I sort the array by subcategory order within the component:</p>&#xA;&#xA;<p><code>category.node.subcategory.sort((a, b) =&gt; {return a.order - b.order})</code></p>&#xA;&#xA;<p>To be clear, this is not a satisfying solution, nor does it answer my question about how I might write multiple GraphQL sorts. But this code does do what I wanted with regards to organising the subcategories.</p>&#xA;",11373921,,6124657,2020-05-31 23:09:21,2020-06-04 05:55:04,Nested sort in GraphQL,<reactjs><graphql><gatsby>,1,1,0,2020-05-31 16:37:21
62124224,2,,62110611,1,,"<p>As stated in the comments, <strong>You can't</strong>. The reactive pattern is to stay in a flow. </p>&#xA;&#xA;<p>So, </p>&#xA;&#xA;<pre><code>Mono&lt;GraphqlResponse&gt; = Flux.just(""A"", ""B"" ""C"")&#xA;  .collectList()&#xA;  .map(this::someMethod);&#xA;&#xA;GraphqlResponse someMethod(List&lt;String&gt; abcs) {&#xA;    return graphQl.doSomething(abcs);&#xA;}&#xA;</code></pre>&#xA;",3795036,,,,2020-06-01 00:52:07,"",,0,0,0,2020-06-01 00:52:07
62152534,2,,62150387,1,,"<p>Yes, you can achieve this by using 2 different queries in your <code>communityQuery</code>. It should look like:</p>&#xA;&#xA;<pre><code>export const CommunityQuery = graphql&#xA;    query CommunityIndexQuery {&#xA;    site {&#xA;        siteMetadata {&#xA;        title&#xA;    }&#xA;    }&#xA;categoryOne: allContentfulBlogPost(&#xA;   filter: {category: {eq: ""category one name""}}&#xA;   sort: { fields: [publishDate], order: DESC }) {&#xA;    edges {&#xA;        node {&#xA;        //your fields&#xA;        }&#xA;      }&#xA;    }&#xA;categoryTwo: allContentfulBlogPost(&#xA;   filter: {category: {eq: ""category two name""}}&#xA;   sort: { fields: [publishDate], order: DESC }) {&#xA;    edges {&#xA;        node {&#xA;        //your fields&#xA;        }&#xA;      }&#xA;    }&#xA;}`&#xA;</code></pre>&#xA;&#xA;<p><em>Note: keep in mind that you provided a generic query so I don't know what fields or what filters you should put to filter by category, this is just an approach.</em></p>&#xA;&#xA;<p>This will generate 2 objects that you can retrieve easily by <code>props.data.categoryOne</code> and <code>props.data.categoryTwo</code> (that queries are aliased, it's a good way to clean up your code, if don't, your object may look like: <code>props.data.allContentfulBlogPost</code>).</p>&#xA;",5585371,,5585371,2020-06-03 04:48:47,2020-06-03 04:48:47,"",,0,4,0,2020-06-02 12:56:19
62159040,1,,,1,979,"<p>I have resolving template that will get start date as date from appsync query. But my date saved in Dynamo is having datetime stamp. How we can compare these two dates without time. Below is my resolver template query:</p>&#xA;&#xA;<pre><code> ""version"": ""2018-05-29"",&#xA; ""operation"": ""Query"", &#xA; ""query"": {&#xA;  ""expression"": ""Id = :Id and startDate =:date"",&#xA;  ""expressionValues"": {&#xA;    #set( $Id = &#xA;      $util.dynamodb.toDynamoDBJson(""fixture#${ctx.args.input.Id}"") )&#xA;    "":Id"": $Id,&#xA;    #set( $date = $util.dynamodb.toDynamoDBJson($ctx.args.input.date)&#xA;    "":date"": $date&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4116915,,4116915,2020-06-03 03:10:58,2020-06-03 06:56:50,DynamoDb query on stored date,<graphql><amazon-dynamodb><aws-appsync><dynamodb-queries>,1,0,0,2020-06-02 18:36:22
62166965,2,,62159040,2,,"<p>DynamoDB does not understand dates. Based on your requirements, there are two ways you can achieve this depending upon the format of the timestamp in your DynamoDB.</p>&#xA;&#xA;<p>1 - If you store timestamp as ""milliseconds/seconds since epoch"", you can convert the AWSDate (which is ISO8601) to Epoch milliseconds/seconds timestamp using</p>&#xA;&#xA;<p><code>$util.time.parseISO8601ToEpochMilliSeconds(""2018-02-01T17:21:05.180+08:00"")</code> </p>&#xA;&#xA;<p>and then use filter with <code>BETWEEN :startDate AND :endDate</code> to query your table based on the input date.&#xA;Please note that </p>&#xA;&#xA;<blockquote>&#xA;  <p>endDate(seconds) = startDate + 86400</p>&#xA;</blockquote>&#xA;&#xA;<p>or </p>&#xA;&#xA;<blockquote>&#xA;  <p>endDate(milliseconds) = startDate + 86400000</p>&#xA;</blockquote>&#xA;&#xA;<p>2 - If you use String representation of timestamp, then you might need to add Global Secondary Index (GSI) with a date field as attribute of keytype ""range"". There are some very good explanation and suggested solution on <a href=""https://stackoverflow.com/questions/14836600/querying-dynamodb-by-date"">this link</a>, <a href=""https://stackoverflow.com/questions/44576855/query-dynamodb-by-date-range"">this link</a> and <a href=""https://stackoverflow.com/questions/35963243/how-to-query-dynamodb-by-date-range-key-with-no-obvious-hash-key"">this link</a>.</p>&#xA;&#xA;<p>I hope this helps you.</p>&#xA;",1819065,,,,2020-06-03 06:56:50,"",,0,0,0,2020-06-03 06:56:50
62181428,1,,,2,1202,"<p>I am currently querying my Hasura database using userId to get location. </p>&#xA;&#xA;<pre><code>users(where: {id: {_eq: 1528}}) {&#xA;    location&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I then use location to query users near that one user. </p>&#xA;&#xA;<pre><code>    users(&#xA;      where:&#xA;        { location: {_st_d_within: {distance: 20000, from: $point }}},&#xA;    ) {&#xA;      firstName&#xA;      city&#xA;      region&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>Is there a way to efficiently combine these two queries such that I only query once? </p>&#xA;",5696181,,,,2020-06-10 10:05:27,How to efficiently use the result of a Hasura query for another query?,<postgresql><graphql><subquery><hasura>,1,2,0,2020-06-03 19:43:31
62186142,1,,,1,486,"<p>I'm currently learning how to use apollo client as for a graphql API exposed via graphene-django's <code>DjangoObjectType</code> node. Here's an example</p>&#xA;&#xA;<p>I define a node </p>&#xA;&#xA;<pre><code>class CompanyNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Company&#xA;        filter_fields = {&#xA;            'domain': ['exact'],&#xA;            'name': ['exact', 'icontains', 'istartswith']&#xA;        }&#xA;        interfaces = (graphene.relay.Node, )&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    companies = DjangoFilterConnectionField(CompanyNode)&#xA;</code></pre>&#xA;&#xA;<p>A typical query looks like this</p>&#xA;&#xA;<pre><code>query queryCompanies {&#xA;  companies {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        __typename&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the response is</p>&#xA;&#xA;<pre><code>{&#xA;  ""data"": {&#xA;    ""companies"": {&#xA;      ""edges"": [&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Q29tcGFueU5vZGU6MQ=="",&#xA;            ""name"": ""great"",&#xA;            ""__typename"": ""CompanyNode""&#xA;          }&#xA;        },&#xA;        {&#xA;          ""node"": {&#xA;            ""id"": ""Q29tcGFueU5vZGU6MTI="",&#xA;            ""name"": ""awesome"",&#xA;            ""__typename"": ""CompanyNode""&#xA;          }&#xA;        },&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm using apollo client with react for the frontend and my queries are returning okay. A typical component looks like this.</p>&#xA;&#xA;<p>To initialize some state in <code>index.js</code> I'm writing the companies data to the cache.</p>&#xA;&#xA;<pre><code>const cache = new InMemoryCache();&#xA;&#xA;cache.writeData({&#xA;  data: {&#xA;    companies: {&#xA;    edges: [],&#xA;    typename: 'CompanyNodeConnection',&#xA;    __typename: 'CompanyNodeConnection',&#xA;  },&#xA;  },&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Then in my component, I'm reading from my cache like below.</p>&#xA;&#xA;<pre><code>import React from 'react';&#xA;import { useQuery, useApolloClient } from '@apollo/react-hooks';&#xA;&#xA;const Companies = () =&gt; {&#xA;  const root = useApolloClient().cache.data.data;&#xA;&#xA;  const QUERY_ALL_COMPANIES = gql`&#xA;  query getCompanies {&#xA;    companies {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;  `;&#xA;&#xA;  const { loading, error } = useQuery(QUERY_ALL_COMPANIES);&#xA;&#xA;  if (error) {&#xA;    return &lt;p&gt;{JSON.stringify(error?.graphQLErrors[0]?.message)}&lt;/p&gt;;&#xA;  }&#xA;&#xA;  return (&#xA;    &lt;div&gt;&#xA;      &lt;h2&gt;Companies&lt;/h2&gt;&#xA;&#xA;      {loading ? (&#xA;        &lt;p&gt;loading&lt;/p&gt;&#xA;      ) : (&#xA;        &lt;div&gt;&#xA;          {root['$ROOT_QUERY.companies'].edges.map((com) =&gt; {&#xA;            const { id: edgeKey } = com;&#xA;            const {&#xA;              node: { id: itemNodeId },&#xA;            } = root[edgeKey];&#xA;            const { id, name } = root[itemNodeId];&#xA;&#xA;            return (&#xA;              &lt;div key={id}&gt;&#xA;                  {name}&#xA;              &lt;/div&gt;&#xA;            );&#xA;          })}&#xA;        &lt;/div&gt;&#xA;      )}&#xA;    &lt;/div&gt;&#xA;  );&#xA;};&#xA;&#xA;export default Companies;&#xA;</code></pre>&#xA;&#xA;<p>Now my question is, is this the proper way to initialise this state? Secondly, is this the proper way of reading this particular query from the cache?</p>&#xA;&#xA;<p>I'd like to see other patterns and opinions on what works. I'm thinking this pattern of reading state is too brittle.</p>&#xA;",2689562,,,,2020-06-04 03:00:33,How do I set initial state in React with Apollo graphql and graphene-django,<reactjs><apollo><graphene-django>,0,2,0,2020-06-04 03:00:33
62186252,1,,,0,1188,"<p>I am working on an open-source library called wertik-js and it uses Graphql, I have added reporting type helpers that return counting of mongoose models based on created at. Here in this case I have reportings like, total_count, total_added_last_year etc, total_added_today etc, For today I have filtered in this way:</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>model.countDocuments(&#xA;  {&#xA;    created_at: {&#xA;      $gt: moment().startOf(""day""),&#xA;      $lt: moment().endOf(""day""),&#xA;    },&#xA;  },&#xA;  function (err, count) {&#xA;    resolve(count);&#xA;  }&#xA;);&#xA;&#xA;</code></pre>&#xA;&#xA;<p>And it works pretty fine. When using for last year, I have data created last year. Which counts in this way for last year</p>&#xA;&#xA;<pre class=""lang-js prettyprint-override""><code>model.countDocuments(&#xA;  {&#xA;    created_at: {&#xA;      $gt: moment().subtract(1, ""year"").startOf(""year""),&#xA;      $lt: moment().subtract(1, ""year"").endOf(""year""),&#xA;    },&#xA;  },&#xA;  function (err, count) {&#xA;    resolve(count);&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>But last year count is not working and every time it returns 0 but I am sure I have written the query in right way and it returns the wrong number which is 0. Where total_added_today returns fine. </p>&#xA;&#xA;<p>To reproduce the bug, you can pull this branch <a href=""https://github.com/Uconnect-Technologies/wertik-js/tree/188-graphql-or-rest-api-enpoint-to-show-all-stats"" rel=""nofollow noreferrer"">https://github.com/Uconnect-Technologies/wertik-js/tree/188-graphql-or-rest-api-enpoint-to-show-all-stats</a> and:</p>&#xA;&#xA;<ol>&#xA;<li>Install packages and run the server sudo yarn &amp;&amp; sudo yarn dev</li>&#xA;<li>Go to <a href=""http://localhost:4000/"" rel=""nofollow noreferrer"">http://localhost:4000/</a></li>&#xA;<li>And execute the graphql query:</li>&#xA;</ol>&#xA;&#xA;<pre><code>{&#xA;  roleStats {&#xA;    total_count&#xA;    total_added_this_month&#xA;    total_added_this_week&#xA;    total_added_last_7_days&#xA;    total_added_today&#xA;    total_added_last_month&#xA;    total_added_last_90_days&#xA;    total_added_last_year&#xA;    total_added_this_year&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And you will be able to reproduce the error. </p>&#xA;&#xA;<p>You can check this file <a href=""https://github.com/Uconnect-Technologies/wertik-js/blob/188-graphql-or-rest-api-enpoint-to-show-all-stats/src/framework/reporting/index.ts#L110"" rel=""nofollow noreferrer"">https://github.com/Uconnect-Technologies/wertik-js/blob/188-graphql-or-rest-api-enpoint-to-show-all-stats/src/framework/reporting/index.ts#L110</a> from line 110 mongoose starts.</p>&#xA;&#xA;<p>What I am doing wrong here?</p>&#xA;&#xA;<p>Any help will be considered as a contribution to this open-source project.</p>&#xA;&#xA;<p><strong>Edit</strong></p>&#xA;&#xA;<p>An example document I am searching:</p>&#xA;&#xA;<pre><code>{&#xA;    ""_id"": {&#xA;        ""$oid"": ""5ed85b8893280c021c2ddfd6""&#xA;    },&#xA;    ""name"": ""John"",&#xA;    ""created_at"": ""Thu Jun 04 2019 07:25:12 GMT+0500 (Pakistan Standard Time)"",&#xA;    ""updated_at"": ""Thu Jun 04 2019 07:25:12 GMT+0500 (Pakistan Standard Time)"",&#xA;    ""__v"": 0&#xA;}&#xA;</code></pre>&#xA;",5247564,,5247564,2020-06-04 16:14:13,2020-06-04 22:49:33,Mongoose.countDocuments is not working when counting documents by moment js that are created last year,<node.js><mongodb><mongoose><graphql><apollo>,2,3,0,2020-06-04 03:14:01
62186414,2,,62186252,0,,"<p>I think the problem is in this line             </p>&#xA;&#xA;<pre><code> $lt: moment().subtract(1, ""year"").endOf(""year""),&#xA;</code></pre>&#xA;&#xA;<p>it should be </p>&#xA;&#xA;<pre><code>      $lt: moment().endOf(""year""),&#xA;</code></pre>&#xA;",9922011,,,,2020-06-04 03:30:54,"",,0,1,0,2020-06-04 03:30:54
62205419,2,,62186252,1,,"<p>The problem is that the <code>created_at</code> field in the document contains a string: <code>""Thu Jun 04 2019 07:25:12 GMT+0500 (Pakistan Standard Time)""</code></p>&#xA;&#xA;<p>This is not sortable by date-time, or matchable with any date-range operators.</p>&#xA;&#xA;<p>You might try converting those to dates with aggregation or update:</p>&#xA;&#xA;<pre><code>db.collection.update({created_at: {$type: ""string""}},&#xA;                     [{$set: {created_at: {$toDate: {""$created_at""}}],&#xA;                     {multi:true})&#xA;</code></pre>&#xA;&#xA;<p>Then you will be able to perform <code>$gt</code> or <code>$lt</code> tests meaningfully.</p>&#xA;",2282634,,,,2020-06-04 22:49:33,"",,0,6,0,2020-06-04 22:49:33
62210695,1,,,2,593,"<p>I have the following query that queries my storyblok CMS:</p>&#xA;&#xA;<pre><code>{&#xA;  allStoryblokEntry(filter: {field_component: {eq: ""blog""}} ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        content&#xA;        published_at&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'd like to sort my nodes however, say by published_at date.&#xA;I don't know how to do this though. GraphiQL suggests a <code>sort</code> parameter, which I somehow cannot get to work though. <a href=""https://www.storyblok.com/docs/api/content-delivery#examples/ordering/order"" rel=""nofollow noreferrer"">Storyblok tells me</a> to use <code>sort_by=name:asc</code> - which my GraphiQL doesn't recognise at all, and which also gives me a syntax error. Has anyone done this before?</p>&#xA;",13095115,,,,2020-06-05 13:15:19,Sorting a Storyblok GraphQL Query,<javascript><graphql><gatsby><graphql-js><storyblok>,1,0,0,2020-06-05 07:58:56
62247016,2,,54218505,2,,"<p>None of the existing answers seemed to work for me as they were presented, however with some slight changes I managed to resolve my problem as follows:</p>&#xA;&#xA;<p>You can create a custom <code>FilterSet</code> class for your object type, and filter the field by using the <code>GlobalIDMultipleChoiceFilter</code>. for example:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>from django_filters import FilterSet&#xA;from graphene_django.filter import GlobalIDFilter, GlobalIDMultipleChoiceFilter&#xA;&#xA;class SampleFilter(FilterSet):&#xA;    id = GlobalIDFilter()&#xA;    id__in = GlobalIDMultipleChoiceFilter(field_name=""id"")&#xA;&#xA;    class Meta:&#xA;        model = Sample&#xA;        fields = (&#xA;            ""id_in"",&#xA;            ""id"",&#xA;        )&#xA;</code></pre>&#xA;&#xA;<p>Something I came cross is that <strong>you can not have filter_fields defined with this approach</strong>. Instead, you have to only rely on the custom <code>FilterSet</code> class exclusively, making your object type effectively look like this:</p>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>from graphene import relay&#xA;from graphene_django import DjangoObjectType&#xA;&#xA;class SampleType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Sample&#xA;        filterset_class = SampleFilter&#xA;        interfaces = (relay.Node,)&#xA;</code></pre>&#xA;",13700404,,,,2020-06-07 14:44:36,"",,0,0,0,2020-06-07 14:44:36
62279276,1,,,2,165,"<p>I have the following query in a React-Native application using Apollo Client:</p>&#xA;&#xA;<pre><code>query getCollection($sortKey: ProductCollectionSortKeys) { ... }&#xA;</code></pre>&#xA;&#xA;<p>Now i need to pass the value PRICE as <code>sortKey</code> parameter. Note: not the string ""PRICE"" but the enum PRICE.</p>&#xA;&#xA;<p>If I use this syntax I will send ""PRICE"" instead of PRICE as enum value:</p>&#xA;&#xA;<pre><code>getCollection({ variables: { sortKey: ""PRICE"" } });&#xA;</code></pre>&#xA;&#xA;<p>I want to send something like:</p>&#xA;&#xA;<pre><code>sortKey: PRICE&#xA;</code></pre>&#xA;&#xA;<p>and not:</p>&#xA;&#xA;<pre><code>sortKey: ""PRICE""&#xA;</code></pre>&#xA;",8534482,,,,2020-06-09 09:27:39,Pass enum value as parameter in Apollo Client instead of a string,<javascript><reactjs><react-native><react-apollo>,0,6,0,2020-06-09 09:27:39
62307372,1,62344419,,1,500,"<p><strong>Problem Definition:</strong></p>&#xA;&#xA;<p>I have read the article about adding JWT authentication my project using <code>graphene-jwt</code> package from <a href=""https://django-graphql-jwt.domake.io/en/latest/quickstart.html"" rel=""nofollow noreferrer"">this official link</a>. According to what is said in the tutorial, some changes should be applied to the project <code>settings.py</code> file:</p>&#xA;&#xA;<ol>&#xA;<li>First of all the package should be installed:</li>&#xA;</ol>&#xA;&#xA;<pre class=""lang-py prettyprint-override""><code>pip3 install django-graphql-jwt&#xA;</code></pre>&#xA;&#xA;<ol start=""2"">&#xA;<li>Add AuthenticationMiddleware to <code>MIDDLEWARE</code> variable.</li>&#xA;</ol>&#xA;&#xA;<pre><code>MIDDLEWARE = [&#xA;    ...&#xA;    'django.contrib.auth.middleware.AuthenticationMiddleware',&#xA;    ...&#xA;]&#xA;</code></pre>&#xA;&#xA;<ol start=""3"">&#xA;<li>Adding JSONWebTokenBackend backend <code>AUTHENTICATION_BACKENDS</code> variable:</li>&#xA;</ol>&#xA;&#xA;<pre><code>AUTHENTICATION_BACKENDS = [&#xA;    'graphql_jwt.backends.JSONWebTokenBackend',&#xA;    'django.contrib.auth.backends.ModelBackend',&#xA;]&#xA;</code></pre>&#xA;&#xA;<ol start=""4"">&#xA;<li>Add JSONWebTokenMiddleware to <code>GRAPEHENE</code> variable.</li>&#xA;</ol>&#xA;&#xA;<pre><code>GRAPHENE = {&#xA;    'SCHEMA': 'apps.schema.schema.schema', # Where your Graphene schema lives&#xA;    'MIDDLEWARE': [&#xA;        'graphql_jwt.middleware.JSONWebTokenMiddleware',&#xA;    ],&#xA;}&#xA;&#xA;</code></pre>&#xA;&#xA;<p>After doing the 4th step, every request to <code>localhost:8000/graphql</code> has the following stacktrace:</p>&#xA;&#xA;<pre><code>errorInternal Server Error: /graphql&#xA;Traceback (most recent call last):&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/django/core/handlers/exception.py"", line 34, in inner&#xA;    response = get_response(request)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/django/core/handlers/base.py"", line 126, in _get_response&#xA;    response = self.process_exception_by_middleware(e, request)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/django/core/handlers/base.py"", line 124, in _get_response&#xA;    response = wrapped_callback(request, *callback_args, **callback_kwargs)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/django/views/generic/base.py"", line 62, in view&#xA;    self = cls(**initkwargs)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphene_django/views.py"", line 78, in __init__&#xA;    schema = graphene_settings.SCHEMA&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphene_django/settings.py"", line 116, in __getattr__&#xA;    val = perform_import(val, attr)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphene_django/settings.py"", line 55, in perform_import&#xA;    return import_from_string(val, setting_name)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphene_django/settings.py"", line 69, in import_from_string&#xA;    module = importlib.import_module(module_path)&#xA;  File ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 994, in _gcd_import&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 971, in _find_and_load&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 955, in _find_and_load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 665, in _load_unlocked&#xA;  File ""&lt;frozen importlib._bootstrap_external&gt;"", line 678, in exec_module&#xA;  File ""&lt;frozen importlib._bootstrap&gt;"", line 219, in _call_with_frames_removed&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/transportation/apps/schema/schema.py"", line 2, in &lt;module&gt;&#xA;    import graphql_jwt&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphql_jwt/__init__.py"", line 1, in &lt;module&gt;&#xA;    from . import relay&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphql_jwt/relay.py"", line 3, in &lt;module&gt;&#xA;    from . import mixins&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphql_jwt/mixins.py"", line 10, in &lt;module&gt;&#xA;    from . import exceptions, settings&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/graphql_jwt/settings.py"", line 26, in &lt;module&gt;&#xA;    JWT_SECRET_KEY = env('JWT_SECRET_KEY', default=settings.SECRET_KEY)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/environ/environ.py"", line 123, in __call__&#xA;    return self.get_value(var, cast=cast, default=default, parse_default=parse_default)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/environ/environ.py"", line 284, in get_value&#xA;    value = self.get_value(value, cast=cast, default=default)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/environ/environ.py"", line 284, in get_value&#xA;    value = self.get_value(value, cast=cast, default=default)&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/environ/environ.py"", line 284, in get_value&#xA;    value = self.get_value(value, cast=cast, default=default)&#xA;  [Previous line repeated 866 more times]&#xA;  File ""/home/mostafa/Desktop/Work/OOD_Project/back/venv/lib/python3.6/site-packages/environ/environ.py"", line 273, in get_value&#xA;    value = self.ENVIRON[var]&#xA;  File ""/usr/lib/python3.6/os.py"", line 666, in __getitem__&#xA;    value = self._data[self.encodekey(key)]&#xA;RecursionError: maximum recursion depth exceeded:&#xA;&#xA;</code></pre>&#xA;&#xA;<p>Project Structure:</p>&#xA;&#xA;<pre><code>├── apps&#xA;│   └── orders&#xA;│       ├── ... other-files&#xA;│       ├── schema.py&#xA;│   └── schema&#xA;│       └── schema.py&#xA;│   └── users&#xA;│       ├── ... other-files&#xA;│       └── schema.py&#xA;</code></pre>&#xA;&#xA;<p><strong>Screenshot:</strong>&#xA;<a href=""https://i.stack.imgur.com/Vq9BC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vq9BC.png"" alt=""grpahql maximum recursion depth exceeded screenshot""></a></p>&#xA;&#xA;<p>I don't know whether it is a bug or my fault. (The API worked perfectly before adding above configurations and it has been checked many times ) I have searched on internet but didn't find proper answer to my question . I would be thankful if anyone could help me.</p>&#xA;&#xA;<p><strong>PS1:</strong> The most famous question related to mine is <a href=""https://stackoverflow.com/questions/3323001/what-is-the-maximum-recursion-depth-in-python-and-how-to-increase-it"">this one</a> which mainly talks  about the maximum recursion depth error in python. But I can't understand the causation of this error here. </p>&#xA;&#xA;<p><strong>PS2:</strong> I have also add the following lines to settings.py but it still doesn't work!</p>&#xA;&#xA;<pre><code>import sys&#xA;sys.setrecursionlimit(10000)&#xA;</code></pre>&#xA;",7310077,,7310077,2020-06-10 16:11:59,2020-06-12 12:36:07,RecursionError at /graphql. maximum recursion depth exceeded,<python><django><graphql><graphene-django><django-graphql-jwt>,1,3,0,2020-06-10 15:32:00
62316342,1,,,1,240,"<p>I am new to graphql and am trying to learn how connections work for pagination. I am following documentation here: <a href=""https://graphql-ruby.org/pagination/using_connections.html"" rel=""nofollow noreferrer"">https://graphql-ruby.org/pagination/using_connections.html</a>. &#xA;I am able to use <code>connection_type</code> to view say <code>User</code> in graphiql. </p>&#xA;&#xA;<blockquote>&#xA;  <p></p>&#xA;</blockquote>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>field :allUsers, Type::MyUsers.connection_type, null: false&#xD;&#xA;&#xD;&#xA;      def allUsers&#xD;&#xA;        Users.all&#xD;&#xA;      end</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>I am not able to understand how to write code in <code>Make connection fields</code> and <code>Return collections</code> as per the documentation if I want to see the User-Post data. &#xA;For Users-Post relation, I have nested the return type in <code>Type::MyUsers</code>, something like:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>class myUsers &lt; GraphApi::BaseObject&#xD;&#xA;      field :name, String, null: false&#xD;&#xA;      field :created_at, GraphQL::Types::ISO8601DateTime, null: true&#xD;&#xA;      field :userPosts, Types::myPosts.connection_type, null: true&#xD;&#xA;end</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p>How do I get the data in posts so that when I see in graphiql the result should be something like:</p>&#xA;&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>query {&#xD;&#xA;  users {&#xD;&#xA;    pageInfo {&#xD;&#xA;      hasNextPage,&#xD;&#xA;      endCursor&#xD;&#xA;    }&#xD;&#xA;    edges {&#xD;&#xA;      node {[&#xD;&#xA;        {name : ""User1"",&#xD;&#xA;        userPosts {&#xD;&#xA;          edges {&#xD;&#xA;            nodes{ [&#xD;&#xA;              {body: ""post1""},&#xD;&#xA;              {body: ""post2""}&#xD;&#xA;              ]&#xD;&#xA;            }  &#xD;&#xA;          }&#xD;&#xA;        }},&#xD;&#xA;        {name : ""User2"",&#xD;&#xA;        userPosts {&#xD;&#xA;          edges {&#xD;&#xA;            nodes{ [&#xD;&#xA;              {body: ""post12""},&#xD;&#xA;              {body: ""post22""}&#xD;&#xA;              ]&#xD;&#xA;            }  &#xD;&#xA;          }&#xD;&#xA;        }}&#xD;&#xA;        ]&#xD;&#xA;      }&#xD;&#xA;    }  &#xD;&#xA;  }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",12475455,,,,2020-06-11 17:24:26,Connections in graphql for pagination,<pagination><graphql><connection>,1,0,0,2020-06-11 03:00:16
62317897,1,62320125,,3,670,"<p>I'm new to Apollo GraphQL.  When reading its docs, it mentioned the word <code>imperative</code> several times.  But I can't really find an explanation online that clarify what exactly ""imperative"" does for Apollo GraphQL. So far, the easiest def. I got is <code>imperative programming is like how you do something, and declarative programming is more like what you do.</code>  </p>&#xA;&#xA;<p>Here is an example of mentioning <code>imperative</code> for Apollo GraphQL:</p>&#xA;&#xA;<blockquote>&#xA;  <p>GraphQL’s mutations are triggered imperatively, but that’s only&#xA;  because a HOC or render prop grants access to the function which&#xA;  executes the mutation (e.g. on a button click). With Apollo, the&#xA;  mutations and queries become declarative over imperative.</p>&#xA;</blockquote>&#xA;&#xA;<p>Could someone provide a solid example to help me understand what imperative mean in Apollo GraphQL?</p>&#xA;",3606412,,,,2020-06-11 08:25:14,What does imperative mean in Apollo GraphQL?,<graphql><apollo>,1,0,0,2020-06-11 05:50:02
62360247,1,,,0,878,"<p>I am trying to delete a node, and then update the UI using <strong>optimisticUpdater</strong> inside the mutation, but I cannot to update the <strong>store</strong> and update the connection. The mutation itself works, but I want the UI to be updated without reloading the page. If I just delete the node from the store, then the error <em>""TypeError: edge.node is null""</em> occurs. I am also trying to access the connection using <strong>ConnectionHandler</strong> to remove the node from the <em>connection</em>, but I cannot figure out how to access the connection inside the mutation. I looked at the Relay documentation on mutations and store, but everything is very compressed there, and there are few examples on the network. The documentation says that the Relay Store is the one source of truth for the entire application, but I don’t understand how to access the right data from any component. Please tell me what I need to do inside optimisticUpdater, or somewhere else, to update the UI after deleting the record.</p>&#xA;&#xA;<p>After removal, the mutation returns the id of the removed node. Here is the mutation code:</p>&#xA;&#xA;<pre><code>import { commitMutation, graphql } from 'react-relay';&#xA;import environment from '../Environment';&#xA;import { ConnectionHandler } from 'relay-runtime';&#xA;&#xA;const mutation = graphql`&#xA;  mutation RemoveHeroMutation($input: RemoveHeroInput!) {&#xA;    removeHero(input: $input) {&#xA;      deletedId&#xA;      deleted&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default (id) =&gt; new Promise((resolve, reject) =&gt; {&#xA;  commitMutation(&#xA;    environment,&#xA;    {&#xA;      mutation,&#xA;      variables: {&#xA;        input: {&#xA;          id&#xA;        }&#xA;      },&#xA;      optimisticUpdater: (store) =&gt; {&#xA;        //this doesn't work&#xA;        const heroProxy = store.get(id);&#xA;        const conn = ConnectionHandler.getConnection(&#xA;          heroProxy,&#xA;          'HeroesList_Heroes'&#xA;        );&#xA;      },&#xA;      onCompleted: (res, err) =&gt; {&#xA;        if (err) return reject(err);&#xA;        return resolve(""Removed"");&#xA;      },&#xA;      onError: err =&gt; console.error(err)&#xA;    },&#xA;  );&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>The root component in which the request occurs. The Fragment container is used here:</p>&#xA;&#xA;<pre><code>import React, { Component, Fragment } from 'react';&#xA;import { Link } from 'react-router-dom';&#xA;import { Button } from 'antd';&#xA;import { PlusOutlined } from '@ant-design/icons';&#xA;import Line from '../components/Line';&#xA;&#xA;import { QueryRenderer, graphql } from 'react-relay';&#xA;import environment from '../Environment';&#xA;import HeroesList from '../components/HeroesList';&#xA;&#xA;const HeroesQuery = graphql`&#xA;  query HeroesQuery {&#xA;    viewer {&#xA;      ...HeroesList_viewer&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;class Heroes extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;Fragment&gt;&#xA;        &lt;h1&gt;Heroes page&lt;/h1&gt;&#xA;        &lt;Line /&gt;&#xA;        &lt;Button type=""primary""&gt;&#xA;          &lt;PlusOutlined /&gt; &lt;Link to=""/addhero""&gt;Add Hero&lt;/Link&gt;&#xA;        &lt;/Button&gt;&#xA;        &lt;QueryRenderer&#xA;          environment={environment}&#xA;          query={HeroesQuery}&#xA;          render={({ error, props }) =&gt; {&#xA;            if (error) {&#xA;              return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA;            } else if (props) {&#xA;              return &lt;HeroesList viewer={props.viewer} /&gt;;&#xA;            }&#xA;            return &lt;div&gt;Loadind...&lt;/div&gt;&#xA;          }}&#xA;        /&gt;      &#xA;      &lt;/Fragment&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default Heroes;&#xA;</code></pre>&#xA;&#xA;<p>The HeroesList component:</p>&#xA;&#xA;<pre><code>import React, { Component } from 'react';&#xA;import HeroTpl from './HeroTpl';&#xA;&#xA;import { createFragmentContainer, graphql } from 'react-relay';&#xA;&#xA;class HeroesList extends Component {&#xA;  constructor(props) {&#xA;    super(props);&#xA;  }&#xA;  render() {&#xA;    return (&#xA;      &lt;div style={{ padding: '10px 0' }}&gt;&#xA;        {this.props.viewer.Heroes.edges.map(edge =&gt; (&#xA;          &lt;HeroTpl hero={edge.node} key={edge.node.id} /&gt;&#xA;        ))}&#xA;        &lt;br/&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;}&#xA;export default createFragmentContainer(&#xA;  HeroesList,&#xA;  {&#xA;    viewer: graphql`&#xA;      fragment HeroesList_viewer on Viewer {&#xA;        Heroes &#xA;          @connection(key: ""HeroesList_Heroes"") {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              ...HeroTpl_hero&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>The 'HeroTpl' component:</p>&#xA;&#xA;<pre><code>import React, { Component, Fragment } from 'react';&#xA;import { Link } from 'react-router-dom';&#xA;import { Row, Col } from 'antd';&#xA;import { createFragmentContainer, graphql } from 'react-relay';&#xA;import { DeleteOutlined } from '@ant-design/icons';&#xA;&#xA;import RemoveHeroMutation from '../mutations/RemoveHeroMutation';&#xA;&#xA;class HeroTpl extends Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;Fragment&gt;&#xA;        &lt;Row className=""line""&gt;&#xA;          &lt;Col span={12}&gt;&#xA;            &lt;Link to={`/heroes/${this.props.hero.id}`}&gt;&#xA;              &lt;h3&gt;{this.props.hero.name}&lt;/h3&gt;&#xA;            &lt;/Link&gt;&#xA;          &lt;/Col&gt;&#xA;          &lt;Col span={6}&gt;{this.props.hero.date}&lt;/Col&gt;&#xA;          &lt;Col span={6}&gt;&#xA;            &lt;DeleteOutlined&#xA;              className=""delete""&#xA;              onClick={() =&gt; { RemoveHeroMutation(this.props.hero.id); }}&#xA;            /&gt;&#xA;          &lt;/Col&gt;&#xA;        &lt;/Row&gt;&#xA;      &lt;/Fragment&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default createFragmentContainer(&#xA;  HeroTpl, {&#xA;    hero: graphql`&#xA;      fragment HeroTpl_hero on Hero {&#xA;        id&#xA;        name&#xA;        date&#xA;      }&#xA;    `&#xA;  }&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>I would be grateful for your help. I'd love to figure it out.</p>&#xA;",11553898,,11553898,2020-06-13 13:58:39,2020-11-07 10:25:12,How to delete a node with optimisticUpdater in Relay?,<javascript><reactjs><graphql><relayjs><relay>,1,0,0,2020-06-13 13:13:19
62361308,2,,53137317,0,,"<p><a href=""https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer"">https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/</a> says sorting is handled by whichever framework you're using, such as <a href=""https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/filtering"" rel=""nofollow noreferrer"">Prisma</a> <a href=""https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer""><code>orderBy</code></a> or <a href=""https://lighthouse-php.com/4.12/api-reference/directives.html#orderby"" rel=""nofollow noreferrer"">Lighthouse</a> <code>@orderBy</code>.</p>&#xA;",470749,,,,2020-06-13 14:41:25,"",,0,0,0,2020-06-13 14:41:25
62390072,2,,62388413,1,,<p>Your <code>id</code> for both orders is the same value (<code>null</code>) so Apollo ends up using the cache key for both orders (<code>Order:null</code>) and the <code>orders</code> field ends up referring to the same key twice. You need to fix your backend so that <code>id</code> is resolved correctly to a unique value for each Order.</p>&#xA;,6024220,,,,2020-06-15 14:14:39,"",,0,1,0,2020-06-15 14:14:39
62441316,1,,,9,12073,"<p>Hi I'm trying to connect a gRPC client to the server but even though the connection is succesful I get the following error when querying it from the graphql resolvers. However if I dial directly from the resolver everything works so it has to do with the client not leaving the connection open.</p>&#xA;&#xA;<p>rpc error: code = Canceled desc = grpc: the client connection is closing</p>&#xA;&#xA;<p>client.go</p>&#xA;&#xA;<pre><code>var kacp = keepalive.ClientParameters{&#xA;    Time:                10 * time.Second, // send pings every 10 seconds if there is no activity&#xA;    Timeout:             time.Second,      // wait 1 second for ping back&#xA;    PermitWithoutStream: true,             // send pings even without active streams&#xA;}&#xA;&#xA;func gqlHandler() http.HandlerFunc {&#xA;&#xA;    conn, err := grpc.Dial(""127.0.0.1:50051"", grpc.WithInsecure(), &#xA;    grpc.WithKeepaliveParams(kacp),&#xA;    grpc.WithBlock())&#xA;&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    defer conn.Close()&#xA;&#xA;    db := proto.NewPlatformDBClient(conn)&#xA;&#xA;    gh := handler.GraphQL(platform.NewExecutableSchema(platform.Config{Resolvers: &amp;platform.Resolver{&#xA;        DB: db,&#xA;    }}))&#xA;&#xA;    gh = cors.Disable(gh)&#xA;&#xA;    return gh&#xA;}&#xA;</code></pre>&#xA;",13766236,,,,2021-12-06 09:12:31,Golang gRPC can't keep alive: the client connection is closing,<go><graphql><grpc>,2,1,0,2020-06-18 02:22:32
62443726,2,,62443616,0,,"<p>Pretty trivial using <code>filter</code>:</p>&#xA;&#xA;<p><code>allDatoCmsNews(sort: { fields: [meta___publishedAt], order: DESC }, limit: 4, filter: {slug: {ne: $slug}})</code></p>&#xA;",2811283,,,,2020-06-18 06:32:21,"",,0,0,0,2020-06-18 06:32:21
62486595,1,,,2,96,"<p>Is it a bad practice to use graphql input types for query arguments like its commonly done in mutations, for example</p>&#xA;<p><code>createPost(CreatePostInput!): CreatePostPayload</code></p>&#xA;<p>I see that a lot of api's use separate queries to fetch an entity by different fields, for example</p>&#xA;<pre><code>userByEmail(email: String!): User&#xA;userByName(name: String!): User&#xA;</code></pre>&#xA;<p>as opposed to</p>&#xA;<p><code>user(email: String, name: String): User</code></p>&#xA;<p>This makes sense, but some queries end up requiring more than one argument, for example paginated results. One might need for example, to modify the start/end cursor, results per page, ordering and others, plus the main query might need more than one argument to find the entities, so these queries end up with 5-6 different arguments.</p>&#xA;<p>The question is, why don't people use input types for these?</p>&#xA;<p>To the answer below, I can't help but wonder why people deem this</p>&#xA;<pre><code>query ($category: String, $perPage: Number, $page: Number, $sortBy: String) {&#xA;    posts(category: $category, perPage: $perPage, page: $page, sortBy: $sortBy) {&#xA;        ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>friendlier than this</p>&#xA;<pre><code>query( $input: PostQueryInput ) {&#xA;    posts(input: $input) {&#xA;        ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Is it because the input types can only contain primitives? I find this really confusing why its better in one case and worse in another.</p>&#xA;<p>I know that people are not forced to to this, you can do it as you like, but in the majority of graphql api's I think it is not done like this and I wonder why might that be - people must have a reason not to do this.</p>&#xA;",9103469,,9103469,2020-06-23 11:11:08,2020-06-23 11:11:08,Using Input types for query arguments,<node.js><graphql>,0,2,0,2020-06-20 13:41:27
62521114,2,,62519618,1,,"<p><code>first</code> is not a keyword in GraphQL. GraphQL has no built-in methods for pagination, filtering, sorting, etc. -- it's up to the individual service to implement those features. Using <code>first</code>, <code>last</code>, <code>after</code> and <code>before</code> as arguments is a common pattern for doing pagination that's outlined in the <a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">Relay Cursor Connection Specification</a>. However, this is not the only (or necessarily the best) way of doing pagination in GraphQL. You can implement whatever pattern makes sense for your specific application. However, whatever pattern you utilize, you'll need to add the appropriate arguments to your field and also implement the logic inside your resolver that makes use of those arguments' values.</p>&#xA;",6024220,,,,2020-06-22 18:28:34,"",,0,0,0,2020-06-22 18:28:34
62548039,1,62604750,,1,83,"<p>I'm developing a map which loads 100 location pinpoints. To do so, I want to save double array of 100 rows and 2 column, which saves 100 locations.(latitude/longitude)</p>&#xA;<p>I am considering CMS or GraphQL-filesystem, but I don't know which to use. I want to to prioritize webpage load time, but if possible, it'd be nice to conceal my data.</p>&#xA;<p>Where should I store my data? Please give me advise. Other options are also welcome Thank you.</p>&#xA;",4972737,,,,2020-06-27 01:02:32,How should I store data(100 x 2 array) in Gatsby?,<graphql><content-management-system><gatsby><graphql-js>,1,0,0,2020-06-24 05:06:42
62558430,1,62558917,,4,4671,"<p>I am trying to follow the example of cursor-based paginating with React Apollo (<a href=""https://www.apollographql.com/docs/react/data/pagination/#cursor-based"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/react/data/pagination/#cursor-based</a>) but am struggling with <em>how my component that rendered the original data gets the new (appended) data</em>.</p>&#xA;<p>This is how we get the original data and pass it to the component:</p>&#xA;<pre><code>const { data: { comments, cursor }, loading, fetchMore } = useQuery(&#xA;    MORE_COMMENTS_QUERY&#xA;);&#xA;&#xA;&lt;Comments&#xA;      entries={comments || []}&#xA;      onLoadMore={...}&#xA;/&gt;&#xA;</code></pre>&#xA;<p>What I'm unsure of is how the <code>fetchMore</code> function works.</p>&#xA;<pre><code>onLoadMore={() =&gt;&#xA;        fetchMore({&#xA;          query: MORE_COMMENTS_QUERY,&#xA;          variables: { cursor: cursor },&#xA;          updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;            const previousEntry = previousResult.entry;&#xA;            const newComments = fetchMoreResult.moreComments.comments;&#xA;            const newCursor = fetchMoreResult.moreComments.cursor;&#xA;&#xA;            return {&#xA;              // By returning `cursor` here, we update the `fetchMore` function&#xA;              // to the new cursor.&#xA;              cursor: newCursor,&#xA;              entry: {&#xA;                // Put the new comments in the front of the list&#xA;                comments: [...newComments, ...previousEntry.comments]&#xA;              },&#xA;              __typename: previousEntry.__typename&#xA;            };&#xA;          }&#xA;        })&#xA;      }&#xA;</code></pre>&#xA;<p>From what I understand, yes, once my component will cal this <code>onLoadMore</code> function (using a button's onClick for example), it will fetch the data based on a new cursor.</p>&#xA;<p>My question is this. I'm sorry if this is too simple and I'm not understanding something basic.</p>&#xA;<p><strong>How does the component get the new data?</strong></p>&#xA;<p>I know the data is there, because I console logged the <code>newComments</code> (in my case, it wasn't newComments, but you get the idea.) And I saw the new data! But those new comments, how are they returned to the component that needs the data? And if I click the button again, it is still stuck on the same cursor as before.</p>&#xA;<p>What am I missing here?</p>&#xA;",898840,,,,2020-06-24 15:47:54,How does fetchMore return data to the component?,<javascript><reactjs><graphql><apollo><react-apollo>,2,0,0,2020-06-24 15:19:13
62565528,2,,56989560,30,,"<p>I think you're being down-voted for asking a good question. The first/last/before/after concept is difficult to implement in SQL.</p>&#xA;<p>I've been breaking my head over the same problem. The pagination documentation does not address how to define cursors when you are applying custom ORDER statements.</p>&#xA;<p>And I haven't really found a comprehensive solution online either. I found some posts where people are addressing the issue, but the answers are only partially correct or partially complete (just base64 encode the ID field to make a cursor seems to be the go-to answer, but that says little on what the query actually has to do to compute the cursor). Also any solutions involving <em>row_number</em> are quite ugly and not applicable across different SQL dialects. So let's try it differently.</p>&#xA;<p>Quick disclaimer, this is going to be a fairly comprehensive post, but if your back-end uses a decent query builder, you could technically program a method that works for implementing the first/last/before/after pagination required by Relay GraphQL onto <strong>ANY</strong> pre-existing query. The only requirement is that the tables you are sorting on all have a column that uniquely represents the default order of the records (usually if your primary key is an integer and is using auto-generated IDs, you can use that one, even though technically ordering a table by its primary key will not always yield the same result as returning the table unordered)</p>&#xA;<p>Forget about base64 for a moment and just assume the ID to be a valid cursor field that represents the default order of the table.</p>&#xA;<p>The answer you find online for using a cursor is usually this.</p>&#xA;<pre><code>SELECT * FROM TABLE T&#xA;WHERE T.id &gt; $cursorId;&#xA;</code></pre>&#xA;<p>Well, this works great to get all the entries after the cursor, AS LONG as you don't apply any other sorts to the query. Once you use a custom sort like in your example, this suggestion breaks down.</p>&#xA;<p>However the core logic in there can be re-applied for queries with sorts, but the solution needs to be broadened. Let's try to come up with the complete algorithm.</p>&#xA;<hr />&#xA;<p>Algorithm for  <strong>first n after c</strong> <em>(first n nodes after cursor)</em></p>&#xA;<p>A node or edge is the same as a row in SQL terminology. (if 1 row represents a single entity, such as 1 author)</p>&#xA;<p>While the cursor is the row after which we will start returning sibling rows, be it forwards or backwards.</p>&#xA;<p>Given <strong>C</strong> is the cursor</p>&#xA;<p><strong>A</strong> is any other row being compared to <strong>C</strong>.</p>&#xA;<p><strong>T</strong> is the table of which both <strong>A</strong> and <strong>C</strong> are rows.</p>&#xA;<p>And <strong>v w x y z</strong> are 5 columns on table <strong>T</strong>, naturally both <strong>A</strong> and <strong>C</strong> have these columns.</p>&#xA;<p>The algorithm has to decide whether A is included or excluded from the return query based on the cursor object, given n, and the provided orders of these 5 columns.</p>&#xA;<p>Let's start with a single order.</p>&#xA;<p>Given there is 1 order <em>(v)</em>: (which there should always be at the very least, if we assume our table to be ordered by its primary key by default)&#xA;To show the <strong>first n records</strong>, we will need to apply a <strong>limit of n</strong>, that is trivial. The difficult part is <strong>after c</strong>.</p>&#xA;<p>For a table which is only being ordered by 1 field that would come down to:</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.v &gt; C.v&#xA; ORDER BY T.v ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>This should show all rows which have a bigger v than C, and remove all rows who's v is smaller than that of C, meaning there will not be any rows left before C. If we assume the primary key correctly represents the natural order, we&#xA;can drop the ORDER BY statement. Then a slightly more readable version of this query would become:</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.id &gt; $cursorIdGivenByClient&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>And there, we've arrived at the simplest solution for providing a cursor to an 'unsorted' table. Which is the same solutation as the commonly accepted answer for dealing with cursors, but incomplete alas.</p>&#xA;<p>Now let's look at a query that is sorted by two columns (<strong>v</strong> and <strong>w</strong>):</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.v &gt; C.v&#xA; OR (A.v = C.v AND A.w &gt; C.w)&#xA; ORDER BY T.v ASC, T.w ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>We start off with the same <code>WHERE A.v &gt; C.v</code>, any row for which value v (A.v) is less than value of C for the first sort (C.v) is removed from the output result. However if the columns for the first order v have the same value for both A and C, <code>A.v = C.v</code> we need to look at the second order column to see if A is still allowed to be shown in the query result. Which will be the case if <code>A.w &gt; C.w</code></p>&#xA;<p>Let's move on to a query with 3 sorts:</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.v &gt; C.v&#xA; OR (A.v = C.v AND A.w &gt; C.w)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x &gt; C.x)&#xA; ORDER BY T.v ASC, T.w ASC, T.x ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>This is the same logic as for 2 sorts but a little bit more worked out. If the first column is the same, we need to look at the 2nd column to see who's the biggest one. If the second column is ALSO the same, we need to look at the 3rd column. It's important to realize that the primary key is always the last sort column in the ORDER BY statement, and the last condition to be compared against. In this case A.x &gt; C.x  (or A.id &gt; $cursorId)</p>&#xA;<p>Anyway a pattern should start to arise. For sorting on 4 columns the query would be like this:</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.v &gt; C.v&#xA; OR (A.v = C.v AND A.w &gt; C.w)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x &gt; C.x)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x = C.x AND A.y &gt; C.y)&#xA; ORDER BY T.v ASC, T.w ASC, T.x ASC, T.y ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>And finally for sorting on 5 columns.</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE A.v &gt; C.v&#xA; OR (A.v = C.v AND A.w &gt; C.w)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x &gt; C.x)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x = C.x AND A.y &gt; C.y)&#xA; OR (A.v = C.v AND A.w = C.w AND A.x = C.x AND A.y = C.y AND A.z &gt; C.z)&#xA; ORDER BY T.v ASC, T.w ASC, T.x ASC, T.y ASC, T.z ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>That's a scary amount of comparisons. For every order added, the number of comparisons required to calculate <strong>first n after c</strong> grows by the <a href=""https://en.wikipedia.org/wiki/Triangular_number"" rel=""noreferrer"">Triangular Number</a> performed on each row. Luckily we can apply some boolean algebra to condense and optimize this query.</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE (A.v &gt; C.v OR&#xA;           (A.v = C.v AND &#xA;              (A.w &gt; C.w OR&#xA;                   (A.w = C.w AND&#xA;                       (A.x &gt; C.x OR&#xA;                           (A.x = C.x AND&#xA;                               (A.y &gt; C.y OR&#xA;                                    (A.y = C.y AND&#xA;                                        (A.z &gt; C.z)))))))))&#xA; ORDER BY T.v ASC, T.w ASC, T.x ASC, T.y ASC, T.z ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>Even after condensing it, the pattern is quite clear. Every condition line alters between OR an AND, and every condition line alters between &gt; and = , finally every 2 condition lines we compare the next order column.</p>&#xA;<p>And this comparison is surprisingly performant as well. On average half of all rows will qualify after the first A.v &gt; C.v check and stop there. And of the other half that do get through, the majority will fail at the second A.v = C.v check and stop there. So while it may generate big queries, I wouldn't be too worried about performance.</p>&#xA;<p>But let's get concrete and use this to give you an answer on how to use a cursor for the example in question:</p>&#xA;<pre><code> SELECT authors.id, authors.last_name, authors.created_at FROM authors&#xA; ORDER BY authors.last_name, author.created_at&#xA;</code></pre>&#xA;<p>Is your base query, sorted, but not yet paginated.</p>&#xA;<p>Your server receives a request to show &quot;first 20 authors after author with cursor&quot;&#xA;After decoding the cursor, we find out that it represents the author with id 15.</p>&#xA;<p>First we can run a small precursor query to get the necessary information we will need:</p>&#xA;<pre><code> $authorLastName, $authorCreatedAt =&#xA;      SELECT authors.last_name, authors.created_at from author where id = 15;&#xA;</code></pre>&#xA;<p>Then we apply the algorithm and substitute the fields:</p>&#xA;<pre><code>  SELECT a.id, a.last_name, a.created_at FROM authors a&#xA;  WHERE (a.last_name &gt; $authorLastName OR&#xA;            (a.last_name = $authorLastName AND &#xA;               (a.created_at &gt; $authorCreatedAt OR&#xA;                    (a.created_at = $authorCreatedAt AND&#xA;                        (a.id &gt; 15)))))&#xA; ORDER BY a.last_name, a.created_at, a.id&#xA; LIMIT 20;&#xA;</code></pre>&#xA;<p>There this query will correctly return the first 20 authors after the author with ID 15 according to the sorts of the query.</p>&#xA;<p>If you don't like using variables or secondary queries you can use subqueries as well:</p>&#xA;<pre><code>  SELECT a.id, a.last_name, a.created_at FROM authors a&#xA;  WHERE (a.last_name &gt; (select last_name from authors where id 15) OR&#xA;            (a.last_name = (select last_name from authors where id 15) AND &#xA;               (a.created_at &gt; (select created_at from authors where id 15)  OR&#xA;                    (a.created_at = (select created_at from authors where id 15) AND&#xA;                        (a.id &gt; 15)))))&#xA; ORDER BY a.last_name, a.created_at, a.id&#xA; LIMIT 20;&#xA;</code></pre>&#xA;<p>Again this isn't as bad as it seems, the subqueries are not correlated and the results will be cached over row loops, so it won't be particularly bad for performance. But the query does become messy, especially when you start using JOINS which will need to be applied in the subqueries as well.</p>&#xA;<p>You wouldn't need to explicitly call the ORDER on a.id, but I do it to be consistent with the algorithm. It does become very important if you're using DESC instead of ASC.</p>&#xA;<p>So what happens if you use DESC columns instead of ASC? Does the algorithm break? Well not if you apply a small extra rule. For whichever column is using DESC instead of ASC, you replace the '&gt;' sign with '&lt;' and the algorithm will now work for sorting in both directions.</p>&#xA;<p>JOINS have no impact on this algorithm (thank god), other than the fact that 20 rows from joined tables won't necessarily represent 20 entities (20 authors in this case), but that's a problem that is independent of the whole first/after matter and which you will also have using OFFSET.</p>&#xA;<p>It's also not particularly difficult to handle queries which already have pre-existing WHERE conditions. You just take all the pre-existing conditions, wrap them between brackets, and combine them with an AND statement to the conditions generated by the algorithm.</p>&#xA;<p>There, we've implemented an algorithm that can handle any input query and properly paginate it using first/after. (If there are edge cases I missed, do let me know)</p>&#xA;<p>And you could stop there but... unfortunately</p>&#xA;<p>You still need to handle <strong>first n</strong>, <strong>last n</strong>, <strong>before c</strong>, <strong>after c</strong>, <strong>last n before c</strong>, <strong>last n after c</strong> and <strong>first n before c</strong> if you want to be compliant with the GraphQL Relay specs and get rid of offset completely :).</p>&#xA;<p>You can get halfway using the given AFTER-algorithm I just provided. But for the other half you will need to use the <strong>BEFORE</strong>-algorithm. It's very similar to the AFTER algorithm:</p>&#xA;<pre><code> SELECT A FROM T&#xA; WHERE (A.v &lt; C.v OR&#xA;           (A.v = C.v AND &#xA;              (A.w &lt; C.w OR&#xA;                   (A.w = C.w AND&#xA;                       (A.x &lt; C.x OR&#xA;                           (A.x = C.x AND&#xA;                               (A.y &lt; C.y OR&#xA;                                    (A.y = C.y AND&#xA;                                        (A.z &lt; C.z)))))))))&#xA; ORDER BY T.v ASC, T.w ASC, T.x ASC, T.y ASC, T.z ASC&#xA; LIMIT n&#xA;</code></pre>&#xA;<p>To get the BEFORE-algorithm, you take the AFTER-algorithm and just switch all '&lt;' operators to '&gt;' operators and vice versa.  (So in essence before and after are the same algorithm with  BEFORE/AFTER + ASC/DESC deciding which direction the operator will have to point to.)</p>&#xA;<p>For 'first n' you don't need to do anything except apply 'LIMIT n' to the query.</p>&#xA;<p>For 'last n' you need to apply 'LIMIT n' and reverse all given ORDERS , switching ASC with DESC and DESC with ASC. There is one caveat with the 'last n' , while it will correctly return the last n records, it will do so in reversed order, so you need to manually reverse the returned set again, be it in your database or inside your code.</p>&#xA;<p>There with those rules you can successfully integrate any pagination requests from the Relay GraphQL spec onto any SQL query, using a unique sortable column, often the primary key, as cursor that represents the source of truth for default sorting of the table.</p>&#xA;<p>It's quite daunting but I managed to write a plugin for Doctrine DQL builder using those algorithms to implement first/last/before/after pagination methods using a MySQL database. So it's definitely doable.</p>&#xA;",3759345,,3759345,2020-06-24 23:33:05,2020-06-24 23:33:05,"",,0,3,0,2020-06-24 23:21:01
62575785,1,62592709,,1,446,"<p>First of all, I am using a simplified version of &quot;Relay&quot; pagination where &quot;List&quot; is a basic equivalent of &quot;connection&quot; and &quot;limit&quot; is the equivalent to &quot;first&quot; and &quot;cursor&quot; is the equivalent to &quot;after&quot;.</p>&#xA;<p>This is the relevant part of my schema:</p>&#xA;<pre><code>extend type Query {&#xA;    artist(id: ID!): Artist&#xA;    artists(limit: Int!, cursor: String): ArtistList!&#xA;}&#xA;&#xA;type Artist {&#xA;    id: ID!&#xA;    account: Account!&#xA;    photos(limit: Int!, cursor: String): PhotoList!&#xA;    website: String&#xA;    instagram: String&#xA;    facebook: String&#xA;    created: Date!&#xA;    updated: Date&#xA;    about: String&#xA;}&#xA;&#xA;type ArtistList {&#xA;    nodes: [Artist]!&#xA;    page: Page!&#xA;}&#xA;</code></pre>&#xA;<p>I want avoid nested pagination, so want permit get next nodes of <code>photos</code> on the query <code>artist</code> and not permit get next nodes of <code>photos</code> on the query <code>artists</code> (For example, permit the argument <code>cursor</code> of <code>photos</code> on query <code>artist</code> and ban it on query <code>artists</code>). But I can't see how to express that in the GraphQL schema.</p>&#xA;",10798494,,,,2020-06-26 10:22:43,Schema design to avoid nested pagination,<graphql><graphql-js>,1,0,0,2020-06-25 12:50:41
62598963,1,,,1,3907,"<p>I have been stuck with this error for a while. Now, I am trying to use Graphene for my graphql Django API but it throws me this error of</p>&#xA;<p><code>error code</code><strong>:</strong>&#xA;<code>ModuleNotFoundError: No module named 'graphene_django'</code></p>&#xA;<pre><code>  File &quot;/usr/local/Cellar/python/3.7.6_1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/importlib/__init__.py&quot;, line 127, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 965, in _find_and_load_unlocked&#xA;ModuleNotFoundError: No module named 'graphene_django' &#xA;</code></pre>&#xA;<p>Here is my environment</p>&#xA;<p>Before you judge</p>&#xA;<pre><code>'pip freeze'&#xA;&#xA;&#xA;graphene==2.1.8&#xA;graphene-django==2.11.0&#xA;graphql-core==2.3.2&#xA;graphql-relay==2.0.1&#xA;gunicorn==20.0.4&#xA;</code></pre>&#xA;",10231419,,6553328,2020-06-27 03:48:36,2021-06-27 09:39:31,ModuleNotFoundError: No module named 'graphene_django',<python><django><graphql><graphene-django>,2,2,0,2020-06-26 16:24:53
62612157,2,,58673525,0,,"<p>You can reuse the preload function to refresh the data:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  .then((data) =&gt; {&#xA;    console.log(data);&#xA;    newEntry.question = '';&#xA;    newEntry.answer = '';&#xA;&#xA;    preload().then(props =&gt; {&#xA;      faqEntries = props.faqEntries&#xA;    })&#xA;</code></pre>&#xA;<p>The approach is useful when you want to show entries that other users have added at the cost of making extra api calls.</p>&#xA;<p>But if you only want to add the recently added entry:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  .then((data) =&gt; {&#xA;     faqEntries = [...faqEntries, {...newEntry}]&#xA;</code></pre>&#xA;",19165,,,,2020-06-27 15:49:44,"",,0,0,0,2020-06-27 15:49:44
62627414,2,,62622239,2,,"<p>I think I've found a solution. Technically speaking I guess these are separate queries (which sort of defeats the purpose of aliases if I'm correct) but it does what I want:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  apollo: {&#xA;    campaigns: {&#xA;      query: gql`&#xA;        query {&#xA;          campaigns: campaigns(&#xA;            where: { archive: &quot;false&quot; }&#xA;            sort: &quot;order:desc&quot;&#xA;          ) {&#xA;            name&#xA;            url&#xA;          }&#xA;        }&#xA;      `&#xA;    },&#xA;    archive: {&#xA;      query: gql`&#xA;        query {&#xA;          archive: campaigns(where: { archive: &quot;true&quot; }, sort: &quot;order:desc&quot;) {&#xA;            name&#xA;            url&#xA;          }&#xA;        }&#xA;      `&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Apparently under some circumstance the initialization &quot;apollo: { <strong>XYZ</strong>:&quot; and the alias &quot;query { <strong>XYZ</strong>:&quot; have to match. I've seen in the docs that they don't necessarily have to match, but I don't fully understand when and why.</p>&#xA;<p>I guess I can't really tell what the initial parameter does.</p>&#xA;",7351958,,,,2020-06-28 19:38:55,"",,0,0,0,2020-06-28 19:38:55
62662015,1,,,2,205,"<p>I am a graphql noob and the first query I have to write turned to be a complex one. Imagine this is the object I'm looking for</p>&#xA;<pre><code>{&#xA;  name : &quot;ferrari&quot;&#xA;  year : &quot;1995&quot;&#xA;}&#xA;</code></pre>&#xA;<p>Now, there is a nested object in which this could be present, The object could look like this</p>&#xA;<pre><code>{&#xA;  &quot;name&quot;: &quot;car&quot;,&#xA;  &quot;year&quot;: &quot;1990&quot;,&#xA;  &quot;morecars&quot;: [&#xA;    {&#xA;      &quot;name&quot;: &quot;ferrari&quot;,&#xA;      &quot;year&quot;: &quot;1995&quot;&#xA;    },&#xA;    {&#xA;      &quot;name&quot;: &quot;bmw&quot;,&#xA;      &quot;year&quot;: &quot;200&quot;&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>or this</p>&#xA;<pre><code>{&#xA;  &quot;name&quot;: &quot;car&quot;,&#xA;  &quot;year&quot;: &quot;1990&quot;,&#xA;  &quot;morecars&quot;: [&#xA;    {&#xA;      &quot;name&quot;: &quot;red&quot;,&#xA;      &quot;year&quot;: &quot;1990&quot;,&#xA;      &quot;morecares&quot;: [&#xA;        {&#xA;          &quot;name&quot;: &quot;ferrari&quot;,&#xA;          &quot;year&quot;: &quot;1995&quot;&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      &quot;name&quot;: &quot;bmw&quot;,&#xA;      &quot;year&quot;: &quot;200&quot;&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>How do fetch the <code>ferrari</code> i need</p>&#xA;",13507941,,,,2020-08-21 20:18:56,Graphql query to get an object nested in multiple layers,<graphql><apollo><react-apollo><querying>,0,1,0,2020-06-30 16:29:22
62670754,1,62673904,,0,152,"<p>I'm refactoring an express+react app that is using redux and I would like to switch to graphql (apollo), but I have a few things that are not quite clear.</p>&#xA;<p>So the general flow is there's GET request to fetch the data (an array of objects) that are then stored in redux store and using selectors paginated and presented as a list. The user then can edit the entries (entries are modified in redux store) and he can then &quot;publish&quot; that takes data from redux store and calls POST endpoint.</p>&#xA;<p>How would I model that in graphql? Do I paginate using a graphql query (using offset/limit in DB)?&#xA;How would I then be able to modify the entries in memory and publish all of the entries at once once I'm done editing?</p>&#xA;",193404,,6124657,2020-07-01 09:14:36,2020-07-01 10:03:47,How to convert Redux app to GraphQL/Apollo?,<reactjs><redux><graphql><apollo>,1,0,0,2020-07-01 06:16:55
62675473,2,,62671287,0,,"<p>You would need to utilize a third type to represent the relationship between the other two types.</p>&#xA;<pre><code>type Todo {&#xA;  id: ID!&#xA;  name: String&#xA;  lists: [ListTodo]&#xA;}&#xA;&#xA;type ListTodo {&#xA;  list: List&#xA;  todo: ToDo&#xA;  order: Int&#xA;}&#xA;&#xA;type List {&#xA;  id: ID!&#xA;  name: String&#xA;  todos: [ListTodo]&#xA;}&#xA;</code></pre>&#xA;<p>If you utilize the <a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">connection pattern</a>, the data from the join table can be added to the appropriate edge type:</p>&#xA;<pre><code>type Todo {&#xA;  id: ID!&#xA;  name: String&#xA;  lists: ListConnection&#xA;}&#xA;&#xA;type ListConnection {&#xA;  pageInfo: PageInfo&#xA;  edges: [ListEdge]&#xA;}&#xA;&#xA;type ListEdge {&#xA;  cursor: String&#xA;  node: Edge&#xA;  order: Int&#xA;}&#xA;</code></pre>&#xA;",6024220,,6024220,2020-07-02 14:39:57,2020-07-02 14:39:57,"",,0,2,0,2020-07-01 11:08:04
62703581,2,,62685267,0,,"<p>I got the reasons.</p>&#xA;<p>1st-&#xA;I have to add <code>reverse: true</code> into GraphQl like below.</p>&#xA;<pre><code>  orders(first: 2 reverse: true) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>2nd -&#xA;I needed to restart and update app after adding <code>'read_orders', 'write_orders'</code>permmissions.</p>&#xA;<p>Thanks!</p>&#xA;",5008823,,,,2020-07-02 19:18:49,"",,0,0,0,2020-07-02 19:18:49
62734914,1,,,0,453,"<p>I had this query runs perfect in AppSync console with no problem:</p>&#xA;<pre><code> query listTftTeamCombos {&#xA;      listTftTeamCombos {&#xA;        items {&#xA;          sortId&#xA;          teamId&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>But when I try to use it in local ide with Vue.js, it gives me validation error:</p>&#xA;<pre><code>Validation error of type UnknownType: Unknown type TableTftTeamComboFilterInput&#xA;</code></pre>&#xA;<p>I managed to come up with two query but none of them works:</p>&#xA;<pre><code>export const test1 = /* GraphQL */ `&#xA;  query ListTftTeamCombos(&#xA;    $filter: TableTftTeamComboFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTftTeamCombos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        sortId&#xA;        teamId&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>Second query:</p>&#xA;<pre><code>export const test2 = /* GraphQL */ `&#xA;    query ListTftTeamCombos{&#xA;        items: {&#xA;          sortId: $sortId&#xA;          teamId: $teamId&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>this is the raw schema from appsync console. (Before generating the schema.graphql which is long and unreadbale.)</p>&#xA;<pre><code>input CreateTftTeamComboInput {&#xA;    sortId: String!&#xA;    teamId: String!&#xA;}&#xA;&#xA;input DeleteTftTeamComboInput {&#xA;    sortId: String!&#xA;    teamId: String!&#xA;}&#xA;&#xA;type Mutation {&#xA;    createTftTeamCombo(input: CreateTftTeamComboInput!): TftTeamCombo&#xA;    updateTftTeamCombo(input: UpdateTftTeamComboInput!): TftTeamCombo&#xA;    deleteTftTeamCombo(input: DeleteTftTeamComboInput!): TftTeamCombo&#xA;}&#xA;&#xA;type Query {&#xA;    getTftTeamCombo(teamId: String!, sortId: String!): TftTeamCombo&#xA;    listTftTeamCombos(filter: TableTftTeamComboFilterInput, limit: Int, nextToken: String): TftTeamComboConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateTftTeamCombo(sortId: String, teamId: String): TftTeamCombo&#xA;        @aws_subscribe(mutations: [&quot;createTftTeamCombo&quot;])&#xA;    onUpdateTftTeamCombo(sortId: String, teamId: String): TftTeamCombo&#xA;        @aws_subscribe(mutations: [&quot;updateTftTeamCombo&quot;])&#xA;    onDeleteTftTeamCombo(sortId: String, teamId: String): TftTeamCombo&#xA;        @aws_subscribe(mutations: [&quot;deleteTftTeamCombo&quot;])&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input TableTftTeamComboFilterInput {&#xA;    sortId: TableStringFilterInput&#xA;    teamId: TableStringFilterInput&#xA;}&#xA;&#xA;type TftTeamCombo {&#xA;    sortId: String!&#xA;    teamId: String!&#xA;}&#xA;&#xA;type TftTeamComboConnection {&#xA;    items: [TftTeamCombo]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input UpdateTftTeamComboInput {&#xA;    sortId: String!&#xA;    teamId: String!&#xA;}&#xA;</code></pre>&#xA;<p>The file schema.json is auto generated by using the command <code>amplify add codege</code> and i didnt change it.</p>&#xA;<p>Should I modify schema.json for my query to work or did i make a mistake when constructing the query?</p>&#xA;<p>Thanks in advance.</p>&#xA;",5083293,,5083293,2020-07-05 17:45:24,2020-07-05 18:13:33,Vue.js using aws AppSync has GraphQL Validation error of type Unknow Type,<vue.js><graphql><aws-amplify><aws-appsync>,1,1,0,2020-07-04 22:04:48
62764542,2,,62723495,1,,<p>Try removing the semicolon in the <code>type complexTypeQuery: {</code> line.</p>&#xA;<p>Update:&#xA;Also you arn't specifying the field resolver in the query definition.</p>&#xA;<pre><code>type Query {&#xA;  complexQuery: complexTypeQuery @field(resolver: &quot;ComplexQuery&quot;)&#xA;}&#xA;</code></pre>&#xA;,2754876,,2754876,2020-07-07 06:23:43,2020-07-07 06:23:43,"",,0,1,0,2020-07-06 21:09:00
62766492,2,,62762271,0,,"<p>To answer your question, no you can't do that. Query execution is not guaranteed to happen in order like what you're describing, and the results <em>are supposed to be</em> what you're seeing.</p>&#xA;<p>But now to just take a step back, it feels like you're approaching this very RESTfully. Instead of having siblings between <code>catchSomeData</code> and <code>specialTypes</code>, the GraphQL way is to nest these objects:</p>&#xA;<pre><code>type Query {&#xA;    catchSomeData: [SomeData]!&#xA;    specialTypes: [SpecialType]!&#xA;}&#xA;&#xA;type SomeData {&#xA;    someDataId: Int!&#xA;    key: String!&#xA;    specialTypeIdA: SpecialType!&#xA;    specialTypeIdB: SpecialType!&#xA;}&#xA;&#xA;type SpecialType {&#xA;    specialTypeId: Int!&#xA;    name: String!&#xA;    someValue: String!&#xA;}&#xA;</code></pre>&#xA;<p>and then your query would be</p>&#xA;<pre><code>query {&#xA;    catchSomeData {&#xA;        someDataId&#xA;        key&#xA;        specialTypeIdA {&#xA;            specialTypeId&#xA;            name&#xA;            someValue&#xA;        }&#xA;        specialTypeIdB {&#xA;            specialTypeId&#xA;            name&#xA;            someValue&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>or if you don't want to type the nested stuff twice, you could use a fragment:</p>&#xA;<pre><code>query {&#xA;    catchSomeData {&#xA;        someDataId&#xA;        key&#xA;        specialTypeIdA {&#xA;            ...specialData&#xA;        }&#xA;        specialTypeIdB {&#xA;            ...specialData&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;fragment specialData on SpecialType {&#xA;    specialTypeId: Int!&#xA;    name: String!&#xA;    someValue: String!&#xA;}&#xA;</code></pre>&#xA;<p>And then I would recommend you look at <a href=""https://github.com/graphql/dataloader"" rel=""nofollow noreferrer"">DataLoader</a> for how to do lookups in bulk like that.</p>&#xA;",652728,,,,2020-07-07 00:47:38,"",,0,2,0,2020-07-07 00:47:38
62772930,2,,62765178,12,,"<p>After a few moments of playing with the playground ... you can use a <strong>workaround</strong> - <code>reverse</code> and <code>first</code></p>&#xA;<pre><code>{&#xA;  orders(first: 10, reverse:true) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        createdAt&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6124657,,6124657,2021-09-14 21:14:34,2021-09-14 21:14:34,"",,0,6,0,2020-07-07 10:12:57
62799993,2,,57529979,0,,"<p>This is filter in use in React / Javascript:</p>&#xA;<pre><code>const [findPage, setFindPage] = useState('') // setup&#xA;&#xA;async function findpoints() {&#xA;  // find user &amp; page if exists read record&#xA;  try {&#xA;    const todoData = await API.graphql(graphqlOperation(listActivitys, {filter : {owner: {eq: props.user}, page: {eq: action}}}))&#xA;    const pageFound = todoData.data.listActivitys.items // get the data&#xA;    console.log('pageFound 1', pageFound)&#xA;    setFindPage(pageFound) // set to State&#xA;  } catch (err) {&#xA;    console.log(err)&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The async / wait approach means the code will try to operate, and move on to other areas of your code putting data into findPage through setFindPage when and if it finds data</p>&#xA;",9968423,,,,2020-07-08 17:08:17,"",,0,0,0,2020-07-08 17:08:17
62806401,2,,62806305,0,,"<p>I don't have enough reputation to comment on your question. So I am sharing this as an answer.</p>&#xA;<p>I think you can use $elemMatch to search for the item in an array.</p>&#xA;<pre><code>const Productos = await Factura.aggregate([{ detlle: { $elemMatch: { $gte: 80, $lt: 85 } } }])&#xA;</code></pre>&#xA;<p>For more detailed info <a href=""https://docs.mongodb.com/manual/reference/operator/query/elemMatch/"" rel=""nofollow noreferrer"">elemMatch</a></p>&#xA;",13773883,,,,2020-07-09 02:22:08,"",,0,0,0,2020-07-09 02:22:08
62828245,2,,62827847,0,,"<p>It's possible to refactor repeating sets of fields using fragments (<a href=""https://www.apollographql.com/docs/react/data/fragments/"" rel=""nofollow noreferrer"">source 1</a>, <a href=""https://hasura.io/docs/1.0/graphql/manual/queries/variables-aliases-fragments-directives.html#using-fragments"" rel=""nofollow noreferrer"">source 2</a>):</p>&#xA;<h3>Query - before</h3>&#xA;<pre><code>gql`&#xA;  mutation insert_shops_users($shopId: uuid) {&#xA;    insert_shops_users(objects: [{ shopId: $shopId }]) {&#xA;      affected_rows&#xA;      returning {&#xA;        Shop {&#xA;          id&#xA;          users {&#xA;            userId&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;      `,&#xA;</code></pre>&#xA;<h3>Query - after using fragments</h3>&#xA;Fragment&#xA;<pre><code>const ShopWithUsers = gql`&#xA;  fragment ShopWithUsers on shops {&#xA;    id&#xA;    users {&#xA;      userId&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;Query&#xA;<pre><code>gql: gql`&#xA;  mutation insert_shops_users($shopId: uuid) {&#xA;    insert_shops_users(objects: [{ shopId: $shopId }]) {&#xA;      affected_rows&#xA;      returning {&#xA;        Shop {&#xA;          ...ShopWithUsers&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;  ${ShopWithUsers}&#xA;`,&#xA;</code></pre>&#xA;",7440006,,7440006,2020-07-10 10:59:37,2020-07-10 10:59:37,"",,0,0,0,2020-07-10 06:09:02
62837388,2,,62837249,1,,"<p>It's a unix timestamp. React or Apollo, or whatever is not involved here.</p>&#xA;<p>You can easily transform it to a JavaScript <a href=""https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Date"" rel=""nofollow noreferrer"">Date</a> object:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>new Date(1594321836292)&#xA;2020-07-09T19:10:36.292Z&#xA;</code></pre>&#xA;<p>Then having this object you can format it as you want using available methods.</p>&#xA;",681548,,681548,2020-07-13 10:57:02,2020-07-13 10:57:02,"",,0,1,0,2020-07-10 15:19:22
62851426,2,,62851194,2,,"<p>with the <code>find</code> (aka the plural form, as the singular uses the <code>findOne</code>) you have to use a where filter:</p>&#xA;<pre><code>query Articles {&#xA;    article (where: { slug: &quot;a&quot; }) {&#xA;        title&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",12052522,,,,2020-07-11 15:56:59,"",,0,0,0,2020-07-11 15:56:59
62855704,1,,,0,31,"<p>From my client I'm trying to send something with the following structure to my server...</p>&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  pet: cat,&#xA;  food: [&#xA;    {&#xA;      brand: &quot;Meow Mix&quot;,&#xA;      types: &quot;dry&quot;&#xA;    },&#xA;    {&#xA;      brand: &quot;Friskies&quot;,&#xA;      types: {&#xA;         type1: dry,&#xA;         type2: wet,&#xA;      }, &#xA;    },&#xA;    &#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>You can see that <code>types</code> can either be a <code>string</code> or <code>object</code>. Presume more brands will be added to the array that will contain either a <code>string</code> or <code>object</code> for <code>types</code>. Is it even possible to send this sort of structure via GraphQL? If so, how would the type be structured? Ideally it would be great to use a <code>union</code> here but that's not available for mutatations.</p>&#xA;<pre><code>input Pets {&#xA;  pet: String!,&#xA;  food: [Brands!]!&#xA;}&#xA;&#xA;input Brands {&#xA;  brand: String!,&#xA;  types: String! | FoodOptions  // here is where I'm getting stuck. i know `or` isn't possible but don't know of a different solution.&#xA;}&#xA;&#xA;input FoodOptions {&#xA;  type1: String!,&#xA;  type2: String&#xA;}&#xA;</code></pre>&#xA;",8378893,,,,2020-07-11 23:42:04,Is it possible to have a GraphQL mutation that contains various input values for a specific key?,<javascript><graphql><apollo>,0,3,0,2020-07-11 23:42:04
62867425,1,63791790,,5,2269,"<p>Provided a very simple model in <code>graphql.schema</code>, how would I perform a simple sort query?</p>&#xA;<pre><code>type Todo @model&#xA;  id: ID!&#xA;  text: String!&#xA;}&#xA;</code></pre>&#xA;<p>Which generates the following in <code>queries.js</code>.</p>&#xA;<pre><code>export const listTodos = /* GraphQL */ `&#xA;  query ListTodos(&#xA;    $filter: ModelTodoFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        text&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I have found multiple sources pointing me in the direction of the <code>@key</code> <a href=""https://docs.amplify.aws/cli/graphql-transformer/directives#how-to-use-key"" rel=""noreferrer"">directive</a>. This similar question addresses that approach (<a href=""https://stackoverflow.com/questions/57954689/graphql-with-aws-amplify-how-to-enable-sorting-on-query"">GraphQL with AWS Amplify - how to enable sorting on query</a>).</p>&#xA;<p>While that may seem promising and successfully generates new queries I can use, all the approaches I have tried require that I filter the data before sorting it. All I want to do is sort my todo results on a given column name, with a given sort direction (ASC/DESC).</p>&#xA;<p>This is how I would perform a simple (unsorted) query:&#xA;<code>const todos = await API.graphql(graphqlOperation(listTodos));</code></p>&#xA;<p>I would be looking to do something along the lines of:&#xA;<code>const todos = await API.graphql(graphqlOperation(listTodos, {sortField: &quot;text&quot;, sortDirection: &quot;ASC&quot;} ))</code>.</p>&#xA;",378204,,,,2020-09-15 02:48:07,Sorting results in AWS Amplify GraphQL without filtering,<graphql><aws-amplify>,2,0,0,2020-07-12 23:30:16
62883282,1,62883506,,1,668,"<p>I'm struggling for hours to pass pageContext array to gatsby page Query</p>&#xA;<p>How I can pass an array to GraphQL?</p>&#xA;<pre><code>query AllCategoriesQuery($id: Int!, $cat: Array) {&#xA;</code></pre>&#xA;<p>below is my complete query</p>&#xA;<pre><code>export const query = graphql`&#xA;  query AllCategoriesQuery($id: Int!) {&#xA;    allStrapiChildcategories: allStrapiChildcategories(&#xA;      filter: { category: { id: { eq: $id } } }&#xA;    ) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          title&#xA;          strapiId&#xA;          category {&#xA;            id&#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    allProducts: allStrapiProducts(&#xA;      filter: { childcategory: { id: { in: $cat } } }&#xA;    ) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          title&#xA;          strapiId&#xA;          childcategory {&#xA;            id&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;",55860,,5585371,2020-07-13 20:30:02,2021-04-26 13:26:28,Passing a pageContext array to Gatsby's pageQuery,<graphql><gatsby>,1,0,0,2020-07-13 19:53:12
62913289,1,62914217,,0,220,"<p>As per Relay client specification, and GraphQL specification I got that list should be implemented via Connection and Edges, to give ability to paginate it.</p>&#xA;<p>But what if I have a lift of nodes that I don't need to paginate? I mean, I always want to load all entries all the time and there is no business cases where I need only part of that list.&#xA;Should it be also paginated anyway?</p>&#xA;",8295423,,,,2020-07-15 11:52:33,Should list in GraphQL type always be paginated?,<graphql><relay><graphql-java>,1,0,0,2020-07-15 10:53:51
62914217,2,,62913289,0,,"<p>No, pagination is not always necessary. There are many cases where you definitely don't want pagination. For example, a graphql query to get dropdown options for a form. So pagination is optional and depends on your use case. Trust your instinct for if you need pagination or not. You can always change it later.</p>&#xA;",13738464,,,,2020-07-15 11:52:33,"",,0,0,0,2020-07-15 11:52:33
62915266,1,,,0,203,"<p>I have encountered a problem similar to this:&#xA;<a href=""https://github.com/prisma/prisma1/issues/1734#issuecomment-362576690"" rel=""nofollow noreferrer"">https://github.com/prisma/prisma1/issues/1734#issuecomment-362576690</a></p>&#xA;<p>if i use fragment in my query, forkJoin doesnt fire -</p>&#xA;<pre><code>forkJoin(...injectorObs).subscribe(result =&gt; {&#xA;&#xA;  this.isHide = hide.apply(this, result);&#xA;  if (this.isHide) {&#xA;    this.hided.emit();&#xA;  }&#xA;</code></pre>&#xA;<p>exactly same code works perfect if i dont use fragment in my query, i.e.&#xA;i change this</p>&#xA;<pre><code>  loans {&#xA;    ...loanDetailsFragment&#xA;  }&#xA;</code></pre>&#xA;<p>to use the field</p>&#xA;<pre><code>  loans {&#xA;    loanNumber&#xA;  }&#xA;</code></pre>&#xA;",1300799,,,,2020-07-15 12:50:05,forkJoin not firing for graphql query with fragment,<angular><graphql><observable><apollo><fork-join>,0,2,0,2020-07-15 12:50:05
62917100,1,62917487,,1,335,"<p>GraphQL and Relay specification requires to have Query type with node(id: ID!) field described and implemented like this:</p>&#xA;<pre><code>type Query {&#xA;  node(id: ID!): Node&#xA;}&#xA;</code></pre>&#xA;<p>Relay want to refetch any object by id. That means server should understand somehow which type of object it should look for. Which table in db to scan.&#xA;It is clear that id cannot be just serial id or uuid, as in this case it have to scan all tables. That is bad approach.</p>&#xA;<p>I came to solution to encode object id along with its type, to be able to understand what table to query. Something like &quot;24|User&quot; encoded in base64 will give unique identifier as &quot;MjR8VXNlcg==&quot;. I am pretty sure that this approach will work, but I wonder is there any better way to handle this situation? What are the alternatives?</p>&#xA;",8295423,,,,2020-07-15 14:40:43,What is the best way of Query node(id: ID!) implementation with RDBMS,<graphql><relay><graphql-java>,1,2,0,2020-07-15 14:21:21
62952351,2,,48382897,-5,,"<p>To understand more about <strong>variables</strong> use in GraphQL</p>&#xA;<p>Please refer these links ( You can go through these links in less than 5 mins)</p>&#xA;<p><a href=""https://graphql.org/learn/queries/#operation-name"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#operation-name</a></p>&#xA;<p><a href=""https://graphql.org/learn/queries/#variables"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#variables</a></p>&#xA;<p><a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#fragments</a></p>&#xA;<p><a href=""https://graphql.org/learn/queries/#using-variables-inside-fragments"" rel=""nofollow noreferrer"">https://graphql.org/learn/queries/#using-variables-inside-fragments</a></p>&#xA;<p>You will get more hold on operation names, variables, fragments and use of variables inside fragments.</p>&#xA;<p>Have a look at this link: <a href=""https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a"" rel=""nofollow noreferrer"">https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a</a></p>&#xA;<p>It will help you in understanding more about <strong>info</strong> argument of resolver function.</p>&#xA;",5443319,,,,2020-07-17 10:42:54,"",,0,1,0,2020-07-17 10:42:54
62955083,2,,62954996,0,,<p>I guess you are missing the curly brackets before getCompanyById. Try this:</p>&#xA;<pre><code>const users = gql` {&#xA;  getCompanyById(query: {id: &quot;Jwx7C2RAekf1XZmUf9kX&quot;}) {&#xA;    __typename&#xA;    ... on Company {&#xA;      name&#xA;      usersConnection(first: 10) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            firstName&#xA;            lastName&#xA;            phone&#xA;            email&#xA;            cpf&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>}&#xA;`;</p>&#xA;,12130019,,,,2020-07-17 13:32:07,"",,0,0,0,2020-07-17 13:32:07
62997807,2,,62955617,0,,<p>Add <code>using System.Reactive.Linq;</code> and <code>Take</code> limits it to e.g. 20 records:</p>&#xA;<pre><code>result&#xA;   .Take(20)&#xA;   .Subscribe(t =&gt;&#xA;</code></pre>&#xA;,1773592,,,,2020-07-20 14:36:31,"",,0,0,0,2020-07-20 14:36:31
63011613,1,63030645,,3,986,"<p>I have the following GraphQL schema, which defines 3 types: a <code>CondaPackage</code> which hasmany <code>CondaVersion</code>, which hasmany <code>CondaExecutable</code>. I want to be able to query a <code>CondaVersion</code> and ask &quot;how many <code>CondaExecutable</code>s do you own which succeeded my analysis&quot;. Currently I've written a <code>succeededExeCount</code> and <code>allExeCount</code> which resolve this field by loading all children and manually counting the number of children that succeeded.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>exports.createSchemaCustomization = ({ actions: { createTypes }, schema }) =&gt; {&#xA;  createTypes([&#xA;    schema.buildObjectType({&#xA;      name: &quot;CondaPackage&quot;,&#xA;      fields: {&#xA;        succeededExeCount: {&#xA;          type: &quot;Int!&quot;,&#xA;          resolve(source, args, context){&#xA;              // TODO&#xA;          }&#xA;        },&#xA;        allExeCount: {&#xA;          type: &quot;Int!&quot;,&#xA;          resolve(source, args, context){&#xA;              // TODO&#xA;          }&#xA;        }&#xA;      },&#xA;      interfaces: [&quot;Node&quot;]&#xA;    }),&#xA;    schema.buildObjectType({&#xA;      name: &quot;CondaVersion&quot;,&#xA;      fields: {&#xA;        succeededExeCount: {&#xA;          type: &quot;Float!&quot;,&#xA;          resolve(source, args, context){&#xA;            const children = context.nodeModel.getNodesByIds({&#xA;              ids: source.children,&#xA;              type: &quot;CondaExecutable&quot;&#xA;            })&#xA;            return children.reduce((acc, curr) =&gt; acc + curr.fields.succeeded, 0)&#xA;          }&#xA;        },&#xA;        allExeCount: {&#xA;          type: &quot;Int!&quot;,&#xA;          resolve(source, args, context){&#xA;            return source.children.length;&#xA;          }&#xA;        }&#xA;      },&#xA;      interfaces: [&quot;Node&quot;]&#xA;    }),&#xA;    schema.buildObjectType({&#xA;      name: &quot;CondaExecutable&quot;,&#xA;      fields: {&#xA;        succeeded: {&#xA;          type: &quot;Boolean!&quot;,&#xA;          resolve(source, args, context, info) {&#xA;            return source.fields.succeeded || false;&#xA;          }&#xA;        },&#xA;      },&#xA;      interfaces: [&quot;Node&quot;]&#xA;    })&#xA;  ])&#xA;}&#xA;</code></pre>&#xA;<p>My first problem is that this seems incredibly inefficient. For each <code>CondaVersion</code> I'm running a separate query for its children, which is a classic N+1 query problem. Is there a way to tell Gatsby/GraphQL to simply &quot;join&quot; the two tables like I would using SQL to avoid this?</p>&#xA;<p>My second problem is that I now need to count the number of succeeding children from the top level type: <code>CondaPackage</code>. I want to ask &quot;how many <code>CondaExecutable</code>s do your child <code>CondaVersion</code>s own which succeeded my analysis&quot;. Again, in SQL this would be easy because I would just <code>JOIN</code> the 3 types. However, the only way I can currently do this is by using <code>getNodesByIds</code> for each child, and then for each child's child, which is <code>n*m*o</code> runtime, which is terrifying. I would like to run a GraphQL query as part of the field resolution which lets me grab the <code>succeededExeCount</code> from each child. However, Gatsby's <a href=""https://www.gatsbyjs.org/docs/node-model/#runQuery"" rel=""nofollow noreferrer""><code>runQuery</code></a> seems to return nodes without including derived fields, and it won't let me select additional fields to return. How can I access fields on a node's child's child in Gatsby?</p>&#xA;",2148718,,2148718,2020-07-21 10:07:21,2020-07-30 08:58:03,Querying child node fields in Gatsby,<javascript><graphql><gatsby><graphql-compose>,1,5,0,2020-07-21 09:37:39
63030645,2,,63011613,1,,"<p><strong>Edit</strong></p>&#xA;<p>Here's the response from a Gatsby maintainer regarding the workaround:</p>&#xA;<blockquote>&#xA;<p>Gatsby has an internal mechanism to filter/sort by fields with custom resolvers. We call it materialization. [...] The problem is that <strong>this is not a public API</strong>. This is a sort of implementation detail that may change someday and that's why it is not documented.</p>&#xA;</blockquote>&#xA;<p>See the <a href=""https://github.com/gatsbyjs/gatsby/issues/25945#issuecomment-662899027"" rel=""nofollow noreferrer"">full thread here</a>.</p>&#xA;<p><strong>Original Answer</strong></p>&#xA;<p>Here's a little 'secret' (not mentioned anywhere in the docs at the time of writing):</p>&#xA;<p>When you use <code>runQuery</code>, Gatsby will try to resolve derived fields... but only if that field is passed to the query's options (filter, sort, group, distinct).</p>&#xA;<p>For example, in <code>CondaVersion</code>, instead of accessing children nodes and look up <code>fields.succeeded</code>, you can do this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const succeededNodes = await context.nodeModel.runQuery({&#xA;  type: &quot;CondaExecutable&quot;,&#xA;  query: { filter: { succeeded: { eq: true } } }&#xA;})&#xA;</code></pre>&#xA;<p>Same thing for <code>CondaPackage</code>. You might try to do this</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const versionNodes = await context.nodeModel.runQuery({&#xA;  type: &quot;CondaVersion&quot;,&#xA;  query: {}&#xA;})&#xA;&#xA;return versionNodes.reduce((acc, nodes) =&gt; acc + node.succeededExeCount, 0) // Error&#xA;</code></pre>&#xA;<p>You'll probably find that <code>succeededExeCount</code> is <code>undefined</code>.</p>&#xA;<p>The trick is to do this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const versionNodes = await context.nodeModel.runQuery({&#xA;  type: &quot;CondaVersion&quot;,&#xA;- query: {}&#xA;+ query: { filter: { succeededExeCount: { gte: 0 } } }&#xA;})&#xA;</code></pre>&#xA;<p>It's counter intuitive, because you'd think Gatsby would just resolve all resolvable fields on a type. Instead it only resolves fields that is 'used'. So to get around this, we add a filter that supposedly does nothing.</p>&#xA;<p>But that's not all yet, <code>node.succeededExeCount</code> is still <code>undefined</code>.</p>&#xA;<p>The resolved data (<code>succeededExeCount</code>) is not directly stored on the node itself, but in <code>node.__gatsby_resolved</code> <a href=""https://github.com/gatsbyjs/gatsby/blob/d842f8c27c0c65d3c6d6a1113bfe12596f93c13c/packages/gatsby/src/schema/node-model.js#L387"" rel=""nofollow noreferrer"">source</a>. We'll have to access it there instead.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const versionNodes = await context.nodeModel.runQuery({&#xA;  type: &quot;CondaVersion&quot;,&#xA;  query: { filter: { succeededExeCount: { gte: 0 } } }&#xA;})&#xA;&#xA;return versionNodes.reduce((acc, node) =&gt; acc + node.__gatsby_resolved.succeededExeCount, 0)&#xA;</code></pre>&#xA;<p>Give it a try &amp; let me know if that works.</p>&#xA;<p>PS: I notice that you probably use <code>createNodeField</code> (in <code>CondaExec</code>'s <code>node.fields.succeeded</code>?) <code>createTypes</code> is also accessible in <code>exports.sourceNodes</code>, so you might be able to add this <code>succeeded</code> field directly.</p>&#xA;",10340970,,10340970,2020-07-30 08:58:03,2020-07-30 08:58:03,"",,0,3,0,2020-07-22 09:04:35
63118972,2,,63110177,3,,"<p>You aren't wrapping the root element here, you're replacing the entirety of the Gatsby app tree. You're probably seeing warnings about page queries being ignored because they're in files that aren't being treated like pages, which is likely where the source of confusion is.</p>&#xA;<p>Here's the example the Gatsby docs provide:</p>&#xA;<pre><code>exports.wrapRootElement = ({ element }) =&gt; {&#xA;  return (&#xA;    &lt;Provider store={store}&gt;&#xA;      {element}&#xA;    &lt;/Provider&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;<p>Note how this example accepts an <code>element</code> prop that it passes down as the children to the <code>Provider</code> component? That's what you're missing. You probably want something like this:</p>&#xA;<pre><code>export const wrapRootElement = ({ element }) =&gt;&#xA;  &lt;ThemeProvider theme={theme}&gt;&#xA;    {element}&#xA;  &lt;/ThemeProvider&gt;&#xA;</code></pre>&#xA;<p>You don't need to check for the existence of <code>window</code> here. If you're in <code>gatsby-browser.js</code> it will only ever be executed in the context of the browser. If you're in <code>gatsby-ssr.js</code> it'll only ever be executed in the context of node. Either way, they need to produce the same DOM output in order to have React hydrate cleanly. Bailing in the way you've shown will result in your entire DOM being replaced when React hydrates, which is less efficient than a client-side rendered app.</p>&#xA;<p>Finally, I removed the <code>FadeTransitionRouter</code> bit because you haven't shared what that is and it is unlikely to be compatible with Gatsby routing. If you'd like to have page transitions, <a href=""https://www.gatsbyjs.org/docs/adding-page-transitions-with-plugin-transition-link/"" rel=""nofollow noreferrer"">this page in the documentation has details on how to set this up</a>.</p>&#xA;",203130,,,,2020-07-27 15:56:21,"",,0,3,0,2020-07-27 15:56:21
63129518,1,,,3,44,"<p>I am building a React app which uses Apollo to request data from the backend.&#xA;The root component requests the data via Apollo and contains two child components:</p>&#xA;<ol>&#xA;<li>Canvas that renders the data via Pixi.js</li>&#xA;<li>FilterContainer that includes multiple filters (the filters are created from the initial data --&gt; don't need to be re-rendered after every request)</li>&#xA;</ol>&#xA;<p>I am using React's Hook useContext to pass the filtered values from the filters to the root component. The root component builds the whole query and starts the request. Since the root component re-renders after the request, it causes the whole app to re-render. Therefore I'm managing the whole state from the filters (e.g. checked checkboxes, search-values, ...) in my ReactContext because otherwise it would be lost after re-rendering.</p>&#xA;<p>My question is, if there is another way to structure my app, since this approach seems very inefficient to me.</p>&#xA;<p>Thanks in advance!</p>&#xA;",8924564,,8924564,2020-07-28 08:13:47,2020-07-28 08:13:47,Inefficient React - Apollo structure for filtering,<reactjs><apollo>,0,0,0,2020-07-28 07:59:45
63136172,1,,,0,101,"<p>so I'm trying to do a query that fetches a certain id first.</p>&#xA;<p>i know the sql syntax is something along the lines of -</p>&#xA;<pre><code>SELECT id, name, colour&#xA;FROM books&#xA;ORDER BY id=2 desc;&#xA;</code></pre>&#xA;<p>i am trying to figure out how to do the same thing in a postgraphile query with pagination</p>&#xA;<p>thank you very much!</p>&#xA;",14009999,,,,2020-07-28 14:14:12,PostGraphile - ordering results by specific id,<graphql><postgraphile>,0,2,0,2020-07-28 14:14:12
63141858,1,,,9,1373,"<p>I'm using <code>graphene-django</code> to build my API. I have a DjangoObjectType named <code>StoreType</code> which represents the model Store. This model has a MultiSelectField named <code>opening_days</code> that indicates what days in the week the store is open. To create new stores, I use this mutation:</p>&#xA;<pre><code>class Weekdays(graphene.Enum):&#xA;    MO = &quot;Mo&quot;&#xA;    TU = &quot;Tu&quot;&#xA;    WE = &quot;We&quot;&#xA;    TH = &quot;Th&quot;&#xA;    FR = &quot;Fr&quot;&#xA;    SA = &quot;Sa&quot;&#xA;    SU = &quot;Su&quot;&#xA;&#xA;class CreateStore(graphene.Mutation):&#xA;    store = graphene.Field(StoreType)&#xA;&#xA;    class Arguments:&#xA;        opening_days = graphene.Argument(graphene.List(Weekdays))&#xA;&#xA;    def mutate(self, info, opening_days):&#xA;        store = Store(opening_days=opening_days)&#xA;        store.save()&#xA;        return CreateStore(store=store)&#xA;</code></pre>&#xA;<p>The mutation works perfectly. But then, when I try to query a store, I get the error <code>&quot;Expected a value of type \&quot;StoreOpeningDays\&quot; but received: Monday, Tuesday&quot;,</code> which makes sense really, because this field saves the data as a single string with the values separated by commas. The issue is that graphene is expecting the list specified in <code>graphene.List(Weekdays)</code> which is impossible to retrieve.</p>&#xA;<p>Any ideas on how to fix this? Thanks in advance!</p>&#xA;",11556154,,,,2021-04-12 13:15:42,"Graphene: ""Expected a value of type XXX but received: ...""",<python><django><graphql><graphene-python>,1,2,0,2020-07-28 19:56:15
63142620,2,,49968899,0,,"<p>What you need to do is:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>&#xA;class ScanResult(SQLAlchemyObjectType):&#xA;    class Meta:&#xA;        model = ScanResultModel&#xA;&#xA;    scans = graphene.List(Scans, description=&quot;Scans from results.&quot;)&#xA;&#xA;    def resolve_scans(self, info):&#xA;        query = Scans.get_query(info)&#xA;        return query.filter(ScansModel.my_id == self.scans_id).all()&#xA;&#xA;</code></pre>&#xA;<p>This will probably enables you to build queries like:</p>&#xA;<pre><code>{&#xA;  scanresult{&#xA;    edges {&#xA;      node {&#xA;         id&#xA;         scans{&#xA;            id&#xA;         }&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",2280641,,,,2020-07-28 20:55:17,"",,0,0,0,2020-07-28 20:55:17
63165898,1,,,0,219,"<blockquote>&#xA;<p>GraphQL Schema:</p>&#xA;</blockquote>&#xA;<pre><code>type Query {&#xA;      getCustomer(customerId:Int!):Customer&#xA;}&#xA;type Customer {&#xA;      customerId : Int&#xA;      customerName : String&#xA;      emailId: String&#xA;      orderId: Int&#xA;      orderDetails(limit:Int):[OrderDetails]&#xA;}&#xA;type OrderDetails {&#xA;      orderId: Int&#xA;      productId: Int&#xA;      quantityOrdered: Int&#xA;      totalCost: Int&#xA;}&#xA;</code></pre>&#xA;<blockquote>&#xA;<p>GraphQL query:</p>&#xA;</blockquote>&#xA;<pre><code>query getCustomer {&#xA;   getCustomer(customerId:100){&#xA;      customerName&#xA;      orderId&#xA;      orderDetails(limit:1){&#xA;          quantityOrdered&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>In this scenario. <strong>Customer</strong> table has only 4 columns : <strong>customerId, customerName, emailId, orderId</strong> but I need to hit an OrderDetails table if that is asked in the query. So I have written a Field Resolver for <strong>orderDetails</strong> and this orderDetails will take input from the <strong>customer</strong> data</p>&#xA;<blockquote>&#xA;<p>Request Mapping Template of orderDetails Resolver</p>&#xA;</blockquote>&#xA;<pre><code>{&#xA;    &quot;version&quot;: &quot;2017-02-28&quot;,&#xA;    &quot;operation&quot;: &quot;GetItem&quot;,&#xA;    &quot;key&quot;: {&#xA;        &quot;orderId&quot;: $util.dynamodb.toDynamoDBJson($ctx.args.orderId),&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/AvXA1.png"" rel=""nofollow noreferrer"">for better understanding of my issue check this image</a></p>&#xA;<p>How do I use this orderId from the same query as a input for the <strong>field resolver (OrderDetails table)</strong> ?</p>&#xA;",14019530,,,,2020-07-30 17:00:12,Field resolver in Appsync using the same query output as argument,<graphql><aws-appsync><resolver>,1,0,0,2020-07-30 03:49:51
63183088,1,,,0,308,"<p>I am trying to pass an argument to the query reading my json file, I have read a lot of tutorials and docs but maybe I am missing something because it doesn't work.</p>&#xA;<p>Here is the code</p>&#xA;<pre><code>query MyQuery {&#xA;  allInternacionalJson {&#xA;    edges {&#xA;      node {&#xA;        regiones(id: 1) {&#xA;          id&#xA;          region&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But the results are the following</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;allInternacionalJson&quot;: {&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;regiones&quot;: [&#xA;              {&#xA;                &quot;id&quot;: 1,&#xA;                &quot;region&quot;: &quot;América del Norte&quot;&#xA;              },&#xA;              {&#xA;                &quot;id&quot;: 2,&#xA;                &quot;region&quot;: &quot;América Latina y el Caribe&quot;&#xA;              },&#xA;              {&#xA;                &quot;id&quot;: 3,&#xA;                &quot;region&quot;: &quot;Europa&quot;&#xA;              },&#xA;              {&#xA;                &quot;id&quot;: 4,&#xA;                &quot;region&quot;: &quot;Asia Pacífico&quot;&#xA;              },&#xA;              {&#xA;                &quot;id&quot;: 5,&#xA;                &quot;region&quot;: &quot;Medio Oriente y África&quot;&#xA;              }&#xA;            ]&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I viewed online that the 'where' search is no longer available and that the filter on top only applies to filtering nodes.</p>&#xA;<p>With that id what I am trying to do is to get only the object that has that id.</p>&#xA;",6353460,,,,2020-07-31 08:29:05,How to query Graphql in Gatsby using parameters/arguments?,<jquery><json><graphql><gatsby>,1,0,0,2020-07-31 00:05:39
63186028,2,,63183088,0,,"<p>The filters must go in the top-level of the query, <code>allInternacionalJson</code> in your case:</p>&#xA;<pre><code>query MyQuery {&#xA;  allInternacionalJson(filter: {regions: {id: {eq: &quot;1&quot;}}}) {&#xA;    edges {&#xA;      node {&#xA;        regiones {&#xA;          id&#xA;          region&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><em>Note: you don't even need to query the <code>id</code> if you don't need it for other purposes,.you can filter without query the parameter.</em></p>&#xA;<p>Basically, you have to deep in each nested object to find your parameter (<code>id</code>) and apply the filtering rule <code>eq</code> (equals).</p>&#xA;<p>You can play and filter by clicking in the <code>localhost:8000/___graphql</code> playground to generate your filtered query.</p>&#xA;<p>Take a look at <a href=""https://www.gatsbyjs.org/docs/graphql-reference/#filter"" rel=""nofollow noreferrer"">GraphQL reference by Gatsby (filter section)</a>.</p>&#xA;",5585371,,5585371,2020-07-31 08:29:05,2020-07-31 08:29:05,"",,0,6,0,2020-07-31 04:58:58
63223604,1,63234163,,0,692,"<p>In the GraphQL API, I often see naming conventions such as NQ and MQ as parameters used in cursor. This is an example, shown below,</p>&#xA;<pre><code> &quot;data&quot;: {&#xA;    &quot;items&quot;: {&#xA;      &quot;totalCount&quot;: 351,&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;hasPreviousPage&quot;: false,&#xA;        &quot;endCursor&quot;: &quot;Mw&quot;,&#xA;        &quot;startCursor&quot;: &quot;MQ&quot;&#xA;      },&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;cursor&quot;: &quot;MQ&quot;,&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;UGxhY2UtMzUy&quot;,&#xA;            &quot;displayName&quot;: &quot;Redbeard&quot;&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;cursor&quot;: &quot;Mg&quot;,&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;UGxhY2UtMzUx&quot;,&#xA;            &quot;displayName&quot;: &quot;Frey of Riverrun&quot;&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;cursor&quot;: &quot;Mw&quot;,&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;QmlsbGVyLTI=&quot;,&#xA;            &quot;displayName&quot;: &quot;Something Else&quot;&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Source:&#xA;<a href=""https://dev.to/tymate/first-dive-into-graphql-ruby-nak"" rel=""nofollow noreferrer"">https://dev.to/tymate/first-dive-into-graphql-ruby-nak</a></p>&#xA;<p>Other examples include this rails example: <a href=""https://www.2n.pl/blog/graphql-pagination-in-rails"" rel=""nofollow noreferrer"">https://www.2n.pl/blog/graphql-pagination-in-rails</a></p>&#xA;<p>What are these naming conventions and how would you for example paginate?</p>&#xA;",14023886,,2704964,2020-08-03 04:12:14,2020-08-03 17:24:30,Cursor Based Pagination Naming Convention in GraphQL,<graphql><cursor>,1,0,0,2020-08-03 04:08:53
63224579,2,,62120967,0,,"<p>Just add pagination to your query <code>$posts = DB::table('posts')-&gt;paginate(12);</code></p>&#xA;<p>Also, here you will found several solutions to this problem:&#xA;<a href=""https://stackoverflow.com/questions/44090392/how-to-use-pagination-with-laravel-dbselect-query"">How to use pagination with laravel DB::select query</a></p>&#xA;<p>Cheer.</p>&#xA;",3198138,,,,2020-08-03 06:15:58,"",,0,0,0,2020-08-03 06:15:58
63225731,1,,,7,514,"<p>I have managed to use Apollo's data mocking for queries. This is what I have so far:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import { addMocksToSchema } from '@graphql-tools/mock'&#xA;import { buildClientSchema, graphql } from 'graphql'&#xA;import schemaJson from './schema.json'&#xA;&#xA;const schema = buildClientSchema(schemaJson)&#xA;const schemaWithMocks = addMocksToSchema({&#xA;  schema,&#xA;  mocks: {&#xA;    Time: () =&gt; '2020-07-10T11:00:00.839379266Z',&#xA;  },&#xA;})&#xA;&#xA;const MyFragment = `&#xA;   fragment MyFragment on SomethingItemList {&#xA;     someField&#xA;   }&#xA;`&#xA;&#xA;graphql({&#xA;  schema: schemaWithMocks,&#xA;  source: `&#xA;  ${MyFragment}&#xA;  query FaultInfoStoryBatterySystems {&#xA;    something {&#xA;      item {&#xA;        list {&#xA;          ...MyFragment&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;`&#xA;}).then((mockedData) =&gt; {&#xA;  console.log('Fragment Data:', mockedData.something.item.list[0])&#xA;})&#xA;&#xA;</code></pre>&#xA;<p>This works... but it is not ideal as what I really want is the fragment data, I don't care about the query at all. Is there any way of doing this with just MyFragment without having to create a query to retrieve that data?</p>&#xA;",3485,,,,2020-08-03 07:58:47,Apollo Graphql mocking fragment data,<graphql><apollo><apollo-client>,0,2,0,2020-08-03 07:58:47
63234163,2,,63223604,0,,"<p>The Relay Server Specification defines how pagination should be done in order to be compatible with the <a href=""https://relay.dev"" rel=""nofollow noreferrer"">Relay GraphQL Client</a>. While it is not the only way how pagination can be done, it has evolved as a standard - at least in examples, since it can be easily referenced.</p>&#xA;<p>The <a href=""https://relay.dev/docs/en/graphql-server-specification.html#connections"" rel=""nofollow noreferrer"">section on connections</a> gives more info about how cursors work:</p>&#xA;<p>Each edge gets a cursor value. This value is - what they call - an opaque value, meaning it should not be interpreted by the server. It is a reference/a pointer that <em>only the server can interpret</em>. So, if you have a query that gets a bunch of values:</p>&#xA;<pre><code>edges: [&#xA;  { cursor: &quot;abc&quot;, node: {...} },&#xA;  { cursor: &quot;def&quot;, node: {...} },&#xA;  { cursor: &quot;ghi&quot;, node: {...} },&#xA;  { cursor: &quot;jkl&quot;, node: {...} },&#xA;  { cursor: &quot;mno&quot;, node: {...} }&#xA;]&#xA;</code></pre>&#xA;<p>You can request the next page by looking at the cursor of the last element <code>mno</code> and pass it into the query.</p>&#xA;<pre><code>query {&#xA;  manyQuery(first: 5, after: &quot;mno&quot;) {&#xA;    edges {&#xA;      cursor&#xA;      node {...}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This will give you the next 5 nodes. See also <a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">this section on graphql.org</a>.</p>&#xA;<p>So to answer your question: The string can potentially contain anything that the server can use to reference one of your nodes. E.g. an id in the database. To remove the temptation to pass in an arbitrary value from the API user this string is often encoded into the base64 format. The value should be meaningless to the client and only be used to be passed around back to the server.</p>&#xA;",3849167,,,,2020-08-03 17:24:30,"",,0,0,0,2020-08-03 17:24:30
63256497,2,,63255839,1,,"<p>If <code>pageFields</code> resolver with <code>nested:true</code> returns <code>paragraphs</code> then this property is already resolved.</p>&#xA;<p>No need to call it separately, it's resolver is skipped, not called.</p>&#xA;<p>This kind of resolver behaviour is used for optimalizations, overfetching in parent, when calling many child (one by one with separate DB request) would be uneffective.</p>&#xA;<p>Remove <code>nested:true</code> or implement additional filtering based on top level <code>hidden</code> arg (if hidden at page==hidden at paragraph). Usually complex (generated) filters build/used at top-parent query level can declare condition for nested child.</p>&#xA;",6124657,,,,2020-08-04 23:42:59,"",,0,5,0,2020-08-04 23:42:59
63259890,1,,,3,63,"<p>I am using F# <a href=""https://fsprojects.github.io/SQLProvider/"" rel=""nofollow noreferrer"">SQLProvider</a> with F# <a href=""https://fsprojects.github.io/FSharp.Data.GraphQL/"" rel=""nofollow noreferrer"">GraphQL</a>. To address classic N+1 select problem with GraphQL nested resolvers, I need to early fetch related/relational/nested data in top-level GraphQL resolver. The basic idea is to recursively walk the GraphQL request AST and build the SQL query with joins. It is very similar to the idea of <a href=""https://blog.smartive.ch/advanced-graphql-patterns-the-almighty-root-resolver-f284872397cb"" rel=""nofollow noreferrer"">almightly root resolver</a></p>&#xA;<p>So far, I can dynamically build the nested query but SQLProvider still loads the fresh data when nested field is accessed by the means of foreign key.</p>&#xA;<p>How can I address this problem with SQLProvider to avoid N+1 select?</p>&#xA;",5723098,,5723098,2020-08-05 15:37:22,2020-08-05 15:37:22,How to do eager fetching of related data using F# SQLProvider with Postgres?,<f#><graphql><f#-data>,0,0,0,2020-08-05 06:54:14
63289775,1,,,0,432,"<p>I'm attempting to create a &quot;Show More&quot; button for my posts index. The index query loads fine with the first 5 posts, when I click the Show More button I can see new posts being returned, however I receive a bunch of errors like:</p>&#xA;<pre><code>Missing field id in {&#xA;  &quot;__typename&quot;: &quot;Post&quot;,&#xA;  &quot;posts&quot;: [&#xA;    {&#xA;      &quot;id&quot;: &quot;5f2b26600c3ec47b279d8988&quot;,&#xA;      &quot;title&quot;: &#xA;</code></pre>&#xA;<p>I receive one of each of these errors pretty much for each post attribute (id, title, content, slug, etc). This prevents the actual new posts from being added to the index. What causes this issue?</p>&#xA;<pre><code>&lt;script&gt;&#xA;&#xA;  import postsQuery from '~/apollo/queries/blog/posts';&#xA;&#xA;  const pageSize = 5;&#xA;&#xA;  export default {&#xA;    name: 'BlogIndex',&#xA;&#xA;    data: () =&gt; ({&#xA;      loadingMorePosts: false,&#xA;      page: 0,&#xA;      pageSize,&#xA;    }),&#xA;&#xA;    apollo: {&#xA;      postsCount: {&#xA;        prefetch: true,&#xA;        query: postsQuery,&#xA;        variables: {&#xA;          page: 0,&#xA;          pageSize,&#xA;        }&#xA;      },&#xA;      posts: {&#xA;        prefetch: true,&#xA;        query: postsQuery,&#xA;        variables: {&#xA;          page: 0,&#xA;          pageSize,&#xA;        }&#xA;      },&#xA;    },&#xA;&#xA;    computed: {&#xA;      morePosts() {&#xA;        return this.posts.length &lt; this.postsCount.aggregate.totalCount;&#xA;      }&#xA;    },&#xA;&#xA;    methods: {&#xA;      async fetchMorePosts() {&#xA;        this.page += this.pageSize;&#xA;&#xA;        this.$apollo.queries.posts.fetchMore({&#xA;          variables: {&#xA;            page: this.page,&#xA;            pageSize,&#xA;          },&#xA;          updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;            const newPosts = fetchMoreResult.posts;&#xA;            console.log('typename: ', previousResult.posts.__typename); &lt;--- returns undefined&#xA;&#xA;            if (!newPosts.length) return previousResult;&#xA;&#xA;            return {&#xA;              posts: {&#xA;                __typename: previousResult.posts.__typename,&#xA;                posts: [...previousResult.posts, ...newPosts],&#xA;              }&#xA;            }&#xA;          }&#xA;        })&#xA;      },&#xA;    },&#xA;  }&#xA;&lt;/script&gt;&#xA;</code></pre>&#xA;<p>UPDATE: added imported posts query</p>&#xA;<pre><code>query Posts($page: Int!, $pageSize: Int!) {&#xA;  posts(&#xA;    start: $page&#xA;    limit: $pageSize&#xA;    sort: &quot;published_at:desc&quot;&#xA;    where: { published: true }&#xA;  ) {&#xA;    id&#xA;    title&#xA;    content&#xA;    slug&#xA;    published&#xA;    createdAt&#xA;    updatedAt&#xA;    published_at&#xA;  }&#xA;  postsCount: postsConnection(where: { published: true }) {&#xA;    aggregate {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3394654,,3394654,2020-08-06 18:39:18,2020-08-06 18:48:09,"Vue Apollo ""__typename"" is undefined in updateQuery",<vue.js><graphql><strapi><vue-apollo>,1,2,0,2020-08-06 18:36:22
63289963,2,,63289775,1,,"<p>I think the problem is here:</p>&#xA;<pre><code>            return {&#xA;              posts: {&#xA;                __typename: previousResult.posts.__typename,&#xA;                posts: [...previousResult.posts, ...newPosts],&#xA;              }&#xA;            }&#xA;</code></pre>&#xA;<p>I'm pretty sure <code>__typename</code> is supposed to belong to each post object, not part of the collection of posts. Let me know how if something like this fixes it:</p>&#xA;<pre><code>            return {&#xA;              posts: {&#xA;                posts: [...previousResult.posts, ...newPosts]&#xA;              }&#xA;            }&#xA;&#xA;</code></pre>&#xA;<p>and changing the query to:</p>&#xA;<pre><code>query Posts($page: Int!, $pageSize: Int!) {&#xA;  posts(&#xA;    start: $page&#xA;    limit: $pageSize&#xA;    sort: &quot;published_at:desc&quot;&#xA;    where: { published: true }&#xA;  ) {&#xA;    __typename    // add this here&#xA;    id&#xA;    title&#xA;    content&#xA;    slug&#xA;    published&#xA;    createdAt&#xA;    updatedAt&#xA;    published_at&#xA;  }&#xA;  postsCount: postsConnection(where: { published: true }) {&#xA;    aggregate {&#xA;      totalCount&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3833784,,,,2020-08-06 18:48:09,"",,0,3,0,2020-08-06 18:48:09
63298798,1,63314472,,0,485,"<p>I'm trying to make a form to create a new announcement, but I get error:</p>&#xA;<p><code>Invariant Violation: Argument of undefined passed to parser was not a valid GraphQL DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document</code></p>&#xA;<p>This is my first time using GraphQL and Apollo, so I don't know exactly what I should do.</p>&#xA;<p><em><strong>CreateAnnouncement component:</strong></em></p>&#xA;<pre><code>import { compose, graphql } from 'react-apollo';&#xA;import { addAnnouncement as addAnnouncementMutation } from '../../../mutations/Announcements.gql';&#xA;import { announcement as announcementQuery } from '../../../queries/Announcements.gql';&#xA;&#xA;class CreateAnnouncement extends React.Component {&#xA;...&#xA;}&#xA;&#xA;export default compose(&#xA;  graphql(announcementQuery, {&#xA;    options: ({ match }) =&gt; ({&#xA;      variables: {&#xA;        _id: match.params._id,&#xA;      },&#xA;    }),&#xA;  }),&#xA;&#xA;  ***THE ERROR POINTS NEXT LINE***&#xA;&#xA;  graphql(addAnnouncementMutation, {&#xA;    name: 'addAnnouncement',&#xA;  }),&#xA;)(CreateAnnouncement);&#xA;</code></pre>&#xA;<p><em><strong>'../../../mutations/Announcements.gql'</strong></em></p>&#xA;<pre><code>#import &quot;../fragments/Announcements.gql&quot;&#xA;&#xA;mutation addAnnouncement($title: String!, $description: String, $date: String!) {&#xA;  addAnnouncement(title: $title, description: $description, date: $date) {&#xA;    ...AnnouncementAttributes&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><em><strong>&quot;../fragments/Announcements.gql&quot;</strong></em></p>&#xA;<pre><code>fragment AnnouncementAttributes on Announcement {&#xA;  _id&#xA;  title&#xA;  description&#xA;  date&#xA;  createdAt&#xA;  updatedAt&#xA;}&#xA;</code></pre>&#xA;",11544569,,,,2020-08-21 07:05:58,React ApolloClient mutations,<reactjs><graphql><react-apollo><apollo-client>,1,1,0,2020-08-07 09:16:20
63303901,1,,,0,932,"<p>I'm trying to get my filter to return my array of objects in descending order according to 'price' when sortPrice === true.</p>&#xA;<p>I'm using 'type-graphql' for my resolver and the package 'fast-sort' to sort the data in descending order.</p>&#xA;<p>here is my resolver code - <em>note that the price filter works as intended.</em></p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>  // Price filter&#xA;  if (minPrice) {&#xA;    filteredItems = filteredItems.filter((item: any) =&gt; item.price &gt;= minPrice);&#xA;  }&#xA;&#xA;  if (maxPrice) {&#xA;    filteredItems = filteredItems.filter((item: any) =&gt; item.price &lt;= maxPrice);&#xA;  }&#xA;&#xA;  // Sort price/rating&#xA;&#xA;  if (sortPrice) {&#xA;    filteredItems = filteredItems.filter((item: any) =&gt; sort(items).desc());&#xA;  }</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>here is my graphql playground query - you can see it is not sorting the array by the price.</p>&#xA;<p><a href=""https://i.stack.imgur.com/16A7A.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/16A7A.png"" alt=""enter image description here"" /></a></p>&#xA;",11285322,,11285322,2020-08-10 16:16:33,2020-08-10 19:44:57,How can I sort this Graphql array with my Typescript resolver?,<arrays><typescript><sorting><graphql><typegraphql>,1,3,0,2020-08-07 14:32:51
63305346,1,,,4,203,"<p>Apollo 3 introduced typePolicies and <a href=""https://www.apollographql.com/docs/react/caching/cache-field-behavior/#specifying-key-arguments"" rel=""nofollow noreferrer"">keyArgs</a> as a way to tell the cache how to store data and avoid duplicate entries. This seems akin to the <a href=""https://www.apollographql.com/docs/react/caching/advanced-topics/#the-connection-directive"" rel=""nofollow noreferrer"">@connection</a> directive, which provides similar functionality (specify a custom store key for results).</p>&#xA;<p>Is it necessary and safe to use both in an application? When would it make sense to choose one over the other?</p>&#xA;",428928,,428928,2020-08-07 16:00:21,2020-08-11 22:38:48,What is the distinction between @connection and keyArgs?,<apollo><apollo-client>,1,0,0,2020-08-07 15:59:35
63315072,1,,,0,331,"<p>I am trying to parameterize a GraphQL query being sent as Body Data in JMeter, but not getting the correct response.</p>&#xA;<p>Here is the graphql:</p>&#xA;<blockquote>&#xA;<p>{&quot;operationName&quot;:&quot;VPercentageQuery&quot;,&quot;variables&quot;:{&quot;thestate&quot;:&quot;CA&quot;},&quot;query&quot;:&quot;query VPercentageQuery($thestate: [String]) {\n  nodeQuery(filter: {conditions: [{operator: EQUAL, field: &quot;type&quot;, value: &quot;v_data&quot;}, {operator: EQUAL, field: &quot;field_vev_percentage_state&quot;, value: $thestate}]}, sort: {field: &quot;field_year&quot;, direction: DESC}, limit: 3) {\n    entities {\n      entityLabel\n      ... on NodeVData {\n        fieldVevPercentageState\n        fieldStatePercentage\n        fieldEffectiveDateRange\n        fieldYear\n        __typename\n      }\n      __typename\n    }\n    __typename\n  }\n}\n&quot;}</p>&#xA;</blockquote>&#xA;<p>Now, substituting &quot;CA&quot; with &quot;${state}&quot;</p>&#xA;<blockquote>&#xA;<p>{&quot;operationName&quot;:&quot;VPercentageQuery&quot;,&quot;variables&quot;:{&quot;thestate&quot;:&quot;${state}&quot;},&quot;query&quot;:&quot;query VPercentageQuery($thestate: [String]) {\n  nodeQuery(filter: {conditions: [{operator: EQUAL, field: &quot;type&quot;, value: &quot;v_data&quot;}, {operator: EQUAL, field: &quot;field_vev_percentage_state&quot;, value: $thestate}]}, sort: {field: &quot;field_year&quot;, direction: DESC}, limit: 3) {\n    entities {\n      entityLabel\n      ... on NodeVData {\n        fieldVevPercentageState\n        fieldStatePercentage\n        fieldEffectiveDateRange\n        fieldYear\n        __typename\n      }\n      __typename\n    }\n    __typename\n  }\n}\n&quot;}</p>&#xA;</blockquote>&#xA;<p>Now, creating a state.csv file with just one column have entries:</p>&#xA;<p>CA&#xA;VA&#xA;SD&#xA;ND</p>&#xA;<p>and adding a CSV Data Set Config , Config Element</p>&#xA;<p>Not getting the response with states in the csv file</p>&#xA;<p>I am using JMeter 5.3</p>&#xA;",454488,,454488,2020-08-08 18:41:31,2020-08-10 05:49:56,JMeter parameterization with GraphQL query,<jmeter><graphql>,1,0,0,2020-08-08 11:54:00
63334774,2,,63315072,0,,"<p><code>&quot;variables&quot;: {&quot;thestate&quot;: &quot;${state}&quot; }</code> works , add CSV Data Set Config&#xA;with Ignore First Line to True ( if you have a heading, <code>state</code> )&#xA;and just add all states in one column, plus keep the Loop Count in the</p>&#xA;",454488,,,,2020-08-10 05:49:56,"",,0,0,0,2020-08-10 05:49:56
63346921,2,,63303901,0,,"<p>As far as I'm concerned, i'm using this piece of code to sort an array of objects.&#xA;Can be sorted in by ASC/DESC, and by one or several keys. I found this function here in stackoverflow few weeks later, that I have adjusted a little bit.&#xA;Have also create an enum to make the code more safe.&#xA;This is in typescript but you can get rid off the types and interface to convert in Javascript</p>&#xA;<pre><code>export declare enum EOrderBy {&#xA;    ASC = &quot;ASC&quot;,&#xA;    DESC = &quot;DESC&quot;&#xA;}&#xA;&#xA;export interface ISortConfig&lt;T&gt; {&#xA;    column: keyof T;&#xA;    order?: keyof typeof EOrderBy;&#xA;    map?: itemMap;&#xA;}&#xA;&#xA;export const sortByValues = &lt;T extends object&gt;(&#xA;    columns: (keyof T | ISortConfig&lt;T&gt;)[]&#xA;): ((a: T, b: T) =&gt; 0 | 1 | -1) =&gt; {&#xA;    return function (a: T, b: T) {&#xA;        const firstKey: keyof T | ISortConfig&lt;T&gt; = columns[0];&#xA;        const isSimple = typeof firstKey === &quot;string&quot;;&#xA;        const key: keyof T = isSimple&#xA;            ? (firstKey as keyof T)&#xA;            : (firstKey as ISortConfig&lt;T&gt;).column;&#xA;        const reverse: boolean = isSimple&#xA;            ? false&#xA;            : (firstKey as ISortConfig&lt;T&gt;).order&#xA;            ? (firstKey as ISortConfig&lt;T&gt;).order?.toUpperCase() === &quot;ASC&quot;&#xA;                ? false&#xA;                : true&#xA;            : false;&#xA;        const map: itemMap | null = isSimple&#xA;            ? null&#xA;            : (firstKey as ISortConfig&lt;T&gt;).map || null;&#xA;&#xA;        const valA = map ? map(a[key]) : a[key];&#xA;        const valB = map ? map(b[key]) : b[key];&#xA;        if (valA === valB) {&#xA;            if (columns.length === 1) {&#xA;                return 0;&#xA;            }&#xA;            return sortByValues&lt;T&gt;(columns.slice(1))(a, b);&#xA;        }&#xA;        if (reverse) {&#xA;            return valA &gt; valB ? -1 : 1;&#xA;        }&#xA;        return valA &gt; valB ? 1 : -1;&#xA;    };&#xA;};&#xA;&#xA;export const sortArray = &lt;T extends object&gt;(&#xA;    array: T[],&#xA;    columns: (keyof T | ISortConfig&lt;T&gt;)[]&#xA;) =&gt; {&#xA;    return array.sort(sortByValues&lt;T&gt;(columns));&#xA;};&#xA;</code></pre>&#xA;<p><strong>example of usage:</strong></p>&#xA;<pre><code>interface IObj {&#xA;    name: string;&#xA;    prenom: string;&#xA;    montant: number;&#xA;}&#xA;&#xA;const arrobj: IObj[] = [&#xA;    {&#xA;        name: &quot;al&quot;,&#xA;        prenom: &quot;jero&quot;,&#xA;        montant: 10,&#xA;    },&#xA;    {&#xA;        name: &quot;al&quot;,&#xA;        prenom: &quot;ale&quot;,&#xA;        montant: 100,&#xA;    },&#xA;    {&#xA;        name: &quot;zozo&quot;,&#xA;        prenom: &quot;aa&quot;,&#xA;        montant: 10,&#xA;    },&#xA;];&#xA;&#xA;//simple order &#xA;console.log(sortArray(arrobj, [{ column: &quot;prenom&quot;, order: &quot;ASC&quot; }]));&#xA;console.log(sortArray(arrobj, [{ column: &quot;montant&quot;, order: &quot;DESC&quot; }]));&#xA;&#xA;&#xA;//order by several properties (montant DESC then name ASC)&#xA;console.log(&#xA;    sortArray(arrobj, [&#xA;        { column: &quot;montant&quot;, order: &quot;DESC&quot; },&#xA;        { column: &quot;name&quot;, order: &quot;ASC&quot; },&#xA;    ])&#xA;);&#xA;&#xA;// preparing the orderBy parameter in a variable then send it to the function&#xA;const orderBy: IOrderBy&lt;IObj&gt;[] = [&#xA;    { column: &quot;name&quot;, order: EOrderBy.DESC },&#xA;    { column: &quot;prenom&quot;, order: EOrderBy.DESC },&#xA;];&#xA;&#xA;console.log(sortArray(arrobj, orderBy));&#xA;</code></pre>&#xA;",9168390,,9168390,2020-08-10 19:44:57,2020-08-10 19:44:57,"",,0,0,0,2020-08-10 19:39:40
63347235,2,,63340253,1,,"<p>[EDITED]</p>&#xA;<p>If you moved the <code>order</code> property into the <code>Thread</code> nodes (which should be valid if each <code>Thread</code> node is connected to only a single <code>Forum</code>), then you can create an <a href=""https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance"" rel=""nofollow noreferrer"">index</a> (or <a href=""https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-schema-constraints"" rel=""nofollow noreferrer"">uniqueness constraint</a>) on <code>:Thread(order)</code> to speed up your query.</p>&#xA;<p>For example, this query should leverage the index to paginate forward faster (assuming that the <code>f.id</code>, the <code>order</code> value to use for pagination purposes, and <code>limit</code> value are passed as the <a href=""https://neo4j.com/docs/cypher-manual/current/syntax/parameters/"" rel=""nofollow noreferrer"">parameters</a> <code>id</code>, <code>order</code>, and <code>limit</code>):</p>&#xA;<pre><code>MATCH (f:Forum)-[:CONTAINS]-&gt;(t:Thread)&#xA;WHERE f.id = $id AND t.order &gt; $order&#xA;WITH f, t&#xA;ORDER BY t.order&#xA;LIMIT $limit&#xA;RETURN f{.id, .name, .URL,&#xA;  firstOrder: MIN(t.order),&#xA;  lastOrder: MAX(t.order),&#xA;  threads: [x IN COLLECT(t) | x{.id, .title, .URL}]}&#xA;</code></pre>&#xA;<p>And here is a (slightly more complex, but also fast) query for backwards pagination:</p>&#xA;<pre><code>MATCH (f:Forum)-[:CONTAINS]-&gt;(t:Thread)&#xA;WHERE f.id = $id AND t.order &lt; $order&#xA;WITH f, t&#xA;ORDER BY t.order DESC&#xA;LIMIT $limit&#xA;WITH f, t&#xA;ORDER BY t.order&#xA;RETURN f{.id, .name, .URL,&#xA;  firstOrder: MIN(t.order),&#xA;  lastOrder: MAX(t.order),&#xA;  threads: [x IN COLLECT(t) | x{.id, .title, .URL}]}&#xA;</code></pre>&#xA;<p>If you analyze the <a href=""https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/"" rel=""nofollow noreferrer"">PROFILE</a> of the above queries with various <code>$limit</code> values, you should see that the db-hit complexity is <code>O(F*L)</code>, where <code>F</code> is the number of <code>Forum</code> nodes (which is probably relatively constant) and <code>L</code> is the <code>$limit</code> value. So, these queries should be significantly faster -- with the index -- as long as:</p>&#xA;<pre><code>F*L &lt;&lt; (average number of `Threads` per `Forum`).&#xA;</code></pre>&#xA;",974731,,974731,2020-08-12 17:06:05,2020-08-12 17:06:05,"",,0,7,0,2020-08-10 20:02:55
63354421,2,,63353312,3,,"<p>You can only pass variables to GraphQL query via context since string interpolation doesn't work in that way. In <a href=""https://www.gatsbyjs.org/docs/page-query/#how-to-add-query-variables-to-a-page-query"" rel=""nofollow noreferrer"">page query</a> (rather than static queries) you can pass a variable using the <code>context</code> object as an argument of <a href=""https://www.gatsbyjs.org/docs/actions/#createPage"" rel=""nofollow noreferrer""><code>createPage</code> API</a>. So, you'll need to add this page creation to your <code>gatsby-node.js</code> and use something like:</p>&#xA;<pre><code>const limit = 10;&#xA;&#xA;page.forEach(({ node }, index) =&gt; {&#xA;  createPage({&#xA;    path: node.fields.slug,&#xA;    component: path.resolve(`./src/pages/index.js`), // your index path&#xA;    // values in the context object are passed in as variables to page queries&#xA;    context: {&#xA;      limit: limit,&#xA;    },&#xA;  })&#xA;})&#xA;</code></pre>&#xA;<p>Now, you have in your <code>context</code> object a <code>limit</code> value with all the required logic behind (now it's a simple number but you can add there some calculations). In your <code>index.js</code>:</p>&#xA;<pre><code>query yourQuery($limit: String) {&#xA;    allMarkdownRemark(limit: $limit, sort: { fields: [frontmatter___date], order: DESC }) {&#xA;      totalCount&#xA;      edges {&#xA;        node {&#xA;          ...&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",5585371,,5585371,2020-08-11 08:41:57,2020-08-11 08:41:57,"",,0,0,0,2020-08-11 08:30:57
63355021,2,,62508371,0,,"<p>You have to add ConnectionKey for paginated records while querying data</p>&#xA;<p>refer this</p>&#xA;<p><a href=""https://relay.dev/docs/en/pagination-container.html#connection"" rel=""nofollow noreferrer"">https://relay.dev/docs/en/pagination-container.html#connection</a>, on how to add connection while querying.</p>&#xA;<p>And after that when when you want to delete using nodeId, you have to use connectionHandler from 'relay-runtime':</p>&#xA;<p><a href=""https://relay.dev/docs/en/relay-store#connectionhandler"" rel=""nofollow noreferrer"">https://relay.dev/docs/en/relay-store#connectionhandler</a></p>&#xA;",8343414,,,,2020-08-11 09:06:16,"",,0,0,0,2020-08-11 09:06:16
63480328,1,,,1,280,"<p>I have an AppSync graphql schema with Users and Events, that should have a bi-directional connection.  My schema looks like this:</p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  email: String&#xA;  events: [EventUser] @connection(name: &quot;EventUser&quot;, keyName: &quot;byUser&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type Event @model {&#xA;  id: ID!&#xA;  name: String&#xA;  description: String&#xA;  registeredUsers: [EventUser] @connection(name: &quot;EventUser&quot;, keyName: &quot;byEvent&quot;, fields: [&quot;id&quot;])&#xA;  invitedUsers: [User]&#xA;}&#xA;&#xA;type EventUser&#xA;  @model(queries: null)&#xA;  @key(name: &quot;byEvent&quot;, fields: [&quot;eventId&quot;, &quot;userId&quot;])&#xA;  @key(name: &quot;byUser&quot;, fields: [&quot;userId&quot;, &quot;eventId&quot;]) {&#xA;  id: ID!&#xA;  eventId: ID!&#xA;  userId: ID!&#xA;  event: Event! @connection(fields: [&quot;eventId&quot;])&#xA;  user: User! @connection(fields: [&quot;userId&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>The query that is generated by the CLI looks like this:</p>&#xA;<pre><code>export const listEvents = /* GraphQL */ `&#xA;  query ListEvents(&#xA;    $filter: ModelEventFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listEvents(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        description&#xA;        registeredUsers {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>When I run this query with:</p>&#xA;<pre><code>const result = await API.graphql(graphqlOperation(queries.listEvents, { limit: 10}))&#xA;</code></pre>&#xA;<p>I get these results:</p>&#xA;<pre><code>[&#xA;  {&#xA;    &quot;createdAt&quot;: &quot;2020-08-17T21:36:04.502Z&quot;,&#xA;    &quot;description&quot;: &quot;Event description&quot;,&#xA;    &quot;id&quot;: &quot;some-unique-id&quot;,&#xA;    &quot;name&quot;: &quot;Event name&quot;,&#xA;    &quot;registeredUsers&quot;: Object {&#xA;      &quot;nextToken&quot;: null,&#xA;    },&#xA;    &quot;updatedAt&quot;: &quot;2020-08-17T21:36:04.502Z&quot;,&#xA;  },&#xA;  {&#xA;     &quot;createdAt&quot;: &quot;2020-08-17T21:36:04.502Z&quot;,&#xA;     &quot;id&quot;: &quot;some-other-unique-id&quot;,&#xA;     &quot;name&quot;: &quot;event 2 name&quot;,&#xA;     &quot;registeredUsers&quot;: Object {&#xA;       &quot;nextToken&quot;: null,                  // &lt;- This seems wrong.&#xA;     },&#xA;     &quot;updatedAt&quot;: &quot;2020-08-17T21:36:04.502Z&quot;&#xA;  }&#xA;]&#xA;</code></pre>&#xA;<p>The <code>registeredUsers</code> field should be an array of items. I can run a query in the AppSync console like this:</p>&#xA;<pre><code>query ListEvents {&#xA;  listEvents( limit: 10) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      registeredUsers {&#xA;        items {&#xA;          userId&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>and it returns correct results:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;listEvents&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;id&quot;: &quot;some-unique-id&quot;,&#xA;          &quot;name&quot;: &quot;event name&quot;,&#xA;          &quot;registeredUsers&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;userId&quot;: &quot;user&quot;&#xA;              },&#xA;              {&#xA;                &quot;userId&quot;: &quot;user1&quot;&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;some-other-unique-id&quot;,&#xA;          &quot;name&quot;: &quot;event 2 name&quot;,&#xA;          &quot;registeredUsers&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        },&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Obviously, the console query is slightly different but it produces correct results, although it does not handle <code>nextToken</code> pagination.</p>&#xA;<p>My question is this: Is the CLI-generated query invalid? If so, is it because my Schema is not set up correctly?&#xA;If the generated query is valid, how would I call it to get the <code>EventUser</code> data?</p>&#xA;",6916944,,6916944,2020-08-19 17:26:47,2020-08-19 17:26:47,AppSync graphql query not returning expected data,<graphql><aws-amplify><aws-appsync><aws-amplify-cli>,0,0,0,2020-08-19 05:07:42
63508542,1,,,2,349,"<p>I'm building a Gatsby site (v2.24.47) where I pull data from a CSV file with information about pages in a book. This is loaded using <code>gatsby-transformer-csv</code>, and I use custom schema to ensure that the column <code>page_num</code> is transformed into a <code>Int</code>-type field. But it seems as if Gatsby is ordering the field <em>alphabetically</em> rather than <em>numerically</em>. For example, if I query all pages after, say, page 12, it includes page 8 and 9, and indeed just sorting the pages also returns them in alphabetic order. I need the pages to be sorted numerically. Is there a way to do so?</p>&#xA;<p>Any help would be much appreciated. I've included a minimal example below.</p>&#xA;<hr />&#xA;<p><strong>gatsby-config.js</strong></p>&#xA;<pre class=""lang-js prettyprint-override""><code>module.exports = {&#xA;  plugins: [&#xA;    {&#xA;      resolve: `gatsby-source-filesystem`,&#xA;      options: {&#xA;        path: `${__dirname}/data/`,&#xA;      }&#xA;    },&#xA;    `gatsby-transformer-csv`&#xA;  ],&#xA;}&#xA;</code></pre>&#xA;<p><strong>gatsby-node.js</strong></p>&#xA;<pre class=""lang-js prettyprint-override""><code>exports.createSchemaCustomization = ({ actions, schema }) =&gt; {&#xA;    const { createTypes } = actions&#xA;    createTypes(`&#xA;        type PagesCsv implements Node @dontInfer {&#xA;            page_num: Int&#xA;        }&#xA;    `)&#xA;}&#xA;</code></pre>&#xA;<p><strong>data/pages.csv</strong></p>&#xA;<pre><code>page_num&#xA;8&#xA;9&#xA;10&#xA;11&#xA;12&#xA;13&#xA;14&#xA;</code></pre>&#xA;<p><strong>GraphQL query</strong> (in GraphiQL)</p>&#xA;<pre><code>query MyQuery {&#xA;  allPagesCsv(filter: {page_num: {gt: 12}}) {&#xA;    nodes {&#xA;      page_num&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>returns</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;allPagesCsv&quot;: {&#xA;      &quot;nodes&quot;: [&#xA;        {&#xA;          &quot;page_num&quot;: 8&#xA;        },&#xA;        {&#xA;          &quot;page_num&quot;: 9&#xA;        },&#xA;        {&#xA;          &quot;page_num&quot;: 13&#xA;        },&#xA;        {&#xA;          &quot;page_num&quot;: 14&#xA;        }&#xA;      ]&#xA;    }&#xA;  },&#xA;  &quot;extensions&quot;: {}&#xA;}&#xA;</code></pre>&#xA;<p>Similarly, querying <code>allPagesCsv(sort: {fields: page_num})</code> returns the pages in alphabetic order 10, 11, 12, 13, 14, 8, 9.</p>&#xA;",14137617,,,,2020-08-20 15:35:53,How can Gatsby/GraphQL sort an integer field numerically rather than alphabetically?,<graphql><gatsby>,0,0,0,2020-08-20 15:35:53
63515435,1,63516778,,1,206,"<p>I am a beginner in Gatsby.js, I am developing a page with a dropdown of 12 months. Once user select the month, I will pass the value into a component, which will display different set of result based on month selected.</p>&#xA;<p>There is a graphql query to retrieve data by using useStaticQuery in my component.</p>&#xA;<p>I understand the useStaticQuery cannot accept any variable, so is it possible to filter the returned data and create another data set based on the month inputted? Or should I just create 12 components and display the correspondning one based on month selected?</p>&#xA;<p>(Actually I tried to loop the data and return a single aggregate value successfully, but I not sure if it is possible to return a subset of data result</p>&#xA;<pre><code>data.allData.edges.forEach(edge =&gt; {&#xA;    if(edge.node.month==inputMonth)&#xA;        total=total+edge.node.amount&#xA;})&#xA;outValue= total&#xA;</code></pre>&#xA;<p>)</p>&#xA;",679225,,,,2020-08-21 05:01:00,Can I apply filter to data result of useStaticQuery in Gatsby.js,<graphql><gatsby>,1,0,0,2020-08-21 01:56:24
63516778,2,,63515435,2,,"<p>I think you are trying to use a <a href=""https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/find"" rel=""nofollow noreferrer""><code>find()</code></a> loop. In your case:</p>&#xA;<pre><code>let matchedMonth = data.allData.edges.find(edge =&gt; edge.node.month === inputMonth)&#xA;</code></pre>&#xA;<p>Basically, you are looping through <code>allData</code> (all months) to find which one is exactly equal to <code>inputMonth</code>. Since you are saving it in <code>matchedMonth</code> you can play whatever you want (passing to a component, etc).</p>&#xA;",5585371,,,,2020-08-21 05:01:00,"",,0,1,0,2020-08-21 05:01:00
63532362,1,63561433,,1,203,"<p>I have modeled this:</p>&#xA;<pre><code>type FreightDriver&#xA;  @model&#xA;  @key(&#xA;    name: &quot;byCityByState&quot;&#xA;    fields: [&quot;state&quot;, &quot;city&quot;]&#xA;    queryField: &quot;freightDriversByStateByCity&quot;&#xA;  ) {&#xA;  id: ID!&#xA;  name: String!&#xA;  state: String!&#xA;  city: String!&#xA;  trucks: [Truck] @connection(keyName: &quot;byFreightDriver&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type Truck&#xA;  @model&#xA;  @key(name: &quot;byFreightDriver&quot;, fields: [&quot;freightDriverId&quot;, &quot;tons&quot;]) {&#xA;  id: ID!&#xA;  freightDriverId: ID!&#xA;  boxId: ID!&#xA;  brand: String!&#xA;  model: String!&#xA;  tons: Float!&#xA;  box: Box @connection(fields: [&quot;boxId&quot;])&#xA;}&#xA;&#xA;type Box @model {&#xA;  id: ID!&#xA;  type: String!&#xA;  width: Float!&#xA;  height: Float!&#xA;  depth: Float!&#xA;}&#xA;</code></pre>&#xA;<p>And I'm querying the data like this:</p>&#xA;<pre><code>query {&#xA;  freightDriversByStateByCity(state: &quot;Jalisco&quot;, city: { eq: &quot;Guadalajara&quot; }) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      city&#xA;      state&#xA;      trucks(tons: { eq: 12 }) {&#xA;        items {&#xA;          brand&#xA;          model&#xA;          box {&#xA;            type&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And I'm getting as a response this:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;freightDriversByStateByCity&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;id&quot;: &quot;aebb6696-573d-41ed-894e-22b69264cace&quot;,&#xA;          &quot;name&quot;: &quot;Diey&quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;brand&quot;: &quot;chevrolet&quot;,&#xA;                &quot;model&quot;: &quot;12&quot;,&#xA;                &quot;box&quot;: {&#xA;                  &quot;type&quot;: &quot;Refrigerada&quot;&#xA;                }&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;6e8e6772-61e7-47d6-b134-d615a3c65f62&quot;,&#xA;          &quot;name&quot;: &quot;Roberto Mendez&quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;d314808c-64e7-421d-b83b-008177ab6b25&quot;,&#xA;          &quot;name&quot;: &quot;Roberto Mendez&quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;19847d0c-185c-48f6-9e5c-435e3907133a&quot;,&#xA;          &quot;name&quot;: &quot;Andrés&quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;brand&quot;: &quot;chevrolet&quot;,&#xA;                &quot;model&quot;: &quot;1234&quot;,&#xA;                &quot;box&quot;: {&#xA;                  &quot;type&quot;: &quot;Refrigerada&quot;&#xA;                }&#xA;              },&#xA;              {&#xA;                &quot;brand&quot;: &quot;chevrolet&quot;,&#xA;                &quot;model&quot;: &quot;1234&quot;,&#xA;                &quot;box&quot;: {&#xA;                  &quot;type&quot;: &quot;Grúa&quot;&#xA;                }&#xA;              },&#xA;              {&#xA;                &quot;brand&quot;: &quot;chevrolet&quot;,&#xA;                &quot;model&quot;: &quot;12&quot;,&#xA;                &quot;box&quot;: {&#xA;                  &quot;type&quot;: &quot;Refrigerada&quot;&#xA;                }&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;2c4c9e3a-bfe5-4d4e-bee7-3eddb1b8ef1b&quot;,&#xA;          &quot;name&quot;: &quot;Roberto Mendez &quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;cb4eb22c-aa54-416e-aecc-305a18bc9c83&quot;,&#xA;          &quot;name&quot;: &quot;Roberto Mendez&quot;,&#xA;          &quot;city&quot;: &quot;Guadalajara&quot;,&#xA;          &quot;state&quot;: &quot;Jalisco&quot;,&#xA;          &quot;trucks&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>If you check, there are some with this:</p>&#xA;<pre><code>&quot;trucks&quot;: {&#xA;  &quot;items&quot;: []&#xA;}&#xA;</code></pre>&#xA;<p>How can I avoid them? Is my model wrongly model? Thank you!</p>&#xA;",8341544,,1806763,2020-08-23 15:19:53,2020-08-24 12:51:36,Filter one to many exact data in appsync graphql,<amazon-web-services><graphql><amazon-dynamodb><aws-amplify><aws-appsync>,1,0,0,2020-08-22 03:43:16
63542015,2,,63461349,1,,"<p>It turns out I was neglecting to use the <code>nextToken</code> in the payload. the query will only look at 10 elements at a time by default so it's the dev's responsiblity to continue querying until they have enough matching results</p>&#xA;<p>Example of method to use <code>nextToken</code>:</p>&#xA;<pre><code>/**&#xA; * @desc Recursively fetch all items in a list query using nextToken&#xA; * @param {Object} query The query object from cda-graphql in use.&#xA; * @param {Object} variables The variables to pass to query.&#xA; * @returns {Array} Array of all items received from queries.&#xA; */&#xA;import { API, graphqlOperation } from 'aws-amplify';&#xA;&#xA;async function fetchItemsNextToken({ query, variables, limit}) {&#xA;    const results = [];&#xA;    while (results.length &lt; limit) {&#xA;        const { data } = await API.graphql(graphqlOperation(query, variables));&#xA;        const key = Object.keys(data).find(k =&gt; k.includes('list'));&#xA;        const res = data[key]; // res = { items: [], nextToken: '' }&#xA;&#xA;        results.push(...res.items);&#xA;        if (!res.nextToken) break;&#xA;&#xA;        // eslint-disable-next-line no-param-reassign&#xA;        variables.nextToken = res.nextToken;&#xA;    }&#xA;    return new Promise((resolve, reject) =&gt; {&#xA;        resolve(results);&#xA;    });&#xA;}&#xA;&#xA;export default fetchItemsNextToken;&#xA;</code></pre>&#xA;",2860182,,,,2020-08-22 23:24:07,"",,0,0,0,2020-08-22 23:24:07
63544137,2,,62120967,3,,"<p>I managed to find the solution:</p>&#xA;<pre><code>extend type Query {&#xA;    products(captionId: ID, subFieldId: ID, q: String): [Product]&#xA;    @paginate(type: &quot;paginator&quot; defaultCount: 10 maxCount: 100&#xA;        builder: &quot;App\\GraphQL\\Queries\\ProductComplex@index&quot;)&#xA;}&#xA;</code></pre>&#xA;<p>Just nedded to use <code>builder</code> inside <code>paginate</code> directive.</p>&#xA;",11671686,,11671686,2022-10-15 13:54:15,2022-10-15 13:54:15,"",,0,0,0,2020-08-23 06:41:43
63581653,1,,,2,2726,"<p>I have a question about MongoDB ISODate type and GraphQL. I need to declare a <code>mutation</code> in my gql schema that allows to add a document in my Mongo database.</p>&#xA;<p>This document has an ISODate property, but in my gql schema, I'am using a <code>String</code> :</p>&#xA;<pre><code>mutation addSomething(data: SomeInput)&#xA;&#xA;type SomeInput {&#xA;    field1: String&#xA;    field2: Int&#xA;    created: String&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>My problem is that, in the new document, the <code>created</code> field is in String format (not ISODate), and I was expecting that. But I wonder how to do to make it insert an ISODate instead. Is there a &quot;custom type&quot; somewhere I could use instead a String ?</p>&#xA;<p>Thank you</p>&#xA;<p>PS: I'am using nodeJS and apollo libraries.</p>&#xA;<h2>Edit 1 : Trying with the graphql-iso-date package</h2>&#xA;<p>I have found this package <a href=""https://www.npmjs.com/package/graphql-iso-date"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/graphql-iso-date</a> that adds 3 date custom types.</p>&#xA;<p>Here is my gql schema :</p>&#xA;<pre><code>const { gql } = require('apollo-server');&#xA;const { GraphQLDateTime } = require('graphql-iso-date')&#xA;&#xA;const typeDefs = gql`&#xA;&#xA;scalar GraphQLDateTime&#xA;&#xA;type Resto {&#xA;    restaurant_id: ID!&#xA;    borough: String&#xA;    cuisine: String&#xA;    name: String&#xA;    address: Address&#xA;    grades: [Grade]&#xA;}&#xA;&#xA;type Address {&#xA;    building: String&#xA;    street: String&#xA;    zipcode: String&#xA;    coord: [Float]&#xA;}&#xA;&#xA;type Grade {&#xA;    date: GraphQLDateTime&#xA;    grade: String&#xA;    score: Int&#xA;}&#xA;&#xA;input GradeInput {&#xA;    date: GraphQLDateTime&#xA;    grade: String&#xA;    score: Int&#xA;}&#xA;&#xA;extend type Query {&#xA;    GetRestos: [Resto]&#xA;    GetRestoById(id: ID!): Resto&#xA;}&#xA;&#xA;extend type Mutation {&#xA;    UpdateGradeById(grade: GradeInput!, id: ID!): Resto&#xA;    RemoveGradeByIdAndDate(date: String, id: ID!): Resto&#xA;}&#xA;&#xA;`&#xA;&#xA;module.exports = typeDefs;&#xA;</code></pre>&#xA;<p>This is a test based on the <a href=""https://docs.atlas.mongodb.com/sample-data/sample-restaurants/"" rel=""nofollow noreferrer"">sample restaurants dataset</a>.</p>&#xA;<p>So, if I try to call the <code>UpdateGradeById()</code> function like this :</p>&#xA;<pre><code>UpdateGradeById(grade:{date:&quot;2020-08-25T08:00:00.000Z&quot;,grade:&quot;D&quot;,score:15},id:&quot;30075445&quot;){...}&#xA;</code></pre>&#xA;<p>The document is updated but the date is always in String format (as you can see on the screenshot bellow) :</p>&#xA;<p><a href=""https://i.stack.imgur.com/m3w1R.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m3w1R.png"" alt=""enter image description here"" /></a></p>&#xA;<p>The date of the last grade in the list is recognized as a string (not as a date).</p>&#xA;<p>I can see an improvement though because before I was using the <code>graphql-iso-date</code> date fields were returned in timestamp format. Now they are returned as ISO string. But the insertion does not work as expected.</p>&#xA;",1508466,,1508466,2020-08-26 09:12:04,2020-08-26 12:24:56,"MongoDB, GraphQL and ISODate type",<mongodb><graphql>,1,6,0,2020-08-25 14:57:32
63597635,2,,63581653,3,,"<p>Ok, I missed to do something important in my previous example : resolvers.&#xA;So, if like me you want to manipulate MongoDB date type through GraphQL, you can use the <code>graphql-iso-date</code> package like this :</p>&#xA;<p>First, modify your schema by adding a new scalar :</p>&#xA;<pre><code>const { gql } = require('apollo-server');&#xA;&#xA;const typeDefs = gql`&#xA;&#xA;scalar ISODate&#xA;&#xA;type Resto {&#xA;    restaurant_id: ID!&#xA;    borough: String&#xA;    cuisine: String&#xA;    name: String&#xA;    address: Address&#xA;    grades: [Grade]&#xA;}&#xA;&#xA;type Address {&#xA;    building: String&#xA;    street: String&#xA;    zipcode: String&#xA;    coord: [Float]&#xA;}&#xA;&#xA;type Grade {&#xA;    date: ISODate&#xA;    grade: String&#xA;    score: Int&#xA;}&#xA;&#xA;input GradeInput {&#xA;    date: ISODate&#xA;    grade: String&#xA;    score: Int&#xA;}&#xA;&#xA;extend type Query {&#xA;    GetRestos: [Resto]&#xA;    GetRestoById(id: ID!): Resto&#xA;}&#xA;&#xA;extend type Mutation {&#xA;    UpdateGradeById(grade: GradeInput!, id: ID!): Resto&#xA;    RemoveGradeByIdAndDate(date: ISODate!, id: ID!): Resto&#xA;}&#xA;&#xA;`&#xA;&#xA;module.exports = typeDefs;&#xA;</code></pre>&#xA;<p>(Here I choose to call my custom date scalar <em>ISODate</em>)</p>&#xA;<p>Then, you have to tell how to &quot;resolve&quot; this new ISODate scalar by modifying you resolvers file :</p>&#xA;<pre><code>const { GraphQLDateTime } = require('graphql-iso-date')&#xA;&#xA;module.exports = {&#xA;    Query: { &#xA;        GetRestos: (_, __, { dataSources }) =&gt;&#xA;            dataSources.RestoAPI.getRestos(),&#xA;&#xA;        GetRestoById: (_, {id}, { dataSources }) =&gt;&#xA;            dataSources.RestoAPI.getRestoById(id),&#xA;&#xA;    },&#xA;    Mutation: {&#xA;        UpdateGradeById: (_, {grade,id}, { dataSources }) =&gt;&#xA;            dataSources.RestoAPI.updateGradeById(grade,id),&#xA;&#xA;        RemoveGradeByIdAndDate: (_, {date,id}, { dataSources }) =&gt;&#xA;            dataSources.RestoAPI.removeGradeByIdAndDate(date,id),&#xA;        &#xA;    },&#xA;    ISODate: GraphQLDateTime&#xA;&#xA;  };&#xA;</code></pre>&#xA;<p>And that's it. Now, date properties in my mongodb documents are well recognized as Date type values.</p>&#xA;<p><a href=""https://i.stack.imgur.com/BKc9P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BKc9P.png"" alt=""enter image description here"" /></a></p>&#xA;",1508466,,,,2020-08-26 12:24:56,"",,0,0,0,2020-08-26 12:24:56
63609167,2,,63434541,3,,"<p>This is Gatsby and currently it is not possible because you can’t pass in variables to queries follow this GH issue <a href=""https://github.com/gatsbyjs/gatsby/issues/10482"" rel=""nofollow noreferrer"">https://github.com/gatsbyjs/gatsby/issues/10482</a></p>&#xA;<p>Supposing that passing variables was possible, I would make all characters as a page query that will allow me to restructure the name from props and then a static query to which I would pass in the name as filter.</p>&#xA;",11321732,,,,2020-08-27 04:24:52,"",,0,5,0,2020-08-27 04:24:52
63615462,1,,,0,149,"<p>I am using <a href=""https://devdocs.magento.com/guides/v2.4/graphql/index.html"" rel=""nofollow noreferrer"">Magento GraphQL</a> api in my project. To create a customer address I used <code>createCustomerAddress</code> mutation(<a href=""https://devdocs.magento.com/guides/v2.4/graphql/mutations/create-customer-address.html"" rel=""nofollow noreferrer"">createCustomerAddress</a>).</p>&#xA;<p>Below is the mutation that I have called to create the customer address :</p>&#xA;<pre><code>mutation createAddress {&#xA;  createCustomerAddress(&#xA;    input: {&#xA;      firstname: &quot;test&quot;&#xA;      lastname: &quot;name&quot;&#xA;      company: &quot;networld&quot;&#xA;      telephone: &quot;1231231231&quot;&#xA;      street: [&quot;test address line 1&quot;, &quot;test address line 2&quot;]&#xA;      city: &quot;Rajkot&quot;&#xA;      region: { region:&quot;Gujarat&quot;, region_code: &quot;GJ&quot; }&#xA;      postcode: &quot;360001&quot;&#xA;      country_code: IN&#xA;    }&#xA;  ) {&#xA;    id&#xA;    prefix&#xA;    firstname&#xA;    lastname&#xA;    middlename&#xA;    city&#xA;    company&#xA;    country_code&#xA;    default_billing&#xA;    default_shipping&#xA;    postcode&#xA;    region {&#xA;      region&#xA;      region_code&#xA;    }&#xA;    street&#xA;    suffix&#xA;    telephone&#xA;    vat_id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is working properly and returning me the result as below :</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;createCustomerAddress&quot;: {&#xA;      &quot;id&quot;: 44,&#xA;      &quot;prefix&quot;: null,&#xA;      &quot;firstname&quot;: &quot;test&quot;,&#xA;      &quot;lastname&quot;: &quot;name&quot;,&#xA;      &quot;middlename&quot;: null,&#xA;      &quot;city&quot;: &quot;Rajkot&quot;,&#xA;      &quot;company&quot;: &quot;networld&quot;,&#xA;      &quot;country_code&quot;: &quot;IN&quot;,&#xA;      &quot;default_billing&quot;: false,&#xA;      &quot;default_shipping&quot;: false,&#xA;      &quot;postcode&quot;: &quot;360001&quot;,&#xA;      &quot;region&quot;: {&#xA;        &quot;region&quot;: &quot;Gujarat&quot;,&#xA;        &quot;region_code&quot;: &quot;GJ&quot;&#xA;      },&#xA;      &quot;street&quot;: [&#xA;        &quot;test address line 1&quot;,&#xA;        &quot;test address line 2&quot;&#xA;      ],&#xA;      &quot;suffix&quot;: null,&#xA;      &quot;telephone&quot;: &quot;1231231231&quot;,&#xA;      &quot;vat_id&quot;: null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But, now when I query to get the customer address, it returning wrong <code>region_code</code>.</p>&#xA;<p>Here is the query I written to get the customer address :</p>&#xA;<pre><code>query{&#xA;  customer{&#xA;    addresses{&#xA;      id&#xA;      firstname&#xA;      lastname&#xA;      street&#xA;      city&#xA;      region{&#xA;        region&#xA;        region_code&#xA;      }&#xA;      country_code&#xA;      postcode&#xA;      telephone&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Result :</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;customer&quot;: {&#xA;      &quot;addresses&quot;: [&#xA;        {&#xA;          &quot;id&quot;: 44,&#xA;          &quot;firstname&quot;: &quot;test&quot;,&#xA;          &quot;lastname&quot;: &quot;name&quot;,&#xA;          &quot;street&quot;: [&#xA;            &quot;test address line 1&quot;,&#xA;            &quot;test address line 2&quot;&#xA;          ],&#xA;          &quot;city&quot;: &quot;Rajkot&quot;,&#xA;          &quot;region&quot;: {&#xA;            &quot;region&quot;: &quot;Gujarat&quot;,&#xA;            &quot;region_code&quot;: &quot;Gujarat&quot;&#xA;          },&#xA;          &quot;country_code&quot;: &quot;IN&quot;,&#xA;          &quot;postcode&quot;: &quot;360001&quot;,&#xA;          &quot;telephone&quot;: &quot;1231231231&quot;&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>As you can see, <code>region_code</code> in this query result and <code>region_code</code> in mutation result was different. Query not returning <code>region_code</code> that generated from the mutation. Mutation generated <code>region_code</code> was <strong>GJ</strong> and query returned <code>region_code</code> was <strong>Gujarat</strong>.</p>&#xA;<p>Can anyone help me why this is happening ? How to solve it ?</p>&#xA;",8182248,,,,2020-12-07 11:49:55,why region_code not storing properly?,<magento><graphql><magento2>,1,0,0,2020-08-27 11:56:01
63767695,1,,,0,282,"<p>I have a graphql api with bunch of filters and pagination available.</p>&#xA;<p>Is it possible to make Apollo filter already fetched results locally and only query the server if there are pages remaining?</p>&#xA;<p>For example, let us have Users with Name and Role filters, and 20 results per page.</p>&#xA;<p>We start with filtered query (name: Alice) and get 15 results. If we add a second filter (role: Admin) the app should do the filtering locally.</p>&#xA;<p>Or we start with (role: Admin) and get 50 results. Now we add a second filter (name: Alice) and the app should instantly filter whatever Alices were present at the first page, yet do the second query, and update the list once it's complete. Then if we remove the first filter, the app should do another query without local filtering at all, cause there may be non-Admin Alices ordered first.</p>&#xA;",13833888,,5437671,2020-09-06 18:46:32,2020-09-06 18:46:32,Apollo cache local filters and pagination,<graphql><apollo>,0,2,0,2020-09-06 18:43:13
63768753,2,,42782604,1,,"<p>Based on <strong>Method 2</strong> given by <a href=""https://stackoverflow.com/users/2030321/chris"">@Chris</a>,</p>&#xA;<p>This is my solution in VueJS, it's roughly the same for ReactJS as well.</p>&#xA;<pre><code>    loadPage(type) {&#xA;      const { endCursor } = this.pageInfo&#xA;      let cursor = null &#xA;      if(type === 'previous') {&#xA;        this.cursorStack = this.cursorStack.slice(0, this.cursorStack.length - 1)&#xA;        cursor = this.cursorStack[this.cursorStack.length - 1]&#xA;      }&#xA;      else {&#xA;        cursor = endCursor&#xA;        this.cursorStack = [...this.cursorStack, cursor]&#xA;      }&#xA;      this.fetchMore({&#xA;        variables: { cursor: cursor },&#xA;        updateQuery: (previousResult, { fetchMoreResult }) =&gt; {&#xA;          if (!fetchMoreResult) return previousResult&#xA;          return fetchMoreResult&#xA;        }&#xA;      })&#xA;    },&#xA;</code></pre>&#xA;<p>In template:</p>&#xA;<pre><code>&lt;button :disabled=&quot;!cursorStack.length&quot; @click=&quot;loadPage('previous')&quot; /&gt;&#xA;&lt;button :disabled=&quot;!pageInfo.hasNextPage&quot; @click=&quot;loadPage('next')&quot; /&gt;&#xA;</code></pre>&#xA;",2677993,,,,2020-09-06 20:46:22,"",,0,0,0,2020-09-06 20:46:22
63783811,2,,58734176,4,,"<p>Based on Bertrand Martel's answer (@bertrand-martel), do not forget to add the following code so that you are not stuck between 1st and 2nd pages. In other words, it will be going forward, and then backward; because there is initially only one <code>&lt;a&gt;</code> tag, whereas the next page has two of these, so it chooses 1st one (&quot;previous&quot;) and returns to the previous page.</p>&#xA;<p>Code:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>...&#xA;    paginationContainer = soup.find(&quot;div&quot;, {&quot;class&quot;:&quot;paginate-container&quot;}).find_all('a')&#xA;    if len(paginationContainer) &gt; 1:&#xA;        paginationContainer = paginationContainer[1]&#xA;    else:&#xA;        paginationContainer = paginationContainer[0]&#xA;...&#xA;</code></pre>&#xA;",5423850,,,,2020-09-07 20:25:38,"",,0,0,0,2020-09-07 20:25:38
63826169,1,,,0,192,"<p>GraphQL has en excellent spec available for cursor pagination (<a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">https://relay.dev/graphql/connections.htm</a> ), but is there any standard or convention about how to implement a more classic offset pagination, without &quot;connections&quot; ? How to name resolver arguments, how total count should be returned, which pagination metadata should be returned and how, how the resulting object should be structured etc</p>&#xA;<p>I saw a lot of different implementations and have no clue about the &quot;right&quot; way to do that, if there is any.</p>&#xA;",3652783,,,,2020-09-10 08:54:05,Is there any standard or convention about implementing offset pagination with GraphQL?,<pagination><graphql>,0,2,0,2020-09-10 08:54:05
63834534,2,,63814755,1,,"<p>You can exclude it in your query using the <strong>ne</strong> operator:</p>&#xA;<pre><code>query MyQuery {&#xA;  allDirectory(filter: {sourceInstanceName: {eq: &quot;dosbox&quot;}, name: { ne: &quot;dosbox&quot; }}) {&#xA;    edges {&#xA;      node {&#xA;        name&#xA;        dir&#xA;        modifiedTime&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1486810,,,,2020-09-10 17:09:42,"",,0,0,0,2020-09-10 17:09:42
63851449,2,,63849102,0,,"<p>The Contentful source plugin doesn't define arguments on any of the nodes it creates, unfortunately. Instead you would need to create these yourself. The easiest way to do that is through the <a href=""https://www.gatsbyjs.com/docs/node-apis/#createResolvers"" rel=""nofollow noreferrer""><code>createResolvers</code> API</a>.</p>&#xA;<p>Here's a similar example from a project of mine:</p>&#xA;<pre><code>// in gatsby-node.js&#xA;exports.createResolvers = ({ createResolvers }) =&gt; {&#xA;  createResolvers({&#xA;    SourceArticleCollection: {&#xA;      // Add articles from the selected section(s)&#xA;      articles: {&#xA;        type: [&quot;SourceArticle&quot;],&#xA;        args: {&#xA;          // here's where the `limit` argument is added&#xA;          limit: {&#xA;            type: &quot;Int&quot;,&#xA;          },&#xA;        },&#xA;        resolve: async (source, args, context, info) =&gt; {&#xA;          // this function just needs to return the data for the field;&#xA;          // in this case, I'm able to fetch a list of the top-level&#xA;          // entries that match a particular condition, but in your case&#xA;          // you might want to instead use the existing data in your&#xA;          // `source` and just slice it in JS.&#xA;          const articles = await context.nodeModel.runQuery({&#xA;            query: {&#xA;              filter: {&#xA;                category: {&#xA;                  section: {&#xA;                    id: {&#xA;                      in: source.sections.map((s) =&gt; s._ref),&#xA;                    },&#xA;                  },&#xA;                },&#xA;              },&#xA;            },&#xA;            type: &quot;SourceArticle&quot;,&#xA;          })&#xA;&#xA;          return (articles || []).slice(0, args.limit || source.limit || 20)&#xA;        },&#xA;      },&#xA;    },&#xA;  })&#xA;}&#xA;</code></pre>&#xA;<p>Because resolvers run as part of the data-fetching routines that support the GraphQL API, this will run server-side at build-time and only the truncated/prepared data will be sent down to the client at request time.</p>&#xA;",203130,,,,2020-09-11 17:06:19,"",,0,4,0,2020-09-11 17:06:19
63867606,1,63904529,,0,558,"<p><em>Some context:</em></p>&#xA;<p>My table has two columns, longitude and latitude.&#xA;I want to be able to create a query that can receive an input of a longitude, latitude and a number that represents the maximum number of kilometers distance.</p>&#xA;<p>The query will return the rows that are within that distance ordered by the resulting distance.</p>&#xA;<p>I have seen few options for custom conditions, but that might be pretty hacky...&#xA;I thought maybe there is a way to do it and use the build in <code>order by</code> that <code>PostGraphile</code> generates, but the I'm if there is a way to pass variable to the order by.</p>&#xA;<p><em>The question:</em></p>&#xA;<p>What is the best to do it in <code>PostGraphile</code>?</p>&#xA;<p>Thanks in advance!</p>&#xA;",8885009,,,,2020-09-15 14:56:28,Postgraphile order by result of calculation (with input),<postgresql><graphql><postgraphile>,1,0,0,2020-09-13 05:53:14
63902324,2,,54192483,5,,"<p>Based on Ben's answer, I tweaked a little the functions to allow a more versatile &quot;<em>filter</em>&quot; object:</p>&#xA;<pre><code>// enum&#xA;export enum Operator {&#xA;  AND = 'AND',&#xA;  OR = 'OR',&#xA;}&#xA;&#xA;// interfaces&#xA;interface FieldOptions {&#xA;  is?: string;&#xA;  not?: string;&#xA;  in?: string;&#xA;  not_in?: string;&#xA;  lt?: string;&#xA;  lte?: string;&#xA;  gt?: string;&#xA;  gte?: string;&#xA;  contains?: string;&#xA;  not_contains?: string;&#xA;  starts_with?: string;&#xA;  not_starts_with?: string;&#xA;  ends_with?: string;&#xA;  not_ends_with?: string;&#xA;}&#xA;&#xA;export interface Field {&#xA;  [key: string]: FieldOptions;&#xA;}&#xA;&#xA;export type Where = {&#xA;  [K in Operator]?: (Where | Field)[];&#xA;};&#xA;&#xA;// functions&#xA;export const filterQuery = &lt;T&gt;(query: SelectQueryBuilder&lt;T&gt;, where: Where) =&gt; {&#xA;  if (!where) {&#xA;    return query;&#xA;  } else {&#xA;    return traverseTree(query, where) as SelectQueryBuilder&lt;T&gt;;&#xA;  }&#xA;};&#xA;&#xA;const traverseTree = (query: WhereExpression, where: Where, upperOperator = Operator.AND) =&gt; {&#xA;  Object.keys(where).forEach((key) =&gt; {&#xA;    if (key === Operator.OR) {&#xA;      query = query.orWhere(buildNewBrackets(where, Operator.OR));&#xA;    } else if (key === Operator.AND) {&#xA;      query = query.andWhere(buildNewBrackets(where, Operator.AND));&#xA;    } else {&#xA;      // Field&#xA;      query = handleArgs(query, where as Field, upperOperator === Operator.AND ? 'andWhere' : 'orWhere');&#xA;    }&#xA;  });&#xA;&#xA;  return query;&#xA;};&#xA;&#xA;const buildNewBrackets = (where: Where, operator: Operator) =&gt; {&#xA;  return new Brackets((qb) =&gt;&#xA;    where[operator].map((queryArray) =&gt; {&#xA;      traverseTree(qb, queryArray, operator);&#xA;    }),&#xA;  );&#xA;};&#xA;&#xA;const handleArgs = (query: WhereExpression, field: Field, andOr: 'andWhere' | 'orWhere') =&gt; {&#xA;  ...&#xA;};&#xA;</code></pre>&#xA;<p>This way we now can have this kind of object as a query parameter:</p>&#xA;<pre><code>{&#xA;  AND: [&#xA;    {&#xA;      OR: [&#xA;        {&#xA;          name: {&#xA;            is: 'John'&#xA;          },&#xA;        },&#xA;        {&#xA;          surname: {&#xA;            is: 'Doe'&#xA;          },&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      AND: [&#xA;        {&#xA;          age: {&#xA;            gt: 30&#xA;          },&#xA;        },&#xA;        {&#xA;          type: {&#xA;            not: 'Employee'&#xA;          }&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      registered_date: {&#xA;        gte: '2000-01-01'&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>The resulting query would be:</p>&#xA;<pre><code>SELECT *&#xA;FROM users U &#xA;WHERE (U.name = 'John' OR U.surname = 'Doe') AND (U.age &gt; 30 AND U.type != 'Employee') AND U.registered_date &gt;= '2000-01-01';&#xA;</code></pre>&#xA;",9849073,,,,2020-09-15 12:55:56,"",,0,0,0,2020-09-15 12:55:56
63904529,2,,63867606,3,,"<p>To do this, step 1 is to build your filter object with your x, y and radius:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const { makePluginByCombiningPlugins, makeAddPgTableConditionPlugin } = require('graphile-utils');&#xA;&#xA;const PositionFilterObjectPlugin = builder =&gt; {&#xA;  builder.hook('build', build =&gt; {&#xA;    const nonNullFloat = new build.graphql.GraphQLNonNull(build.graphql.GraphQLFloat);&#xA;    const PositionFilter = new build.graphql.GraphQLInputObjectType({&#xA;      name: 'PositionFilter',&#xA;      fields: {&#xA;        x: {&#xA;          type: nonNullFloat,&#xA;        },&#xA;        y: {&#xA;          type: nonNullFloat,&#xA;        },&#xA;        radius: {&#xA;          type: nonNullFloat,&#xA;        },&#xA;      },&#xA;    });&#xA;    build.addType(PositionFilter);&#xA;&#xA;    return build;&#xA;  });&#xA;};&#xA;&#xA;/*&#xA;   Due to a plugin ordering issue that cannot be addressed in V4, we can't&#xA;   just use makeExtendSchemaPlugin to add this type; we have to write it&#xA;   out by hand in the build hook.&#xA;&#xA;   input PositionFilter {&#xA;     x: Float!&#xA;     y: Float!&#xA;     radius: Float!&#xA;   }&#xA;*/&#xA;</code></pre>&#xA;<p>(<code>build.graphql</code> is an instance of the <code>graphql</code> module, the reference GraphQL implementation, you can read more about it <a href=""https://graphql.org/graphql-js/type/"" rel=""nofollow noreferrer"">here</a> and <a href=""https://github.com/graphql/graphql-js"" rel=""nofollow noreferrer"">here</a>.)</p>&#xA;<p>Step 2 is to add a condition that <em>also</em> does ordering:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const PositionConditionPlugin = makeAddPgTableConditionPlugin(&#xA;  'public',&#xA;  'entities',&#xA;  'closeTo',&#xA;  build =&gt; ({&#xA;    type: build.getTypeByName('PositionFilter'),&#xA;  }),&#xA;  (value, { queryBuilder, sql, sqlTableAlias }) =&gt; {&#xA;    if (value == null) {&#xA;      return;&#xA;    }&#xA;&#xA;    const { x, y, radius } = value;&#xA;    const valX = sql.value(x);&#xA;    const valY = sql.value(x);&#xA;    const valR = sql.value(radius);&#xA;&#xA;    const distance = sql.fragment`(((${sqlTableAlias}.x - ${valX}) ^ 2 + (${sqlTableAlias}.y - ${valY}) ^ 2) ^ 0.5)`;&#xA;&#xA;    // Order the result set by the proximity of the entity to the given point&#xA;    queryBuilder.orderBy(&#xA;      distance,&#xA;      true, // Ascending&#xA;      false,&#xA;    );&#xA;&#xA;    // Filter to only entities within the given radius&#xA;    return sql.fragment`${distance} &lt; ${valR}`;&#xA;  },&#xA;);&#xA;</code></pre>&#xA;<p>Finally you either load both these plugins or if you prefer you can make a single plugin that encompasses both:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>module.exports = makePluginByCombiningPlugins(PositionFilterObjectPlugin, PositionConditionPlugin);&#xA;</code></pre>&#xA;<p>I've added an example with ordering to the docs:</p>&#xA;<p><a href=""https://www.graphile.org/postgraphile/make-add-pg-table-condition-plugin/#example-with-ordering"" rel=""nofollow noreferrer"">https://www.graphile.org/postgraphile/make-add-pg-table-condition-plugin/#example-with-ordering</a></p>&#xA;<p>NOTE: before graphile-utils 4.9.1 is released you'll need to add this plugin via <code>--prepend-plugins</code> (or <code>prependPlugins</code> for library users) because otherwise there's a plugin ordering issue that means that orders added by <code>makeAddPgTableConditionPlugin</code> come after the default orders.</p>&#xA;",141284,,,,2020-09-15 14:56:28,"",,0,0,0,2020-09-15 14:56:28
63917036,2,,63193046,1,,"<p>Too much [unguarded/unconditional] decomposition... stop at must exist node:</p>&#xA;<pre><code>const { data: { allContentfulPages: { edges }}} = result;&#xA;if( edges &amp;&amp; edges[0] ) {&#xA;  return {&#xA;    metaJson: JSON.parse(edges[0].node.meta.internal.content),&#xA;    opengraphJson: JSON.parse(edges[0].node.opengraph.internal.content)&#xA;  };&#xA;</code></pre>&#xA;",6124657,,,,2020-09-16 09:26:20,"",,0,0,0,2020-09-16 09:26:20
63926971,1,,,0,15,"<p>I was wondering if there was a GraphQL tool or command that provides all the variables available for consumption in a query or mutation.</p>&#xA;<p>For example, if you know the query name, you'd be provided a full list of GraphQL query arguments. Something like:</p>&#xA;<pre><code>    {&#xA;        person(){&#xA;            nodes{&#xA;            firstName,&#xA;            lastName,&#xA;            birthDate,&#xA;            arg1,&#xA;            arg2,&#xA;            ...,&#xA;            argn&#xA;            }&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>Then you'd have a list provided somehow. Does this exist?</p>&#xA;",4630250,,,,2020-09-16 19:42:48,Are arguments for GraphQL automatically provided?,<graphql>,0,2,0,2020-09-16 19:42:48
63933945,2,,63848594,9,,"<p>From the <a href=""https://docs.gitlab.com/ee/api/graphql/getting_started.html#pagination"" rel=""noreferrer"">documentation</a> :</p>&#xA;<blockquote>&#xA;<p>By default, GitLab’s GraphQL API will return only the first 100 records of any collection. This can be changed by using first or last arguments. Both arguments take a value, so first: 10 will return the first 10 records, and last: 10 the last 10 records.</p>&#xA;</blockquote>&#xA;<p>So you have to do the pagination yourself, your first query would be for example :</p>&#xA;<pre><code>query {                                                                                                                                                                                       &#xA;  users(first: 10) {&#xA;    edges {&#xA;      node {                                                                                                                                                                                   &#xA;        id                                                                                                                                                                                      &#xA;        name                                                                                                                                                                                    &#xA;        username                                                                                                                                                                                &#xA;      } &#xA;    }&#xA;    pageInfo {&#xA;      endCursor&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Then use the <code>PageInfo</code> result values to know if you have more pages to fetch and the cursor ID to fetch the next page, for example you could get the following result :</p>&#xA;<pre><code>...&#xA;&quot;pageInfo&quot;: {&#xA;   &quot;endCursor&quot;: &quot;eyJpZCI6Ijc****************zNjk0MDUwMDAgOVRDIn0&quot;,&#xA;   &quot;hasNextPage&quot;: true&#xA;}&#xA;</code></pre>&#xA;<p>So for the next page, you have to query :</p>&#xA;<pre><code>query {                                                                                                                                                                                       &#xA;  users(first: 10, after: &quot;eyJpZCI6IjcxMj**********************Ni4zNjk0MDUwMDAgOVRDIn0&quot;) {&#xA;    edges {&#xA;      node {                                                                                                                                                                                   &#xA;        id                                                                                                                                                                                      &#xA;        name                                                                                                                                                                                    &#xA;        username                                                                                                                                                                                &#xA;      } &#xA;    }&#xA;    pageInfo {&#xA;      endCursor&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And so on until <code>hasNextPage</code> returns <code>false</code>.</p>&#xA;<p>For more info about pagination and cursors, see GraphQL documentation : <a href=""https://graphql.org/learn/pagination/"" rel=""noreferrer"">https://graphql.org/learn/pagination/</a></p>&#xA;",1274485,,5321614,2020-09-22 17:18:03,2020-09-22 17:18:03,"",,0,4,0,2020-09-17 08:14:58
63963126,2,,60719312,8,,"<p>This error usually occurs if you have named two or more of your Object Types with the same <code>name</code>.</p>&#xA;<p>For example,</p>&#xA;<pre><code>const X = new GraphQLObjectType({&#xA;   name: 'Hello',&#xA;   ...&#xA;});&#xA;&#xA;const Y = new GraphQLObjectType({&#xA;   name: 'Hello',&#xA;   ...&#xA;});&#xA;</code></pre>&#xA;<p>Both <code>X</code> and <code>Y</code> Object Types have the same <code>name</code> which is not allowed in GraphQL.&#xA;Try using different names.</p>&#xA;",12417164,,3025856,2020-09-18 23:00:36,2020-09-18 23:00:36,"",,0,2,0,2020-09-18 21:36:48
63986955,1,63988413,,0,300,"<p>Here's a simple graphQL query to fetch all people. I'd like to add a limit to to the number of friends each (Person) node will have (say e.g. max 5) when retrieved. Is this possible in graphQL? I know its possible to add a limit to allPeople, something like <code>allPeople(limit: 5)</code>&#xA;but i don't think that will help my use-case.</p>&#xA;<pre><code>{&#xA;  allPeople {&#xA;    nodes {&#xA;      id&#xA;      friends {&#xA;        name&#xA;        id&#xA;        phone&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1159915,,,,2020-09-21 08:22:59,Adding limit's to nested value in graphql,<graphql><limit>,1,1,0,2020-09-21 06:06:23
63995388,2,,63959469,0,,"<p>You could try using a <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html"" rel=""nofollow noreferrer"">Global Secondary Index</a> on the field you want to query. In your AppSync resolver, you need to specify the index you want to use for the query.</p>&#xA;<p>Another way would be to run a <code>scan</code> operation against your DB (you don't need to specify a key in this case), although that would be way more inefficient than a <code>GSI</code>.</p>&#xA;",8793935,,1839439,2020-09-21 15:34:03,2020-09-21 15:34:03,"",,0,0,0,2020-09-21 15:28:05
63996258,1,,,0,208,"<p>I am trying to design a schema for an application and I have a problem that I can't solve.  Here is a detail of the application</p>&#xA;<p>User A LIKES  User B&#xA;User B MATCHS User B&#xA;Now User A and User B can start chatting with each others.</p>&#xA;<p>I also keep track of who visited each profile&#xA;User A VISITED BY User B&#xA;User A Visited BY User C</p>&#xA;<p>In the application, I have Me type with details of the user running the app. I have a me query that looks like this:</p>&#xA;<pre><code>me {&#xA;  id&#xA;  name&#xA;  email&#xA;  ...&#xA;  ...&#xA;  likes {  ## users who liked me&#xA;    nextToken&#xA;    edges {&#xA;      node { ## user&#xA;        id&#xA;        name&#xA;        ...&#xA;      }&#xA;    }&#xA;  }&#xA;  matchs { ## users who matched with me&#xA;    nextToken&#xA;    edges {&#xA;      node { ## user&#xA;        id&#xA;        name&#xA;        ...&#xA;        ...&#xA;      }&#xA;    }&#xA;  } &#xA;  Vists { ## users who visited me&#xA;    nextToken&#xA;    edges {&#xA;      node { ## &#xA;        id&#xA;        name&#xA;        ...&#xA;        ...&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In addition to that, I have listUsers query that list users nearby to Me and looks something like this:</p>&#xA;<pre><code>listUsers {&#xA;  nextToken&#xA;  total&#xA;  edges {&#xA;    distance&#xA;    node {  ## user&#xA;      id&#xA;      name&#xA;      ...&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>MY QUESTION&#xA;Since there is a relationship between users (LIKED_BY, MATCHED_WITH) where do I use this relationship in my schema such that it is cashable.  Keep in mind the relationship can change at the client from NO_RELATIONSHIP to LIKED_BY to MATCHED_WITH so if the relationship is duplicated in multiple places, this will be a problem.</p>&#xA;<p>I would really appreciate any help as I am out of ideas.</p>&#xA;<p>Thanks in advance.</p>&#xA;",10557732,,10557732,2020-09-21 16:56:03,2020-09-21 19:22:30,Graphql schema design problem that I can't solve,<graphql><graphql-schema>,2,0,0,2020-09-21 16:20:59
63996588,1,,,-1,251,"<p>I have a rest API that is a proxy to graphql API. Before I send the query to the actual graphql API, I need to update the filter object.</p>&#xA;<pre><code>test_query = { &quot;query&quot;: &quot;{ \&#xA;    viewer { \&#xA;        socks(filter: {sockId:'12345'}) { \&#xA;            colorGroups( \&#xA;                limit: 10000, \&#xA;                filter: { \&#xA;                    datetime_gt: '2019-02-13T00:00:00Z', \&#xA;                    datetime_lt: '2019-02-20T00:00:00Z'}, \&#xA;                orderBy: [datetime_ASC]) { \&#xA;                    size, \&#xA;                    brand \&#xA;                } \&#xA;        } \&#xA;    } \&#xA;}&quot;}&#xA;</code></pre>&#xA;<p>In this case, I need to update the filter on the 'socks' node as such:</p>&#xA;<p><code>socks(filter: {sockId:'12345'})</code>&#xA;needs to be&#xA;<code>socks(filter: {sockId:'actual sock id'})</code></p>&#xA;<p>Any advice for this? I know there are a few graphql libraries I  could use.  Previously I tried to force user to send <code>{sockId: $sockId}</code> and just added the correct value to variables object. I have also tried using regexes to sub the value user send for sockId but that has proved to be sort of limiting.</p>&#xA;",14304114,,,,2020-09-21 17:47:24,How to update filter in graphql query string body?,<python><dictionary><parsing><graphql><filtering>,1,1,0,2020-09-21 16:42:34
63999706,1,,,1,33,"<p>I am using GraphQL to download the entire dataset from an API.</p>&#xA;<p>Pagination is implemented using the <code>first</code> and <code>after</code> arguments.</p>&#xA;<p>If I order the items by create date desc, and my code is polling using the <code>after</code> set to the last item it received, will it see new items as they are created?</p>&#xA;<p>Or is the <code>cursor</code> like an actual database cursor where you are iterating over a result (inside an RDMS read transaction, which is like a snapshot of the result set)?</p>&#xA;<p>Note: The API does not implement <code>subscription</code> so I cannot subscribe to events.</p>&#xA;",4949386,,,,2020-09-21 20:41:31,GraphQL: Are cursors part of a read transaction? Polling for new data,<graphql><github-api>,0,0,0,2020-09-21 20:41:31
64014541,1,64015025,,1,60,"<p>How do you handle accessing the objects inside a JSON response when the key is dynamic?</p>&#xA;<p>In my code sample, I've created a reducer that makes API calls but requires params to work:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import { fetchAPI } from '../lib/api'&#xA;&#xA;export async function resultsReducer(dataType, sortParam, nodeFields) { &#xA;  let allResults = []&#xA;  let fetch = await fetchAPI(`&#xA;    query {&#xA;      ${dataType} (sortBy: ${sortParam}) {&#xA;        pageInfo {&#xA;          hasNextPage&#xA;          startCursor&#xA;          endCursor&#xA;        }&#xA;        edges {&#xA;          node {&#xA;            ${nodeFields}&#xA;          }&#xA;          cursor&#xA;        }&#xA;        totalCount&#xA;      }&#xA;    }&#xA;  `)&#xA;&#xA;  // How I access the dataType key - this doesn't work &#xA;  fetch.dataType.edges.map( (item) =&gt; {&#xA;    allResults.push(item)&#xA;  })&#xA;}&#xA;</code></pre>&#xA;<p>That function works and it returns a response that gets deposited on <code>fetch</code> that looks like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  allLocationss: {&#xA;    pageInfo: {&#xA;      hasNextPage: true,&#xA;      startCursor: 'YXJyYXljb25uZWN0aW9uOjA=',&#xA;      endCursor: 'YXJyYXljb25uZWN0aW9uOjE5'&#xA;    },&#xA;    edges: [&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object], [Object],&#xA;      [Object], [Object]&#xA;    ],&#xA;    totalCount: 52&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In my example response, <code>allLocationss</code> is the key, but some times it's <code>allTopics</code> or <code>allEvents</code>, etc. If I use <code>Object.keys(fetch)[1]</code> I get a string returned. I also tried <code>fetch.Object.keys(fetch)[1].edges</code> but that doesn't work either. Would love some ideas S.O.</p>&#xA;",241153,,241153,2020-09-22 17:26:44,2020-09-22 17:55:24,Access Javascript Object Value with Dynamic Key,<javascript><object><graphql>,2,5,0,2020-09-22 17:08:51
64033021,1,64033129,,1,2991,"<p>I've a Django project where I'm using django-graphene to create a GraphQL API.</p>&#xA;<p>There's an issue when trying to use <code>DjangoFilterConnectionField</code> together with the <code>relay.Connection</code> (<a href=""https://docs.graphene-python.org/en/latest/relay/connection/"" rel=""nofollow noreferrer"">which is the core of pagination's feature</a>)</p>&#xA;<p>My model is too large and has many relationships, but let's keep things simple...</p>&#xA;<pre><code>class Pattern(models.Model):&#xA;    code = models.CharField(&#xA;        max_length=15&#xA;    )&#xA;    name = models.CharField(&#xA;        max_length=50&#xA;    )&#xA;    slug = AutoSlugField(&#xA;        populate_from='name',&#xA;        max_length=150&#xA;    )&#xA;    ...&#xA;</code></pre>&#xA;<p>My node looks like:</p>&#xA;<pre><code>class PatternNode(DjangoObjectType):&#xA;    # Many fields here...&#xA;    ...&#xA;&#xA;    class Meta:&#xA;        model = Pattern&#xA;        interfaces = (relay.Node,)&#xA;        filterset_class = PatternFilterSet&#xA;</code></pre>&#xA;<p>As you can see, I've setup the <code>filterset_class</code> attribute in the <code>Meta</code> of my Node.</p>&#xA;<p>So, here's that filter set:</p>&#xA;<pre><code>class PatternFilterSet(FilterSet):&#xA;    order_by = OrderingFilter(&#xA;        fields=(&#xA;            ('date', 'date'),&#xA;            ('name', 'name'),&#xA;        )&#xA;    )&#xA;    productcategorization__design__contains = CharFilter(method=&quot;product_categorization_design_filter&quot;)&#xA;    products__predominant_colors__contains = CharFilter(method=&quot;products_predominant_colors_filter&quot;)&#xA;&#xA;    class Meta:&#xA;        model = Pattern&#xA;        fields = {&#xA;            'name': ['exact', 'icontains', 'istartswith'],&#xA;            'alt_name': ['exact', 'icontains', 'istartswith'],&#xA;            'slug': ['exact'],&#xA;            'pattern_class': ['exact'],&#xA;            'sectors': ['exact', 'in'],&#xA;            'products__instances': ['exact'],&#xA;            'productcategorization__business': ['exact'],&#xA;            'productcategorization__market_segment': ['exact', 'in'],&#xA;        }&#xA;&#xA;    @staticmethod&#xA;    def product_categorization_design_filter(queryset, name, value):&#xA;        &quot;&quot;&quot;&#xA;        Does a productcategorization__design__contains filter &quot;manually&quot; because adding it in the Meta.fields does not&#xA;        work for ArrayField.&#xA;&#xA;        Args:&#xA;             queryset (patterns.managers.PatternQuerySet)&#xA;             name (str)&#xA;             value (Array) comma delimited list of designs&#xA;&#xA;        Returns:&#xA;            filtered_queryset (QuerySet)&#xA;        &quot;&quot;&quot;&#xA;        return queryset.filter(productcategorization__design__contains=value.split(&quot;,&quot;))&#xA;&#xA;    @staticmethod&#xA;    def products_predominant_colors_filter(queryset, name, value):&#xA;        &quot;&quot;&quot;&#xA;        Does a products__predominant_colors__contains filter &quot;manually&quot; because adding it in the Meta.fields does not&#xA;        work for ArrayField.&#xA;&#xA;        Args:&#xA;             queryset (patterns.managers.PatternQuerySet)&#xA;             name (str)&#xA;             value (Array) comma delimited list of designs&#xA;&#xA;        Returns:&#xA;            filtered_queryset (QuerySet)&#xA;        &quot;&quot;&quot;&#xA;        return queryset.filter(products__predominant_colors__contains=value.split(&quot;,&quot;)).distinct()&#xA;</code></pre>&#xA;<p>As you can see there are many special filtering options I need in my API for that particular Model.</p>&#xA;<p>In my schema I've the following:</p>&#xA;<pre><code>class PatternConnection(relay.Connection):&#xA;    class Meta:&#xA;        node = PatternNode&#xA;&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    pattern = relay.Node.Field(&#xA;        PatternNode,&#xA;        id=ID(),&#xA;        slug=String()&#xA;    )&#xA;    patterns = relay.ConnectionField(PatternConnection)&#xA;</code></pre>&#xA;<p>Everything works pretty fine at this point, but filters aren't working.</p>&#xA;<p>I'm executing the following query:</p>&#xA;<pre><code>query Patterns {&#xA;    patterns(first: 2) {&#xA;        pageInfo {&#xA;            startCursor&#xA;            endCursor&#xA;            hasNextPage&#xA;        }&#xA;        edges {&#xA;            cursor&#xA;            node {&#xA;                id&#xA;                name&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>and receiving the following response:</p>&#xA;<pre><code>{&#xA;    &quot;data&quot;: {&#xA;        &quot;patterns&quot;: {&#xA;            &quot;pageInfo&quot;: {&#xA;                &quot;startCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjA=&quot;,&#xA;                &quot;endCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjE=&quot;,&#xA;                &quot;hasNextPage&quot;: true&#xA;            },&#xA;            &quot;edges&quot;: [&#xA;                {&#xA;                    &quot;cursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjA=&quot;,&#xA;                    &quot;node&quot;: {&#xA;                        &quot;id&quot;: &quot;UGF0dGVybk5vZGU6Mjcw&quot;,&#xA;                        &quot;name&quot;: &quot;42 Oz - Jk&quot;&#xA;                    }&#xA;                },&#xA;                {&#xA;                    &quot;cursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjE=&quot;,&#xA;                    &quot;node&quot;: {&#xA;                        &quot;id&quot;: &quot;UGF0dGVybk5vZGU6Mjcx&quot;,&#xA;                        &quot;name&quot;: &quot;42 Oz - Pebble Top - Jk&quot;&#xA;                    }&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>so pagination is working well!</p>&#xA;<p>Now, when I try it using one of my filters, like this:</p>&#xA;<pre><code>query Patterns ($predominantColors: String) {&#xA;    patterns(first: 2, products_PredominantColors_Contains: $predominantColors) {&#xA;        pageInfo {&#xA;            startCursor&#xA;            endCursor&#xA;            hasNextPage&#xA;        }&#xA;        edges {&#xA;            cursor&#xA;            node {&#xA;                id&#xA;                name&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>I'm receiving the following response:</p>&#xA;<pre><code>{&#xA;    &quot;errors&quot;: [&#xA;        {&#xA;            &quot;message&quot;: &quot;Unknown argument \&quot;products_PredominantColors_Contains\&quot; on field \&quot;patterns\&quot; of type \&quot;Query\&quot;.&quot;,&#xA;            &quot;locations&quot;: [&#xA;                {&#xA;                    &quot;line&quot;: 2,&#xA;                    &quot;column&quot;: 24&#xA;                }&#xA;            ]&#xA;        }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;<p>I assume, that's because I'm not using the <code>DjangoFilterConnectionField</code> <a href=""https://docs.graphene-python.org/projects/django/en/latest/filtering/#filterable-fields"" rel=""nofollow noreferrer"">as suggested here</a>, but when I try to do this:</p>&#xA;<pre><code>class PatternConnection(relay.Connection):&#xA;    class Meta:&#xA;        node = PatternNode&#xA;&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    pattern = relay.Node.Field(&#xA;        PatternNode,&#xA;        id=ID(),&#xA;        slug=String()&#xA;    )&#xA;    patterns = DjangoFilterConnectionField(PatternConnection)&#xA;</code></pre>&#xA;<p>I'm getting the following error:</p>&#xA;<pre><code>September 23, 2020 - 17:06:12&#xA;Django version 2.2.12, using settings 'proquinal_api.settings'&#xA;Starting development server at http://api.spradling.local:8000/&#xA;Quit the server with CONTROL-C.&#xA;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/types.py:131: UserWarning: Django model &quot;cities_light.City&quot; does not have a field or attribute named &quot;location&quot;. Consider removing the field from the &quot;exclude&quot; list of DjangoObjectType &quot;CityNode&quot; because it has no effect&#xA;  type_=type_,&#xA;Internal Server Error: /graphql/&#xA;Traceback (most recent call last):&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/settings.py&quot;, line 79, in import_from_string&#xA;    module = importlib.import_module(module_path)&#xA;  File &quot;/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.7/lib/python3.7/importlib/__init__.py&quot;, line 127, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 967, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 677, in _load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 728, in exec_module&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed&#xA;  File &quot;/Users/cristianrojas/www/spradling-api/proquinal_api/schema.py&quot;, line 49, in &lt;module&gt;&#xA;    mutation=Mutation&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/schema.py&quot;, line 78, in __init__&#xA;    self.build_typemap()&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/schema.py&quot;, line 168, in build_typemap&#xA;    initial_types, auto_camelcase=self.auto_camelcase, schema=self&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/typemap.py&quot;, line 80, in __init__&#xA;    super(TypeMap, self).__init__(types)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphql/type/typemap.py&quot;, line 31, in __init__&#xA;    self.update(reduce(self.reducer, types, OrderedDict()))  # type: ignore&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/typemap.py&quot;, line 88, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/typemap.py&quot;, line 117, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphql/type/typemap.py&quot;, line 109, in reducer&#xA;    field_map = type_.fields&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphql/pyutils/cached_property.py&quot;, line 22, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphql/type/definition.py&quot;, line 198, in fields&#xA;    return define_field_map(self, self._fields)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphql/type/definition.py&quot;, line 212, in define_field_map&#xA;    field_map = field_map()&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene/types/typemap.py&quot;, line 275, in construct_fields_for_type&#xA;    map = self.reducer(map, field.type)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/fields.py&quot;, line 98, in type&#xA;    assert _type._meta.connection, &quot;The type {} doesn't have a connection&quot;.format(&#xA;AttributeError: 'ConnectionOptions' object has no attribute 'connection'&#xA;&#xA;During handling of the above exception, another exception occurred:&#xA;&#xA;Traceback (most recent call last):&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/django/core/handlers/exception.py&quot;, line 34, in inner&#xA;    response = get_response(request)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/django/core/handlers/base.py&quot;, line 115, in _get_response&#xA;    response = self.process_exception_by_middleware(e, request)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/django/core/handlers/base.py&quot;, line 113, in _get_response&#xA;    response = wrapped_callback(request, *callback_args, **callback_kwargs)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/django/views/decorators/csrf.py&quot;, line 54, in wrapped_view&#xA;    return view_func(*args, **kwargs)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/django/views/generic/base.py&quot;, line 62, in view&#xA;    self = cls(**initkwargs)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/views.py&quot;, line 100, in __init__&#xA;    schema = graphene_settings.SCHEMA&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/settings.py&quot;, line 126, in __getattr__&#xA;    val = perform_import(val, attr)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/settings.py&quot;, line 65, in perform_import&#xA;    return import_from_string(val, setting_name)&#xA;  File &quot;/Users/cristianrojas/.virtualenvs/spradling-api-YJ5S1R6Y/lib/python3.7/site-packages/graphene_django/settings.py&quot;, line 88, in import_from_string&#xA;    raise ImportError(msg)&#xA;ImportError: Could not import 'proquinal_api.schema.schema' for Graphene setting 'SCHEMA'. AttributeError: 'ConnectionOptions' object has no attribute 'connection'.&#xA;[23/Sep/2020 17:08:02] &quot;POST /graphql/ HTTP/1.1&quot; 500 212017&#xA;</code></pre>&#xA;<p>So I'm wondering what's the right way to use <code>DjangoFilterConnectionField</code> in combination with my <code>PatternConnection</code> Relay's Connection to make filters and pagination work together.</p>&#xA;",923323,,,,2020-09-23 17:18:09,How to use Relay's pagination feature with filterset_class from django-filter when using graphene-django,<python><django><graphql><graphene-django>,1,0,0,2020-09-23 17:10:25
64039899,1,64056449,,0,1123,"<p>How to implement query filters and sorting using Graphql SPQR?</p>&#xA;<p>I'm looking for a solution with Graphql SPQR for schema which looks something like this.</p>&#xA;<pre><code>schema {&#xA;    query: Query&#xA;    mutation: Mutation&#xA;}&#xA;&#xA;enumSortOrder {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;&#xA;type Article {&#xA;   id: String&#xA;   name: String&#xA;createdByUserId: String&#xA;createdOn: String&#xA;lastUpdatedOn: String&#xA;}&#xA;&#xA;type Feedback {&#xA;    id: String&#xA;feedbackText: String&#xA;articleId: String&#xA;createdByUserId: String&#xA;createdOn: String&#xA;lastUpdatedOn: String&#xA;}&#xA;&#xA;type Query {&#xA;    getAllArticles(pageNumber: Int!, pageSize : Int!, sortOrder: SortOrder!, sortBy: String!): [Article]&#xA;    getFeedBacksForArticle(articleId: String!): [Feedback]&#xA;}&#xA;&#xA;type Mutation {&#xA;    createArticle(name: String!, createdByUserId: String!): Article&#xA;    createNewFeedback(feedbackText: String!, articleId: String!, createdByUserId: String!): Feedback&#xA;}&#xA;</code></pre>&#xA;",2106260,,,,2020-09-25 01:14:21,How to implement query filters and sorting using Graphql SPQR?,<graphql><graphql-java><graphql-spqr>,1,0,0,2020-09-24 05:09:54
64065427,1,64419520,,-1,88,"<p>I am new to relay, I have a query that delivers a response, which I can see in the network tab of the inspector, but what I dont understand is how to grab that response for use in my component. Could someone please explain that?</p>&#xA;<p>My query is</p>&#xA;<pre><code>const query = graphql`&#xA;query AdvisorProfileQuery($id: ID!) {&#xA;    node(id: $id) {&#xA;        ...on Advisor {&#xA;            name&#xA;            postalCode&#xA;            products&#xA;            referralCode&#xA;            status&#xA;            updatedAt&#xA;        }&#xA;    }&#xA;}`;&#xA;</code></pre>&#xA;<p>and runs through the renderer</p>&#xA;<pre><code>const QueryRenderer = LoadingQueryRenderer(AdvisorProfile, query);&#xA;export default ({ i18n }) =&gt; {&#xA;return (&#xA;    &lt;&gt;&#xA;        &lt;QueryRenderer&#xA;            params={{ id: id }}&#xA;        /&gt;&#xA;    &lt;/&gt;&#xA;);&#xA;};&#xA;</code></pre>&#xA;<p>but what is the variable name that holds that data that is returned to the component? I want to pass that data as a prop to another component.</p>&#xA;<p>This is how the response looks&#xA;<a href=""https://i.stack.imgur.com/JKYxr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JKYxr.png"" alt=""relay response"" /></a></p>&#xA;",6388582,,,,2020-10-19 00:04:35,How to capture the response of a query in GraphQL Relay,<reactjs><graphql><relayjs>,1,0,0,2020-09-25 13:47:10
64066731,1,,,1,99,"<p>I'm attempting to load information about a type in 2 steps (since the info I'm asking for in  secondQuery will take some time to load):</p>&#xA;<p><strong>Component:</strong></p>&#xA;<pre><code>const MyComponent = ({startDate}) =&gt; {&#xA;  const firstQuery = useQuery(&#xA;    GET_INFO_PART_ONE,&#xA;    {&#xA;     variables: {startDate}&#xA;    }&#xA;  );&#xA;&#xA;  const secondQuery = useQuery(&#xA;    GET_INFO_PART_TWO,&#xA;    {&#xA;     variables: {startDate}&#xA;    }&#xA;  );&#xA;}&#xA;</code></pre>&#xA;<p><strong>Queries:</strong></p>&#xA;<pre><code>export const GET_INFO_PART_ONE = gql`&#xA;  query getInfoPartOne(&#xA;    $startDate: DateTime!&#xA;  ) {&#xA;    infoPageResults(&#xA;      startDate: $startDate&#xA;    ) {&#xA;      edges {&#xA;        info {&#xA;          infoID&#xA;          infoFieldOne&#xA;          infoFieldTwo&#xA;          infoFieldThree&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export const GET_INFO_PART_TWO = gql`&#xA;  query getInfoPartTwo(&#xA;    $startDate: DateTime!&#xA;  ) {&#xA;    infoPageResults(&#xA;      startDate: $startDate&#xA;    ) {&#xA;      edges {&#xA;        info {&#xA;          infoID&#xA;          infoFieldFour{&#xA;            netRate&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>When I do this and both queries resolve, the cache's ROOT_QUERY includes the data as I would expect it, with infoPageResults containing an array of edges where each edge's <code>info</code> __typename includes the fields specified in the <code>GET_INFO_PART_ONE</code> and <code>GET_INFO_PART_TWO</code> queries. I would then expect <code>firstQuery.data.infoPageResults.edges</code> in the above component to include the fields loaded from the second query.</p>&#xA;<p><strong>The Problem</strong></p>&#xA;<p>After both firstQuery and secondQuery are finished loading, firstQuery.data.infoPageResults.edges does not contain the fields loaded by secondQuery, even though the cached values look as I would expect them.</p>&#xA;<ol>&#xA;<li>Is there something obvious I'm misunderstanding about how the query hooks work?</li>&#xA;<li>Is there a better strategy for loading additional fields onto a _typename in 2 steps?</li>&#xA;</ol>&#xA;",14340585,,,,2020-09-27 19:35:29,Loading __typename fields in seperate queries Apollo-Client not Updating UI,<graphql><apollo-client>,1,0,0,2020-09-25 15:06:28
64073990,1,,,0,31,"<p>I have a <code>Teacher</code> type that looks like this:</p>&#xA;<pre><code>  type Teacher {&#xA;    id: ID!&#xA;    name: String&#xA;    reservations: [Applicant],&#xA;    reservations_by_day: {&#xA;      monday: [Applicant]&#xA;      tuesday: [Applicant]&#xA;      wednesday: [Applicant]&#xA;      thursday: [Applicant]&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>this is the <code>Applicant</code> type:</p>&#xA;<pre><code>  type Applicant {&#xA;    id: ID!&#xA;    code: String&#xA;    name: String&#xA;    option: Option!&#xA;  }&#xA;</code></pre>&#xA;<p>And this is the <code>Option</code> type:</p>&#xA;<pre><code>  type Option {&#xA;    id: ID!&#xA;    teacher: String&#xA;    time: String&#xA;    day: String&#xA;    workshop: Workshop!&#xA;  }&#xA;</code></pre>&#xA;<p>Basically I want to resolve <code>reservations_by_day</code> depending on the day the applicant chose. How could I code my resolver to accomplish this? Taking into account that the <code>day</code> prop is nested inside other stuff:</p>&#xA;<pre><code>{&#xA;  Applicant {&#xA;    Option {&#xA;      day&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Teacher resolvers</p>&#xA;<pre><code>  Teacher: {&#xA;    options: (obj) =&gt;&#xA;      db.options.filter((option) =&gt; option.teacher_id === obj.id),&#xA;    reservations: (obj) =&gt;&#xA;      db.applicants.filter((applicant) =&gt;&#xA;        new RegExp(obj.id).test(applicant.option_id)&#xA;      ),&#xA;      reservations_by_day: {&#xA;        monday: () =&gt; [],&#xA;        tuesday: () =&gt; [],&#xA;        wednesday: () =&gt; [],&#xA;        thursday: () =&gt; [],&#xA;      }&#xA;  }&#xA;</code></pre>&#xA;",3440297,,3440297,2020-09-26 05:38:01,2020-09-26 05:38:01,How to resolve a list separated by some nested property on their children?,<javascript><graphql><apollo>,0,4,0,2020-09-26 04:44:03
64090675,2,,61017389,5,,"<p>A bit late, though I was able to implement it like so</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const FacilitySchema: Schema = new Schema(&#xA;    {&#xA;        name: { type: String, required: true, maxlength: 50, text: true },&#xA;        short_description: { type: String, required: true, maxlength: 150, text: true },&#xA;        description: { type: String, maxlength: 1000 },&#xA;        location: { type: LocationSchema, required: true },&#xA;    },&#xA;    {&#xA;        timestamps: true,&#xA;    }&#xA;);&#xA;&#xA;FacilitySchema.index(&#xA;    {&#xA;        name: 'text',&#xA;        short_description: 'text',&#xA;        'category.name': 'text',&#xA;        'location.address': 'text',&#xA;        'location.city': 'text',&#xA;        'location.state': 'text',&#xA;        'location.country': 'text',&#xA;    },&#xA;    {&#xA;        name: 'FacilitiesTextIndex',&#xA;        default_language: 'english',&#xA;        weights: {&#xA;            name: 10,&#xA;            short_description: 5,&#xA;            // rest fields get weight equals to 1&#xA;        },&#xA;    }&#xA;);&#xA;</code></pre>&#xA;<p>After creating your ObjectTypeComposer for the model, add this</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const paginationResolver = FacilityTC.getResolver('pagination').addFilterArg({&#xA;    name: 'search',&#xA;    type: 'String',&#xA;    query: (query, value, resolveParams) =&gt; {&#xA;        resolveParams.args.sort = {&#xA;            score: { $meta: 'textScore' },&#xA;        };&#xA;        query.$text = { $search: value, $language: 'en' };&#xA;        resolveParams.projection.score = { $meta: 'textScore' };&#xA;    },&#xA;});&#xA;&#xA;FacilityTC.setResolver('pagination', paginationResolver);&#xA;</code></pre>&#xA;<p>Then you can assign like so</p>&#xA;<pre class=""lang-js prettyprint-override""><code>&#xA;const schemaComposer = new SchemaComposer();&#xA;&#xA;schemaComposer.Query.addFields({&#xA;   // ...&#xA;   facilities: Facility.getResolver('pagination')&#xA;   // ...&#xA;});&#xA;</code></pre>&#xA;<p>On your client side, perform the query like so</p>&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  facilities(filter: { search: &quot;akure&quot; }) {&#xA;    count&#xA;    items {&#xA;      name&#xA;    }&#xA;  } &#xA;}&#xA;</code></pre>&#xA;",7124240,,,,2020-09-27 16:20:23,"",,0,0,0,2020-09-27 16:20:23
64092094,2,,49384737,0,,"<p>GraphQL allows for the client to specify exactly what data is desired but it doesn't has any inbuilt way of filtering and sorting the data. You will have write code for that yourself. Regarding injecting the filters, one possible way of doing it can be following:</p>&#xA;<pre><code>type Query {&#xA;    allCars(filter: String, range: String, sort: String): [Car]!&#xA;}&#xA;</code></pre>&#xA;<p>For above Query, sample request would be like:</p>&#xA;<pre><code>{&#xA;    allCars(filter: &quot;{brand: 'Abc'}&quot;, range: &quot;[0, 100]&quot;, sort: &quot;[id, ASC]&quot;) { # Fetch first 100 cars of brand 'Abc' sorted by id&#xA;        id&#xA;        model&#xA;        brand&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Then your getAllCars method would be like following:</p>&#xA;<pre><code>public List&lt;Car&gt; getAllCars(String filter, String range, String sort) {&#xA;    // Implement parser and filter by using JPA specifications&#xA;}&#xA;</code></pre>&#xA;<p>To see a sample implementation of parser and its conversion it to JPA specifications, please refer to following project: <a href=""https://github.com/jaskaransingh156/spring-boot-graphql-with-custom-rql"" rel=""nofollow noreferrer"">https://github.com/jaskaransingh156/spring-boot-graphql-with-custom-rql</a></p>&#xA;",2557608,,2557608,2020-10-11 08:03:09,2020-10-11 08:03:09,"",,0,0,0,2020-09-27 18:47:36
64115673,1,64118572,,1,192,"<p>I am trying to request a Graphql API through python. I have written the script which is trying to pull audit log from Github for each organisation.</p>&#xA;<p>This is the Python script I have written.</p>&#xA;<pre><code>Query = &quot;&quot;&quot;&#xA;query {&#xA;  organization(login: '{}') {&#xA;    auditLog(first: 100, '{}') {&#xA;      edges {&#xA;        node {&#xA;          ... on RepositoryAuditEntryData {&#xA;            repository {&#xA;              name&#xA;            }&#xA;          }&#xA;          ... on OrganizationAuditEntryData {&#xA;            organizationResourcePath&#xA;            organizationName&#xA;            organizationUrl&#xA;          }&#xA;&#xA;          ... on TeamAuditEntryData {&#xA;            teamName&#xA;          }&#xA;&#xA;          ... on TopicAuditEntryData {&#xA;            topicName&#xA;          }&#xA;&#xA;          ... on OauthApplicationAuditEntryData {&#xA;            oauthApplicationName&#xA;          }&#xA;          &#xA;          ... on EnterpriseAuditEntryData {&#xA;            enterpriseResourcePath&#xA;            enterpriseUrl&#xA;            enterpriseSlug&#xA;          }&#xA;&#xA;          ... on AuditEntry {&#xA;            actorResourcePath&#xA;            action&#xA;            actorIp&#xA;            actorLogin&#xA;            operationType&#xA;            createdAt&#xA;            actorLocation {&#xA;              countryCode&#xA;              country&#xA;              regionCode&#xA;              region&#xA;              city&#xA;            }&#xA;            #User 'Action' was performed on&#xA;            userLogin&#xA;            userResourcePath&#xA;            userUrl&#xA;          }&#xA;        }&#xA;        cursor&#xA;      }&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&quot;&quot;&quot;&#xA;  &#xA;l = []&#xA;l.append(&quot;CoreDevOpsTools&quot;) &#xA;l.append(&quot;JIRA-Cloud&quot;)&#xA;&#xA;res = []&#xA;&#xA;for i in range(len(l)):   &#xA;    org = str(l[i])&#xA;    after = ''&#xA;&#xA;    while True:&#xA;        result = requests.post('https://api.github.com/graphql',&#xA;                                json={'query': Query.format(org,after)},&#xA;                                headers=headers)&#xA;&#xA;        json_data = json.loads(result.text)&#xA;&#xA;        if 'errors' in json_data:&#xA;            print(json_data['errors'])&#xA;            break&#xA;&#xA;        res_list = json_data['data']['organization']['auditLog']&#xA;&#xA;        for items in res_list['edges']:&#xA;            res.append(items)&#xA;&#xA;        if not res_list['pageInfo']['hasNextPage']:&#xA;            break&#xA;&#xA;        after = 'after: &quot;%s&quot;' % res_list['edges'][-1]['cursor']&#xA;        time.sleep(1)&#xA;&#xA;</code></pre>&#xA;<pre><code>  File &quot;../AuditLog.py&quot;, line 98, in &lt;module&gt;&#xA;    json={'query': Query.format(org,after)},&#xA;KeyError: '\n  organization(login'&#xA;</code></pre>&#xA;<p>This is the structure of query in Insomnia/Postman.</p>&#xA;<pre><code>query {&#xA;  organization(login: &quot;CoreDevOpsTools&quot;) {&#xA;    auditLog(first: 100, after: &quot;XYZ&quot;) {&#xA;      edges {&#xA;        node {&#xA;          ... on RepositoryAuditEntryData {&#xA;            repository {&#xA;              name&#xA;            }&#xA;          }&#xA;          ... on OrganizationAuditEntryData {&#xA;            organizationResourcePath&#xA;            organizationName&#xA;            organizationUrl&#xA;          }&#xA;&#xA;          ... on TeamAuditEntryData {&#xA;            teamName&#xA;          }&#xA;&#xA;          ... on TopicAuditEntryData {&#xA;            topicName&#xA;          }&#xA;&#xA;          ... on OauthApplicationAuditEntryData {&#xA;            oauthApplicationName&#xA;          }&#xA;          &#xA;          ... on EnterpriseAuditEntryData {&#xA;            enterpriseResourcePath&#xA;            enterpriseUrl&#xA;            enterpriseSlug&#xA;          }&#xA;&#xA;          ... on AuditEntry {&#xA;            actorResourcePath&#xA;            action&#xA;            actorIp&#xA;            actorLogin&#xA;            operationType&#xA;            createdAt&#xA;            actorLocation {&#xA;              countryCode&#xA;              country&#xA;              regionCode&#xA;              region&#xA;              city&#xA;            }&#xA;            #User 'Action' was performed on&#xA;            userLogin&#xA;            userResourcePath&#xA;            userUrl&#xA;          }&#xA;        }&#xA;        cursor&#xA;      }&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is error I am getting, I am not able to figure out what is wrong. I looked at other same type of questions here but that didn't work either.</p>&#xA;",8049537,,8049537,2020-09-29 09:18:38,2020-09-29 11:21:37,Getting error while Formatting request query in Python,<python><python-3.x><string><graphql><format>,1,0,0,2020-09-29 08:23:32
64118572,2,,64115673,1,,"<p>The issue with your code is that the string you're trying to format itself has curly brackets in places where you don't want to replace things. e.g the first line &quot;query {&quot;</p>&#xA;<p>You can fix this by doubling the curly brackets. So &quot;{&quot; becomes &quot;{{&quot; etc.&#xA;More on this here: <a href=""https://stackoverflow.com/questions/5466451/how-can-i-print-literal-curly-brace-characters-in-python-string-and-also-use-fo"">stackoverflow.com</a></p>&#xA;",8581150,,,,2020-09-29 11:21:37,"",,0,2,0,2020-09-29 11:21:37
64135898,2,,64133999,0,,"<p>Solved here <a href=""https://elixirforum.com/t/how-to-do-pagination-in-a-nested-graphql-query-with-dataloader-batch-load/25282"" rel=""nofollow noreferrer"">https://elixirforum.com/t/how-to-do-pagination-in-a-nested-graphql-query-with-dataloader-batch-load/25282</a> maybe it helps somebody. It should be query like this with a partitioning.</p>&#xA;<pre><code>  def query(queryable, params) do&#xA;   case params do&#xA;      %{chapters: true, offset: offset, first: first} -&gt;&#xA;        last = offset + first&#xA;        query = from r in queryable, select: r, select_merge: %{chapter_number: fragment(&quot;row_number() over (PARTITION by parent_id order by \&quot;name\&quot;)&quot;)}&#xA;        from r in subquery(query), select: %Wikisource.Book{id: r.id, name: r.name, info: r.info, preface: r.preface, info_html: r.info_html, preface_html: r.preface_html}, where: r.chapter_number &gt;= ^offset and r.chapter_number &lt; ^last&#xA;      %{order_by: order_by, offset: from, first: size} -&gt; from record in queryable, order_by: ^order_by, offset: ^from, limit: ^size&#xA;</code></pre>&#xA;",14351138,,14351138,2020-10-01 12:31:57,2020-10-01 12:31:57,"",,0,0,0,2020-09-30 10:43:00
64158489,1,64161509,,0,1767,"<p>I am using <code>graphene-python</code>, <code>django-filters</code> and <code>relay</code> in my GraphQL API. Let's imagine I have a type <code>FrameType</code> which has an integer field <code>time_offset</code> and I would like to be able to use a <strong>range</strong> on it - ask only for frames which have the <code>time_offset</code> within the given range. I prepared my <code>schema.py</code> according to the <a href=""https://docs.graphene-python.org/projects/django/en/latest/filtering/#custom-filtersets"" rel=""nofollow noreferrer"">graphene-python docs</a> with a custom <code>FilterSet</code>:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>import django_filters&#xA;from graphene import ObjectType, relay&#xA;from graphene_django import DjangoObjectType, filter&#xA;from my_app.blabla import models&#xA;&#xA;&#xA;&#xA;class FrameFilter(django_filters.FilterSet):&#xA;    time_offset = django_filters.RangeFilter()&#xA;&#xA;    class Meta:&#xA;        model = models.Frame&#xA;        fields = (&quot;time_offset&quot;,)&#xA;&#xA;&#xA;class FrameType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = models.Frame&#xA;        filterset_class = FrameFilter&#xA;        interfaces = (relay.Node,)&#xA;&#xA;&#xA;class Query(ObjectType):&#xA;    frames = filter.DjangoFilterConnectionField(FrameType)&#xA;&#xA;    class Meta:&#xA;        abstract = True&#xA;</code></pre>&#xA;<p>However, I have no idea how to query the <code>timeOffset</code> field now. I found no examples online for the <code>django_filters.RangeFilter</code> field. This is a query I tried:</p>&#xA;<pre><code>query Frame {&#xA;  frames(first: 20, timeOffset: &quot;{\&quot;gt\&quot;:\&quot;4350\&quot;, \&quot;lt\&quot;:\&quot;5000\&quot;}&quot;) {&#xA;    edges {&#xA;      node {&#xA;        timeOffset&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>... also with these alternatives:</p>&#xA;<pre><code>timeOffset: &quot;{\&quot;gt\&quot;:4350, \&quot;lt\&quot;:5000}&quot;&#xA;timeOffset: &quot;{\&quot;start\&quot;:\&quot;4350\&quot;, \&quot;end\&quot;:\&quot;5000\&quot;}&quot;&#xA;timeOffset: &quot;{\&quot;min\&quot;:\&quot;4350\&quot;, \&quot;max\&quot;: \&quot;4500\&quot;}&quot;&#xA;timeOffset: &quot;[\&quot;4350\&quot;, \&quot;5000\&quot;]&quot;&#xA;timeOffset: &quot;[4350, 5000]&quot;&#xA;timeOffset: &quot;[4350]&quot;&#xA;timeOffset: &quot;4350,5000&quot;&#xA;</code></pre>&#xA;<p>These queries don't raise any error, but they don't filter either (all results are returned). I am lost, I'm not sure if I still haven't found the proper syntax, or maybe there's some mistake in my backend code. How should I use and query the <code>django_filters.RangeFilter</code> on a field?</p>&#xA;",8654161,,,,2021-10-26 15:24:22,How to write a GraphQL query that will use a range filter on an integer field using `django-filters`?,<python><graphql><graphene-python><django-filters>,4,0,0,2020-10-01 15:25:59
64161509,2,,64158489,1,,"<p>Sadly, this isn't possible. But, there is a workaround for it</p>&#xA;<p>Adjust your filter class as</p>&#xA;<pre><code><b>def custom_range_filter_method(queryset, field_name, value):&#xA;    if value:&#xA;        queryset = queryset.filter(**{f'{field_name}__range': value.split(',')})&#xA;    return queryset</b>&#xA;&#xA;&#xA;class FrameFilter(django_filters.FilterSet):&#xA;    time_offset = <b>filters.Filter(method=custom_range_filter_method)</b>&#xA;&#xA;    class Meta:&#xA;        model = models.Frame&#xA;        fields = (""time_offset"",)</code></pre>&#xA;<p>Now query the schema with</p>&#xA;<pre><code>query Frame {&#xA;  frames(first: 20, <b>timeOffset: ""4350,5000""</b>) {&#xA;    edges {&#xA;      node {&#xA;        timeOffset&#xA;    }&#xA;  }&#xA;}</code></pre>&#xA;<h3>Reference</h3>&#xA;<ul>&#xA;<li>Customize filter result with <a href=""https://django-filter.readthedocs.io/en/stable/guide/usage.html#customize-filtering-with-filter-method"" rel=""nofollow noreferrer""><strong><code>Filter.method</code></strong>--(<code>django-filter</code> doc)</a></li>&#xA;</ul>&#xA;",8283848,,,,2020-10-01 18:46:59,"",,0,0,0,2020-10-01 18:46:59
64202326,2,,61556293,-1,,"<p>You can use the <a href=""https://www.npmjs.com/package/uuid"" rel=""nofollow noreferrer""><code>uuid</code></a> and generate a unique id when you create the record.</p>&#xA;<p>for example</p>&#xA;<pre><code>import { v4 as uuidv4 } from 'uuid';&#xA;&#xA;&#xA;const uuid  = uuidv4(); &#xA;&#xA;  prisma.user.create({&#xA;    id : uuid&#xA;     name : name&#xA;  });&#xA;</code></pre>&#xA;",11825891,,,,2020-10-05 04:05:51,"",,0,0,0,2020-10-05 04:05:51
64218392,2,,64218349,0,,"<p>There is one glaring issue in your code. This line</p>&#xA;<pre><code>insert_business_images(objects: [$images]) {&#xA;</code></pre>&#xA;<p>should be</p>&#xA;<pre><code>insert_business_images(objects: $images) {&#xA;</code></pre>&#xA;<p>Notice the removed square brackets.</p>&#xA;<p>If that does not help, then we'll need more information, such as:</p>&#xA;<ul>&#xA;<li>what error do you get?</li>&#xA;<li>which implementation of GraphQL are you using both client-side and server-side?</li>&#xA;<li>what does the GraphQL code (and possibly resolvers) look like on the server? You have only given us the client-side of the equation.</li>&#xA;</ul>&#xA;",3744574,,,,2020-10-06 02:06:04,"",,0,1,0,2020-10-06 02:06:04
64228224,2,,64227500,0,,"<p>You <code>filter</code> value is not a valid syntax, not sure what you trying to do but it might look like:</p>&#xA;<pre><code>{&#xA;  getConstructionNumberListing(filter: &quot;{ subProject__id: 36 }&quot;) {&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",7882470,,,,2020-10-06 14:46:22,"",,0,2,0,2020-10-06 14:46:22
64228565,1,64231267,,0,52,"<p>Lets say I have a query that gets an <code>advisors</code>. That query returns a list of advisor <code>id</code>s that are connected to that advisor.  Now I want to rerun the query that got the advisor in the first place, with the <code>n</code> number of <code>id</code>s, and get those advisors.  I only need to do this once, and not recursively.</p>&#xA;<pre><code>const query = graphql`&#xA;  query AdvisorProfileQuery($id: ID!) {&#xA;    advisor: node(id: $id) {&#xA;      ... on Advisor {&#xA;        name&#xA;        assignments (first: 100) {&#xA;          edges {&#xA;            node {&#xA;              id &lt;---- i want these ids and plug them back into the query to just get &quot;name&quot; of the list of ids&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const QueryRenderer = LoadingQueryRenderer(AdvisorProfile, query);&#xA;export default ({ i18n }) =&gt; {&#xA;  const { id } = useParams();&#xA;  return (&#xA;    &lt;&gt;&#xA;      &lt;QueryRenderer params={{ id: id }} /&gt;&#xA;    &lt;/&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;",6388582,,,,2020-10-06 17:52:41,(Relay) What is the correct syntax to re-run a query based on the result of that query,<graphql><relayjs>,1,0,0,2020-10-06 15:04:26
64229475,1,,,1,2020,"<p>I have a NestJS (Express) backend with the Apollo GraphQL server. I have successfully wired up the SSR process and I can 100% verify that HTML, including Apollo initial state, is getting properly generated on the server.&#xA;The issue is the very weird behavior during hydration: only the very first JSX js expression <code>{}</code> in a given tag gets hydrated. Here's an example, I'm SSRing a Cat type:</p>&#xA;<p>Page source shows correct data:</p>&#xA;<pre><code>&lt;span&gt;Ace 9&lt;/span&gt;&#xA;&lt;script&gt;window.__APOLLO_STATE__ = {&quot;Cat:1&quot;:{&quot;id&quot;:1,&quot;__typename&quot;:&quot;Cat&quot;,&quot;name&quot;:&quot;Ace&quot;,&quot;age&quot;:9},&quot;ROOT_QUERY&quot;:{&quot;__typename&quot;:&quot;Query&quot;,&quot;cats&quot;:[{&quot;__ref&quot;:&quot;Cat:1&quot;}]}}&lt;/script&gt;&#xA;</code></pre>&#xA;<p>And the component is acting weird</p>&#xA;<pre><code>  const { data } = useQuery&lt;Cats&gt;(findAll, {&#xA;    fetchPolicy: 'network-only',&#xA;  })&#xA;  const cat = data?.cats[0]&#xA;  return (&#xA;    &lt;&gt;&#xA;      &lt;span&gt;&#xA;        {cat?.name} {cat?.age}&#xA;      &lt;/span&gt;&#xA;    &lt;/&gt;&#xA;  )&#xA;</code></pre>&#xA;<p>This will error as <code>Warning: Text content did not match. Server: &quot;Ace 9&quot; Client: &quot;Ace&quot;</code>. If I would swap positions of <code>{cat?.name}</code> and <code>{cat?.age}</code> the error would become <code>Server: &quot;9 Ace&quot; Client: &quot;9&quot;</code>. But if I give each expression its own tag error doesn't occur:</p>&#xA;<pre><code>&lt;span&gt;{cat?.name}&lt;/span&gt; &lt;span&gt;{cat?.age}&lt;/span&gt;&#xA;</code></pre>&#xA;<p>If I put data into a single string unsurprisingly it doesn't occur as well:</p>&#xA;<pre><code>const a = `${cat?.name} ${cat?.age}`&#xA;return &lt;&gt;{a}&lt;/&gt;&#xA;&#xA;</code></pre>&#xA;<p>I've banged my head against this wall for an entire day now, I would really appreciate any pointers.</p>&#xA;",5165511,,3383693,2020-10-06 16:13:53,2020-10-06 16:13:53,React hydration - Text content did not match,<reactjs><apollo><server-side-rendering>,0,1,0,2020-10-06 15:54:27
64230563,1,64236994,,2,1412,"<p>I'm at a loss as to how to render an array of objects that are nested inside a record with react-admin. The data I get back from the API looks like this:</p>&#xA;<pre><code>{&#xA;    &quot;data&quot;: {&#xA;        &quot;getPromotion&quot;: {&#xA;            &quot;id&quot;: &quot;ckfxvfrvs00033h5sz4ucoi7e&quot;,&#xA;            &quot;reference&quot;: &quot;Monday special&quot;,&#xA;            &quot;startDate&quot;: &quot;2020-10-06T11:20:00.000Z&quot;,&#xA;            &quot;endDate&quot;: &quot;2020-10-13T11:20:00.000Z&quot;,&#xA;            &quot;promotionItems&quot;: {&#xA;                &quot;items&quot;: [{&#xA;                    &quot;id&quot;: &quot;ckfxxrcyg00073h5v33a27pb8&quot;,&#xA;                    &quot;productId&quot;: &quot;4286857122685&quot;,&#xA;                    &quot;promotionId&quot;: &quot;ckfxvfrvs00033h5sz4ucoi7e&quot;,&#xA;                    &quot;retailerId&quot;: &quot;ckfxvcmjf00013h5sgi4x56rp&quot;,&#xA;                    &quot;discountPrice&quot;: 0.5,&#xA;                    &quot;startDate&quot;: &quot;2020-10-06T11:20:00.000Z&quot;,&#xA;                    &quot;endDate&quot;: &quot;2020-10-13T11:20:00.000Z&quot;,&#xA;                    &quot;createdAt&quot;: &quot;2020-10-06T12:25:10.072Z&quot;,&#xA;                    &quot;updatedAt&quot;: &quot;2020-10-06T12:25:10.072Z&quot;,&#xA;                    &quot;owner&quot;: &quot;xxxxx@xxxxx.com&quot;&#xA;                }],&#xA;                &quot;nextToken&quot;: null&#xA;            },&#xA;            &quot;createdAt&quot;: &quot;2020-10-06T11:20:15.749Z&quot;,&#xA;            &quot;updatedAt&quot;: &quot;2020-10-06T11:20:15.749Z&quot;,&#xA;            &quot;owner&quot;: &quot;xxxxx@xxxxx.com&quot;&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>My main Show component looks like this:</p>&#xA;<pre><code>export const PromotionShow = (props) =&gt; {&#xA;  return (&#xA;    &lt;Show {...props}&gt;&#xA;      &lt;SimpleShowLayout&gt;&#xA;        &lt;TextField source=&quot;reference&quot; label=&quot;Promotion Code&quot; /&gt;&#xA;        &lt;DateField source=&quot;startDate&quot; /&gt;&#xA;        &lt;DateField source=&quot;endDate&quot; /&gt;&#xA;        &lt;PromotionItemsGrid /&gt;&#xA;      &lt;/SimpleShowLayout&gt;&#xA;    &lt;/Show&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>The TextField and DateFields render fine, but the PromotionItemsGrid component just shows a blank grid with no records.</p>&#xA;<p>The PromotionItemsGrid component looks like this:</p>&#xA;<pre><code>const PromotionItemsGrid = (props) =&gt; {&#xA;  console.log(&quot;props from the show component&quot;, JSON.stringify(props));&#xA;  return (&#xA;    &lt;List {...props}&gt;&#xA;      &lt;ArrayField source=&quot;props.record.promotionItems.items&quot;&gt;&#xA;        &lt;Datagrid&gt;&#xA;          &lt;TextField source=&quot;id&quot; /&gt;&#xA;          &lt;TextField source=&quot;productId&quot; /&gt;&#xA;          &lt;TextField source=&quot;retailerId&quot; /&gt;&#xA;          &lt;TextField source=&quot;discountPrice&quot; /&gt;&#xA;        &lt;/Datagrid&gt;&#xA;      &lt;/ArrayField&gt;&#xA;    &lt;/List&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>The output of the console.log indicates the component is getting all the data it needs, I just can't figure out how to pass the array to the ArrayField for the Datagrid to render.</p>&#xA;<p>I've tried every combination of props.record.promotionItems.items I can think of in the &quot;source&quot;  prop of the ArrayField component, but all I ever get is a blank datagrid with no rows (but the columns specified are there). I'm reasonably confident it's a silly thing I'm missing, but I can't for the life of me work it out.</p>&#xA;<p>Any help gratefully received!</p>&#xA;<p>Thanks,</p>&#xA;",14326448,,14326448,2020-10-06 18:37:47,2020-10-07 03:59:52,How can I render the contents of an array nested inside an object in React Admin's show/ArrayField component?,<reactjs><graphql><react-admin>,1,0,0,2020-10-06 17:03:33
64231267,2,,64228565,0,,"<p>Answer was to create a fragment and splat it in...</p>&#xA;<p>Parent component</p>&#xA;<pre><code>const query = graphql`&#xA;  query AdvisorProfileQuery($id: ID!) {&#xA;    advisor: node(id: $id) {&#xA;      ... on Advisor {&#xA;        ... BottomCardTable_advisor&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const QueryRenderer = LoadingQueryRenderer(AdvisorProfile, query);&#xA;export default ({ i18n }) =&gt; {&#xA;  const { id } = useParams();&#xA;  return (&#xA;    &lt;&gt;&#xA;      &lt;QueryRenderer params={{ id: id }} /&gt;&#xA;    &lt;/&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>on child component</p>&#xA;<pre><code>export default createFragmentContainer(TableComponent, graphql`&#xA;  fragment BottomCardTable_advisor on Advisor {&#xA;    assignments: assignments (first: 100) {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          primaryName&#xA;          primaryEmail&#xA;          assignedOn&#xA;          type&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`);&#xA;</code></pre>&#xA;",6388582,,,,2020-10-06 17:52:41,"",,0,0,0,2020-10-06 17:52:41
64261065,1,,,0,1251,"<p>I use an GraphQL API with Django (graphene-django) and I need to upload files through this API.</p>&#xA;<p>The Backend mutation is as following (I use the graphene-file-upload library):</p>&#xA;<pre><code>class UploadBOM(graphene.relay.ClientIDMutation, ProjectMixin):&#xA;&#xA;    class Input:&#xA;        bom = Upload()&#xA;        project_id = graphene.ID(required=True)&#xA;        region = graphene.String(required=True)&#xA;        is_test = graphene.Boolean()&#xA;&#xA;    @project_authorization&#xA;    def mutate_and_get_payload(root, info, **inputs):&#xA;        is_test = inputs.get('is_test', False)&#xA;        inputs['project'].upload_bom(&#xA;            inputs['bom'], &#xA;            inputs['region'], &#xA;            is_test&#xA;        )&#xA;        return UploadBOM(project=inputs['project'])&#xA;</code></pre>&#xA;<p><em>@project_authorization decorator is used for checking if the user can modify the project model.</em></p>&#xA;<p>I have already made the query work with curl and inside Insomnia, but I'm going nuts with VueJs (axios).</p>&#xA;<p>This is how it works with curl.</p>&#xA;<pre><code>curl http://localhost:8001/graphql \&#xA;  -F operations='{&quot;query&quot;: &quot;mutation ($file: Upload, $projectId: ID!, $region: String!, $isTest: Boolean) { uploadBom(input: {bom: $file, projectId: $projectId, region: $region, isTest: $isTest }) { project {id} }}&quot;, &quot;variables&quot;: { &quot;file&quot;: null, &quot;projectId&quot;: &quot;THE_PROJECT_ID&quot;, &quot;region&quot;: &quot;Lombardia&quot;, &quot;isTest&quot;: true}}' \&#xA;  -F map='{ &quot;0&quot;: [&quot;variables.file&quot;]}' \&#xA;  -F 0=@CME4.xlsx \&#xA;  -H &quot;Authorization: JWT MYJSONTOKEN&quot;&#xA;</code></pre>&#xA;<p>I have searched stack overflow for an answer and tried the following with no luck:</p>&#xA;<pre><code>async previewFile(event) {&#xA;      const bomFile = event.target.files[0]&#xA;      alert(bomFile)&#xA;      const formData = new FormData()&#xA;      formData.append('operations', {&quot;query&quot;: &quot;mutation ($file: Upload, $projectId: ID!, $region: String!, $isTest: Boolean) { uploadBom(input: {bom: $file, projectId: $projectId, region: $region, isTest: $isTest }) { project {id} }}&quot;, &quot;variables&quot;: { &quot;file&quot;: bomFile, &quot;projectId&quot;: &quot;UHJvamVjdE5vZGU6MTU=&quot;, &quot;region&quot;: &quot;Lombardia&quot;, &quot;isTest&quot;: true}})&#xA;      formData.append('0', bomFile)&#xA;      formData.append('map', { '0': [&quot;variables.file&quot;]})&#xA;      &#xA;      try {&#xA;        axios.defaults.headers.common[&quot;Authorization&quot;] =&#xA;          &quot;JWT &quot; + localStorage.getItem(&quot;edilgo-token&quot;)&#xA;        const result = await axios({&#xA;          method: 'POST',&#xA;          url: process.env.VUE_APP_API_URL,&#xA;          data: formData,&#xA;        })&#xA;        alert(result)&#xA;      } catch (error) {&#xA;        console.error(error)&#xA;      }&#xA;    },&#xA;</code></pre>&#xA;<p>And also this:</p>&#xA;<pre><code>methods: {&#xA;    async previewFile(event) {&#xA;      const bomFile = event.target.files[0]&#xA;      alert(bomFile)&#xA;      axios.defaults.headers.common[&quot;Authorization&quot;] =&#xA;        &quot;JWT &quot; + localStorage.getItem(&quot;edilgo-token&quot;)&#xA;      axios.defaults.headers.common[&quot;Content-Type&quot;] = &quot;application/graphql&quot;&#xA;      axios.defaults.headers.common[&quot;Content-Transfer-Encoding&quot;] = &quot;multipart/form-data&quot;&#xA;      const isTest = true // GIL: some condition that nows when it's the real deal&#xA;      const result = await axios({&#xA;        method: 'POST',&#xA;        url: process.env.VUE_APP_API_URL,&#xA;        data: {&#xA;          query: `&#xA;              mutation (&#xA;                $file: Upload,&#xA;                $projectId: ID!,&#xA;                $region: String!,&#xA;                $isTest: Boolean,&#xA;              ) {&#xA;              uploadBom(&#xA;                input: {&#xA;                  bom: $file,&#xA;                  projectId: $projectId,&#xA;                  region: $region,&#xA;                  isTest: $isTest,&#xA;                }) {&#xA;                    project {&#xA;                        id&#xA;                        name&#xA;                      }&#xA;                  }&#xA;              }&#xA;            `,&#xA;          variables: {&#xA;            file: bomFile,&#xA;            projectId: &quot;UHJvamVjdE5vZGU6MTU=&quot;,&#xA;            region: &quot;Lombardia&quot;,&#xA;            isTest: isTest&#xA;          }&#xA;        }&#xA;      })&#xA;      console.log(result.data.data.projects)&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Client side is giving me the error following:</p>&#xA;<pre><code>BOMUpload.vue?2363:79 Error: Request failed with status code 500&#xA;    at createError (createError.js?2d83:15)&#xA;    at settle (settle.js?467f:18)&#xA;    at XMLHttpRequest.handleLoad (xhr.js?b50d:77)&#xA;</code></pre>&#xA;<p>The error traceback I get from Django is:</p>&#xA;<pre><code>2020-10-08 14:07:54,394 - ERROR - Internal Server Error: /graphql&#xA;Traceback (most recent call last):&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/core/handlers/exception.py&quot;, line 47, in inner&#xA;    response = get_response(request)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/core/handlers/base.py&quot;, line 179, in _get_response&#xA;    response = wrapped_callback(request, *callback_args, **callback_kwargs)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/views/decorators/csrf.py&quot;, line 54, in wrapped_view&#xA;    return view_func(*args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/views/generic/base.py&quot;, line 73, in view&#xA;    return self.dispatch(request, *args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/utils/decorators.py&quot;, line 43, in _wrapper&#xA;    return bound_method(*args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/django/utils/decorators.py&quot;, line 130, in _wrapped_view&#xA;    response = view_func(request, *args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/graphene_django/views.py&quot;, line 151, in dispatch&#xA;    data = self.parse_body(request)&#xA;  File &quot;/usr/local/lib/python3.8/site-packages/graphene_file_upload/django/__init__.py&quot;, line 15, in parse_body&#xA;    operations = json.loads(request.POST.get('operations', '{}'))&#xA;  File &quot;/usr/local/lib/python3.8/json/__init__.py&quot;, line 357, in loads&#xA;    return _default_decoder.decode(s)&#xA;  File &quot;/usr/local/lib/python3.8/json/decoder.py&quot;, line 337, in decode&#xA;    obj, end = self.raw_decode(s, idx=_w(s, 0).end())&#xA;  File &quot;/usr/local/lib/python3.8/json/decoder.py&quot;, line 355, in raw_decode&#xA;    raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None&#xA;json.decoder.JSONDecodeError: Expecting value: line 1 column 2 (char 1)&#xA;</code></pre>&#xA;<p>Can anyone see what I'm doing wrong?&#xA;Thanks!</p>&#xA;",8338956,,8338956,2020-10-08 12:12:05,2020-10-08 12:12:05,How can I write a multipart (data and files) GraphQL request in axios?,<vue.js><axios><graphql>,0,3,0,2020-10-08 10:55:58
64299728,2,,64299685,2,,"<p>You need to define the variable in the top level query before you can use it inside the query body.</p>&#xA;<pre><code>query($max: Int) {&#xA;  boards(limit: $max) {&#xA;    items(limit: $max) {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><sub>New line characters added for readability. You can collapse this to one line for your actual code.</sub></p>&#xA;<p>The difference here is the <code>($max: Int)</code> after <code>query</code>. That let's the graphql engine know that some variables will be used and what their type is. I'm assuming for your example that the variable is an integer.</p>&#xA;<hr />&#xA;<p>Also, when you submit your variables, make sure you keep the data as an integer.</p>&#xA;<pre><code>Variables = new&#xA;{&#xA;   max = 1 // don't quote this&#xA;}&#xA;</code></pre>&#xA;<p>You've got three places where the types need to line up correctly.</p>&#xA;<ol>&#xA;<li>The <code>Variables</code> property of the GraphQLRequest</li>&#xA;<li>The declaration of the variable in <code>query()</code></li>&#xA;<li>The expected type for the arguments you are using.</li>&#xA;</ol>&#xA;<p>Double check that the <code>limit</code> arguments of BOTH <code>boards()</code> and <code>items()</code> is an <code>Int</code>, and not for some reason another data type (like String).</p>&#xA;",1043380,,1043380,2020-10-11 01:25:22,2020-10-11 01:25:22,"",,0,1,0,2020-10-11 01:02:55
64300602,1,,,0,3302,"<p>I've seen several useful posts on how to create schemas in AWS-Amplify's GrahphQL API package that will return a sorted response. In brief, if you have the following in your <code>schema.graphql</code> file</p>&#xA;<pre><code>type Record @model&#xA;@key(name: &quot;byDateCreated&quot;, fields: [&quot;status&quot;, &quot;createdAt&quot;], queryField: &quot;RecordsByDateCreated&quot;) {&#xA;    id: ID!&#xA;    status: RecordStatus!&#xA;    description: String!&#xA;    createdAt: String&#xA;}&#xA;</code></pre>&#xA;<p>It will create a custom query called <code>recordsByDateCreated</code>. Using it as follows (js here, folks):</p>&#xA;<pre><code>await API.graphql(graphqlOperation(recordsByDateCreated, { status: 'unused', limit: 10 }));&#xA;</code></pre>&#xA;<p>will return the first 10 records in the table sorted by their <code>createdAt</code> values. By default, this data will be returned in <strong>ascending</strong> order, which means that you'll get the <strong>oldest</strong> records first.</p>&#xA;<p>However, what I need is a response that has the newest records first. What do I have to add to in schema or my query so I can set the order of the sorting?</p>&#xA;",1218746,,,,2021-09-12 16:38:17,How to control sort direction in a list query in AWS-Amplify with GraphQL,<javascript><graphql><aws-amplify>,2,0,0,2020-10-11 04:28:15
64300603,2,,64300602,2,,"<p><strong>(Spoiler alert: I'm answering my own question here in case anyone else is looking for help with this.)</strong></p>&#xA;<p>You would need a way to order the table's records in <strong>descending</strong> order. If you go and look at the file generated by AWS-Amplify you'll see that the new query you've created accepts a series of arguments:</p>&#xA;<pre><code>export const recordsByDateCreated = /* GraphQL */ `&#xA;  query RecordsByDateCreated(&#xA;    $status: RecordStatus&#xA;    $createdAt: ModelStringKeyConditionInput&#xA;    $sortDirection: ModelSortDirection&#xA;    $filter: ModelRecordFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    RecordsByDateCreated(&#xA;      status: $status&#xA;      createdAt: $createdAt&#xA;      sortDirection: $sortDirection&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        description&#xA;        status&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>It turns out that if you know what the possible values are for <code>ModelSortDirection</code> (they are are 'ASC' and 'DESC') you can pass one in as one of the variables arguments when you make that query like so:</p>&#xA;<pre><code>await API.graphql(graphqlOperation(recordsByDateCreated, { status: 'unused', limit: 10, sortDirection: 'DESC' }));&#xA;</code></pre>&#xA;<p>(Note that the key for the variable you're passing is <code>sortDirection</code> and not <code>$sortDirection</code>, or <code>ModelSortDirection</code>.)</p>&#xA;<p>I couldn't find this in AWS-Amplify's docs and relied on other posts that I've found. If you've found any documentation relevant to this then maybe you could add a link in the comments.</p>&#xA;",1218746,,,,2020-10-11 04:28:15,"",,0,0,0,2020-10-11 04:28:15
64305719,1,,,0,231,"<p><strong>Given the following schema:</strong></p>&#xA;<pre><code>input CreateSurveysInput {&#xA;    uuid: String!&#xA;    year: Int!&#xA;    geocode: AWSJSON!&#xA;    metadata: AWSJSON!&#xA;    observations: AWSJSON!&#xA;    report_url: String&#xA;    survey_date: String!&#xA;    video_url: String!&#xA;}&#xA;&#xA;input CreateWaterQualityInput {&#xA;    uuid: String!&#xA;}&#xA;&#xA;input DeleteSurveysInput {&#xA;    uuid: String!&#xA;    year: Int!&#xA;}&#xA;&#xA;input DeleteWaterQualityInput {&#xA;    uuid: String!&#xA;}&#xA;&#xA;type Mutation {&#xA;    createSurveys(input: CreateSurveysInput!): Surveys&#xA;    updateSurveys(input: UpdateSurveysInput!): Surveys&#xA;    deleteSurveys(input: DeleteSurveysInput!): Surveys&#xA;    createWaterQuality(input: CreateWaterQualityInput!): WaterQuality&#xA;    updateWaterQuality(input: UpdateWaterQualityInput!): WaterQuality&#xA;    deleteWaterQuality(input: DeleteWaterQualityInput!): WaterQuality&#xA;}&#xA;&#xA;type Query {&#xA;    getSurveys(year: Int!, uuid: String!): Surveys&#xA;    listSurveys(filter: TableSurveysFilterInput, limit: Int, nextToken: String): SurveysConnection&#xA;    getWaterQuality(uuid: String!): WaterQuality&#xA;    listWaterQualities(filter: TableWaterQualityFilterInput, limit: Int, nextToken: String): WaterQualityConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreateSurveys(&#xA;        uuid: String,&#xA;        year: Int,&#xA;        geocode: AWSJSON,&#xA;        metadata: AWSJSON,&#xA;        observations: AWSJSON&#xA;    ): Surveys&#xA;        @aws_subscribe(mutations: [&quot;createSurveys&quot;])&#xA;    onUpdateSurveys(&#xA;        uuid: String,&#xA;        year: Int,&#xA;        geocode: AWSJSON,&#xA;        metadata: AWSJSON,&#xA;        observations: AWSJSON&#xA;    ): Surveys&#xA;        @aws_subscribe(mutations: [&quot;updateSurveys&quot;])&#xA;    onDeleteSurveys(&#xA;        uuid: String,&#xA;        year: Int,&#xA;        geocode: AWSJSON,&#xA;        metadata: AWSJSON,&#xA;        observations: AWSJSON&#xA;    ): Surveys&#xA;        @aws_subscribe(mutations: [&quot;deleteSurveys&quot;])&#xA;    onCreateWaterQuality(uuid: String): WaterQuality&#xA;        @aws_subscribe(mutations: [&quot;createWaterQuality&quot;])&#xA;    onUpdateWaterQuality(uuid: String): WaterQuality&#xA;        @aws_subscribe(mutations: [&quot;updateWaterQuality&quot;])&#xA;    onDeleteWaterQuality(uuid: String): WaterQuality&#xA;        @aws_subscribe(mutations: [&quot;deleteWaterQuality&quot;])&#xA;}&#xA;&#xA;type Surveys {&#xA;    uuid: String!&#xA;    year: Int!&#xA;    geocode: AWSJSON!&#xA;    metadata: AWSJSON!&#xA;    observations: AWSJSON!&#xA;    report_url: String&#xA;    survey_date: String!&#xA;    video_url: String!&#xA;}&#xA;&#xA;type SurveysConnection {&#xA;    items: [Surveys]&#xA;    nextToken: String&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    contains: Float&#xA;    notContains: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    contains: Int&#xA;    notContains: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;}&#xA;&#xA;input TableSurveysFilterInput {&#xA;    uuid: TableStringFilterInput&#xA;    year: TableIntFilterInput&#xA;    report_url: TableStringFilterInput&#xA;    survey_date: TableStringFilterInput&#xA;    video_url: TableStringFilterInput&#xA;}&#xA;&#xA;input TableWaterQualityFilterInput {&#xA;    uuid: TableStringFilterInput&#xA;}&#xA;&#xA;input UpdateSurveysInput {&#xA;    uuid: String!&#xA;    year: Int!&#xA;    geocode: AWSJSON&#xA;    metadata: AWSJSON&#xA;    observations: AWSJSON&#xA;    report_url: String&#xA;    survey_date: String&#xA;    video_url: String&#xA;}&#xA;&#xA;input UpdateWaterQualityInput {&#xA;    uuid: String!&#xA;}&#xA;&#xA;type WaterQuality {&#xA;    uuid: String!&#xA;    flow: AWSJSON!&#xA;    free_chlorine: AWSJSON!&#xA;    location: String!&#xA;    ph: AWSJSON!&#xA;    pressure: AWSJSON!&#xA;    temperature: AWSJSON!&#xA;    timestamp: Int!&#xA;}&#xA;&#xA;type WaterQualityConnection {&#xA;    items: [WaterQuality]&#xA;    nextToken: String&#xA;}&#xA;</code></pre>&#xA;<p>...and the following resolver attached to the list query <strong>listWaterQualities</strong>:</p>&#xA;<pre><code>{&#xA;  &quot;version&quot;: &quot;2017-02-28&quot;,&#xA;  &quot;operation&quot;: &quot;Scan&quot;,&#xA;  &quot;filter&quot;: #if($context.args.filter) $util.transform.toDynamoDBFilterExpression($ctx.args.filter) #else null #end,&#xA;  &quot;limit&quot;: $util.defaultIfNull($ctx.args.limit, 20),&#xA;  &quot;nextToken&quot;: $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null)),&#xA;}&#xA;&#xA;$util.toJson($context.result.items)&#xA;</code></pre>&#xA;<p><strong>...and the following db table structure (primary key uuid):</strong></p>&#xA;<pre><code>{&#xA;  &quot;flow&quot;: {&#xA;    &quot;raw&quot;: 7.1148501551630785,&#xA;    &quot;value&quot;: 113.83760248260926&#xA;  },&#xA;  &quot;free_chlorine&quot;: {&#xA;    &quot;raw&quot;: 0.35,&#xA;    &quot;value&quot;: 0.35&#xA;  },&#xA;  &quot;location&quot;: &quot;mars&quot;,&#xA;  &quot;ph&quot;: {&#xA;    &quot;raw&quot;: 0.2,&#xA;    &quot;value&quot;: -6.15152&#xA;  },&#xA;  &quot;pressure&quot;: {&#xA;    &quot;raw&quot;: 13248.528910641011,&#xA;    &quot;value&quot;: 86.19716484615098&#xA;  },&#xA;  &quot;temperature&quot;: {&#xA;    &quot;raw&quot;: 684.7506156784981,&#xA;    &quot;value&quot;: 16.883287645632485&#xA;  },&#xA;  &quot;timestamp&quot;: 1602381709752,&#xA;  &quot;uuid&quot;: &quot;008b5a2ad27b42b8a311f021510fca87&quot;&#xA;}&#xA;</code></pre>&#xA;<p><strong>...and running the query in both the AppSync Console and via code. Im getting a timeout.</strong></p>&#xA;<pre><code>content-length: 1033&#xA;content-type: text/html&#xA;date: Sun, 11 Oct 2020 15:09:06 GMT&#xA;server: CloudFront&#xA;status: 504&#xA;via: 1.1 xxxxxxx.cloudfront.net (CloudFront)&#xA;x-amz-cf-id: xxxxxxx_2whgDivdLvdgGMRHz7O6g1d-5CSiBX0xVLXhIvfhQA==&#xA;x-amz-cf-pop: DFW3-C1&#xA;x-cache: Error from cloudfront&#xA;</code></pre>&#xA;<p>Apologies if this has already been addressed but i couldn't find a relevant solution, can anyone spot my error/issue.  Something I am overlooking, or obvious as the cause of the error?</p>&#xA;<p>As always thanks for any and all feedback and thanks in advance!</p>&#xA;",965901,,,,2020-10-11 21:17:43,AWS AppSync list query erring out with 504 in console and code,<amazon-web-services><graphql><aws-amplify><aws-appsync>,1,0,0,2020-10-11 15:23:06
64309524,1,,,0,115,"<p>I am using Amplify and therefore DynamoDB. I believe I have a fairly simple schema setup, but coming from MySQL my brain is going a little screw!!</p>&#xA;<p>The basic setup (a football league) is,</p>&#xA;<pre><code>[League]&#xA;   [Season]&#xA;     [Divisions]&#xA;        [Teams]&#xA;           [Club]&#xA;              [Ground]&#xA;[Club]&#xA;  [Teams]&#xA;     [TeamConnection] (I needed a connection schema as a team can belong to multiple divisions/seasons/leagues. I could not think of another way to connect this on the `Team` model)&#xA;        [League]&#xA;        [Season]&#xA;        [Division]&#xA;</code></pre>&#xA;<p>Schemas</p>&#xA;<pre><code>    ....&#xA;    Other Schemas&#xA;    ...&#xA;type Club @model @key(name: &quot;byClub&quot;, fields: [&quot;leagueID&quot;, &quot;name&quot;])&#xA;    {&#xA;      id: ID!&#xA;      name: String!&#xA;      leagueID: ID!&#xA;      leagues: [League] @connection(fields: [&quot;leagueID&quot;])&#xA;      teams: [Team] @connection(keyName: &quot;byTeams&quot;, fields: [&quot;id&quot;])&#xA;      grounds: [Ground] @connection(keyName: &quot;byGround&quot;, fields: [&quot;id&quot;])&#xA;    }&#xA;&#xA;enum TeamGender {&#xA;      Male&#xA;      Female&#xA;    }&#xA;    &#xA;type Team @model&#xA;      @key(name: &quot;byTeamsClubId&quot;, fields: [&quot;clubID&quot;])&#xA;      @key(name: &quot;byTeams&quot;, fields: [&quot;clubID&quot;, &quot;name&quot;])&#xA;      {&#xA;        id: ID!&#xA;        name: String!&#xA;        faId: ID!&#xA;        clubID: ID!&#xA;        club: Club @connection(fields: [&quot;clubID&quot;])&#xA;        teamDetails: [TeamConnection] @connection(keyName: &quot;byTeamsConnection&quot;, fields: [&quot;id&quot;])&#xA;        gender: TeamGender!&#xA;      }&#xA;&#xA;type TeamConnection @model @key(name: &quot;byTeamsConnection&quot;, fields: [&quot;teamID&quot;,&quot;seasonID&quot;, &quot;leagueID&quot;, &quot;divisionID&quot;])&#xA;    &#xA;    {&#xA;      id: ID!&#xA;      teamID: ID!&#xA;      leagueID: ID!&#xA;      seasonID: ID!&#xA;      divisionID: ID!&#xA;      leagues: [League] @connection(fields: [&quot;leagueID&quot;])&#xA;      teams: [Team] @connection(fields: [&quot;teamID&quot;])&#xA;      seasons: [Season] @connection(fields: [&quot;seasonID&quot;])&#xA;      divisions: [Division] @connection(fields: [&quot;divisionID&quot;])&#xA;    }&#xA;&#xA;type Ground @model @key(name: &quot;byGround&quot;, fields: [&quot;clubID&quot;, &quot;name&quot;])&#xA;&#xA;    {&#xA;      id: ID!&#xA;      name: String!&#xA;      address1: String&#xA;      address2: String&#xA;      town: String&#xA;      postcode: String&#xA;      rating: Int&#xA;      type: String&#xA;      link: String&#xA;      clubID: ID!&#xA;      clubs: [Club] @connection(fields: [&quot;clubID&quot;])&#xA;    }&#xA;&#xA;</code></pre>&#xA;<h2>Error</h2>&#xA;<p>This query works with no error</p>&#xA;<pre><code>//$leagueID: ''&#xA;export const LIST_CLUBS = /* GraphQL */ `&#xA;  query ListClubs($leagueID: ID) {&#xA;    listClubs(filter: { leagueID: { eq: $leagueID } }) {&#xA;      items {&#xA;        name&#xA;        leagueID&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>This is the auto generated query used. If I used the <strong>below query</strong>, then the error seen below will kick in. This does confuse me.</p>&#xA;<pre><code>&#xA;//filter: { leagueID: { eq: leagueID } },&#xA;&#xA;    export const listClubs = /* GraphQL */ `&#xA;      query ListClubs(&#xA;        $filter: ModelClubFilterInput&#xA;        $limit: Int&#xA;        $nextToken: String&#xA;      ) {&#xA;        listClubs(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;          items {&#xA;            id&#xA;            name&#xA;            leagueID&#xA;            leagues {&#xA;              items {&#xA;                id&#xA;                name&#xA;                faId&#xA;                logo&#xA;                seasons {&#xA;                  items {&#xA;                    id&#xA;                    name&#xA;                    faId&#xA;                    yearStart&#xA;                    yearEnd&#xA;                    leagueID&#xA;                    createdAt&#xA;                    updatedAt&#xA;                  }&#xA;                  nextToken&#xA;                }&#xA;                division {&#xA;                  items {&#xA;                    id&#xA;                    name&#xA;                    faId&#xA;                    divisionSeasonFaId&#xA;                    leagueID&#xA;                    seasonID&#xA;                    ageInput&#xA;                    level&#xA;                    createdAt&#xA;                    updatedAt&#xA;                  }&#xA;                  nextToken&#xA;                }&#xA;                createdAt&#xA;                updatedAt&#xA;              }&#xA;              nextToken&#xA;            }&#xA;            teams {&#xA;              items {&#xA;                id&#xA;                name&#xA;                faId&#xA;                clubID&#xA;                club {&#xA;                  id&#xA;                  name&#xA;                  leagueID&#xA;                  leagues {&#xA;                    nextToken&#xA;                  }&#xA;                  teams {&#xA;                    nextToken&#xA;                  }&#xA;                  grounds {&#xA;                    nextToken&#xA;                  }&#xA;                  createdAt&#xA;                  updatedAt&#xA;                }&#xA;                teamDetails {&#xA;                  items {&#xA;                    id&#xA;                    teamID&#xA;                    leagueID&#xA;                    seasonID&#xA;                    divisionID&#xA;                    createdAt&#xA;                    updatedAt&#xA;                  }&#xA;                  nextToken&#xA;                }&#xA;                gender&#xA;                createdAt&#xA;                updatedAt&#xA;              }&#xA;              nextToken&#xA;            }&#xA;            grounds {&#xA;              items {&#xA;                id&#xA;                name&#xA;                address1&#xA;                address2&#xA;                town&#xA;                postcode&#xA;                rating&#xA;                type&#xA;                link&#xA;                clubID&#xA;                clubs {&#xA;                  items {&#xA;                    id&#xA;                    name&#xA;                    leagueID&#xA;                    createdAt&#xA;                    updatedAt&#xA;                  }&#xA;                  nextToken&#xA;                }&#xA;                createdAt&#xA;                updatedAt&#xA;              }&#xA;              nextToken&#xA;            }&#xA;            createdAt&#xA;            updatedAt&#xA;          }&#xA;          nextToken&#xA;        }&#xA;      }&#xA;    `;&#xA;&#xA;</code></pre>&#xA;<p>//Console</p>&#xA;<pre><code>Error: GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;GraphQL error: Query condition missed key schema element&#xA;    at new ApolloError (/var/www/co.uk/node_modules/apollo-client/bundle.umd.js:92:26)&#xA;</code></pre>&#xA;<p>Query working as mentioned above.&#xA;<a href=""https://i.stack.imgur.com/3iWlx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3iWlx.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Errors returned from GraphIQL</p>&#xA;<p><a href=""https://i.stack.imgur.com/jHnRH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jHnRH.png"" alt=""enter image description here"" /></a>&#xA;However frustratingly, which I did not know. The data is actually returned, plus the errors at the end.</p>&#xA;<p><a href=""https://i.stack.imgur.com/HKe5C.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HKe5C.png"" alt=""enter image description here"" /></a></p>&#xA;",240363,,240363,2020-10-11 23:06:48,2020-10-11 23:06:48,Error: GraphQL error: Query condition missed key schema element,<amazon-web-services><graphql><amazon-dynamodb><aws-amplify>,0,11,0,2020-10-11 22:15:28
64323329,1,64323648,,1,104,"<p>I have the following GraphQL query:</p>&#xA;<pre><code>query workflowState($id: String!, $after: String!){&#xA;    workflowState(id: $id) {&#xA;    issues(after: $after) {&#xA;      pageInfo {&#xA;        hasNextPage,&#xA;        endCursor&#xA;      }&#xA;      nodes {&#xA;        id&#xA;        title&#xA;        labels{&#xA;          nodes {&#xA;            id,&#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The first time I run the query I do not want to pass <code>after</code> to the <code>issues</code> I would like to get all issues from the beginning.</p>&#xA;<p>When I parse the response, if <code>hasNextPage</code> is true I would like to call the query again and this time pass <code>endCursor</code> to <code>after</code> so I get the next set of paginated results.</p>&#xA;<p>I can successfully parse the response and make the second call but&#xA;how do I go about making the first call that does not have and <code>after</code> value?</p>&#xA;<p>I have tried passing an empty or non-existent UUID, and I get the error: <code>Invalid input: after must be an UUID</code></p>&#xA;",1076173,,,,2020-10-12 18:47:47,GraphQL - optional after value,<graphql>,1,2,0,2020-10-12 18:23:24
64329321,2,,64328105,0,,"<p>I solved this by rewriting part of the code:</p>&#xA;<pre><code>  const results = await session&#xA;    .run(cypher, { idA, idsB })&#xA;    .then((result) =&gt; {&#xA;      return result.records.map((record) =&gt; {&#xA;        // diff start&#xA;        const obj = record.toObject()&#xA;        const bs = obj.bs.map((b) =&gt; b.properties)&#xA;        return {&#xA;          bs, // diff end&#xA;          score: record.get('score')?.low || null,&#xA;        }&#xA;      })&#xA;    })&#xA;    .catch(console.log)&#xA;    .then((results) =&gt; {&#xA;      session.close()&#xA;      console.log(results)&#xA;      return results&#xA;    })&#xA;  return results&#xA;</code></pre>&#xA;",2942471,,,,2020-10-13 05:52:31,"",,0,0,0,2020-10-13 05:52:31
64353404,2,,51927420,1,,"<p>In the meantime I came to another conclusion: I think it doesn't really matter whether you use an all-in-one cursor, or if you repeat <code>filter</code> and <code>orderBy</code> with each request.</p>&#xA;<p>There are basically two types of cursors:</p>&#xA;<p>(1.) You can treat a cursor as a <em>&quot;pointer to a specific item&quot;</em>. This way the filter and sorting can change, but your cursor can stay the same. Kinda like the pivot element in quicksort, where the pivot element stays in place and everything around it can move.</p>&#xA;<p><a href=""https://www.elastic.co/guide/en/elasticsearch/reference/7.9/paginate-search-results.html#search-after"" rel=""nofollow noreferrer"">Elasticsearch's Search After</a> works like this. Here the <code>cursor</code> is just a pointer to a specific item in the dataset. But <code>filter</code> and <code>orderBy</code> can change independently.</p>&#xA;<p>The implementation for this style of cursor is dead simple: Just concat <strong>every</strong> sortable field. Done. <em>Example:</em> If your entity can be sorted by <code>price</code> and <code>title</code> (plus of course <code>id</code>, because you need some unique field as tie breaker), your cursor always consists of <code>{ id, price, title }</code>.</p>&#xA;<p>(2.) The <em>&quot;all-in-one cursor&quot;</em> on the other hand acts like a <em>&quot;pointer to an item within a filtered and sorted result set&quot;</em>. It has the benefit, that you can encode whatever you want. The server could for example change the <code>filter</code> and <code>orderBy</code> data (for whatever reason) without the client noticing it.</p>&#xA;<p>For example you could use <a href=""https://www.elastic.co/guide/en/elasticsearch/reference/current/scroll-api.html"" rel=""nofollow noreferrer"">Elasticsearch's Scroll API</a>, which caches the result set on the server and though doesn't need <code>filter</code> and <code>orderBy</code> after the initial search request.</p>&#xA;<p>But aside from Elasticsearch's Scroll API, you always need <code>filter</code>, <code>orderBy</code>, <code>limit</code>, <code>pointer</code> in every request. Though I think it's an implementation detail and a matter of taste, whether you include everything within your <code>cursor</code>, or if you send it as separate arguments. The outcome is the same.</p>&#xA;",1321564,,1321564,2020-10-15 18:00:40,2020-10-15 18:00:40,"",,0,0,0,2020-10-14 12:36:32
64354518,1,,,0,321,"<p>Let's say I've got a top-level query and a sub-component with a fragment like follows:</p>&#xA;<pre><code>export const HomePageQuery = graphql`&#xA;    query HomePageQuery {&#xA;        viewer {&#xA;            ...SubComponent_viewer&#xA;        }&#xA;    }&#xA;`&#xA;&#xA;// then a sub-component with&#xA;const SubComponentWithFragment = createFragmentContainer(SubComponent, {&#xA;    viewer: graphql`&#xA;        fragment SubComponent_viewer on Viewer {&#xA;            me {&#xA;                someImportantValue&#xA;            }&#xA;        }&#xA;    `&#xA;})&#xA;</code></pre>&#xA;<p>I want to call <code>HomePageQuery</code> imperatively, and then once I get the result do something with <code>someImportantValue</code>.</p>&#xA;<p>So I tried this:</p>&#xA;<pre><code>// This is a Relay Environment using react-relay-network-modern w/ some middleware&#xA;// can give implementation details if required but didn't think necessary&#xA;import relayEnv from 'Relay/createRelayEnvironment'&#xA;&#xA;const data = await fetchQuery(relayEnv.environment, HomePageQuery, {})&#xA;console.log(data)&#xA;</code></pre>&#xA;<p>This then returns me the result, but still broken down into fragments. e.g.</p>&#xA;<pre><code>{ viewer:&#xA;   {&#xA;    __fragments: {SubComponent_viewer: {…}}&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Is there a way to get the response from this as you'd find in graphiQL? e.g.</p>&#xA;<pre><code>{&#xA;  viewer: {&#xA;    me: {&#xA;       someImportantValue: 39&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I <em>could</em> try and navigate my way through the fragments to find what I need, but this seems over-complicated and would be fragile to changes in component structure.</p>&#xA;<p>Is my only option to fetch it from the local store afterwards?</p>&#xA;<p>Currently using Relay v7</p>&#xA;",4388938,,,,2020-10-22 17:33:31,Relay fetchQuery: How to get result of query without fragment structure,<graphql><relayjs><relay>,1,0,0,2020-10-14 13:35:43
64354558,2,,64325611,0,,"<p>You cannot wrap apollo query in an <code>if</code> statement. You can use <a href=""https://apollo.vuejs.org/guide/apollo/queries.html#skipping-the-query"" rel=""nofollow noreferrer"">skip</a> instead. In your example it would be like this:</p>&#xA;<pre><code>listItems: {&#xA; query() { &#xA;  return gql`&#xA;    {&#xA;      bills {&#xA;        billId&#xA;        order {&#xA;          orderId&#xA;          customer {&#xA;            customerId&#xA;            billingAddress {&#xA;              title&#xA;            }&#xA;          }&#xA;        }&#xA;        createdAt&#xA;      }&#xA;    }`&#xA; },&#xA; skip() {&#xA;  return this.listType != &quot;bills&quot;&#xA;}&#xA;</code></pre>&#xA;<p>}</p>&#xA;",12464900,,,,2020-10-14 13:37:57,"",,0,2,0,2020-10-14 13:37:57
64356954,1,,,0,51,"<p>I have a query,</p>&#xA;<pre><code>query {&#xA;    foo {&#xA;        baz&#xA;&#xA;        bar (barBaz: baz) {&#xA;            ...&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>How would I get the value of <code>foo.baz</code> to then use it as a filter in <code>foo.bar</code>?</p>&#xA;",2518552,,,,2020-10-14 15:42:59,Use parent scope field as variable in inner scope,<graphql>,0,3,0,2020-10-14 15:42:59
64360929,2,,64360239,0,,"<blockquote>&#xA;<p>I would like to return all orders with the same customer_id appears more than one. ...</p>&#xA;</blockquote>&#xA;<blockquote>&#xA;<p>So the order for custmer_id = &quot;bbbbbbbb&quot; has to be eliminated since this customer_id appears only once.</p>&#xA;</blockquote>&#xA;<blockquote>&#xA;<p>How to write the GraphQL query?</p>&#xA;</blockquote>&#xA;<p><strong>graphql is not for that</strong></p>&#xA;<p>Filtering, searching, counting ... is <strong>out of graphql specs</strong>. There is <strong>no standarized params or syntax for this requirements</strong>.</p>&#xA;<p><strong>It's resolver role to perform actions/bussiness logic</strong> [in reaction on some parameters/variables - data-driven actions].</p>&#xA;<p>In this case you can use some 'filter flag', f.e. 'recurringOnly' (not required, false default), for 'orders' resolver. When query will contain <code>true</code> value for this flag:</p>&#xA;<pre><code>query{&#xA;  orders(recurringOnly: true) {&#xA;</code></pre>&#xA;<p>... resolver should filter out non-recurring entries ... how? depends on server/service implementation details/DB/ORM/libs/whatever used to resolve data/results.</p>&#xA;",6124657,,,,2020-10-14 20:19:06,"",,0,0,0,2020-10-14 20:19:06
64370842,1,,,3,1670,"<p>I have a query that takes input params, say date</p>&#xA;<pre><code>  const { loading, data, error } = useQuery(GET_LIST, {&#xA;    variables: {&#xA;      input: {&#xA;        date: date,&#xA;      },&#xA;    },&#xA;  });&#xA;&#xA;</code></pre>&#xA;<pre><code>export const GET_LIST = gql`&#xA;  query list($input: ListParams) {&#xA;    list(input: $input) {&#xA;      totalCount&#xA;      recordCount&#xA;      list {&#xA;        listId&#xA;        date&#xA;        qty&#xA;        amount&#xA;        currency&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<pre><code>input ListParams {&#xA;  date: String&#xA;}&#xA;</code></pre>&#xA;<p>I need to fetch the list, where the user can filter based on date. Now on initial load, date is not set, query is called. The user sets a date, no issues, the query is called again with the the date value, now when the user removes the date filter, the date value becomes undefined, and I would expect useQuery to be called again with no variables this time, but it is never called.</p>&#xA;<p>I have tried setting empty string as well, even then useQuery does not get called which is not the intended behaviour</p>&#xA;<pre><code> input: {&#xA;        date: date||'',&#xA;      },&#xA;</code></pre>&#xA;",8036199,,,,2022-06-28 08:19:00,useQuery does not trigger when a variable in input object is set to undefined or empty string,<graphql><apollo><react-apollo><apollo-client>,1,0,0,2020-10-15 11:42:14
64373379,1,73815764,,2,165,"<p>I have been looking for a way to paginate on a standard relay graphql query, rather than creating a fragment and paginating on that. I havent really been able to find any documentation on how to achieve such a thing. I just want to run the query, come up with the first <code>n</code> records, and then run the query again (although i read thats not necessarily best practice, and then load the next 20 but increasing the count and running the query... has anyone done such a thing?</p>&#xA;<p>What I want in theory is...</p>&#xA;<pre><code>  const = useLazyLoadQuery{&#xA;    data,&#xA;    loadNext,&#xA;    loadPrevious,&#xA;    hasNext,&#xA;    hasPrevious,&#xA;    isLoadingNext,&#xA;    isLoadingPrevious,&#xA;    refetch, // For refetching connection&#xA;  } = usePaginationFragment(&#xA;    graphql`&#xA;      fragment Table_user on User&#xA;      @refetchable(queryName: &quot;UserQuery&quot;)&#xA;      @argumentDefinitions(&#xA;        count: { type: &quot;Int&quot;, defaultValue: 20 }&#xA;        cursor: { type: &quot;String&quot; }&#xA;      ) {&#xA;      query UserQuery(&#xA;          $first: Int!,&#xA;          $after: String&#xA;    ) {&#xA;      users(search: $search) {&#xA;      id&#xA;      name&#xA;      phone&#xA;      email&#xA;      postalCode&#xA;      status&#xA;      referralCode&#xA;      products&#xA;      updatedAt&#xA;      nextAssignmentOn&#xA;    }&#xA;   }&#xA;  }&#xA;</code></pre>&#xA;<p>I'm sure theres a way to do this, but many attempts have failed</p>&#xA;",6388582,,,,2022-09-22 13:44:17,React Relay paginate on a query instead of a fragment,<graphql><apollo><relayjs><relay>,1,0,0,2020-10-15 14:07:05
64379032,2,,64337332,0,,"<p>I wasn't able to find any Apollo Server architecture to help implement this feature. So I decided to use this simplified approach:</p>&#xA;<pre><code>class CustomDataSource extends DataSource {&#xA;  // Override this method in MyProjectDataSource (optional).&#xA;  static onFilterEvent(args, info, eargs) {&#xA;    return eargs;&#xA;  }&#xA;&#xA;  // Add filter.&#xA;  eargs = { filter: get(args, 'filter') };&#xA;  eargs = this.constructor.onFilterEvent(this.args, this.info, eargs);&#xA;  if (eargs.filter) {&#xA;    // Run database query with modified filter in eargs.filter.&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre><code>class MyProjectDataSource extends CustomDataSource {&#xA;  static onFilterEvent(args, info, eargs) {&#xA;    eargs.filter = { isDeleted: false }; // TODO: If existing filter then use and clause.&#xA;    return eargs;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",464435,,,,2020-10-15 20:12:56,"",,0,0,0,2020-10-15 20:12:56
64405463,1,64408297,,4,8175,"<p>I've following component, which has a <code>date</code> variable. On each re render, <code>date</code> variable is getting updated. Now the the problem is as I've assigned date to a query variable, graphql fetches again and again infinitely. I have debugged the code and found apollo is Observing on <code>date</code> variable, when it is receiving a new value, it is to re.</p>&#xA;<pre><code>import React from 'react';&#xA;import { getISODate } from '../../dateUtils';&#xA;import { useQuery } from '@apollo/react-hooks';&#xA;import { GET_EXPENSE_STATUS } from '../../queries';&#xA;import get from 'lodash/get';&#xA;&#xA;const ExpenseStatus = (props) =&gt; {&#xA;  const date = getISODate(); // returns current date as ISO String Format&#xA;  const { loading, error, data } = useQuery(GET_EXPENSE_STATUS, {&#xA;    variables: {&#xA;      date&#xA;    }&#xA;  });&#xA;  if (error) return &lt;p&gt;Error :(&lt;/p&gt;;&#xA;  return(&#xA;    &lt;div&gt;&#xA;       {get(data, 'expenseStatus.value')}&#xA;    &lt;/div&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>I also tried with <code>useLazyQuery</code>. But no luck.</p>&#xA;<pre><code> const date = getISODate(); // returns current date in ISO String&#xA;&#xA; const [loadExpenseStatus, { loading, error, data }] = useLazyQuery(GET_EXPENSE_STATUS, {&#xA;     variables: {&#xA;       date&#xA;     }&#xA; });&#xA;&#xA; useEffect(() =&gt; {&#xA;   if(!called) {&#xA;     loadExpenseStatus();&#xA;   }&#xA; }, []);&#xA;</code></pre>&#xA;<p>So, Is there any way, I can skip this Observer? I just want to receive the fetch call once.</p>&#xA;",3445573,,,,2021-02-10 15:45:46,How to restrict api call by useQuery to be called only once?,<reactjs><graphql><react-apollo><apollo-client>,1,10,0,2020-10-17 17:41:57
64406791,1,64415763,,0,354,"<p>For example, I want to flatten an array of lists returned by the query at <strong>build time</strong> before it is available to the page component, <em>ie</em>, without having to do it client side on every request.&#xA;Is there a lifecycle method or middleware where this can be done?</p>&#xA;",5125032,,,,2020-10-18 16:38:54,Gatsby: Transforming data returned from a page query at build time,<reactjs><graphql><gatsby>,1,0,0,2020-10-17 20:02:04
64408830,2,,50204685,0,,<p>I fixed this by changing the variable type of ID from <code>Int</code> to <code>Float</code></p>&#xA;,14470335,,,,2020-10-18 01:18:59,"",,0,0,0,2020-10-18 01:18:59
64415757,2,,56001993,1,,"<p>If you decorate your query with <code>@connection</code>, then you can use the <code>ConnectionHandler</code> to easily remove records:</p>&#xA;<pre><code>const query = graphql`query WidgetListQuery {&#xA;    widgets(first: 10) @connection(key: &quot;WidgetList_widgets&quot;) {&#xA;        ...&#xA;    }&#xA;}`&#xA;</code></pre>&#xA;<pre><code>optimisticUpdater(store) {&#xA;    const widgets = ConnectionHandler.getConnection(store.getRoot(), 'WidgetList_widgets');&#xA;    ConnectionHandler.deleteNode(widgets, deleted_widget.id)&#xA;}&#xA;</code></pre>&#xA;",6653955,,,,2020-10-18 16:38:32,"",,0,0,0,2020-10-18 16:38:32
64419467,1,64419755,,0,299,"<p>I have months of experience of using relay graphql. I continue the project from another dev that is leaving, I use one QueryRenderer on every page and pour the data fetched from the main query as a plain object as props to every child component, I see no problem here. But I see people are using fragments and suggesting fragments heavily. I think it's just more typings and real waste. I don't really understand, we can just put the data as a prop to every child component, so why people really need a fragment? is there a technical benefit that I miss?</p>&#xA;",9822382,,,,2020-10-19 00:43:35,What is benefit of relay graphql fragment?,<reactjs><graphql><relayjs><relay>,1,0,0,2020-10-18 23:55:56
64419520,2,,64065427,0,,"<p>You can follow the example from <a href=""https://relay.dev/docs/en/query-renderer"" rel=""nofollow noreferrer"">official docs</a></p>&#xA;<pre><code>import React from 'react';&#xA;import { QueryRenderer, graphql } from 'react-relay';&#xA; &#xA;const Example = (props) =&gt; {&#xA;  return (&#xA;    &lt;QueryRenderer&#xA;      environment={environment}&#xA;      query={graphql`&#xA;        query ExampleQuery($pageID: ID!) {&#xA;          page(id: $pageID) {&#xA;            name&#xA;          }&#xA;        }&#xA;      `}&#xA;      variables={{&#xA;        pageID: '110798995619330',&#xA;      }}&#xA;      render={({ props }) =&gt; {&#xA;        if (props) {&#xA;          return &lt;ChildComponent page={page.name} /&gt;;&#xA;        }&#xA;        return &lt;div&gt;Loading&lt;/div&gt;;&#xA;      }}&#xA;    /&gt;&#xA;  );&#xA;}&#xA;</code></pre>&#xA;<p>you can consume the data inside the QueryRenderer render like usual props</p>&#xA;",9822382,,,,2020-10-19 00:04:35,"",,0,0,0,2020-10-19 00:04:35
64419755,2,,64419467,1,,"<p>It helps you to maintain your code.</p>&#xA;<p>If you have a Page with 3 different components and every component need different data than you can specify the needed data for each component within a fragment inside the component. If you later want to get rid of one of the 3 components, you just need to remove the fragment for this component form your QueryRenderer instead of checking which params you can remove from your QueryRenderer.</p>&#xA;<p>By specifying the needed data in the component it is much easier to be sure to have the correct and only the necessary data fetched. If 3 different developers write the components (each of them one), it is easy to write the QueryRenderer for the page. Because instead of checking the data each component needs and passing the individual params to the components, you just specify the 3 fragments in the QueryRenderer and it will work.</p>&#xA;",4632620,,,,2020-10-19 00:43:35,"",,0,1,0,2020-10-19 00:43:35
64436979,1,64437346,,15,34708,"<p>I know you can set arguments in a schema to default values but is it possible to make the argument <code>limit</code> argument completely optional in my GraphQL Schema?</p>&#xA;<p>Right now it seems like when I hit this without specifying a limit I think that's why I get <code>Int cannot represent non-integer value: undefined</code></p>&#xA;<pre><code>const schema = buildSchema(`&#xA;  companies(limit: Int): [Company]&#xA;...)&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/yLF7x.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/yLF7x.jpg"" alt=""enter image description here"" /></a></p>&#xA;<p>I want to be able to skip the limit so that it gets all companies.</p>&#xA;<p>In JS, I call it like this:</p>&#xA;<pre><code>query: `query { &#xA;          companies(limit: ${limit}) {&#xA; ...&#xA;</code></pre>&#xA;<p>but sometimes I don't want to specify a limit.  So what is happening is the client is sending <code>crafters(limit: undefined)</code> and it's probably trying to convert that to Int.  I'm not sure how to not send <code>limit</code> in and how to make that entire param optional.</p>&#xA;<p>(I also read that from the <strong>client</strong> I should be instead specifying the arguments as <strong>variables</strong> like <code>query($limit: Int) {  companies(limit: $limit) {</code> I guess from my <strong>client</strong>, from <strong>JS</strong>?  If so how would I send in my limit <strong>JS variable</strong> into that?</p>&#xA;",4694781,,4694781,2020-10-20 01:16:09,2020-10-20 01:54:09,GraphQL optional Query Arguments,<javascript><graphql>,2,3,0,2020-10-20 00:49:06
64437106,2,,64418287,1,,"<p>Try this (untested), leave the <code>mix.js</code> line you mentioned untouched.&#xA;Then on a new line:</p>&#xA;<pre><code>mix.options({&#xA;   vue: {&#xA;      transpileOptions: {&#xA;         transforms: {&#xA;            dangerousTaggedTemplateString: true&#xA;         }&#xA;      }&#xA;   }&#xA;});&#xA;</code></pre>&#xA;",2185093,,,,2020-10-20 01:07:57,"",,0,0,0,2020-10-20 01:07:57
64437346,2,,64436979,25,,"<p>Arguments in GraphQL are nullable (i.e. optional) by default. So if your type definition looks like this:</p>&#xA;<pre><code>companies(limit: Int): [Company]&#xA;</code></pre>&#xA;<p>there is nothing else you need to do to make <code>limit</code> optional -- it already is. If you wanted to make <code>limit</code> required, you would make it non-nullable by appending a <code>!</code> to the type like this:</p>&#xA;<pre><code>companies(limit: Int!): [Company]&#xA;</code></pre>&#xA;<p>The errors you are seeing are unrelated to the type of the <code>limit</code> argument. The issue is with the query that you're sending, which based on the error messages, looks something like this:</p>&#xA;<pre><code>query ($limit: Int){&#xA;  companies (limit: undefined) {&#xA;    # ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>There's two issues here: One, you are defining a variable ($limit) that you never actually use inside the query (as indicated by the second error). Two, you are setting the limit to <code>undefined</code>, which isn't a valid literal in GraphQL.</p>&#xA;<p>Instead of using string interpolation, you should use variables to pass any dynamic values to your query. For example:</p>&#xA;<pre><code>query ($limit: Int){&#xA;  companies (limit: $limit) {&#xA;    # ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>If the variable is nullable (notice we used <code>Int</code> instead of <code>Int!</code>), then it can be omitted from the request entirely, effectively making the value of the argument undefined server-side. It's unclear how you're sending your requests to the server, but assuming you're not using some client library, you can check the documentation <a href=""https://graphql.org/learn/serving-over-http/"" rel=""noreferrer"">here</a> for how to structure your request. Otherwise, check your library's documentation for how to correctly use variables with your query.</p>&#xA;",6024220,,,,2020-10-20 01:44:23,"",,0,0,0,2020-10-20 01:44:23
64440960,1,,,0,827,"<p>Relatively new to GraphQL. I have a question around how to make the connections style of pagination reusable in schema.</p>&#xA;<p>eg.) If I have such a schema</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>type SomeEdge {&#xA;    node: SomeNodeView // This can be different for different use cases.&#xA;}&#xA;&#xA;type SomeConnection {&#xA;    metaInfo: MetaInfo&#xA;    edges: SomeEdge // this can be different for different use cases.&#xA;}&#xA;// But the overall structure remains the same.</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>Is there a way to handle this a bit generic in GraphQL?</p>&#xA;<p>This is the closest I have found so far searching online (<a href=""https://github.com/graphql/graphql-spec/issues/190"" rel=""nofollow noreferrer"">https://github.com/graphql/graphql-spec/issues/190</a>)</p>&#xA;<p>I am using this with Typescript.</p>&#xA;",1640282,,,,2020-10-20 11:45:38,How to create a generic Pagination Connections schema in GraphQL,<typescript><pagination><graphql>,1,0,0,2020-10-20 08:05:17
64463632,1,,,1,1252,"<p>Strapi (my api) fixed a limit of 100 fetch items. My question is how to fetch more than the 100 limit items in strapi. I made my request with Apollo graphql.</p>&#xA;<p><a href=""https://i.stack.imgur.com/y2wqi.png"" rel=""nofollow noreferrer"">I started to use parameters in my graphql request. But it limited the number only on the limit of the api. So, I can fetch only 20 items for example, but not 110 items for example.</a></p>&#xA;<p>I imagine it's possible to pass parameter in the api call, but I don't know how to.</p>&#xA;<p><a href=""https://i.stack.imgur.com/x80VR.png"" rel=""nofollow noreferrer"">I stock my api url here.</a></p>&#xA;<p><a href=""https://i.stack.imgur.com/x6Q6w.png"" rel=""nofollow noreferrer"">Here I use Apollo to dispatch my api.</a></p>&#xA;<p>Thank you in advance!</p>&#xA;",14492534,,6231562,2020-10-25 23:54:20,2020-10-31 08:55:43,How to fetch more than 100 items limit with Apollo graphql and strapi?,<react-native><graphql><apollo><fetch-api><strapi>,1,1,0,2020-10-21 12:33:49
64466254,1,64468729,,0,654,"<p>I have a requirement of passing region and primary key of the table as an input to my graphql query which internally call the jpa repository and retrieves the data.</p>&#xA;<p>Now based on the region, I have to hide few fields in my response.</p>&#xA;<p>Example</p>&#xA;<pre><code>query {&#xA;  getEmployee(Id: 1, region : &quot;A&quot;) {&#xA;    firstName,&#xA;    lastName,&#xA;    age,&#xA;    department&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>For the above graphql request, if user pass region <em>A</em>, then only <code>firstName</code>, <code>lastName</code> and <code>age</code> should be displayed. If user pass region as <em>B</em>, then all the four values should be returned.</p>&#xA;<p>is it possible to achieve this in  graphql? Please help !&#xA;Thank you!!</p>&#xA;",10710469,,5371168,2020-10-25 21:40:24,2020-10-25 21:40:24,How to hide few fields based on the region passed in graphql with spring boot,<spring-boot><graphql><graphql-java>,1,0,0,2020-10-21 14:53:22
64485157,2,,64482319,0,,<p>I realized that nexusjs use naming convention to determine if the query should return a list or not !</p>&#xA;<p>changing the table name from <code>purchase</code> to <code>purchases</code> solves the problem</p>&#xA;,12894172,,,,2020-10-22 15:07:36,"",,0,0,0,2020-10-22 15:07:36
64487592,2,,64354518,0,,"<p>I did manage to semi-answer this...</p>&#xA;<p>You can use the <code>@inline</code> directive in <a href=""https://relay.dev/docs/en/graphql-in-relay#inline"" rel=""nofollow noreferrer"">Relay</a> to allow you to retrieve the unmasked result.</p>&#xA;<p>This didn't <em>quite</em> solve my particular use-case, as I want the query itself to remain masked, but get the unmasked result when I call <code>HomePageQuery</code> imperatively. But if you don't have this requirement it should work.</p>&#xA;",4388938,,,,2020-10-22 17:33:31,"",,0,0,0,2020-10-22 17:33:31
64489731,2,,53495730,3,,"<pre><code>sequelize.fn(&quot;DATEADD&quot;, sequelize.literal(&quot;DAY&quot;), 4, sequelize.col('Your Date')) // 4 number of days adding&#xA;</code></pre>&#xA;<p>If want to find the difference including this added date from current date</p>&#xA;<pre><code>sequelize.fn('DATEDIFF', sequelize.literal(&quot;DAY&quot;), sequelize.fn(&quot;DATEADD&quot;, sequelize.literal(&quot;DAY&quot;), 4, sequelize.col('Your Date')), sequelize.fn(&quot;GETDATE&quot;)&#xA;</code></pre>&#xA;",4061801,,4061801,2020-10-22 20:12:47,2020-10-22 20:12:47,"",,0,1,0,2020-10-22 20:02:10
64502109,1,,,-2,276,"<p>To return all the data, I can use</p>&#xA;<pre><code>    {&#xA;      allEmployees {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            name&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>I have the variable&#xA;<code>{&quot;name&quot;: &quot;Roy&quot;}</code></p>&#xA;<p>How do I select all the employees named Roy?</p>&#xA;",14507207,,,,2020-10-23 15:57:54,How to add a parameter to a graphql query with edges and nodes,<graphql><graphiql>,1,0,0,2020-10-23 14:39:37
64508985,1,,,1,214,"<p>I have components that are almost identical but target different graphql entities, im trying to figure out if there's a way I can reduce the duplication of code. For example I have these two fragments:</p>&#xA;<pre><code>const PROCESS_REQUEST_MUTATION_A = graphql`&#xA;  mutation EntityA($input: ProcessRequestInput!) {&#xA;    processRequest(input: $input) {&#xA;      errors&#xA;      currentRequest {&#xA;        id&#xA;        state&#xA;        items {&#xA;          edges {&#xA;            item {&#xA;              id&#xA;            }&#xA;          }&#xA;        }&#xA;        events {&#xA;          ...RequestHistory_events&#xA;        }&#xA;      }&#xA;      nextRequest {&#xA;        id&#xA;        primaryType&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>In another component which is essentially a duplicate, I have:</p>&#xA;<pre><code>const PROCESS_REQUEST_MUTATION_ = graphql`&#xA;  mutation EntityB($input: ProcessRequestInput!) {&#xA;    processRequest(input: $input) {&#xA;      errors&#xA;      currentRequest {&#xA;        id&#xA;        state&#xA;        items {&#xA;          edges {&#xA;            item {&#xA;              id&#xA;              ...EntityB_item&#xA;            }&#xA;          }&#xA;        }&#xA;        events {&#xA;          ...RequestHistory_events&#xA;        }&#xA;      }&#xA;      nextRequest {&#xA;        id&#xA;        primaryType&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I'd like to have only one component and somehow simplify the fragment to handle this without so much duplication.</p>&#xA;",1297248,,,,2020-10-24 00:58:16,How to reduce duplication in relay fragments,<graphql><relay><relaymodern>,0,2,0,2020-10-24 00:58:16
64524994,1,64525937,,0,163,"<p>I am curious if I have to always include the <code>id</code> field when making queries to a relay graph QL server?</p>&#xA;<p>For example:</p>&#xA;<pre><code>users_connection {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        userId&#xA;        firstName&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>I sometime use the <code>id</code> field as a component key when looping on results, but generally speaking I don't use it. Does relay use this under the hood on the client to perform caching?</p>&#xA;<p>I have tested removing this from my queries and haven't notice a difference to my app.</p>&#xA;",10141904,,10141904,2020-10-25 15:58:53,2020-10-25 16:16:03,Do I need to always pull the id field when using react relay,<graphql><react-relay>,1,0,0,2020-10-25 14:42:52
64533283,1,64533455,,1,763,"<p>I am getting this error: GraphQLError [Object]: Syntax Error: Expected &quot;:&quot;, found &quot;}&quot;, while I am trying to build out a GraphQL Server using Apollo and will eventually host on MongoDB.</p>&#xA;<p>But I cannot understand why, can someone maybe spot a mistake in my code?</p>&#xA;<pre><code>&#xA;const gameWeek = gql`&#xA;    type Query {&#xA;        GameWeeks: [GameWeek]!&#xA;    }&#xA;    type Mutation {&#xA;        createGameWeek(player_id: ID!): GameWeekUpdateResponse!&#xA;        updateGameWeek(player_id: ID!): GameWeekUpdateResponse!&#xA;        deleteGameWeek(player_id: ID!)&#xA;    }&#xA;    type createGameWeek {&#xA;        player_id: ID!&#xA;        player_name: String!&#xA;        points: Float&#xA;        rank: Int!&#xA;        previous_rank: Int!&#xA;        total: Float&#xA;        team_name: String!&#xA;        team_id: Int&#xA;    }&#xA;    type GameWeekUpdateResponse {&#xA;        success: Boolean!&#xA;        message: String&#xA;        gameweeks: [GameWeek]&#xA;    }&#xA;    type GameWeek {&#xA;        player_id: ID!&#xA;        player_name: String!&#xA;        points: Float&#xA;        rank: Int!&#xA;        previous_rank: Int!&#xA;        total: Float&#xA;        team_name: String!&#xA;        team_id: Int&#xA;    }&#xA;`;&#xA;&#xA;module.exports = gameWeek;```&#xA;</code></pre>&#xA;",13668074,,,,2020-10-26 08:10:50,"GraphQLError: Syntax Error: Expected :, found { Probably a syntax error",<graphql><apollo>,1,0,0,2020-10-26 07:57:56
64538108,1,64575445,,0,544,"<p>Quick background:</p>&#xA;<p>I've got a listings project with around 40 cities and 16 regions that I'm targeting. I'm programatically creating a search results page for each city: <pre>example.com/london, example.com/paris etc...</pre>Then, I need each city page to have a query to retrieve listings that are only related to that city.</p>&#xA;<p>As of now, I'm querying same listings on each search page and then in the component I'm filtering the results on the client. The problem with that solution is that I'm loading thousands of listings on each page with page-data.json that I don't need.</p>&#xA;<p>I don't expect the listings to exceed few thousands that's why I don't want to add apollo to query directly from the client. I'd like all pages to be ssr'd. Filtering of results and pagination will be done via component and filtering of the array of results once the page loads.</p>&#xA;<p>The way I imagined that was:</p>&#xA;<ol>&#xA;<li>Run a query to retrieve list of cities</li>&#xA;<li>For each city retrieved run a actual page query with cityId as filter parameter. For performance purposes, I'd like that to happen in gatsby-node.js and not pass cityId to the pageContext and then run a pageQuery from the page.js (which for some reason I couldn't make that work either)</li>&#xA;</ol>&#xA;<p>Here's my gatsby-node.js</p>&#xA;<pre><code>const path = require('path')&#xA;&#xA;function slugify(str) {&#xA;    str = str.replace(/^\s+|\s+$/g, ''); // trim&#xA;    str = str.toLowerCase();&#xA;&#xA;    // remove accents, swap ñ for n, etc&#xA;    var from = &quot;ãàáäâąęẽèéëêćìíïîõòóöôùúüûñńçłśżź·/_,:;&quot;;&#xA;    var to   = &quot;aaaaaaeeeeeeciiiiooooouuuunnclszz------&quot;;&#xA;    for (var i=0, l=from.length ; i&lt;l ; i++) {&#xA;         str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));&#xA;    }&#xA;&#xA;    str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars&#xA;    .replace(/\s+/g, '-') // collapse whitespace and replace by -&#xA;    .replace(/-+/g, '-'); // collapse dashes&#xA;&#xA;    return str;&#xA;};&#xA;&#xA;&#xA;&#xA;exports.createPages = async ({ graphql, actions }) =&gt; {&#xA;&#xA;  const { createPage } = actions;&#xA;&#xA;  const listingQueryResults = await graphql(`&#xA;    query {&#xA;      allDatoCmsListing {&#xA;        nodes {&#xA;          company {&#xA;            cities {&#xA;              cityName&#xA;              region {&#xA;                regionName&#xA;              }&#xA;            }&#xA;            companyName&#xA;            address&#xA;            logo {&#xA;              fixed(imgixParams: {w: &quot;128&quot;, h: &quot;128&quot;, fit: &quot;fillmax&quot;}) {&#xA;                src&#xA;              }&#xA;            }&#xA;&#xA;            #Companywide Terms&#xA;            insurancePolicy&#xA;            otherInsuranceTerms&#xA;            pricePerKm&#xA;            minAge&#xA;            deposit&#xA;            bookingPhoneNumber&#xA;            displayPhoneNumber&#xA;            bookingEmail&#xA;          }&#xA;          featuredInCountry&#xA;          monthlyPrice&#xA;          listingTitle&#xA;          pricesIncludeVat&#xA;          id&#xA;          originalId&#xA;          featuredImage {&#xA;            fluid(imgixParams: {fit: &quot;crop&quot;, w: &quot;800&quot;, h: &quot;600&quot;, crop: &quot;focalpoint&quot;}) {&#xA;              aspectRatio&#xA;              base64&#xA;              height&#xA;              sizes&#xA;              src&#xA;              srcSet&#xA;              tracedSVG&#xA;              width&#xA;            }&#xA;            originalId&#xA;          }&#xA;          gallery {&#xA;            fluid {&#xA;              width&#xA;              tracedSVG&#xA;              srcSet&#xA;              src&#xA;              sizes&#xA;              height&#xA;              base64&#xA;              aspectRatio&#xA;            }&#xA;          }&#xA;          featuredInCity&#xA;          featuredInRegion&#xA;          listingDescription&#xA;          make {&#xA;            makeName&#xA;          }&#xA;          spec&#xA;          seats&#xA;          topSpeed&#xA;          transmission {&#xA;            transmissionType&#xA;          }&#xA;          weekendLimit&#xA;          weekendNoDepositPrice&#xA;          weekendPrice&#xA;          weeklyLimit&#xA;          weeklyNoDepositPrice&#xA;          weeklyPrice&#xA;          acceleration&#xA;          collectionDropoff&#xA;          color {&#xA;            colorName&#xA;            colorValue&#xA;          }&#xA;          dailyLimit&#xA;          dailyNoDepositPrice&#xA;          dailyPrice&#xA;          doors&#xA;          engine {&#xA;            engineType&#xA;          }&#xA;          engineSize&#xA;          horsepower&#xA;          monthlyLimit&#xA;          monthlyNoDepositPrice&#xA;          noDepositPricingAvailable&#xA;          &#xA;          #Listing Terms&#xA;          applyCompanywideTerms&#xA;          insurancePolicy&#xA;          otherInsuranceTerms&#xA;          pricePerKm&#xA;          minAge&#xA;          deposit&#xA;          listingApproved&#xA;        }&#xA;      }&#xA;    }&#xA;  `);&#xA;  const listingTemplate = path.resolve(`src/templates/listing.js`);&#xA;  listingQueryResults.data.allDatoCmsListing.nodes.forEach(node =&gt; {&#xA;    createPage({&#xA;      path: `/oferta/${node.originalId}-${slugify(node.listingTitle)}`,&#xA;      component: listingTemplate,&#xA;      context: {&#xA;        listing: node&#xA;      }&#xA;    });&#xA;  });&#xA;&#xA;  const queryResults = await graphql(`&#xA;    query {&#xA;      allDatoCmsCity {&#xA;        nodes {&#xA;          cityName&#xA;          cityCase&#xA;          id&#xA;        }&#xA;      }&#xA;&#xA;      allDatoCmsRegion {&#xA;        nodes {&#xA;          regionName&#xA;          regionCase&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  `);&#xA;&#xA;  const searchTemplate = path.resolve(`src/templates/search.js`);&#xA;  queryResults.data.allDatoCmsCity.nodes.forEach(node =&gt; {&#xA;  &#xA;    createPage({&#xA;      path: `/${slugify(node.cityName)}`,&#xA;      component: searchTemplate,&#xA;      context: {&#xA;        search: node,&#xA;      }&#xA;    });&#xA;  });&#xA;&#xA;  queryResults.data.allDatoCmsRegion.nodes.forEach(node =&gt; {&#xA;    createPage({&#xA;      path: `/${slugify(node.regionName)}`,&#xA;      component: searchTemplate,&#xA;      context: {&#xA;        search: node&#xA;      }&#xA;    })&#xA;  })&#xA;&#xA;  const emptySearch = {&#xA;    cityName: null,&#xA;    regionName: null&#xA;  }&#xA;&#xA;  createPage({&#xA;    path: `/cala-polska`,&#xA;    component: searchTemplate,&#xA;    context: {&#xA;      search: emptySearch&#xA;    }&#xA;  })&#xA;};&#xA;</code></pre>&#xA;<p>I guess the more precised question is:</p>&#xA;<ol>&#xA;<li>What's the best way to achieve the above. That is to get all cities &amp; regions</li>&#xA;<li>Loop through cities &amp; regions and query each city &amp; region separately as opposed to running the exact same query and getting results for all cities/regions on a specific city/region page?</li>&#xA;</ol>&#xA;",13157228,,,,2020-10-28 14:54:46,[Gatsby][GraphQL]: running a query after retrieving filter parameters from another query,<javascript><graphql><gatsby>,1,0,0,2020-10-26 13:30:28
64541507,1,,,2,497,"<p>I would like to sort with strapi's graphql</p>&#xA;<p>I can do that by</p>&#xA;<pre><code>{&#xA;  users (sort: &quot;id:asc&quot;) {&#xA;    id&#xA;    username&#xA;    email&#xA;    address {&#xA;      id&#xA;      city&#xA;      state&#xA;      street&#xA;    }&#xA;  }&#xA;} &#xA;</code></pre>&#xA;<p>I can sort by the first level of columns but how do I go deeper, for example address.city, because&#xA;&quot;. / :&quot; don't work, graphql playground returns:</p>&#xA;<pre><code>&quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;select \&quot;users\&quot;.* from \&quot;users\&quot; order by \&quot;address\&quot;.\&quot;city\&quot; desc limit $1 - missing FROM-clause entry for table \&quot;address\&quot;&quot;,&#xA;</code></pre>&#xA;",11114341,,,,2021-02-08 11:06:04,Strapi Graphql deep sort,<graphql><strapi>,0,2,0,2020-10-26 16:50:34
64552949,1,,,1,381,"<p>This gets me all events with <code>showOnSite === true</code>:</p>&#xA;<pre><code>query MyQuery {&#xA;  allSanityP2Event(filter: {showOnSite: {eq: true}}) {&#xA;    edges {&#xA;      node {&#xA;        showOnSite&#xA;        title&#xA;        relatedEvents {&#xA;          showOnSite&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I want to then filter <code>relatedEvents</code> within those results, also by <code>showOnSite === true</code>. Surely GraphQL can do this?</p>&#xA;<p>Using <code>elemMatch</code> doesn't work as it gives me ONLY events where <code>relatedEvents</code> have <code>showOnSite === true</code>, like this:</p>&#xA;<pre><code>query MyQuery {&#xA;  allSanityP2Event(filter: {showOnSite: {eq: true}, relatedEvents: {elemMatch: {showOnSite: {eq: true}}}}) {&#xA;    edges {&#xA;      node {&#xA;        showOnSite&#xA;        title&#xA;        relatedEvents {&#xA;          showOnSite&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Logically, I'd expect this to work, but no...</p>&#xA;<pre><code>query MyQuery {&#xA;  allSanityP2Event(filter: {showOnSite: {eq: true}}) {&#xA;    edges {&#xA;      node {&#xA;        showOnSite&#xA;        title&#xA;        relatedEvents(filter: {showOnSite: {eq: true}}) {&#xA;          showOnSite&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",13010984,,,,2020-10-27 14:19:21,How can I filter child arrays in Gatsby GraphQL?,<graphql><gatsby><sanity>,1,0,0,2020-10-27 10:57:09
64581612,1,,,1,566,"<p>i have this pagination in relay modern:</p>&#xA;<pre><code>const CategoryContent = () =&gt; {&#xA;  const { categoryQuery } = useRoute&lt;CategoryContentScreenRouteProp&gt;().params;&#xA;  const { viewer } = useLazyLoadQuery&lt;CategoryContentQuery&gt;(&#xA;    graphql`&#xA;      query CategoryContentQuery(&#xA;        $count: Int&#xA;        $cursor: String&#xA;        $category: String&#xA;      ) {&#xA;        viewer {&#xA;          ...InfiniteCategories_viewer&#xA;            @arguments(count: $count, cursor: $cursor, category: $category)&#xA;        }&#xA;      }&#xA;    `,&#xA;    { count: 7, category: categoryQuery }&#xA;  );&#xA;  //console.log(&quot;CategoryContent viewer&quot;, viewer);&#xA;  return (&#xA;    &lt;Suspense fallback={&lt;LoadingView /&gt;}&gt;&#xA;      &lt;View&gt;&#xA;        &lt;Text&gt;CategoryContent&lt;/Text&gt;&#xA;      &lt;/View&gt;&#xA;      &lt;InfiniteCategories viewer={viewer} /&gt;&#xA;    &lt;/Suspense&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>and this is the infinite pagination:</p>&#xA;<pre><code>const InfiniteCategories = ({&#xA;  viewer,&#xA;}: {&#xA;  viewer: InfiniteCategories_viewer$key;&#xA;}) =&gt; {&#xA;  const { data, loadNext, hasNext, isLoadingNext } = usePaginationFragment&lt;&#xA;    InfiniteCategoriesPaginationQuery,&#xA;    any&#xA;  &gt;(&#xA;    graphql`&#xA;      fragment InfiniteCategories_viewer on Viewer&#xA;      @argumentDefinitions(&#xA;        count: { type: &quot;Int&quot;, defaultValue: 7 }&#xA;        cursor: { type: &quot;String&quot;, defaultValue: null }&#xA;        category: { type: &quot;String&quot; }&#xA;      )&#xA;      @refetchable(queryName: &quot;InfiniteCategoriesPaginationQuery&quot;) {&#xA;        merchants(first: $count, after: $cursor, category: $category)&#xA;          @connection(key: &quot;InfiniteCategories_viewer_merchants&quot;) {&#xA;          pageInfo {&#xA;            startCursor&#xA;            endCursor&#xA;          }&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              category&#xA;              logo&#xA;              createdAt&#xA;              isFavorite&#xA;              pk&#xA;              name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;    viewer&#xA;  );&#xA;  console.log(&quot;data InfiniteCategories&quot;, data);&#xA;  return (&#xA;    &lt;StyledFlatList&#xA;      {...{&#xA;        data:&#xA;          data &amp;&amp; data.merchants &amp;&amp; data.merchants.edges&#xA;            ? data.merchants.edges&#xA;            : [],&#xA;        contentContainerStyle: styles.contentContainerStyle,&#xA;        showsVerticalScrollIndicator: false,&#xA;        keyExtractor: ({ cursor }) =&gt; cursor,&#xA;        renderItem: ({ item }) =&gt; (&#xA;          &lt;View&gt;&#xA;            &lt;Text&gt;{item.node.name}&lt;/Text&gt;&#xA;          &lt;/View&gt;&#xA;        ),&#xA;        ListFooterComponent: () =&gt; {&#xA;          if (isLoadingNext) return &lt;ActivityIndicator /&gt;;&#xA;          if (hasNext)&#xA;            return (&#xA;              &lt;LoadMoreButton&#xA;                onPress={() =&gt; {&#xA;                  loadNext(7);&#xA;                }}&#xA;              /&gt;&#xA;            );&#xA;          return null;&#xA;        },&#xA;      }}&#xA;    /&gt;&#xA;  );&#xA;};&#xA;</code></pre>&#xA;<p>however my problem is in every render like when i get back to the screen, it's being loaded again? how can i stop it from happening since it's pagination, user would have to do load more again to regain its' data, and i don't want that?</p>&#xA;",5288560,,,,2020-10-28 21:32:23,stop relay modern useLazyLoadQuery refetching in a pagination when data is available in cache?,<reactjs><graphql><relayjs><relaymodern><react-relay>,0,1,0,2020-10-28 21:32:23
64613889,1,,,1,115,"<p>Existing code in query_type.rb:</p>&#xA;<pre><code>def flags(program_id:, filter: {}, sort: {})&#xA;      program = Program.find(program_id)&#xA;      context[:auth].set_current_parent_program_id(program.id)&#xA;      flags = Report.joins(:participant).where(registrants: { program_id: program.id })&#xA;      Types::Programs::FlagsFilter.get_filtered(flags: flags, filter: filter, sort: sort)&#xA; end&#xA;</code></pre>&#xA;<p>I am new to Ruby and the flags are coming in reverse order (ascending) and I want to set the default value to descending. I tried setting it like this:</p>&#xA;<pre><code>def flags(program_id:, filter: {}, sort: { column: 'created_at', direction: 'DESCENDING' })&#xA;      program = Program.find(program_id)&#xA;      context[:auth].set_current_parent_program_id(program.id)&#xA;      flags = Report.joins(:participant).where(registrants: { program_id: program.id })&#xA;      Types::Programs::FlagsFilter.get_filtered(flags: flags, filter: filter, sort: sort)&#xA; end&#xA;</code></pre>&#xA;<p>but I'm getting an error: undefined method `column’ for {:column=&gt;“created_at”, :direction=&gt;“DESCENDING”}:Hash and my flags table is no longer rendering. Any suggestions? I've also tried putting column in quotes.</p>&#xA;",12649687,,12649687,2020-10-30 19:18:49,2020-10-30 21:17:55,How to add a default value to sort: in query_type.rb,<ruby><typescript><ruby-on-rails-3><graphql><graphql-ruby>,1,0,0,2020-10-30 18:25:52
64615832,2,,64613889,0,,"<p>to set the default value for <code>sort</code> parameter</p>&#xA;<pre><code>flags(program_id:, filter: {}, sort: { column: 'created_at', direction: 'desc' })&#xA;</code></pre>&#xA;<p>above sample code is probably the solution</p>&#xA;<p>'coz it all still depends on your actual code within the <code>Types::Programs::FlagsFilter.get_filtered</code> class method :-)</p>&#xA;",13839360,,13839360,2020-10-30 21:17:55,2020-10-30 21:17:55,"",,0,0,0,2020-10-30 21:11:47
64624742,2,,62751079,1,,"<p>@Mat-KH's answer was actually pointing in the right direction.&#xA;Your issue is in this line (and I'm frankly surprised that this works at all, given your schema):</p>&#xA;<pre><code>let myDataStore = await DataStore.save(new User({input}));&#xA;</code></pre>&#xA;<p>This creates a separate <code>input</code> object, resulting in your data being nested inside <code>User.input</code>.</p>&#xA;<p>Instead, you can do</p>&#xA;<pre><code>// create a new User&#xA;const input = {&#xA;    // id is auto-generated (see below)&#xA;    username: username,&#xA;    userPhone: userPhone,&#xA;    createdAt: createdAt,&#xA;}&#xA;const user = await DataStore.save(new User(input));&#xA;&#xA;// the above auto-generates an ID -&gt; use that in the query below&#xA;const user = await DataStore.query(User, c =&gt; c.id(&quot;eq&quot;, &quot;f86d3252-7b1d-44f6-b4cd-b8a7a3a88def&quot;));&#xA;</code></pre>&#xA;",495771,,,,2020-10-31 17:45:43,"",,0,0,0,2020-10-31 17:45:43
64655116,1,,,0,39,"<p>Short version: I want to write a check that says if this piece of data from the GraphQL query is undefined, set it to 1 week ago. How do I write this in the return in a typescript file? This is what I have been trying:</p>&#xA;<pre><code>{data?.program?.flagPageVisits?.edges?.[1]?.node?.createdAt === undefined ? (data.program.flagPageVisits.edges.[1].node.createdAt = new Date(moment().subtract(&quot;days&quot;, 7).format(&quot;DD-MMM-YYYY&quot;))) : &quot;&quot;}&#xA;</code></pre>&#xA;<p>I created a new table LastPageVisits and I only want to show rows in a table with a red dot if it's a &quot;new&quot; row for the user, meaning it was created since their LastPageVisit. If the value of the (second to last) LastPageVisit is undefined, I want to set it to 1 week ago. How can I write this check in a React/Typescript return function (data is coming from GraphQL query)?</p>&#xA;",12649687,,,,2020-11-03 00:21:34,How to set a Date value to an object's value that could be undefined in Javascript,<javascript><reactjs><typescript><graphql>,0,3,0,2020-11-03 00:21:34
64657154,1,,,3,1294,"<p>Getting Scanned count but not count of data according to filter</p>&#xA;<pre><code>count: null&#xA;items: [{id: &quot;bcd75096-7fd9-4e9d-8675-6877f0609ac2&quot;, name: &quot;dxfrdhjkhklklkl&quot;, description: &quot;dgdxrfg&quot;,…},…]&#xA;0: {id: &quot;bcd75096-7fd9-4e9d-8675-6877f0609ac2&quot;, name: &quot;dxfrdhjkhklklkl&quot;, description: &quot;dgdxrfg&quot;,…}&#xA;1: {id: &quot;52f6ff60-fc07-4631-a1fb-b039f376ff21&quot;, name: &quot;ghnfgyhj&quot;, description: &quot;gyhkjmuhjolk&quot;,…}&#xA;2: {id: &quot;f73dfb37-2778-4b87-88c7-e6f9f5b5c931&quot;, name: &quot;drftgserty&quot;, description: &quot;trse54rte54ty&quot;,…}&#xA;3: {id: &quot;6df9f5c2-ec06-4e70-b5e2-133cb0d8e958&quot;, name: &quot;tygujghukuh&quot;, description: &quot;tuyjyuikuolnh&quot;,…}&#xA;4: {id: &quot;9360a766-ac89-420c-881b-2b3089bcca7f&quot;, name: &quot;kl;&quot;, description: &quot;vcbghnjmk,l&quot;, is_active: true,…}&#xA;5: {id: &quot;c0dcbaff-37d4-4e4c-9375-584ff7110d77&quot;, name: &quot;dfhgbdcb&quot;, description: &quot;dfxvcx&quot;, is_active: true,…},...&#xA;scannedCount: 100&#xA;</code></pre>&#xA;<p>I have followed these tutorials to get count <a href=""https://www.riccardosirigu.com/blog/aws-amplify-dynamodb-total-count-graphql-queries/"" rel=""nofollow noreferrer"">HOW TO COUNT THE NUMBER OF RESULTS WITH AWS AMPLIFY DYNAMODB AND GRAPHQL</a></p>&#xA;<p>Filter</p>&#xA;<pre><code>      var body = {&#xA;        filter: {&#xA;          is_active: {&#xA;            eq: true&#xA;          }&#xA;        }&#xA;      }&#xA;</code></pre>&#xA;<p>Query to get list of todos</p>&#xA;<pre><code>export const listTodos = /* GraphQL */ `&#xA;  query ListTodos(&#xA;    $filter: ModelTodoFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      count&#xA;      items {&#xA;        id&#xA;        name&#xA;        description&#xA;        is_active&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      scannedCount&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>GraphQl shema</p>&#xA;<pre><code>type Todo @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  description: String!&#xA;  is_active: Boolean&#xA;}&#xA;&#xA;type ModelTodoConnection {&#xA;  items: [Todo]&#xA;  scannedCount: Int&#xA;  count: Int&#xA;  total: Int&#xA;}&#xA;</code></pre>&#xA;<p>And IF I set limit to 5 and it will send back <code>scannedCount</code> 5 if when I have total data in database around 110. I want to count data where   <code>is_active: { eq: true }</code></p>&#xA;",12761193,,12761193,2020-11-05 10:10:18,2022-02-23 15:42:50,Not getting count according to filter in GraphQL amplify queries,<graphql><amazon-dynamodb><aws-amplify><aws-appsync><aws-amplify-cli>,1,7,0,2020-11-03 05:14:50
64659027,2,,64658819,3,,"<p>It's not a spread operator like we know it in JavaScript, in GraphQL stands for a query fragment.</p>&#xA;<p>A fragment's a way of querying a set of fields using reusable units. From <a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">GraphQL docs</a>:</p>&#xA;<blockquote>&#xA;<p>Let's say we had a relatively complicated page in our app, which lets&#xA;us look at two heroes side by side, along with their friends. You can&#xA;imagine that such a query could quickly get complicated, because we&#xA;would need to repeat the fields at least once - one for each side of&#xA;the comparison.</p>&#xA;<p>That's why GraphQL includes reusable units called fragments. Fragments&#xA;let you construct sets of fields, and then include them in queries&#xA;where you need to. Here's an example of how you could solve the above&#xA;situation using fragments:</p>&#xA;</blockquote>&#xA;<p>In your case, the fragment is provided by <a href=""https://www.gatsbyjs.com/plugins/gatsby-source-contentful/"" rel=""nofollow noreferrer""><code>gatsby-source-contentful</code></a> and basically, is querying a fluid asset from Contentful, as you do normally when using <a href=""https://www.gatsbyjs.com/plugins/gatsby-image/#fragments"" rel=""nofollow noreferrer""><code>gatsby-image</code></a> for local files.</p>&#xA;<p>In other words, with <code>...GatsbyContentfulFluid</code> fragment you are fetching the mandatory fields from Contentful assets that allow you to use a <code>gatsby-image</code> within the asset.</p>&#xA;<p>Fragments are not available in the GraphQL playground due to a limitation of the GraphiQL:</p>&#xA;<blockquote>&#xA;<p>Note, due to a limitation of GraphiQL, you can not currently use these&#xA;fragments in the GraphiQL IDE.</p>&#xA;</blockquote>&#xA;<p>So, you can use fragments (indeed, you should) but you will need to check your fetched data in your code (via <code>console.logs</code> or via debug breakpoints) directly since they are not available in the GraphQL playground.</p>&#xA;",5585371,,5585371,2020-11-03 12:35:11,2020-11-03 12:35:11,"",,0,2,0,2020-11-03 08:16:07
64693353,1,,,0,98,"<p>I'm using Gatsby to build a new website. I'd like to render some markdown files for a blog, but it doesn't seem to be able to process the lists/unordered lists based on the markdown syntax. For instance, this is the syntax:</p>&#xA;<pre><code>* Purple dots are points on the graph, each point has an x and y coordinate. These are your observed values&#xA;&#xA;* Blue line is the prediction line, covering the estimated values of the model&#xA;&#xA;* The red line between each purple point and the prediction line are the errors. Each error is the distance from the point to its predicted point.&#xA;</code></pre>&#xA;<p>This is the output:</p>&#xA;<p><a href=""https://i.stack.imgur.com/C9uIg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/C9uIg.png"" alt=""Unordered List"" /></a></p>&#xA;<p>I also found that it's not possible to use <code>#</code> for the headers. For instance, here's my post description and title:</p>&#xA;<pre><code>_Making Use of the scipy.optimize Library in Python to Minimize Error_&#xA;&#xA;## Revision&#xA;</code></pre>&#xA;<p>Output:</p>&#xA;<p><a href=""https://i.stack.imgur.com/VndYG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VndYG.png"" alt=""Title and description"" /></a></p>&#xA;<p>I'm not sure what I need to change within Gatsby to render the markdown correctly?</p>&#xA;",2482149,,,,2020-11-05 08:50:21,Markdown File Unable To Process Unordered Lists Gatsby,<reactjs><graphql><markdown><gatsby>,1,1,0,2020-11-05 08:09:56
64696988,1,64698051,,4,6930,"<p>I have the following GraphQL query (using Apollo Client JS):</p>&#xA;<pre><code>query GetUsers($searchFilter: String) {&#xA;    users(&#xA;        first: 10,&#xA;        filter: { search: $searchFilter }&#xA;    ) {&#xA;        nodes {&#xA;            id&#xA;            name&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>This works well when I pass in the <code>$searchFilter</code> argument. However, I want this <code>$searchFilter</code> argument to be <strong>optional</strong>. So when it's <code>null</code> it doesn't apply the filter.</p>&#xA;<p>This seems simple enough, but the API requires the <code>search</code> to be non-nullable. So passing in <code>filter: { search: null }</code> is not allowed.</p>&#xA;<p>I would like to achieve the following:</p>&#xA;<pre><code>query GetUsers($searchFilter: String) {&#xA;    users(&#xA;        first: 10,&#xA;        filter: $searchFilter = null ? null : { search: $searchFilter }&#xA;    ) {&#xA;        nodes {&#xA;            id&#xA;            name&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>How do I conditionally include the <code>filter</code> argument?</p>&#xA;",4136777,,6124657,2021-11-10 09:25:33,2021-11-10 09:25:33,How to conditionally include a filtering argument in a GraphQL query?,<javascript><graphql><apollo>,1,5,0,2020-11-05 12:13:42
64698051,2,,64696988,8,,"<p>Just pass (entire 'composed/prepared earlier') value for <code>filter</code> (define at query) variable. Leaving this variable undefined makes it optional.</p>&#xA;<pre><code>query GetUsers($filter: SomeFilterInputType) {&#xA;  users(&#xA;    first: 10, &#xA;    filter: $filter ) {&#xA;</code></pre>&#xA;<p>pass value for <code>filter</code> in [query] variables:</p>&#xA;<pre><code>{&#xA;  filter: { search: 'sth'}&#xA;}&#xA;</code></pre>&#xA;<p><strong>... where <code>SomeFilterInputType</code> is a [<code>users</code> query] arg type name, it can be read from API specs, available in graphiql/playground docs ... or server code/type defs</strong></p>&#xA;<p>It can be tested in graphiql/playground using QUERY VARIABLES.</p>&#xA;<p><strong><code>variables</code> passed from JavaScript is an object with the same structure, easily created/modified conditionally.</strong></p>&#xA;<p>In this case <code>SomeFilterInputType</code> (no <code>!</code> mark after type name) means it (<code>filter</code> variable) can be nulled/undefined - <strong>usually optional args are nullable</strong> (not required). If some arg is required in API/BE specs then it must be required in client, too.</p>&#xA;",6124657,,,,2020-11-05 13:19:36,"",,0,1,0,2020-11-05 13:19:36
64718669,2,,54218505,0,,"<p>Another way is to tell the Relay filter of graphene_django to also deals with a list. This filter is register in a mixin in graphene_django and applied to any filter you define.</p>&#xA;<p>So here my solution:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>from graphene_django.filter.filterset import (&#xA;    GlobalIDFilter,&#xA;    GrapheneFilterSetMixin,&#xA;)&#xA;from graphql_relay import from_global_id&#xA;&#xA;&#xA;class CustomGlobalIDFilter(GlobalIDFilter):&#xA;    &quot;&quot;&quot;Allow __in lookup for IDs&quot;&quot;&quot;&#xA;    def filter(self, qs, value):&#xA;        if isinstance(value, list):&#xA;            value_lst = [from_global_id(v)[1] for v in value]&#xA;            return super(GlobalIDFilter, self).filter(qs, value_lst)&#xA;        else:&#xA;            return super().filter(qs, value)&#xA;&#xA;# Fix the mixin defaults&#xA;GrapheneFilterSetMixin.FILTER_DEFAULTS.update({&#xA;    AutoField: {&quot;filter_class&quot;: CustomGlobalIDFilter},&#xA;    OneToOneField: {&quot;filter_class&quot;: CustomGlobalIDFilter},&#xA;    ForeignKey: {&quot;filter_class&quot;: CustomGlobalIDFilter},&#xA;})&#xA;</code></pre>&#xA;",1988874,,,,2020-11-06 16:53:48,"",,0,0,0,2020-11-06 16:53:48
64767241,2,,61319773,0,,<p>You can try with following code :</p>&#xA;<pre><code>filter : &quot;{\&quot;brandName\&quot;: {\&quot;$like\&quot; :\&quot;%Continental%\&quot;}}&quot;&#xA;</code></pre>&#xA;,7865164,,,,2020-11-10 10:35:41,"",,0,0,0,2020-11-10 10:35:41
64776031,2,,64446904,0,,"<p>You can create an Index with values = id.</p>&#xA;<p>For e.g.</p>&#xA;<pre><code>{&#xA;  &quot;shipperID&quot; : 1,&#xA;  &quot;companyName&quot; : &quot;Speedy Express&quot;,&#xA;  &quot;phone&quot; : &quot;(503) 555-9831&quot;&#xA;}&#xA;</code></pre>&#xA;<pre><code>CreateIndex(&#xA;{&#xA;name: &quot;shippers_id&quot;,&#xA;source: Collection(&quot;shippers&quot;),&#xA;values:  [{field: [&quot;data&quot;, &quot;shipperID&quot;]}]&#xA;})&#xA;</code></pre>&#xA;<p><code>SELECT shipperID FROM shippers</code> in fql would be <code>Paginate(Match(Index(&quot;shippers_id&quot;)))</code></p>&#xA;",10935091,,,,2020-11-10 20:06:42,"",,0,0,0,2020-11-10 20:06:42
64784227,1,64786333,,0,614,"<p>According to graphQl docs:</p>&#xA;<blockquote>&#xA;<p>When you're passing arguments in code, it's generally better to avoid&#xA;constructing the whole query string yourself. Instead, you can use $&#xA;syntax to define variables in your query, and pass the variables as a&#xA;separate map.</p>&#xA;</blockquote>&#xA;<p><a href=""https://graphql.org/graphql-js/passing-arguments/"" rel=""nofollow noreferrer"">https://graphql.org/graphql-js/passing-arguments/</a></p>&#xA;<p>In this context, I'm trying to query the following schema:</p>&#xA;<pre><code>const typeDefs = &quot;&#xA;input OrderInputData {    &#xA;  date: String!&#xA;  time: String!&#xA;  frequency: String!&#xA;  extras: [Int!]&#xA;  mailAlarm: String&#xA;  phoneAlarm: String&#xA;  rating: Float&#xA;  comments: String&#xA;}&#xA;&#xA;type Mutation {&#xA;  updateIntent(&#xA;    paymentIntentId: String, &#xA;    setupIntentId: String, &#xA;    pairIntentId: String,&#xA;    orderInput: OrderInputData): Boolean&#xA;}&quot;&#xA;</code></pre>&#xA;<p>I'm having a bit of difficulty to build the query respecting graphQl's better practices, since this case is more complex than the one depicted on the documentation, due to the presence of a nested document(OrderInputData). This is what I have up to know:</p>&#xA;<pre><code>  const dummyData = {&#xA;    date: &quot;11/11/2020&quot;,&#xA;    frequency: &quot;One time&quot;,&#xA;    time: &quot;6:17 PM&quot;,&#xA;    mailAlarm: &quot;teste&quot;,&#xA;    phoneAlarm: &quot;teste&quot;,&#xA;    extras: [1, 3, 7],&#xA;  };&#xA;&#xA;const graphqlQuery = {&#xA;      query: `&#xA;      mutation updateIntent (&#xA;        $paymentIntentId: String, &#xA;        $pairIntentId: String, &#xA;        $orderInput: { &#xA;          date: String!, &#xA;          time: String!, &#xA;          frequency: String!, &#xA;          extras: [Int!], &#xA;          mailAlarm: String, &#xA;          phoneAlarm: String&#xA;        }) {&#xA;      updateIntent (&#xA;        paymentIntentId: $paymentIntentId, &#xA;        pairIntentId: $pairIntentId, &#xA;        orderInput: { &#xA;          date: $date, &#xA;          time: $time, &#xA;          frequency: $frequency, &#xA;          extras: $extras, &#xA;          mailAlarm: $mailAlarm, &#xA;          phoneAlarm: $phoneAlarm&#xA;        })&#xA;      }`,&#xA;      variables: {&#xA;        paymentIntentId: paymentIntentId, &#xA;        pairIntentId: setupIntentId,&#xA;        &quot;orderInput.date&quot;: dummyData.date, &#xA;        &quot;orderInput.time&quot;: dummyData.time, &#xA;        &quot;orderInput.frequency&quot;: dummyData.frequency, &#xA;        &quot;orderInput.extras&quot;: dummyData.extras, &#xA;        &quot;orderInput.mailAlarm&quot;: dummyData.mailAlarm, &#xA;        &quot;orderInput.phoneAlarm&quot;: dummyData.phoneAlarm&#xA;      }&#xA;</code></pre>&#xA;<p>What is my mistake?</p>&#xA;",11356516,,11356516,2020-11-12 10:20:15,2020-11-12 10:20:15,Passing variables to query with complex input types,<graphql>,1,0,0,2020-11-11 09:58:51
64796887,1,,,0,182,"<p>I am not sure whether it is good to create a function with any type in input/ output for the function in a typescript project, and how to strike a balance between &quot;strict type checking&quot; and &quot;flexibility&quot;.</p>&#xA;<p>Now I am trying to create a helper function to remove the edges and node in graphQL response for easier handle in view components, take an example:</p>&#xA;<pre><code>// Input A&#xA;{&#xA;    &quot;students&quot;: {&#xA;        &quot;edges&quot;: [&#xA;            {&#xA;                &quot;node&quot;: {&#xA;                    &quot;name&quot;: &quot;Peter&quot;,&#xA;                    &quot;age&quot;: 12&#xA;                }&#xA;            },&#xA;            {&#xA;                &quot;node&quot;: {&#xA;                    &quot;name&quot;: &quot;Mike&quot;,&#xA;                    &quot;age&quot;: 12&#xA;                }&#xA;            }&#xA;        ]&#xA;    }&#xA;}&#xA;&#xA;// Input B&#xA;{&#xA;    &quot;teachers&quot;: {&#xA;        &quot;edges&quot;: [&#xA;            {&#xA;                &quot;node&quot;: {&#xA;                    &quot;name&quot;: &quot;Mary&quot;,&#xA;                    &quot;age&quot;: 40&#xA;                }&#xA;            },&#xA;            {&#xA;                &quot;node&quot;: {&#xA;                    &quot;name&quot;: &quot;John&quot;,&#xA;                    &quot;age&quot;: 35&#xA;                }&#xA;            }&#xA;        ]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>My proposed helper function:</p>&#xA;<pre><code>const simpleConnectionsHandler = (obj: any): any =&gt; {&#xA;// Some logic to remove edges and nodes&#xA;...&#xA;}&#xA;</code></pre>&#xA;<p>Expect what I can get from the function (output):</p>&#xA;<pre><code>// Output A&#xA;{&#xA;    &quot;students&quot;: [&#xA;        { &quot;name&quot;: &quot;Peter&quot;, &quot;age&quot;: 12 },&#xA;        { &quot;name&quot;: &quot;Mike&quot;, &quot;age&quot;: 12 }&#xA;    ]&#xA;}&#xA;&#xA;// Output B&#xA;{&#xA;    &quot;teachers&quot;: [&#xA;        { &quot;name&quot;: &quot;Mary&quot;, &quot;age&quot;: 40 },&#xA;        { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35 }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;<p>In my view components I am going to take the simplified version of response like this:</p>&#xA;<pre><code>const studentList: studentsSimplified = simpleConnectionsHandler(inputA); &#xA;const teacherList: teachersSimplified = simpleConnectionsHandler(inputB);&#xA;</code></pre>&#xA;<p>The reason I do that is, I would like to prevent declare two versions of type for the response json, one is the response with edges and node, and one is the response without edges and node.</p>&#xA;<p>I would like to know whether it is good to accept input as &quot;any&quot; and return &quot;any&quot; for the output, and I convert back to the simplified version of response when I get back the result in the caller side.</p>&#xA;",6088507,,6088507,2020-11-12 04:18:38,2020-11-12 04:18:38,"Should we use ""any"" when transforming a generic json response",<typescript><apollo>,2,3,0,2020-11-12 02:05:33
64797462,2,,64411293,1,,<p>If I understand you correctly you want to filter based on if the mutation's returned value is in an array that is passed as an argument to the subscription. Sorry to say that is not possible at this time. Subscription filters only evaluate to true or false and cannot accommodate any logic other than that.</p>&#xA;,5532302,,,,2020-11-12 03:27:29,"",,0,0,0,2020-11-12 03:27:29
64803231,1,,,1,383,"<p>I have been searching for 2 days throughout docs, YouTube and GitHub projects to see if I could solve this problem. I am creating a pizza ordering system of which I have a few different GraphQL types. In this scenario, I have a Topping Type and a Pizza Type. The Pizza Type contains a <em>toppings</em> field which is an array of Topping type.</p>&#xA;<pre><code>    type Topping {&#xA;        id: ID!&#xA;        name: String!&#xA;        price: Float!&#xA;        createdAt: String!&#xA;    }&#xA;    type Pizza {&#xA;        id: ID!&#xA;        location: String!&#xA;        price: Float!&#xA;        toppings: [Topping!]!&#xA;        createdAt: String!&#xA;        toppingCount: Int!&#xA;    }&#xA;</code></pre>&#xA;<p>The Mutation is:</p>&#xA;<pre><code>    createPizza(pizzaInput: PizzaInput): Pizza!&#xA;&#xA;    input PizzaInput {&#xA;        location: String!&#xA;        price: Float!&#xA;        toppings: [ID]! # How To Pass Existing Topping IDs Copied From DB?&#xA;        createdAt: String!&#xA;    }&#xA;</code></pre>&#xA;<p>Passing an array of IDs when calling the mutation within GraphQL playground results in many different errors relation to the structure of the toppings input.</p>&#xA;<pre><code>mutation {&#xA;  createPizza(pizzaInput: {&#xA;    location:&quot;Barcelona&quot;&#xA;    price:12&#xA;    toppings: { # How To Structure This Input?&#xA;      create: [&#xA;        connect:&quot;5faaca3129c74ff103d3ccaf&quot;&#xA;        connect:&quot;5fab01e8e0a1942d701fd408&quot;&#xA;        connect:&quot;5faaed887ac3c53010b8075b&quot;&#xA;        connect:&quot;5fab024de0a1942d701fd409&quot;&#xA;        ]&#xA;    }&#xA;    createdAt:&quot;Now&quot;&#xA;  }){&#xA;    id&#xA;    price&#xA;    location&#xA;    toppings&#xA;    createdAt&#xA;    toppingCount&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Below is the create pizza mutation resolver:</p>&#xA;<pre><code>    Mutation: {&#xA;        createPizza: async (&#xA;            _,&#xA;            { pizzaInput: { location, price, toppings, createdAt } }&#xA;        ) =&gt; {&#xA;            const { valid, errors } = validateCreatePizza(location, price);&#xA;            if (!valid) {&#xA;                throw new UserInputError(&quot;Errors&quot;, { errors });&#xA;            }&#xA;&#xA;            const newPizza = Pizza({&#xA;                location,&#xA;                price,&#xA;                toppings,&#xA;                createdAt&#xA;            });&#xA;&#xA;            console.log(newPizza);&#xA;&#xA;            const pizza = await newPizza.save();&#xA;            return pizza;&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>Topping and Pizza Models:</p>&#xA;<pre><code>const toppingSchema = new Schema({&#xA;    name: String,&#xA;    price: Number,&#xA;    createdAt: String&#xA;});&#xA;module.exports = model(&quot;Topping&quot;, toppingSchema);&#xA;&#xA;const pizzaSchema = new Schema({&#xA;    location: String,&#xA;    price: Number,&#xA;    toppings: [&#xA;        {&#xA;            type: Schema.Types.ObjectId,&#xA;            ref: &quot;toppings&quot;&#xA;        }&#xA;    ],&#xA;    createdAt: String&#xA;});&#xA;module.exports = model(&quot;Pizza&quot;, pizzaSchema);&#xA;</code></pre>&#xA;",7953790,,7953790,2020-11-12 21:41:34,2020-11-12 21:41:34,GraphQL Mutation - Type Error - for One-to-Many Relationship,<javascript><graphql>,1,6,0,2020-11-12 11:39:41
64803530,2,,64803231,0,,"<p>Modify your the structure of your input: i. separate each key/value pair passed as argument object, <code>pizzaInput</code>, with commas; ii. make price a float; iii. <code>toppings</code> in the context of your input type is an array of IDs -- update syntax to reflect that - remove <code>create</code> key and comma separate array values (there is no need to further nest the array in an object).</p>&#xA;<pre><code>mutation {&#xA;  createPizza(pizzaInput: {&#xA;    location: &quot;Barcelona&quot;,&#xA;    price: 12.00, &#xA;    toppings: [&#xA;        &quot;5faaca3129c74ff103d3ccaf&quot;,&#xA;        &quot;5fab01e8e0a1942d701fd408&quot;,&#xA;        &quot;5faaed887ac3c53010b8075b&quot;,&#xA;        &quot;5fab024de0a1942d701fd409&quot;&#xA;       ],&#xA;     createdAt: &quot;Now&quot;&#xA;    }&#xA;  }) {&#xA;    id&#xA;    price&#xA;    location&#xA;    toppings&#xA;    createdAt&#xA;    toppingCount&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>FWIW, looking at your schema for <code>Pizza</code> type, unless a topping will always present, I would make that type nullable, that is, <code>toppings: [Topping!]</code>.</p>&#xA;",8715397,,,,2020-11-12 12:00:23,"",,0,1,0,2020-11-12 12:00:23
64815127,2,,56867951,1,,"<p>In case anyone is wondering, this is because graphene v2 uses commas instead of ampersands in interfaces</p>&#xA;<pre><code>interface x implements y, z {&#xA;   ...&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>and this syntax no longer works, a workaround is to monkey-patch get_sdl</p>&#xA;<pre><code>import re&#xA;&#xA;from myproject import Query, Mutation&#xA;from graphene_federation import service, build_schema&#xA;&#xA;&#xA;# monkey patch old get_sdl&#xA;old_get_sdl = service.get_sdl&#xA;&#xA;def get_sdl(schema, custom_entities):&#xA;    string_schema = old_get_sdl(schema, custom_entities)&#xA;    string_schema = string_schema.replace('\n', ' ')&#xA;&#xA;    pattern_types_interfaces = r'type [A-Za-z]* implements ([A-Za-z]+\s*,?\s*)+'&#xA;    pattern = re.compile(pattern_types_interfaces)&#xA;&#xA;    string_schema = pattern.sub(lambda matchObj: matchObj.group().replace(',', ' &amp;'), string_schema)&#xA;    return string_schema&#xA;&#xA;service.get_sdl = get_sdl&#xA;schema = build_schema(Query, mutation=Mutation)&#xA;</code></pre>&#xA;<p>and it works.</p>&#xA;",6472447,,,,2020-11-13 03:35:49,"",,0,0,0,2020-11-13 03:35:49
64819953,1,64826742,,0,776,"<p>Hi everyone I am creating an api with graphql and mongodb. I am using mongodb aggregation to filter my documents.</p>&#xA;<pre><code>export const findAllVariants = async (_, { orderby, filter, skip, sort, perPage }, context) =&gt; {&#xA;  await jwtAuthentication.verifyTokenMiddleware(context);&#xA;&#xA;  try {&#xA;    const aggregate = Variant.aggregate();&#xA;    const match = { $and: [] };&#xA;&#xA;    if (filter) {&#xA;      await filter.split(' ').forEach((f) =&gt; {&#xA;        match.$and.push({&#xA;          $or: [&#xA;            {&#xA;              color: {&#xA;                $regex: new RegExp(transliterate(f), 'i')&#xA;              }&#xA;            },&#xA;            {&#xA;              size: {&#xA;                $regex: new RegExp(transliterate(f), 'i')&#xA;              }&#xA;            },&#xA;            {&#xA;              sku: {&#xA;                $regex: new RegExp(transliterate(f), 'i')&#xA;              }&#xA;            },&#xA;            {&#xA;              barcode: {&#xA;                $regex: new RegExp(transliterate(f), 'i')&#xA;              }&#xA;            }&#xA;          ]&#xA;        });&#xA;      });&#xA;      aggregate.match(match);&#xA;    }&#xA;&#xA;    const options = {&#xA;      allowDiskUse: true,&#xA;      limit: perPage,&#xA;      page: skip,&#xA;      sortBy: { [orderby]: sort }&#xA;    };&#xA;&#xA;    return Variant.aggregatePaginate(aggregate, options, (err, results, pageCount, count) =&gt; {&#xA;      if (err) {&#xA;        return new ApolloError(`There was an error ${err}`);&#xA;      }&#xA;      console.log(results);&#xA;      return {&#xA;        count,&#xA;        variants: results,&#xA;        pageCount,&#xA;        skip&#xA;      };&#xA;    });&#xA;  } catch (err) {&#xA;    return new ApolloError(`There was an error ${err}`);&#xA;  }&#xA;};&#xA;</code></pre>&#xA;<p>My graphql def is this</p>&#xA;<pre><code>export default gql`&#xA;  type VariantsResult {&#xA;    variants: [Variant]&#xA;    count: Int&#xA;    pageCount: Int&#xA;    skip: Int&#xA;  }&#xA;&#xA;  type Variant {&#xA;    id: String!&#xA;    color: String&#xA;    size: String&#xA;    quantity: Int&#xA;    sku: String&#xA;    barcode: String&#xA;    price: Price&#xA;    images: [String]&#xA;  }&#xA;&#xA;  input VariantInfo {&#xA;    id: ID!&#xA;    color: String!&#xA;    size: String!&#xA;    quantity: Int&#xA;    sku: String!&#xA;    barcode: String!&#xA;    price: InputPrice!&#xA;    images: [ImageInfo]!&#xA;  }&#xA;&#xA;  extend type Query {&#xA;    findAllVariants(orderby: Int, filter: String, skip: Int, sort: Int, perPage: Int): VariantsResult&#xA;  }&#xA;&#xA;  extend type Mutation {&#xA;    createVariant(variantInfo: VariantInfo): Variant!&#xA;    removeVariantFromProduct(variantInfo: VariantInfo, productInfo: ProductInfo): Product!&#xA;    addVariantToProduct(variantInfo: VariantInfo, productInfo: ProductInfo): Product!&#xA;    editVariantFromProduct(variantInfo: VariantInfo): Variant!&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>Now in apollo playground when i provide the data needed and I return the id value it says the following message &quot;Cannot return null for non-nullable field Variant.id.&quot;</p>&#xA;<p>This only happens for the id field, all the others work just fine.&#xA;Please help!</p>&#xA;",11830357,,,,2020-11-14 14:22:28,Graphql mongodb cannot return _id,<node.js><mongodb><graphql>,1,0,0,2020-11-13 11:17:03
64829947,1,64830739,,2,1274,"<p>I am currently developing a Pizza Ordering/Tracking system for my local pizzeria. As you can see below, I have the GraphQL types and Mongoose models defined. In my pizza, I have an array of toppings which I set to reference the topping model. My question is, what would my mutation definition and the call to that mutation with the required arguments look like?</p>&#xA;<p>I want my Pizza document in Mongoose to containt the relevant ToppingIds so I can reference other fields of that topping such as the name and price. Hope that's clear. Maybe an array is not the best way to approach this??</p>&#xA;<p>If there is a more efficient way to have toppings within the pizza model, pls do share.</p>&#xA;<p>GraphQL Types:</p>&#xA;<pre><code>    type Topping {&#xA;        id: ID!&#xA;        name: String!&#xA;        price: Float!&#xA;        createdAt: String!&#xA;    }&#xA;    type Pizza {&#xA;        id: ID!&#xA;        location: String!&#xA;        price: Float!&#xA;        toppings: [Topping]!&#xA;        createdAt: String!&#xA;        toppingCount: Int!&#xA;    }&#xA;</code></pre>&#xA;<p>Mongoose Models:</p>&#xA;<pre><code>const pizzaSchema = new Schema({&#xA;    location: String,&#xA;    price: Number,&#xA;    toppings: {&#xA;        type: Schema.Types.ObjectId,&#xA;        ref: &quot;toppings&quot;&#xA;    },&#xA;    createdAt: String&#xA;});&#xA;&#xA;const toppingSchema = new Schema({&#xA;    name: String,&#xA;    price: Number,&#xA;    createdAt: String&#xA;});&#xA;</code></pre>&#xA;<p>So ideally when viewing a pizza in the database, it should look like:</p>&#xA;<pre><code>_id: ObjectId(&quot;5fab2e6cc4b5e628685228f6&quot;)&#xA;&gt; toppings:Array&#xA;[&#xA;    ObjectId(&quot;5fab2e6cc4b5e628685228f7&quot;)&#xA;    ObjectId(&quot;5fab2e6cc4b5e628685228f8&quot;)&#xA;]&#xA;location:&quot;Barcelona&quot;&#xA;price:123&#xA;createdAt:&quot;12&quot;&#xA;__v:0&#xA;</code></pre>&#xA;<p>Thanks in advance.</p>&#xA;<p>Edit: My Mutation Type and Mutation Call/Args + Error Message</p>&#xA;<pre><code>createPizza(pizzaInput: PizzaInput): Pizza!&#xA;input PizzaInput {&#xA;    location: String!&#xA;    price: Float!&#xA;    toppings: [ID]!&#xA;    createdAt: String!&#xA;}&#xA;&#xA;mutation {&#xA;  createPizza(pizzaInput: {&#xA;    location:&quot;Barcelona&quot;&#xA;    price:12&#xA;    toppings: [&#xA;      &quot;5faaca3129c74ff103d3ccaf&quot;&#xA;      &quot;5faaed887ac3c53010b8075b&quot;&#xA;    ]&#xA;    createdAt:&quot;AAAA&quot;&#xA;  }){&#xA;    id&#xA;    price&#xA;    location&#xA;    toppings {&#xA;      id&#xA;    }&#xA;    createdAt&#xA;    toppingCount&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Error Message:&#xA;&quot;ID cannot represent value: &lt;Buffer 5f aa ca 31 29 c7 4f f1 03 d3 cc af&gt;&quot;</p>&#xA;",7953790,,7953790,2020-11-16 14:57:36,2020-11-18 05:41:54,GraphQL & Mongoose Schema - How to store an array of mongoose objectId references to another type?,<node.js><mongodb><mongoose><graphql>,1,0,0,2020-11-14 01:04:31
64830739,2,,64829947,3,,"<p>I believe you'll need the toppings value in the pizzaSchema to reflect that it is an array. Currently, it is just defined as an object like this:</p>&#xA;<pre><code>    toppings: {&#xA;        type: Schema.Types.ObjectId,&#xA;        ref: &quot;toppings&quot;&#xA;    },&#xA;</code></pre>&#xA;<p>Instead of (note the brackets indicating an array):</p>&#xA;<pre><code>    toppings: [{&#xA;        type: Schema.Types.ObjectId,&#xA;        ref: &quot;toppings&quot;&#xA;    }],&#xA;</code></pre>&#xA;<p>Or in full, it should look like this:</p>&#xA;<pre><code>const pizzaSchema = new Schema({&#xA;    location: String,&#xA;    price: Number,&#xA;    toppings: [{&#xA;        type: Schema.Types.ObjectId,&#xA;        ref: &quot;toppings&quot;&#xA;    }],&#xA;    createdAt: String&#xA;});&#xA;</code></pre>&#xA;<p>Update after <a href=""https://stackoverflow.com/revisions/64829947/2"">your edit</a>:</p>&#xA;<p>Do you have a resolver defined for Pizza.toppings? I'm guessing that you're missing something like this in your resolvers map:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  Pizza: {&#xA;    toppings: (parent) =&gt; {&#xA;      const obj_ids = parent.toppings.map((id) =&gt; ObjectId(id));&#xA;      return Topping.find({ _id: { $in: obj_ids } });&#xA;    },&#xA;  }&#xA;</code></pre>&#xA;<p>I'm not a GraphQL expert so I'm not sure if there is a more efficient way to have toppings within the pizza model, but based on a test I did adding the above resolver gets passed the &quot;ID cannot represent value...&quot; issue.</p>&#xA;",3534,,3534,2020-11-18 05:41:54,2020-11-18 05:41:54,"",,0,5,0,2020-11-14 03:43:29
64838885,1,,,1,75,"<p>I'm working on a website built with Gatsby. To consume the data (coming from an airTable table), I've created a custom hook (useData) that performs a GraphQL query, using useStaticQuery. I need to filter this data according to their status (those that have Status = &quot;open&quot;); so, I've created a filter in the query for it, like this:</p>&#xA;<pre><code>    useStaticQuery(graphql`&#xA;    query {&#xA;      allAirtable(&#xA;        filter: { table: { eq: &quot;Positions&quot; }, data: { Title: { ne: null }, Status: { eq: &quot;open&quot; } } }&#xA;      ) {&#xA;        nodes {&#xA;          data {&#xA;            Title&#xA;            Location&#xA;            Status&#xA;            ID&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `);&#xA;</code></pre>&#xA;<p>The hook useData, looks like this:</p>&#xA;<pre><code>import { useStaticQuery, graphql } from 'gatsby';&#xA;import { useTranslateNodes } from './useTranslateNodes';&#xA;&#xA;export default function useData() {&#xA;  const queryData = useStaticQuery(graphql`&#xA;    query {&#xA;      allAirtable(&#xA;        filter: { table: { eq: &quot;Positions&quot; }, data: { Title: { ne: null }, Status: { eq: &quot;open&quot; } } }&#xA;      ) {&#xA;        nodes {&#xA;          data {&#xA;            Title&#xA;            Location&#xA;            Status&#xA;            ID&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `);&#xA;  const {&#xA;    allAirtable: { nodes },&#xA;  } = queryData;&#xA;&#xA;  const positions = useTranslateNodes({ nodes, table: 'Positions' });&#xA;&#xA;  return { positions };&#xA;}&#xA;</code></pre>&#xA;<p><em>(The useTranslateNodes hook, maps the array from the query and returns a better structured array. This is not really important for the issue)</em></p>&#xA;<p>The problem is when I test the query result (I want to be sure that the hook is doing it's job, and is returning the positions with Status = &quot;open&quot;), because according to the <a href=""https://www.gatsbyjs.com/docs/testing-components-with-graphql/"" rel=""nofollow noreferrer"">Gatsby docs</a>, I have to mock the data from the query, but that's not the real data! And it makes no sense to me... I also try using the <a href=""https://www.gatsbyjs.com/plugins/gatsby-plugin-testing/"" rel=""nofollow noreferrer"">gatsby-plugin-testing</a>, to get the real data from the query, but in the end, still taking the mock data (because without it, it doesn't work).</p>&#xA;<p>My question is: How can I do a unit test for the filter of the query? I mean, I wanna test that the filter is doing its job!</p>&#xA;<p>I hope I have provided the necessary information to resolve this issue. I've been reading related issues here, but still without a concrete solution. I'm a testing newbie and I'm a bit confused about it, so thanks for the help you can provide!</p>&#xA;",13282380,,6463558,2020-11-18 04:04:32,2020-11-18 04:04:32,How to unit testing the filter result of a graphql query in Gatsby?,<javascript><unit-testing><jestjs><graphql><gatsby>,0,0,0,2020-11-14 21:38:26
64881852,2,,64876804,1,,"<p>&quot;AND&quot; should contain array of objects, not object.</p>&#xA;<pre><code>&quot;conditions&quot;: {&quot;AND&quot;: [{&quot;column&quot;: &quot;PRICE&quot;, &quot;operator&quot;: &quot;LTE&quot;,&quot;value&quot;: &quot;190&quot;}}]&#xA;</code></pre>&#xA;",14505288,,,,2020-11-17 19:15:43,"",,0,0,0,2020-11-17 19:15:43
64884273,2,,55165772,0,,"<p>I had a similar situation where I had to aggregate data through paginating from a GraphQL endpoint. Trying the above solution didn't work for me that well.</p>&#xA;<p>to start my header config for graphql was like this:</p>&#xA;<pre><code> headers = {&#xA;        &quot;Authorization&quot;:f&quot;Bearer {token}&quot;,&#xA;        &quot;Content-Type&quot;:&quot;application/graphql&quot;&#xA;}&#xA;</code></pre>&#xA;<p>for my query string, I used the triple quote with a variable placeholder:</p>&#xA;<pre><code>  user_query = &#xA;   &quot;&quot;&quot;&#xA;         {&#xA;           user(&#xA;                limit:100,&#xA;                page:$page,&#xA;                sort:[{field:&quot;email&quot;,order:&quot;ASC&quot;}]&#xA;            ){&#xA;                list{&#xA;                    email, &#xA;                    count&#xA;                 }&#xA;            }&#xA;   &quot;&quot;&quot;&#xA;</code></pre>&#xA;<p>Basically, I had my loop here for the pages:</p>&#xA;<pre><code>for page in range(1, 9):&#xA;    formatted_query = user_query.replace(&quot;$page&quot;,f'{page}')&#xA;    response = requests.post(api_url, data=formatted_query, &#xA;    headers=headers)&#xA;    status_code, json = response.status_code, response.json()&#xA;</code></pre>&#xA;",8329515,,,,2020-11-17 22:27:39,"",,0,0,0,2020-11-17 22:27:39
64894982,1,,,0,227,"<p>I am a traditional programmer new to GraphQL and I can't seem  to find documentation on what I consider the basics, aka manipulating variables. Note: I am using GraphQL with Shopify(Admin API), through an app GraphiQL, so that my effect syntax and capabilities.</p>&#xA;<p>Here is a piece of hypo (&amp; broken) code where I have two iterations of the same code block</p>&#xA;<ol>&#xA;<li>&lt;&gt;that tries to add two variables</li>&#xA;<li>&lt;&gt;on that sum items in a list. The specific code in this lines are guesswork..</li>&#xA;</ol>&#xA;<p>&#xA;If anyone has suggestions on sources for example code or API docs beyond GraphQL site, I have been searching and nothing I have found addresses this type of functionality.&#xA;<pre><code>query fiveorTenOrders($n: Int = 5,$m: list =[5,5], $boo: Boolean = true) {&#xA;  FiveOrds: orders(first: $n) {&#xA;    edges @include(if: $boo) {&#xA;      node {&#xA;        ...ordrecs&#xA;      }&#xA;    }&#xA;  }&#xA;  #&lt;&lt;&lt;HERE and as basic arithmetic&gt;&gt;&gt; &#xA;  TenOrds: orders(first: ($n+$n) {&#xA;    edges @skip(if: $boo) {&#xA;      node {&#xA;        ...ordrecs&#xA;        &#xA;  #&lt;&lt;&lt;OR HERE ...as a sum of list&gt;&gt;&gt; &#xA;  TenOrds: orders(first: $m:SUM {&#xA;    edges @skip(if: $boo) {&#xA;      node {&#xA;        ...ordrecs      &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment ordrecs on Order {&#xA;  id&#xA;  name&#xA;  createdAt&#xA;  shippingAddress {&#xA;    id&#xA;    city&#xA;    provinceCode&#xA;    zip&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",9225740,,,,2020-11-18 14:33:15,How do you perform operations on variables in GraphQL?,<graphql><shopify><graphiql>,1,0,0,2020-11-18 14:23:50
64921423,2,,64921272,1,,"<p>I would use map for this since you dont want to return filtered nodes, but instead return the titles of each</p>&#xA;<pre><code>var nodes = data.data.shop.products.edges;&#xA;&#xA;var silks = nodes.map(node =&gt; {&#xA;    if node.material.value === 'Silk':&#xA;        return node.title&#xA;})&#xA;&#xA;var cotton = nodes.map(node =&gt; {&#xA;    if node.material.value === 'Cotton':&#xA;        return node.title&#xA;})&#xA;</code></pre>&#xA;",8644261,,,,2020-11-19 23:13:01,"",,0,1,0,2020-11-19 23:13:01
64932895,2,,64930953,1,,"<p>There's no way to do what you're asking using GraphQL syntax alone. However, you could use string interpolation and <a href=""http://spec.graphql.org/June2018/#sec-Field-Alias"" rel=""nofollow noreferrer"">field aliases</a> to achieve the same result. Here's what that would look like using JavaScript:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const inputs = [...]&#xA;const variableDefinitions = inputs&#xA;  .map((_input, index) =&gt; `$input${index}: EntityInput!`)&#xA;  .join(', ')&#xA;const selectionSet = inputs&#xA;  .map((_input, index) =&gt; `&#xA;    entityUpdate${index}: entityUpdate(input: $input${index}) {&#xA;      entity {&#xA;        id&#xA;      }&#xA;    }&#xA;  `)&#xA;  .join('/n')&#xA;const query = `&#xA;  mutation (${variableDefinitions}) {&#xA;    ${selectionSet}&#xA;  }&#xA;}&#xA;`&#xA;const variables = inputs.reduce((acc, input, index) =&gt; {&#xA;  acc[`input${index}`] = input&#xA;  return acc&#xA;}, {})&#xA;</code></pre>&#xA;<p>This results in a map of variables like <code>$input0</code>, <code>$input1</code>, etc. and a responding query like:</p>&#xA;<pre><code>mutation ($input0: EntityInput!, $input1: EntityInput) {&#xA;  entityUpdate0: entityUpdate(input: $input0) {&#xA;      entity {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;  entityUpdate1: entityUpdate(input: $input1) {&#xA;      entity {&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>You can utilize a fragment to reduce the duplication among the selection sets and reduce the size of your payload.</p>&#xA;<p>Additionally, some servers (like <a href=""https://chillicream.com/docs/hotchocolate/v10/execution-engine/batching#request-batching"" rel=""nofollow noreferrer"">Hot Chocolate</a>) support batching operations inside a single HTTP request. If the server you're querying supports this feature, that would be an alternative way of accomplishing the same goal.</p>&#xA;",6024220,,,,2020-11-20 16:09:45,"",,0,0,0,2020-11-20 16:09:45
64936501,1,,,-2,176,"<p>I have to call graphql query in the fetch method. So how can I call this method?</p>&#xA;<p>I have to call the below query in the fetch method.</p>&#xA;<pre><code>query AddressList($street:String, $city:String, $state:String, $zip:String) {&#xA;   address_list(street:$street, city:$city, state:$state, zip:$zip){&#xA;    street&#xA;    city&#xA;    state&#xA;    zip&#xA;    &#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Anyone, please suggest me a solution.</p>&#xA;<p>Thanks.</p>&#xA;",11481068,,,,2020-11-21 02:20:05,Call graphql query in fetch method,<node.js><graphql><apollo-server>,1,1,0,2020-11-20 20:33:04
64939203,2,,64936501,0,,"<p><a href=""http://tnickel.de/"" rel=""nofollow noreferrer"">I</a> am using this one:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>    async function graphql(query, variables={}){&#xA;        const r = await fetch('/graphql', {&#xA;            method:&quot;POST&quot;,&#xA;            headers: {&#xA;                &quot;Content-Type&quot;: &quot;application/json&quot;&#xA;            },&#xA;            body:JSON.stringify({&#xA;                query,&#xA;                variables&#xA;            })&#xA;        });&#xA;        var result = (await r.json());&#xA;&#xA;        // error handling&#xA;        if(result.errors){&#xA;            throw result.errors&#xA;            &#xA;        }&#xA;        &#xA;        if(r.ok){&#xA;            return result.data&#xA;        }&#xA;        &#xA;        throw result;&#xA;    }&#xA;</code></pre>&#xA;<p>You can use it like:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const { address_list } = await graphql(`query AddressList($street:String, $city:String, $state:String, $zip:String) {&#xA;   address_list(street:$street, city:$city, state:$state, zip:$zip){&#xA;    street&#xA;    city&#xA;    state&#xA;    zip&#xA;    &#xA;  }&#xA;}`,{street:'streetName',city: 'cityName', state:'stateName'})&#xA;</code></pre>&#xA;",4129819,,,,2020-11-21 02:17:30,"",,0,0,0,2020-11-21 02:17:30
64942355,2,,64942104,1,,"<p>You could take an array for filtering with key/value pairs, like</p>&#xA;<pre><code>filters = [&#xA;    ['author', 'eliot'],&#xA;    ['genre', 'fiction']&#xA;]&#xA;</code></pre>&#xA;<p>and an object for storing special type of searching, like</p>&#xA;<pre><code>methods = {&#xA;    genre: 'includes'&#xA;}&#xA;</code></pre>&#xA;<p>Together, you get the following function</p>&#xA;<pre><code>result = books.filter(book =&gt; filter.every(([key, value]) =&gt; key in methods&#xA;    ? book[key][methods[key]](value)&#xA;    : book[key] === value&#xA;));&#xA;</code></pre>&#xA;<p>Because of <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"" rel=""nofollow noreferrer""><code>Array#every</code></a>'s return value of <code>true</code> for empty arrays, you need no further action to get all books.</p>&#xA;",1447675,,,,2020-11-21 11:08:15,"",,0,0,0,2020-11-21 11:08:15
64950335,2,,60115193,0,,"<p>I had the same issue in an Android project I was working on.</p>&#xA;<p>I fixed it by placing the next code in a file I created under <code>app/src/main/graphql</code> (I had to create the folder graphql).</p>&#xA;<p><strong>/app/src/main/graphql/aws-directives.graphql</strong></p>&#xA;<pre><code>directive @connection(name: String, keyField: String, sortField: String, limit: Int) on FIELD_DEFINITION&#xA;</code></pre>&#xA;<p>Then, instead of using @key I only used the directive @connection like this</p>&#xA;<pre><code>type Comment @model {&#xA;   id: ID!&#xA;   text: String!&#xA;   postId: Post @connection(name: &quot;commentsByPost&quot;)&#xA;}&#xA;&#xA;&#xA;type Post @model {&#xA;   id: ID!&#xA;   comments: [Comment] @connection(name: &quot;commentsByPost&quot;)&#xA;}&#xA;</code></pre>&#xA;<p>Finally when you create comments you have to pass the postId. If you do a query to list the Posts and its comments you will get the comments associated with each post correctly.</p>&#xA;",14684280,,,,2020-11-22 03:15:50,"",,0,1,0,2020-11-22 03:15:50
65001867,2,,64544465,1,,"<p>I believe you have to do the sorting on the &quot;clients&quot; method. Therefore i am not sure the field resolver is going to help you. You better separate that into a utility function and reuse it in both methods.</p>&#xA;<p>To to the sorting on the clients method:</p>&#xA;<ul>&#xA;<li>if you use mongodb, maybe you can do an aggregated query that will create this virtual field and order by it</li>&#xA;<li>if you use another DB , you will have to look if they have this kind of feature</li>&#xA;</ul>&#xA;<p>If you don't want to do sorting through DB, you can get the array of clients and do a sort</p>&#xA;<p><code>clients.sort((a,b) =&gt; sortByCompanyName(company.CLIENT_NAME_SORT, a, b))</code></p>&#xA;<pre><code>getFullIdentificator(order, client) {&#xA;  if (order === ClientNameSort.FIRST_NAME) {&#xA;      return `${client.firstName} ${client.lastName} ${client.id}`&#xA;    } else {&#xA;      return `${client.lastName} ${client.firstName} ${client.id}`&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<pre><code>sortByCompanyName(order, prev, next) {&#xA;  return getFullIdentificator(order, prev) &gt;  getFullIdentificator(order, next) ? 1 : -1 &#xA;}&#xA;</code></pre>&#xA;",1635774,,,,2020-11-25 09:30:47,"",,0,0,0,2020-11-25 09:30:47
65011608,1,65044661,,3,673,"<p>I have parent component that ends up with nested fragments looking like this:</p>&#xA;<pre><code>query MyAppQuery(&#xA;    $id&#xA;    $a&#xA;    $b&#xA;    $c&#xA;) {&#xA;    viewer {&#xA;      ...App_viewer&#xA;      ...ComponentA_viewer @include(if: $a)&#xA;      ...ComponentB_viewer @include(if: $b)&#xA;      ...ComponentC_viewer @include(if: $c)&#xA;    }&#xA;    allEmployees: allUsers(userType: &quot;1&quot;) {&#xA;        ...ComponentA_allEmployees @include(if: $a)&#xA;        ...ComponentB_allEmployees @include(if: $b)&#xA;        ...ComponentC_allEmployees @include(if: $c)&#xA;    }&#xA;};&#xA;</code></pre>&#xA;<p>Relay fails if I don't include all this child fragments but the data is the same for all these, it seems pretty dumb having to declare a view fragment on all my child components that require the signed in user.</p>&#xA;<p>How can I request this piece of data at the top of my application and have it available to child components without having to include the all these fragments.</p>&#xA;<p>This is starting to feel like reverse prop drilling with I have to declare a fragment at the lower end of my app and pass it up the chain.</p>&#xA;<p>Same with allEmployees. It's the same data that I should only get once and pass down or access through context but I have to pass in all these stupid fragments or relay complains.</p>&#xA;",1297248,,,,2020-11-27 22:49:21,How to pass down props without duplicating fragments,<javascript><graphql><relayjs><relay><react-relay>,1,0,0,2020-11-25 19:36:30
65039071,1,,,0,117,"<p>I need to be able to create a catalog for a given entity and then somewhere in the grandchildren I want to use the catalog IDs and resolve them.</p>&#xA;<p>think of this (very simplified) data model</p>&#xA;<pre><code>type Entity {&#xA;  id: ID&#xA;  componentCatalog: [Component]&#xA;  child: Child&#xA;}&#xA;&#xA;type Child {&#xA;  grandChildren: [GrandChild]&#xA;}&#xA;&#xA;type GrandChild {&#xA;  components: [Component]&#xA;}&#xA;</code></pre>&#xA;<p>in the NoSQL db I would store this as:</p>&#xA;<pre><code>{&#xA;   id: 'abc',&#xA;   componentCatalog: [ { id: 1, title: 'a' }, { id: 2, title: 'b' }],&#xA;   child: {&#xA;     grandChildren: [&#xA;      {&#xA;        componentIds: [1]&#xA;      },&#xA;      {&#xA;        componentIds: [1,2]&#xA;      }&#xA;     ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>and I would like to resolve the IDs to the components that are stored in the catalog of the Entity&#xA;however how do I get to the data from the grandchildren? Parent is just a child, do I have to save the catalog into the GQL context? If so then how? If there are multiple entities in the query how do I know which Grandchild belongs to which entity?</p>&#xA;<p>Thanks a lot in advance</p>&#xA;",671704,,,,2020-11-27 14:31:29,GraphQL ancestor data context,<graphql>,0,2,0,2020-11-27 14:31:29
65044661,2,,65011608,1,,"<p>This is a core pattern to Relay, and despite the verbosity, it is actually highly encouraged.</p>&#xA;<p>In Relay, child components are encouraged to specify their data requirements on their own in the form of fragments.</p>&#xA;<p>Ultimately, you're going to end up accumulating a lot of fragments that get spread elsewhere in your app, so it's worth pointing out a few key Relay features about why this is good:</p>&#xA;<ol>&#xA;<li><p>Relay will not send duplicate requests to your API if you declare several fragments next to each other that request the same field(s). Instead, they will all get fetched once, in one round-trip. You don't have to worry about introducing overfetching/duplicate query problems, because they don't exist in Relay.</p>&#xA;</li>&#xA;<li><p>Relay introduces a compilation step via the Relay Compiler, that intelligently analyzes your GraphQL schema and any <code>graphql</code> template tags that you define in your code. This generates <em>artifacts</em>, which help manage fetching data and updating the Relay store automagically, so you don't have to. By declaring a lot of fragments, you are effectively telling the compiler and store about the data requirements of your components, even if they are the same/similar. Duplication here is what makes Relay great.</p>&#xA;</li>&#xA;<li><p>Your QueryRenderer ancestor at the root of the tree will handle the actual fetching, and the fragments you've defined on child components lower in the tree instruct the Relay Compiler and Store where to send the data once it is fetched. This follows from #2.</p>&#xA;</li>&#xA;</ol>&#xA;<p>So, in short, to make the most of Relay, declare your components' data requirements with fragments, and let Relay do the heavy lifting, and don't worry about duplication and lack of reusability. It is to your advantage.</p>&#xA;",4301222,,,,2020-11-27 22:49:21,"",,0,4,0,2020-11-27 22:49:21
65052418,1,,,0,80,"<p>I want to keep all of the types in a single collection named “BenchmarkDatasets”. Do I need to declare the subtypes(LatData, AggregateData, MetaData) differently or do I just need to accept that I’ll have a collection for every type?</p>&#xA;<p>Any help is greatly appreciated.</p>&#xA;<p>Here's the Schema I <a href=""https://walmartlabs.github.io/json-to-simple-graphql-schema/"" rel=""nofollow noreferrer"">generated</a>:</p>&#xA;<pre><code>type LatData {&#xA;    LatResults: [[Int ]] &#xA;    LatResultSize: [Int ] &#xA;}&#xA;&#xA;type AggregateData { &#xA;    EVRCounter: Int&#xA;    EVRLatencyTotal: Int&#xA;    EVRLatencyAverage: Float&#xA;    LatTestCount: Int&#xA;    LatencyTotal: Int&#xA;    LatencyAverage: Float &#xA;}&#xA;&#xA;type MetaData { &#xA;    StartTimeUTC: String&#xA;    EndTimeUTC: String&#xA;    StartTimeLocal: String&#xA;    EndTimeLocal: String &#xA;}&#xA;&#xA;type BenchmarkDataset { &#xA;    LatData: LatData&#xA;    AggregateData: AggregateData&#xA;    MetaData: MetaData&#xA;}&#xA;&#xA;type Query {&#xA;  allBenchmarkDatasets: [BenchmarkDataset!]&#xA;}&#xA;</code></pre>&#xA;<p>And here's the data I want to shove into &quot;BenchmarkDatasets&quot;:</p>&#xA;<pre><code>    {&#xA;        &quot;MetaData&quot; : &#xA;            {&#xA;                &quot;StartTimeUTC&quot; : &quot;Sun Oct 18 21:41:38 2020\n&quot;,&#xA;                &quot;EndTimeUTC&quot; : &quot;Sun Oct 18 21:45:38 2020\n&quot;,&#xA;                &quot;StartTimeLocal&quot; : &quot;Sun Oct 18 16:41:38 2020\n&quot;,&#xA;                &quot;EndTimeLocal&quot; : &quot;Sun Oct 18 16:45:38 2020\n&quot;&#xA;            },&#xA;            &quot;AggregateData&quot; : &#xA;            {&#xA;                &quot;EVRCounter&quot; : 3,&#xA;                &quot;EVRLatencyTotal&quot; : 70,&#xA;                &quot;EVRLatencyAverage&quot; : 23.333333333333332,&#xA;                &quot;LatTestCount&quot; : 159,&#xA;                &quot;LatencyTotal&quot; : 11871,&#xA;                &quot;LatencyAverage&quot; : 74.660377358490564&#xA;            },&#xA;            &quot;LatData&quot; : &#xA;            {&#xA;                &quot;LatResultSize&quot; : &#xA;                [&#xA;                    4,&#xA;                    4,&#xA;                    4&#xA;                ],&#xA;                &quot;LatResults&quot; : &#xA;                [&#xA;                    [&#xA;                        0,&#xA;                        2,&#xA;                        &quot;zoom&quot;,&#xA;                        &quot;latencymonitor&quot;&#xA;                    ],&#xA;                    [&#xA;                        1,&#xA;                        1,&#xA;                        &quot;zoom&quot;,&#xA;                        &quot;latencymonitor&quot;&#xA;                    ],&#xA;                    [&#xA;                        2,&#xA;                        1,&#xA;                        &quot;zoom&quot;,&#xA;                        &quot;latencymonitor&quot;&#xA;                    ],&#xA;                    [&#xA;                        3,&#xA;                        1,&#xA;                        &quot;dota2&quot;,&#xA;                        &quot;dota2&quot;&#xA;                    ]&#xA;                ]&#xA;            }&#xA;        }&#xA;</code></pre>&#xA;<p>Also, I know that my data is not well formatted(specifically the 2d &quot;LatData&quot; array that contains 2 ints and 2 strings), and any data format tips are also appreciated.</p>&#xA;",2934222,,2934222,2020-11-30 12:56:47,2020-11-30 12:56:47,Keeping multiple types ( nesting types / embedding types ) in a single collection:,<graphql><faunadb>,1,2,0,2020-11-28 17:18:14
65056068,1,,,0,558,"<p>My DynamoDB table data schema:</p>&#xA;<pre><code>PartitionKey: &quot;PK&quot; -&gt; String&#xA;SortKey: &quot;SK&quot; -&gt; Number (timestamp)&#xA;Attribute: &quot;Summary&quot; -&gt; JsonMap&#xA;</code></pre>&#xA;<p>My main usecase is that I have a &quot;PK&quot; and the range of &quot;SK&quot;, which is the target time range, and query DDB to get a list of &quot;Summaries&quot;. This data design is good for DDB APIs.</p>&#xA;<p>Now, I want to use AppSync to create a GraphQL API for this DynamoDB for a Amplify app. So I create a GraphQL schema like this:</p>&#xA;<pre><code>type DataSummary {&#xA;    PK: String!&#xA;    SK: Float!&#xA;    Summary: AWSJSON&#xA;}&#xA;</code></pre>&#xA;<p>GraphQL automatically creates 2 query APIs for me: <code>getDataSummary</code> and <code>listDataSummary</code>. What supperises me is, when I do list API, I can use filter to define the query as:</p>&#xA;<pre><code>query listDataSummaries {&#xA;  listDataSummaries(filter: {PK: {eq: &quot;##Some key string##}&quot;}, SK: {gt: ##Some timestamp##}}) {&#xA;    items {&#xA;      PK&#xA;      SK&#xA;      Summary&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But, the return value is &quot;null&quot; because of paginating, which means GraphQL is doing a table scan to gather all items in the table and then does a filter based on my request. This is against my table design because it requires significantly more RCUs than a normal DDB API call for the same result.&#xA;So, what did I miss? How can I &quot;ask&quot; GraphQL to do a DDB query instead of a scan for PK/SK list operation?</p>&#xA;",8859029,,11301220,2020-11-29 01:42:42,2020-11-29 05:17:55,AWS AppSync GraphQL - How to use PK/SK query instead of scanning whole dynamoDB table for graphql list APIs,<amazon-web-services><graphql><amazon-dynamodb><aws-appsync>,1,0,0,2020-11-29 01:17:39
65067967,1,65073702,,2,85,"<p>Beforehand, hello to everyone!</p>&#xA;<p>I initialize Graphql in Loopback 4 like this:</p>&#xA;<pre><code>  const graphqlPath = '/graphql';&#xA;  // @ts-ignore&#xA;  const oas: Oas3 = await (&lt;Oas3&gt;app.restServer.getApiSpec());&#xA;  console.log(graphqlHTTP);&#xA;  const {schema} = await createGraphQLSchema(oas, {&#xA;    strict: false,&#xA;    viewer: true,&#xA;    baseUrl: url,&#xA;  });&#xA;  //@ts-ignore&#xA;  const handler: graphqlHTTP.Middleware = graphqlHTTP({&#xA;    schema,&#xA;    graphiql: true,&#xA;  });&#xA;  app.mountExpressRouter(graphqlPath, handler);&#xA;  console.log(`Graphql: ${url}${graphqlPath}`);&#xA;</code></pre>&#xA;<p>Then I have a relation Favors&gt;User (a User can have many Favors, but a Favor has only one User). I've created this relation with <code>lb4 relation</code>, and <strong>I haven't made any other change</strong>.</p>&#xA;<p>User Model:</p>&#xA;<pre><code>  @hasMany(() =&gt; Favor)&#xA;  favors: Favor[];&#xA;</code></pre>&#xA;<p>Favor Model:</p>&#xA;<pre><code>  @belongsTo(() =&gt; User)&#xA;  userId: string;&#xA;</code></pre>&#xA;<p>At the moment of the query (<code>http://localhost:3000/graphql</code>) this is what happens:</p>&#xA;<pre><code>{&#xA;  favors {&#xA;    id&#xA;    userId&#xA;    user {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/by6F8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/by6F8.png"" alt=""Query result"" /></a></p>&#xA;<p>I have no idea if it has something to do with the <code>loopback-connector-mongodb</code> which does not match ObjectId correctly, but I have no clue how to solve this.</p>&#xA;<p>My package.json:</p>&#xA;<pre><code>    &quot;@loopback/core&quot;: &quot;^2.12.0&quot;,&#xA;    &quot;openapi-to-graphql&quot;: &quot;^2.2.5&quot;,&#xA;    &quot;loopback-connector-mongodb&quot;: &quot;^5.4.0&quot;,&#xA;</code></pre>&#xA;",5520391,,,,2020-11-30 14:28:05,Can't see relations - Loopback 4 + MongoDB + openapi-to-graphql,<mongodb><graphql><loopback>,1,0,0,2020-11-30 04:03:45
65095247,1,,,1,1754,"<p>Using HotChocolate Version: 10.5.5</p>&#xA;<p>And given the following <code>Customer</code> domain model:</p>&#xA;<pre><code>public class Customer&#xA;{&#xA;    [Key]&#xA;    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]&#xA;    public int CustomerID { get; set; }&#xA;    public string FirstName { get; set; }&#xA;    public string LastName { get; set; }&#xA;    public string CompanyName { get; set; }&#xA;    public string SalesPerson { get; set; }&#xA;}&#xA;</code></pre>&#xA;<p>When exposing the Entity Framework <code>Customers</code> dbset in a query interface:</p>&#xA;<pre><code>[UseSelection]&#xA;[UseFiltering]&#xA;public IQueryable&lt;Customer&gt; GetCustomers([Service] AdventureWorksContext ctx) =&gt; ctx.Customers;&#xA;</code></pre>&#xA;<p>And executing the following graphql query:</p>&#xA;<pre><code>query {&#xA;  friendlyBikeShop: customers (where: { companyName: &quot;Friendly Bike Shop&quot;}){&#xA;    firstName,&#xA;    lastName&#xA;  },&#xA;  frontSportingGoods: customers (where: { companyName: &quot;Front Sporting Goods&quot;}){&#xA;    firstName,&#xA;    lastName&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Results in the following two SQL statements:</p>&#xA;<pre><code>SELECT [c].[FirstName], [c].[LastName]&#xA;FROM [SalesLT].[Customer] AS [c]&#xA;WHERE [c].[CompanyName] = N'Front Sporting Goods'&#xA;&#xA;SELECT [c].[FirstName], [c].[LastName]&#xA;FROM [SalesLT].[Customer] AS [c]&#xA;WHERE [c].[CompanyName] = N'Front Sporting Goods'&#xA;</code></pre>&#xA;<p>This isn't ideal as I would like to merge this into one SQL statement:</p>&#xA;<pre><code>SELECT [c].[FirstName], [c].[LastName]&#xA;FROM [SalesLT].[Customer] AS [c]&#xA;WHERE [c].[CompanyName] in (N'Front Sporting Goods', N'Front Sporting Goods')&#xA;</code></pre>&#xA;<p>A first attempt to solve this problem using a <code>GroupDataLoader</code> is as follows:</p>&#xA;<pre><code>[UseSelection]&#xA;[UseFiltering]&#xA;public Task&lt;Customer[]&gt; GetCustomersByCompanyName(IResolverContext resolverCtx, [Service] AdventureWorksContext ctx, string companyName) =&gt;&#xA;    resolverCtx.GroupDataLoader&lt;string, Customer&gt;(&quot;customers&quot;, async keys =&gt;&#xA;    {&#xA;        var customers = await ctx.Customers.Where(customer =&gt; keys.Any(key =&gt; key == customer.CompanyName)).ToListAsync();&#xA;        return customers.ToLookup(customer =&gt; customer.CompanyName);&#xA;    }).LoadAsync(companyName, default);&#xA;</code></pre>&#xA;<p>And executing the following graphql:</p>&#xA;<pre><code>query {&#xA;  friendlyBikeShop: customersByCompanyName(companyName: &quot;Friendly Bike Shop&quot;){&#xA;    firstName,&#xA;    lastName&#xA;  },&#xA;  frontSportingGoods: customersByCompanyName(companyName: &quot;Front Sporting Goods&quot;){&#xA;    firstName,&#xA;    lastName&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Results in the following single SQL statement:</p>&#xA;<pre><code>SELECT [c].[CustomerID], [c].[CompanyName], [c].[FirstName], [c].[LastName], [c].[SalesPerson]&#xA;FROM [SalesLT].[Customer] AS [c]&#xA;WHERE [c].[CompanyName] IN (N'Friendly Bike Shop', N'Front Sporting Goods')&#xA;</code></pre>&#xA;<p>The drawback to this approach is that <code>Filtering</code> and <code>Selection</code> isn't factored into the dynamically created SQL statement generated by EF, this is only applied AFTER the result set has returned from the database.</p>&#xA;<p>How do I return an <code>IQueryable</code> on the query interface so that the <code>Filtering</code> and <code>Selection</code> middleware will apply and be factored into the the SQL statement which is dynamically generated and still force this to be executed in a single batch?</p>&#xA;",978139,,,,2021-01-17 17:50:55,Hot Chocolate GraphQL batching Queries and applying Selection and Filtering middleware to EF SQL,<sql-server><graphql><entity-framework-core><hotchocolate>,1,0,0,2020-12-01 17:15:31
65120752,2,,65120434,0,,"<p>Not efficient way to do as below but tried my luck using filter and deep cloning object to not alter the main :</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code> let bookData = {&#xA;  ""data"": {&#xA;    ""books"": {&#xA;      ""author"": {&#xA;        ""name"": ""Book Bookinson"",&#xA;        ""books"": [&#xA;          {&#xA;            ""name"": ""book 1 "",&#xA;            ""stars"": ""1""&#xA;          },&#xA;          {&#xA;            ""address1"": ""book 2 "",&#xA;            ""phone1"": ""1""&#xA;          },&#xA;          {&#xA;            ""name"": ""book 3 "",&#xA;            ""stars"": ""3""&#xA;          },&#xA;          {&#xA;            ""address1"": ""book 4 "",&#xA;            ""phone1"": ""3""&#xA;          },&#xA;        ]&#xA;      },&#xA;    },&#xA;  },&#xA;  }&#xA;  &#xA;  let oneStar = JSON.parse(JSON.stringify(bookData)); // deep clone &#xA;  oneStar.data.books.author.books =  oneStar.data.books.author.books.filter(book=&gt;typeof book.stars!==""undefined"" &amp;&amp; parseInt(book.stars)===1); // filter if book has property stars and equals 1&#xA;&#xA;  /* console.log(bookData) */&#xA;  console.log(oneStar);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",11737596,,,,2020-12-03 06:13:28,"",,0,1,0,2020-12-03 06:13:28
65152333,1,,,2,466,"<p>I'm using <code>graph-ql-js</code> on a <code>node</code> server. I've written the following query and am trying to filter on a subfield, but haven't been able to find documentation to do this successfully. I'm wondering if it's possible to filter on a sub-field using <code>graph-ql-js</code> or if I'll need to use an ORM or external library?</p>&#xA;<p>I'm using the following documentation but don't see syntax to sort sub-fields. I've only been able to find options to filter on query args:</p>&#xA;<p><a href=""https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer"">https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/</a></p>&#xA;<p>Thanks in advance!</p>&#xA;<p>Here is my code:</p>&#xA;<pre><code>            scope(name: &quot;${custName}&quot;) {&#xA;                    ... on Customer{&#xA;                        field_a,&#xA;                        field_b,&#xA;                        field_c&#xA;                        scope {&#xA;                            ... on Member {&#xA;                                field_a,&#xA;                                field_b, &#xA; *** line in question *** &gt;     field_c(filter: in_scope{name: ${custName}}){&#xA;                                    field_a, &#xA;                                    field_b,&#xA;                                }&#xA;                        }&#xA;&#xA;&#xA;&#xA; &#xA;</code></pre>&#xA;",14752417,,,,2020-12-04 23:55:06,Filter on sub-fields in graphql-js,<javascript><api><graphql><graphql-js><express-graphql>,0,0,0,2020-12-04 23:55:06
65178392,1,,,-1,1403,"<p>what changes need to perform the code:</p>&#xA;<pre><code>const data = client.mutate({&#xA;    mutation: (Query)&#xA;});&#xA;&#xA;let Query = gql`&#xA;  mutation{&#xA;    create(input:{&#xA;         department:&quot;Tester&quot;, &#xA;         code:&quot;Tester&quot;&#xA;    }&#xA;    )&#xA;      {&#xA;        code,&#xA;        details,&#xA;        description,   &#xA;    }&#xA;  }`&#xA;console.log(data, &quot;data&quot;)&#xA;</code></pre>&#xA;<p>how to pass input dynamically? I have my input as:</p>&#xA;<pre><code>var department = {&#xA;   department:&quot;Tester&quot;, &#xA;   code:&quot;Tester&quot;&#xA;}&#xA;</code></pre>&#xA;",14778600,,2845905,2020-12-08 08:27:23,2020-12-08 08:27:23,how to pass the variables dynamic in GraphQL?,<reactjs><graphql><apollo-client><gql>,1,0,0,2020-12-07 08:38:12
65178760,2,,65178392,1,,"<p>I haven't tested it, but it will work.<br />&#xA;in react apollo-client</p>&#xA;<pre><code>import { gql, useMutation } from '@apollo/client';&#xA;&#xA;const Query = gql`&#xA;  mutation Create($department: String!, $code: String!) {&#xA;    create(department: $department, code: $code) {&#xA;        code&#xA;        details&#xA;        description&#xA;    }&#xA;  }&#xA;`;&#xA;const [create] = useMutation(Query);&#xA;create({ variables: { department: department_value, code: code_value } });&#xA;</code></pre>&#xA;<hr />&#xA;<p>other way</p>&#xA;<pre><code>const departmentValue = &quot;Tester&quot;&#xA;const codeValue = &quot;Tester&quot;&#xA;client.mutate({&#xA;  variables: { department: departmentValue, code:codeValue },&#xA;  mutation: gql`&#xA;    mutation Create($department: String!, $code: String!){&#xA;      create(department: $department, code: $code){&#xA;        code&#xA;        details&#xA;        description&#xA;      }&#xA;    }&#xA;  `,&#xA;})&#xA;.then(result =&gt; { console.log(result) })&#xA;.catch(error =&gt; { console.log(error) });&#xA;</code></pre>&#xA;",14753784,,14753784,2020-12-07 09:22:32,2020-12-07 09:22:32,"",,0,0,0,2020-12-07 09:05:51
65181220,2,,63615462,0,,"<p>I just stumbled upon this bug myself in Magento 2.3.4 and it looks like it's buggy with the region_code. There's a workaround for this, try to send the region_id instead of region_code, like this:</p>&#xA;<pre><code>mutation {&#xA;  createCustomerAddress(input: {&#xA;    region: {&#xA;      region: &quot;Vendeé&quot;&#xA;      region_id: 799&#xA;    }&#xA;    country_code: FR&#xA;    street: [&quot;123 Main Street&quot;]&#xA;    telephone: &quot;7777777777&quot;&#xA;    postcode: &quot;77777&quot;&#xA;    city: &quot;Phoenix&quot;&#xA;    firstname: &quot;Bob&quot;&#xA;    lastname: &quot;Loblaw&quot;&#xA;    default_shipping: true&#xA;    default_billing: false&#xA;  }) {&#xA;    id&#xA;    region {&#xA;      region&#xA;      region_code&#xA;    }&#xA;    country_code&#xA;    street&#xA;    telephone&#xA;    postcode&#xA;    city&#xA;    default_shipping&#xA;    default_billing&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>After this, if you retrieve the region_code, it will show fine. It looks like it has problems identifying the region by the region_code.</p>&#xA;",3982862,,,,2020-12-07 11:49:55,"",,0,0,0,2020-12-07 11:49:55
65186766,2,,65184935,0,,<p>I found out that the issue was in importing errors from apollo-servers had to be in an alphabetical order.</p>&#xA;,12865189,,,,2020-12-07 17:50:19,"",,0,0,0,2020-12-07 17:50:19
65190473,2,,59605114,1,,"<p>For me (using same technologies like you), creating custom filter component (CorsFilter) worked the best out of all other options:</p>&#xA;<p>Example of my configuration:</p>&#xA;<pre><code>@Component&#xA;class CorsFilter: WebFilter {&#xA;&#xA;    @Value(&quot;\${cors.allowed_origin}&quot;)&#xA;    lateinit var allowedOrigin: String&#xA;&#xA;    override fun filter(ctx: ServerWebExchange, chain: WebFilterChain): Mono&lt;Void&gt; {&#xA;        ctx.response.headers.add(&quot;Access-Control-Allow-Origin&quot;, allowedOrigin)&#xA;        ctx.response.headers.add(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, PUT, POST, DELETE, OPTIONS&quot;)&#xA;        ctx.response.headers.add(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)&#xA;        ctx.response.headers.add(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range, Authorization&quot;)&#xA;        return when {&#xA;            ctx.request.method == HttpMethod.OPTIONS -&gt; {&#xA;                ctx.response.headers.add(&quot;Access-Control-Max-Age&quot;, &quot;1728000&quot;)&#xA;                ctx.response.statusCode = HttpStatus.NO_CONTENT&#xA;                Mono.empty()&#xA;            }&#xA;            else -&gt; {&#xA;                ctx.response.headers.add(&quot;Access-Control-Expose-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&quot;)&#xA;                chain.filter(ctx)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>note: <code>allowedOrigin</code> variable is taken from applications.properties files</p>&#xA;",9351463,,,,2020-12-07 22:37:30,"",,0,0,0,2020-12-07 22:37:30
65207166,2,,65202333,2,,"<p>Your <code>dataProvider.getList()</code> should return an object containing an array of records in the 'data' key:</p>&#xA;<pre><code>{&#xA;&quot;data&quot;: [{&#xA;     &quot;createdAt&quot;: &quot;2020-12-04T04:24:00.118Z&quot;,&#xA;     &quot;deletedAt&quot;: null,&#xA;     &quot;eventName&quot;: &quot;Confirmed Withdraw* between 5 and 24 hrs&quot;,&#xA;     &quot;eventDate&quot;: &quot;2020-12-04T00:00:00.000Z&quot;,&#xA;     &quot;eventPoint&quot;: -20,&#xA;     &quot;shiftId&quot;: 44332,&#xA;     &quot;facilityName&quot;: &quot;Tester Facility Friendswood&quot;,&#xA;     &quot;facilityId&quot;: 927,&#xA;     &quot;id&quot;: 4,&#xA;     &quot;nurseId&quot;: 12508,&#xA;   }]&#xA;}&#xA;</code></pre>&#xA;<p>See the official react-admin documentation about dataProvider response format for details:</p>&#xA;<p><a href=""https://marmelab.com/react-admin/DataProviders.html#response-format"" rel=""nofollow noreferrer"">https://marmelab.com/react-admin/DataProviders.html#response-format</a></p>&#xA;",1333479,,,,2020-12-08 21:28:42,"",,0,0,0,2020-12-08 21:28:42
65210329,2,,65206248,-2,,"<p>This can be done by defining a function which does simple string formatting outside of your JSX. You can then call your function in the curly brases <code>{myFunction(parameter)}</code> passing the graphQL query data to this function as a parameter.</p>&#xA;<pre><code>function dayMonth(data){&#xA;&#xA;    const monthNames = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,&#xA;                        &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;];&#xA;&#xA;    //split up the string to get the day and month                    &#xA;    var month = parseInt(data.slice(5,7));&#xA;    var day = data.slice(8,10);&#xA;&#xA;    //remove 0 from 02, 03 etc ... until 10&#xA;    if(day[0]==&quot;0&quot;){&#xA;        day = day.slice(1,2);&#xA;    }&#xA;&#xA;    //concatenate the two together again and return&#xA;    var formatted = day + &quot; &quot; + monthNames[month];&#xA;&#xA;    return formatted;&#xA;}&#xA;&#xA;const BlogPage = () =&gt;{&#xA;&#xA;    const data = useStaticQuery(graphql`&#xA;    query{&#xA;        allMarkdownRemark{&#xA;        edges{&#xA;          node{&#xA;            frontmatter{&#xA;              title&#xA;              date&#xA;              featuredImage{&#xA;                  childImageSharp{&#xA;                      fluid{&#xA;                        ...GatsbyImageSharpFluid&#xA;                      }&#xA;                  }&#xA;              }&#xA;            }&#xA;            fields{&#xA;                slug&#xA;              }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    `);&#xA;&#xA;    return(&#xA;        &lt;div id=&quot;blog&quot;&gt;&#xA;            &lt;div class=&quot;blog-pad&quot;&gt;&lt;/div&gt;&#xA;            &lt;div class=&quot;blog-posts&quot;&gt;&#xA;            &#xA;                {data.allMarkdownRemark.edges.map((edge) =&gt;(&#xA;                    &lt;div class=&quot;blog-post&quot;&gt;&#xA;                        &lt;Img fluid={edge.node.frontmatter.featuredImage.childImageSharp.fluid} /&gt;&#xA;                        &lt;div class=&quot;meta&quot;&gt;&#xA;                                &lt;h3&gt;&#xA;                                {dayMonth(edge.node.frontmatter.date)}&#xA;                                &lt;/h3&gt;&#xA;                            &lt;div class=&quot;title-date&quot;&gt;&#xA;                                &lt;h3&gt;&#xA;                                    &lt;a href={&quot;/blog/&quot; + edge.node.fields.slug}&gt;{edge.node.frontmatter.title}&lt;/a&gt;&#xA;                                &lt;/h3&gt; &#xA;                                &lt;p&gt;{edge.node.frontmatter.date}&lt;/p&gt;  &#xA;                                &lt;p&gt;Author&lt;/p&gt;  &#xA;                            &lt;/div&gt;&#xA;                        &lt;/div&gt;    &#xA;                        &lt;/div&gt;&#xA;                ))}&#xA;           &#xA;            &lt;/div&gt;&#xA;            &lt;div class=&quot;blog-pad&quot;&gt;&lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;    )&#xA;}  &#xA;</code></pre>&#xA;",2779479,,,,2020-12-09 03:44:36,"",,0,0,0,2020-12-09 03:44:36
65211658,2,,65206253,0,,"<p>You should pass <a href=""https://www.gatsbyjs.com/docs/creating-and-modifying-pages/"" rel=""nofollow noreferrer"">via context your filter value</a>, in that case, the <code>ad_title</code> field. So, in your <code>gatsby-node.js</code> you should have something like:</p>&#xA;<pre><code>createPage({&#xA;  path: `/promo/${URL_ext}`, // or your value&#xA;  component: individualPromoComponent, // or your component&#xA;  context: {&#xA;    ad_title: node.ad_title,&#xA;  },&#xA;})&#xA;</code></pre>&#xA;<p>Now, you can use <code>ad_title</code> in your component using <code>$ad_title</code> in:</p>&#xA;<pre><code>export const query = graphql`&#xA;  query PromoQuery($ad_title: String) {&#xA;    allMysqlPromos(filter: { id: { eq: $ad_title } }) {&#xA;      edges {&#xA;        node {&#xA;          ad_title&#xA;          ad_filename&#xA;          ad_body&#xA;          URL_ext&#xA;          phone&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",5585371,,,,2020-12-09 06:24:04,"",,0,1,0,2020-12-09 06:24:04
65215697,1,,,2,3687,"<p>I'm using @apollo/client 3.2.0 with react. I have a component that retrieves the data using the useQuery hook. The query looks similar to this one:</p>&#xA;<pre><code>query getChartData($year: Int!, $type: String!) {&#xA;  first_series_data(kpi: &quot;SOME_KPI&quot;, year: $year, orderBy: &quot;week&quot;, type: $type) {&#xA;    edges {&#xA;      node {&#xA;        value&#xA;        week&#xA;      }&#xA;    }&#xA;  }&#xA;  second_series_data(kpi: &quot;SOME_KPI&quot;, year: $year, type: $type) {&#xA;    edges {&#xA;      node {&#xA;        date&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>As you can see in the query, I have two variables: <strong>year</strong> and <strong>type</strong>. Both are passed as props in the component and this component is rendered twice in the same view, with a different type prop.</p>&#xA;<p><strong>The problem</strong> that I have is related to the <strong>fetchPolicy</strong> option. If I'm using one of <code>cache-and-network</code> or <code>network-only</code> fetch policies, one of the queries is called twice. This doesn't happen when I use <code>no-cache</code>. So I think it's a cache conflict, because the queries are similar, but I'm not sure and I don't know how to fix this.</p>&#xA;<p>Do you have any ideas?</p>&#xA;",9211189,,,,2021-04-29 03:06:15,Apollo client fetchPolicy issues - query called twice,<reactjs><apollo-client>,1,2,0,2020-12-09 11:15:00
65217610,2,,64158489,1,,"<p>You can handle the <strong>range</strong> option at Django's queryset level without disturbing the existing relay query.</p>&#xA;<p>In your case,</p>&#xA;<ol>&#xA;<li>Pass <code>start_time_offset</code> and <code>end_time_offset</code> arguments to <code>DjangoConnectionField</code></li>&#xA;<li>Override <code>resolve_frames</code></li>&#xA;<li>filter on django queryset if <code>start_time_offset</code> or <code>end_time_offset</code> is provided by user else return <code>objects.all()</code></li>&#xA;</ol>&#xA;<pre class=""lang-python prettyprint-override""><code>class Query(ObjectType):&#xA;    frames = filter.DjangoFilterConnectionField(FrameType, start_time_offset=graphene.Int(), end_time_offset=graphene.Int())&#xA;&#xA;    def resolve_frames(self, info, start_time_offset=None, end_time_offset=None, **kwargs):&#xA;        if start_time_offset and end_time_offset:&#xA;            return Frame.objects.filter(time_offset__range=(start_time_offset, end_time_offset))&#xA;        elif start_time_offset:&#xA;            return Frame.objects.filter(time_offset__gte=start_time_offset)&#xA;        elif end_time_offset:&#xA;            return Frame.objects.filter(time_offset__lte=end_time_offset)&#xA;        return Frame.objects.all()&#xA;</code></pre>&#xA;<p>Now you can query on it with your regular filters provided by relay:</p>&#xA;<pre class=""lang-graphql prettyprint-override""><code>query Frame {&#xA;  frames(last: 5, startTimeOffset: 4350, endTimeOffset:5000) {&#xA;    edges {&#xA;      node {&#xA;        timeOffset&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",8315492,,8654161,2021-06-22 14:47:10,2021-06-22 14:47:10,"",,0,0,0,2020-12-09 13:18:48
65224328,2,,65147368,0,,"<p>Solved the problem by adding a field which iterates 1 or -1 each time like is clicked, and sorting by that instead</p>&#xA;",9264688,,,,2020-12-09 20:23:30,"",,0,0,0,2020-12-09 20:23:30
65233069,2,,65232222,2,,"<p>You can just do this:</p>&#xA;<pre><code>const [, { error: mutationError }] = response&#xA;</code></pre>&#xA;<p>Note the comma</p>&#xA;",270592,,,,2020-12-10 10:46:27,"",,0,1,0,2020-12-10 10:46:27
65239010,2,,65202333,-1,,"<p>The Problem is from my graphQL server not returning the count of the query, so the dataProvider was unable to paginate the result successfully, which leads to an inability to render.</p>&#xA;",8160309,,,,2020-12-10 17:05:48,"",,0,0,0,2020-12-10 17:05:48
65246561,1,65589164,,2,401,"<p>I'm new to Relay, GraphQL and Postgres and I'm trying to extend the auto-generated schema that PostGraphile creates to include the Viewer Type which is a staple of Relay.</p>&#xA;<p>The example from their docs is probably enough for most people to work with but I'm having trouble fleshing it out. I basically want it to add a the field <code>viewer: Viewer!</code> to every Type.</p>&#xA;<p>Any help would be awesome.</p>&#xA;<pre><code>const { makeExtendSchemaPlugin, gql } = require('graphile-utils');&#xA;&#xA;const AddViewerPlugin = makeExtendSchemaPlugin(build =&gt; {&#xA;  // Get any helpers we need from `build`&#xA;  const { pgSql: sql, inflection } = build;&#xA;&#xA;  return {&#xA;    typeDefs: gql`...`,&#xA;    resolvers: {&#xA;      /*...*/ &#xA;    },&#xA;  };&#xA;});&#xA;&#xA;module.exports = AddViewerPlugin;&#xA;</code></pre>&#xA;<p>My db has a public.person table and a private.person_account table but I hesitate to rename one of those viewer.</p>&#xA;",1704772,,,,2021-01-06 01:57:22,Postgraphile -- makeExtendSchemaPlugin to add Viewer Type to schema -- Relay/Postgres,<postgresql><graphql><relay><postgraphile>,1,0,0,2020-12-11 06:09:17
65274180,2,,62119025,2,,"<p>It seems like filtering on array field is not so well implemented currently:</p>&#xA;<blockquote>&#xA;<p><a href=""https://github.com/strapi/strapi/discussions/6480#discussioncomment-61022"" rel=""nofollow noreferrer"">https://github.com/strapi/strapi/discussions/6480#discussioncomment-61022</a></p>&#xA;</blockquote>&#xA;<p>However, there is a workaround for you to try.</p>&#xA;<p>First you should know how to write your own GraphQL <code>Resolver</code> on Strapi:</p>&#xA;<blockquote>&#xA;<p><a href=""https://strapi.io/documentation/v3.x/plugins/graphql.html#customize-the-graphql-schema"" rel=""nofollow noreferrer"">https://strapi.io/documentation/v3.x/plugins/graphql.html#customize-the-graphql-schema</a></p>&#xA;</blockquote>&#xA;<p>Then here is a simple workaround, you could try below code (assume your model is <code>ont</code>):</p>&#xA;<pre><code>resolver: async (obj, options, ctx) =&gt; {&#xA;  // Get all onts first&#xA;  const onts = await strapi.api.onts.services.onts.find()&#xA;&#xA;  // Filter your result&#xA;  return onts.filter(ont =&gt; ont.images.length &gt; 0)&#xA;}&#xA;</code></pre>&#xA;<p>Note that if you need more complicated implementation such as paging and sorting, you will need something like <code>strapi.model</code> to use underlying ORM api:</p>&#xA;<p>And your code would look like this (take mongodb as an example)</p>&#xA;<pre><code>resolver: async (obj, options, {context}) =&gt; {&#xA;  const {_start, _limit, _sort} = context  &#xA;&#xA;  // Get your 'onts' from database&#xA;  const onts = await strapi.query('ont').model.aggregate([{&#xA;        $lookup: {&#xA;            from: &quot;ont&quot;,&#xA;            localField: &quot;_id&quot;,&#xA;            foreignField: &quot;ont&quot;,&#xA;            as: &quot;images&quot;&#xA;        }&#xA;    }, {&#xA;        $match: {&#xA;            // Your filter here, same as image.length &gt; 0&#xA;            'images.0': {$exists:true}&#xA;        }&#xA;    }, {&#xA;        $sort: {_sort}&#xA;    }, {&#xA;        $skip: parseInt(_start)&#xA;    }, {&#xA;        $limit: parseInt(_limit)&#xA;    }])&#xA;&#xA;  return onts&#xA;}&#xA;</code></pre>&#xA;<p>Hope it helps you~!</p>&#xA;",14816076,,,,2020-12-13 09:38:07,"",,0,1,0,2020-12-13 09:38:07
65303170,1,,,2,186,"<p>Here is an example of my schema</p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  friends: [Friendship] @connect(name: &quot;UserFriends&quot;)&#xA;  outgoingFriendRequests: [FriendRequest] @connect(name: &quot;SenderRequests&quot;)&#xA;  incomingFriendRequests: [FriendRequest] @connect(name: &quot;ReceiverRequests&quot;)&#xA;}&#xA;&#xA;type Friendship @model {&#xA;  id: ID!&#xA;  user: User! @connect(name: &quot;UserFriends&quot;)&#xA;  friend: User! @connect&#xA;&#xA;type FriendRequest @model {&#xA;  id: ID!&#xA;  sender: User! @connect(name: &quot;SenderRequests&quot;)&#xA;  receiver: User! @connect(name: &quot;ReceiverRequests&quot;)&#xA;</code></pre>&#xA;<p>Here assume for <code>userA</code> and <code>userB</code>,&#xA;suppose <code>userA</code> added <code>userB</code> as friend(added an entry to friendship model).</p>&#xA;<pre><code>{&#xA;  id: 'some-id&#xA;  user: user-A-id&#xA;  friend: user-B-id&#xA;&#xA;}&#xA;</code></pre>&#xA;<p>Here we can query the <code>userA</code>'s <code>friends</code> field to see <code>userB</code> as his friend(by relationship below)</p>&#xA;<pre><code>@connect(name: &quot;UserFriends&quot;)&#xA;</code></pre>&#xA;<p>But for <code>userB</code>, <code>userA</code> is still not available in its <code>friends</code> field. Is there any workaround we can do in the model design in order to mutually notify the added friendship. Or am I doing something wrong?</p>&#xA;",13489541,,10255200,2020-12-15 10:54:41,2020-12-15 10:54:41,Modelling friendship with aws amplify,<amazon-web-services><graphql><aws-amplify>,0,0,0,2020-12-15 09:28:43
65329566,1,65331170,,0,298,"<p>I would like to send to clients different subscription response, based on some condition. <code>withFilter</code> filter and send response only when condition is met. I want to send two different response based on some condition - map response, based on condition. Is there any <code>withMap</code> or something like that?</p>&#xA;",13514288,,,,2020-12-16 21:12:22,How to send different subscription response based on condition in GraphQL (NestJS)?,<graphql><nestjs><publish-subscribe><subscription>,1,0,0,2020-12-16 19:02:26
65340532,1,,,2,456,"<p>I am executing a GraphQL query:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const userByName = /* GraphQL */ `&#xA;  query employee(&#xA;    $first_name: String&#xA;    $sortDirection: ModelSortDirection&#xA;    $filter: ModelUserFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    employee(&#xA;      first_name: $first_name&#xA;      sortDirection: $sortDirection&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        employee_type&#xA;        first_name&#xA;        last_name&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;     }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>When I execute this query, I get this error:</p>&#xA;<pre><code>sortDirection is not supported for List operations without a Sort key defined.&#xA;</code></pre>&#xA;<p>I am executing this query using this code:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const userInfo = await API.graphql(&#xA;  graphqlOperation(employee, {&#xA;    first_name: name,&#xA;    sortDirection: 'DESC'&#xA;  })&#xA;)&#xA;</code></pre>&#xA;<p>I'm trying to retrieve data, but the above error arises. I have also tried removing <code>sortDirection</code>, but I just get an empty array as a response.</p>&#xA;",14051962,,801702,2020-12-17 12:55:28,2020-12-17 12:55:28,Amplify Sort Direction with Sort Field Name,<reactjs><amazon-web-services><graphql><aws-amplify><amplify>,0,0,0,2020-12-17 12:12:31
65350644,1,65350975,,-1,39,"<p>I am using react and apollo</p>&#xA;<p>I made a query in a file that looks like</p>&#xA;<p>query1.graphql</p>&#xA;<pre><code>query User($pk: Int!) {&#xA;    user(pk: $pk) {&#xA;        id&#xA;        email&#xA;        name&#xA;        userType&#xA;        ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Now, in another place in the code I would like to request only one field.</p>&#xA;<p>query2.graphql</p>&#xA;<pre><code>query User($pk: Int!) {&#xA;    user(pk: $pk) {&#xA;        id&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>but this during generation will trigger an error that the query is already defined, but I don't want to have all the parameters</p>&#xA;<p>Is there a way to do so ? Or I just have to use the big query and keep what I want ?</p>&#xA;",3241192,,,,2020-12-18 02:19:17,Identical query definition but with different response in graphql,<graphql><apollo>,1,1,0,2020-12-18 01:36:00
65354853,1,65361602,,0,447,"<p>I'm trying to sort some data returned by a query in GraphQl. I'm running a Meteor/React/Apollo/Graphql stack, and this line allows me to obtain all the data in my database in a resolver <code>resolvers.js</code> : <code>return database.find({})</code> I would like to sort it server-side by the &quot;name&quot; field and according to the docs and everything else I've been able to find online so far, <code>return database.find({}).sort({name:1})</code> should have cut it, but it's not actually returning anything and I can't seem to figure out why, nothing shows up in my console and no errors are being thrown, and hence I believe it's just null or empty.</p>&#xA;<p>In my Robo3T console I can run <code>database.find({}).sort({name:1})</code> and I can see the data actually being sorted. According to the <a href=""https://docs.mongodb.com/manual/reference/method/cursor.sort/"" rel=""nofollow noreferrer"">docs</a> I thought it may have been due to the <a href=""http://mongodb.github.io/node-mongodb-native/3.6/api/Cursor.html"" rel=""nofollow noreferrer"">Node implementation</a>, and so I tried <code>sort([[&quot;name&quot;,1]])</code> but that did not work either, and I'm not quite sure how else to go about this.</p>&#xA;<p>If there is no way to do this - should I just rely on client-side sorting? It's not many entries, &lt; 100, and I think I should just sort it in the database itself because I never need the unsorted data and it's likely not even going to change much.</p>&#xA;<p>I would like to ask this regardless though, even if just sorting it once in my database is enough for this specific situation, how would I otherwise go about sorting data in a resolver, because I would need to do this in other instances?</p>&#xA;<p>Thanks!</p>&#xA;<p>EDIT - This is what I have:</p>&#xA;<pre><code>export default {&#xA;    Query: {&#xA;        test_query(obj, args, context) {&#xA;            // Bottom line is output&#xA;            console.log(&quot;test1&quot;);&#xA;            console.log(Database.find({}).sort({name:1}));&#xA;            // Bottom line is not output&#xA;            console.log(&quot;test2&quot;);&#xA;            return Database.find({});&#xA;        },&#xA;}&#xA;</code></pre>&#xA;<p>EDIT2: My database is defined as <code>Database = new Mongo.Collection(&quot;db_name&quot;)</code></p>&#xA;",8714992,,8714992,2020-12-18 20:45:55,2020-12-18 20:45:55,Sorting MongoDB data in GraphQL resolver (Meteor/React/Apollo),<reactjs><mongodb><meteor><graphql><apollo>,2,3,0,2020-12-18 09:51:45
65377415,1,,,0,99,"<p>I have to decide whether to populate or not according to the query request, but I don't know how to do it.</p>&#xA;<p>So Example</p>&#xA;<p>If my model User is looks like this</p>&#xA;<p><em>below syntax is from typegoose and typegraphql</em></p>&#xA;<pre><code>class User {&#xA;    @Field()&#xA;    @prop()&#xA;    name: string;&#xA;&#xA;    @Field()&#xA;    @prop(ref:&quot;House&quot;)&#xA;    house: Ref&lt;House&gt;&#xA;}&#xA;</code></pre>&#xA;<p>And here is two diffent query</p>&#xA;<p><strong>Query1</strong></p>&#xA;<pre><code>  user {&#xA;    name&#xA;  } &#xA;</code></pre>&#xA;<p><strong>Query2</strong></p>&#xA;<pre><code>  user {&#xA;    name&#xA;    house {&#xA;      location&#xA;    }&#xA;  } &#xA;</code></pre>&#xA;<p>And in the resolver</p>&#xA;<pre><code>User: () =&gt; {&#xA;   const user = UserModel.find(blahblah)**.populate(&quot;house&quot;)**&#xA;&#xA;   return user&#xA;}&#xA;</code></pre>&#xA;<p>Query1 dose not need populate<br />&#xA;but Query2 need<br />&#xA;in same resolver!</p>&#xA;<p><strong>I want to decide whether to populate or not depending on the requirements of the query.</strong><br />&#xA;I can't decide whether to populate or not without knowing what is the actual query was in resolver.</p>&#xA;<p>I found very similar question in stackoverflow&#xA;But there is not proper answer...&#xA;<a href=""https://stackoverflow.com/questions/59483032/solving-relationships-in-mongoose-and-graphql"">Solving relationships in Mongoose and GraphQL</a></p>&#xA;",14727639,,14727639,2020-12-20 06:32:11,2020-12-20 13:27:17,Mongodb Ref dynamic populate with grapqhl?,<mongodb><graphql><typegraphql><typegoose>,1,1,0,2020-12-20 06:17:04
65383633,2,,65310879,0,,"<p>I solved it by adding the used data to the page context by editing the gatsby-node.js:</p>&#xA;<ol>&#xA;<li>Get the mdxAST of the post, filter the  components, then filter the ids used.</li>&#xA;<li>Add this list of ids to the page context.</li>&#xA;<li>Move the query stated in the question above to the post GraphQL query. Use the list of ids provided by page context to filter the data down to only the used ids in this post.</li>&#xA;<li>Pass this data as a property to the MDXRenderer.</li>&#xA;<li>Pass this data in the .mdx file to the cards component, such as: <code>&lt;Cards data={props.cards_data} /&gt;</code>.</li>&#xA;<li>Now the compontent received the data without using a StaticQuery.</li>&#xA;</ol>&#xA;<p>This works, but it feels kinda weird. There must be a better, more clean, solution in my opinion.</p>&#xA;",14831651,,,,2020-12-20 18:54:37,"",,0,0,0,2020-12-20 18:54:37
65417055,1,,,0,28,"<p>I am trying to define my GraphQL schema using the <code>graphql</code> library.  The schema I am trying to achieve, simplified, is this:</p>&#xA;<pre><code>type TypeA {&#xA;  fieldA: String&#xA;  fieldAorB: TypeAorB&#xA;}&#xA;&#xA;type TypeB {&#xA;  fieldB: String&#xA;}&#xA;&#xA;union TypeAorB = TypeA | TypeB&#xA;</code></pre>&#xA;<p>I am struggling to figure out how to achieve this using the graphql library, given that I can't define the union type before the other types are defined.</p>&#xA;<p>Hopefully this snippet highlights my predicament.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import * as graphql from &quot;graphql&quot;;&#xA;&#xA;const typeA = new graphql.GraphQLObjectType({&#xA;  name: &quot;TypeA&quot;,&#xA;  fields: { &#xA;    fieldA: { type: graphql.GraphQLString },&#xA;    fieldAorB: { type: [???] } // what goes here?&#xA;  },&#xA;});&#xA;const typeB = new graphql.GraphQLObjectType({&#xA;  name: &quot;TypeB&quot;,&#xA;  fields: {&#xA;    fieldB: { type: graphql.GraphQLString }&#xA;  },&#xA;});&#xA;&#xA;const typeAorB = new graphql.GraphQLUnionType({&#xA;  name: &quot;TypeAorB&quot;,&#xA;  types: [typeA, typeB],&#xA;});&#xA;</code></pre>&#xA;",1171276,,,,2020-12-22 23:20:46,GraphQL defining union before type,<graphql><graphql-js>,1,0,0,2020-12-22 23:14:41
65430050,2,,51740174,1,,"<p>In case anyone is still wondering,</p>&#xA;<p>You can use TypeGraphQL together with Typegoose to create all the schemas within one single class with decorators like this:</p>&#xA;<pre><code>@ObjectType()&#xA;export class Book{&#xA;&#xA;@Field() @prop({ required: true })&#xA;title!: string;&#xA;&#xA;@Field() @prop({ required: true })&#xA;name!: string;&#xA;}&#xA;</code></pre>&#xA;",11622101,,,,2020-12-23 19:41:40,"",,0,0,0,2020-12-23 19:41:40
65451483,1,,,0,127,"<p>I don't believe its a big deal, but my GraphIQL generates all of its queries and mutations from my PSQL schema. Is it possible to have it general a file for me with each change that I can use directly in my project? As currently I am having to write manually my queries/mutations as below and often I am changing the schema and then having to update all my instances of this.</p>&#xA;<pre><code>export const UPDATE = gql`&#xA;  mutation updateOrganiserByOrganiserId(&#xA;    $organiserName: String!&#xA;    $address: String&#xA;    $address2: String&#xA;    $city: String&#xA;    $country: String&#xA;    $postCode: String&#xA;    $manufacturerId: Int&#xA;    $organiserId: Int!&#xA;    $competitionSystemId: Int!&#xA;  ) {&#xA;    updateOrganiserByOrganiserId(&#xA;      input: {&#xA;        clientMutationId: &quot;updateOrganisation&quot;&#xA;        organiserId: $organiserId&#xA;        organiserPatch: {&#xA;          organiserName: $organiserName&#xA;          address: $address&#xA;          address2: $address2&#xA;          city: $city&#xA;          country: $country&#xA;          postCode: $postCode&#xA;          manufacturerId: $manufacturerId&#xA;          competitionSystemId: $competitionSystemId&#xA;        }&#xA;      }&#xA;    ) {&#xA;      clientMutationId&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;",240363,,,,2020-12-25 21:11:07,Procedurally generated queries/mutations from postgraphile GraphQL,<javascript><graphql><postgraphile>,1,0,0,2020-12-25 20:20:50
65451573,1,,,0,70,"<p>i'm trying to use <code>createPaginationContainer</code> with some variables, here is example of my code:</p>&#xA;<pre><code>export const GiftRecipientsPaginationContainer = createPaginationContainer(&#xA;  GiftRecipients,&#xA;  {&#xA;    giftRecipientsMe: graphql`&#xA;      fragment GiftRecipients_giftRecipientsMe on Me&#xA;      @argumentDefinitions(&#xA;        filter: {&#xA;          type: &quot;GiftRecipientsFilterInput!&quot;&#xA;          defaultValue: { metaMaskEthAddress: null, name: null }&#xA;        }&#xA;        products: { type: &quot;[ProductGiftInput!]!&quot; }&#xA;        first: { type: &quot;Int&quot;, defaultValue: 6 }&#xA;        after: { type: &quot;String&quot;, defaultValue: null }&#xA;      ) {&#xA;        giftRecipientsConnection(&#xA;          products: $products&#xA;          filter: $filter&#xA;          first: $first&#xA;          after: $after&#xA;        )&#xA;          @connection(&#xA;            key: &quot;GiftRecipientsMe_giftRecipientsConnection&quot;&#xA;            filters: [&quot;filter&quot;, &quot;products&quot;]&#xA;          ) {&#xA;          pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;            hasPreviousPage&#xA;            startCursor&#xA;          }&#xA;          edges {&#xA;            node {&#xA;              vipXP&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;  {&#xA;    direction: &quot;forward&quot;,&#xA;    getConnectionFromProps(props) {&#xA;      return props.giftRecipientsMe.giftRecipientsConnection&#xA;    },&#xA;    getFragmentVariables(prevVars, totalCount) {&#xA;      console.log(&quot;prevVars&quot;, prevVars)&#xA;      return {&#xA;        ...prevVars,&#xA;        count: totalCount,&#xA;      }&#xA;    },&#xA;    getVariables(props, { count, cursor }, fragmentVariables) {&#xA;      console.log(props, fragmentVariables)&#xA;      return {&#xA;        filter: fragmentVariables.filter,&#xA;        products: fragmentVariables.products,&#xA;        first: fragmentVariables.first,&#xA;        after: cursor,&#xA;        count,&#xA;      }&#xA;    },&#xA;    query: graphql`&#xA;      query GiftRecipientsPaginationQuery(&#xA;        $filter: GiftRecipientsFilterInput!&#xA;        $products: [ProductGiftInput!]!&#xA;        $first: Int!&#xA;        $after: String&#xA;      ) {&#xA;        me {&#xA;          ...GiftRecipients_giftRecipientsMe&#xA;            @arguments(&#xA;              filter: $filter&#xA;              products: $products&#xA;              first: $first&#xA;              after: $after&#xA;            )&#xA;        }&#xA;      }&#xA;    `,&#xA;  }&#xA;)&#xA;</code></pre>&#xA;<p>In parent component i pass my variable like this:</p>&#xA;<pre><code>&lt;GiftRecipients&#xA;    metaMaskEthAddress={metaMaskEthAddress}&#xA;    giftRecipientsMe={me}&#xA;/&gt;&#xA;</code></pre>&#xA;<p>Now non of my logs in the getFragmentVariables or getVariables show until i refetch.&#xA;How do i pass variables to the <code>createPaginationContainer</code> on initial request?</p>&#xA;",10159768,,,,2020-12-26 13:05:13,how to pass initial variables to createPaginationContainer,<graphql><react-relay>,1,0,0,2020-12-25 20:33:56
65456693,2,,65451573,0,,"<p>eh, my mistake they have to come from the parent fragment and be passed into the graphql query</p>&#xA;<p>Something like this:</p>&#xA;<pre><code>const CheckoutPromptQueryRenderer = (&#xA;  props: CheckoutPromptQueryRendererProps&#xA;) =&gt; {&#xA;  if (!props.checkoutPrompt) return null&#xA;&#xA;  const { checkoutPrompt, relay, metaMaskEthAddress } = props&#xA;&#xA;  return (&#xA;    &lt;QueryRenderer&#xA;      environment={relay.environment}&#xA;      query={graphql`&#xA;        query CheckoutPromptQueryRendererQuery(&#xA;          $filter: GiftRecipientsFilterInput!&#xA;          $products: [ProductGiftInput!]!&#xA;        ) {&#xA;          me {&#xA;            ...GiftRecipients_giftRecipientsMe&#xA;              @arguments(products: $products, filter: $filter)&#xA;          }&#xA;        }&#xA;      `}&#xA;      variables={{&#xA;        products: checkoutPrompt.productIDs.map(id =&gt; ({ productID: id })),&#xA;        filter: metaMaskEthAddress&#xA;          ? { metaMaskEthAddress: metaMaskEthAddress, name: null }&#xA;          : { metaMaskEthAddress: null, name: null },&#xA;      }}&#xA;      render={(&#xA;        response: QueryRendererReadyState&lt;CheckoutPromptQueryRendererQueryResponse&gt;&#xA;      ) =&gt; {&#xA;        if (response.error) {&#xA;          console.log(response.error)&#xA;          throw &quot;Error querying checkout prompt&quot;&#xA;        }&#xA;        if (!response.props) return null&#xA;&#xA;        return &lt;CheckoutPrompt {...response.props} /&gt;&#xA;      }}&#xA;    /&gt;&#xA;  )&#xA;}&#xA;&#xA;</code></pre>&#xA;",10159768,,,,2020-12-26 13:05:13,"",,0,0,0,2020-12-26 13:05:13
65478451,1,,,0,34,"<p><strong>Index.js</strong></p>&#xA;<pre><code>import React, { Fragment, useContext, useState } from 'react';&#xA;import { useQuery } from '@apollo/client';&#xA;import { getIssuesPaginationQuery } from '@modules/CaseManager/CaseManagerDashboard/graphql';&#xA;import { Checkbox, Col, Icon, Row, Table } from 'antd';&#xA;import { removeFieldsFromObject } from '@components/helpers';&#xA;import FormattedDate from '@components/FormattedDate';&#xA;import { Link } from 'react-router-dom';&#xA;import { PermissionContext } from '@context/PermissionContext';&#xA;import { getCaseLink } from '@modules/CaseManager/CaseManagerDashboard/helpers';&#xA;import SearchInput from '@components/SearchInput';&#xA;import {&#xA;  MY_CASES_FILTER_KEY,&#xA;  SEARCH_FILTER_KEY,&#xA;  UNASSIGNED_FILTER_KEY,&#xA;} from '@modules/CaseManager/CaseManagerDashboard/constants';&#xA;import LocalizedText from '@components/i18n/LocalizedText';&#xA;&#xA;const { Column } = Table;&#xA;&#xA;function CaseManagerDashboard({ match: { params: { snr } = {} } = {} }) {&#xA;  const [currentPage, setCurrentPage] = useState(1);&#xA;  const [pageSize, setPageSize] = useState(20);&#xA;  const [sorting, setSorting] = useState({});&#xA;  const [searchValue, setSearchValue] = useState(&#xA;    snr || localStorage.getItem(SEARCH_FILTER_KEY) || ''&#xA;  );&#xA;  const [myCasesFilter, setMyCasesFilter] = useState(&#xA;    eval(localStorage.getItem(MY_CASES_FILTER_KEY))&#xA;  );&#xA;  const [unassignedCasesFilter, setUnassignedCasesFilter] = useState(&#xA;    eval(localStorage.getItem(UNASSIGNED_FILTER_KEY))&#xA;  );&#xA;  const { hasAccess } = useContext(PermissionContext);&#xA;&#xA;  const { data, loading } = useQuery(getIssuesPaginationQuery, {&#xA;    variables: {&#xA;      options: {&#xA;        offset: (currentPage - 1) * pageSize || 0,&#xA;        limit: pageSize || 20,&#xA;        searchValue,&#xA;        sortBy: sorting &amp;&amp; sorting.field,&#xA;        sortOrder: sorting &amp;&amp; sorting.order === 'ascend' ? 1 : -1,&#xA;        myCases: myCasesFilter,&#xA;        unassignedCases: unassignedCasesFilter,&#xA;      },&#xA;    },&#xA;    fetchPolicy: 'no-cache',&#xA;  });&#xA;  const {&#xA;    pagination: { items = [], totalCount = 0 } = {},&#xA;  } = removeFieldsFromObject(data);&#xA;&#xA;  return (&#xA;    &lt;Fragment&gt;&#xA;      &lt;Row&gt;&#xA;        &lt;Col span={7}&gt;&#xA;          &lt;h2&gt;&#xA;            &lt;LocalizedText textKey=&quot;search.input.searchaccident&quot; /&gt;&#xA;          &lt;/h2&gt;&#xA;        &lt;/Col&gt;&#xA;      &lt;/Row&gt;&#xA;&#xA;      &lt;Row&gt;&#xA;        &lt;Col span={6}&gt;&#xA;          &lt;SearchInput&#xA;            onChange={(value) =&gt; {&#xA;              localStorage.setItem(SEARCH_FILTER_KEY, value);&#xA;              setSearchValue(value);&#xA;            }}&#xA;            initialValue={searchValue}&#xA;          /&gt;&#xA;        &lt;/Col&gt;&#xA;      &lt;/Row&gt;&#xA;&#xA;  &lt;Row style={{ margin: '10px 0' }}&gt;&#xA;        &lt;Col span={24}&gt;&#xA;          &lt;Checkbox&#xA;            checked={myCasesFilter}&#xA;            onChange={(e) =&gt; {&#xA;              localStorage.setItem(MY_CASES_FILTER_KEY, e.target.checked);&#xA;              setMyCasesFilter(e.target.checked);&#xA;            }}&#xA;          &gt;&#xA;            {' '}&#xA;            &lt;LocalizedText textKey=&quot;search.checkbox.mycases&quot; /&gt;&#xA;          &lt;/Checkbox&gt;&#xA;(...)&#xA;</code></pre>&#xA;<p><strong>graphql.js</strong></p>&#xA;<pre><code>port { gql } from '@apollo/client';&#xA;&#xA;export const getIssuesPaginationQuery = gql`&#xA;  query CaseManagerDashboard($options: CasePaginationArgsInput!) {&#xA;    pagination: getIssuesPagination(options: $options) {&#xA;      items {&#xA;        _id&#xA;        CaseNumber&#xA;        CaseNumberNormalized&#xA;        CreationDate&#xA;        UpdateDate&#xA;        AccidentDate&#xA;        SinglePerson {&#xA;          _id&#xA;          Firstname&#xA;          Lastname&#xA;          Birthday&#xA;          InvoiceCheck {&#xA;            CreationDate&#xA;          }&#xA;        }&#xA;        Clerks {&#xA;          _id&#xA;          Firstname&#xA;          Lastname&#xA;        }&#xA;      }&#xA;      totalCount&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p><strong>constant.js</strong></p>&#xA;<pre><code>export const SEARCH_FILTER_KEY = 'CaseManagerDashboard.searchValue';&#xA;export const MY_CASES_FILTER_KEY = 'CaseManagerDashboard.myCases';&#xA;export const UNASSIGNED_FILTER_KEY = 'CaseManagerDashboard.unassignedCases';&#xA;</code></pre>&#xA;<p><strong>PaginationArgs.ts</strong></p>&#xA;<pre><code>import { ArgsType, Field, InputType } from 'type-graphql'&#xA;&#xA;@ArgsType()&#xA;@InputType('PaginationArgsInput')&#xA;export class PaginationArgs {&#xA;  @Field({ nullable: true })&#xA;  offset?: number&#xA;&#xA;  @Field({ nullable: true })&#xA;  limit?: number&#xA;&#xA;  @Field({ nullable: true })&#xA;  searchValue?: string&#xA;&#xA;  @Field({ nullable: true })&#xA;  sortBy?: string&#xA;&#xA;  @Field({ nullable: true })&#xA;  sortOrder?: number&#xA;}&#xA;</code></pre>&#xA;<p><strong>CaseArgs.ts</strong></p>&#xA;<pre><code>@ArgsType()&#xA;@InputType('AssignToClerkInput')&#xA;export class AssignToClerkArgs {&#xA;  @Field()&#xA;  snr: string = ''&#xA;&#xA;  @Field(() =&gt; CopyAndAddCaseClerkInput)&#xA;  clerk: CopyAndAddCaseClerkInput = new CopyAndAddCaseClerkInput()&#xA;}&#xA;&#xA;@ArgsType()&#xA;@InputType('CasePaginationArgsInput')&#xA;export class CasePaginationArgs extends PaginationArgs{&#xA;  @Field({ nullable: true })&#xA;  myCases?: boolean&#xA;&#xA;  @Field({ nullable: true })&#xA;  unassignedCases?: boolean&#xA;}&#xA;</code></pre>&#xA;<p><strong>schema.graphql</strong></p>&#xA;<pre><code>(...)&#xA;&#xA;input CasePaginationArgsInput {&#xA;  limit: Float&#xA;  myCases: Boolean&#xA;  offset: Float&#xA;  searchValue: String&#xA;  sortBy: String&#xA;  sortOrder: Float&#xA;  unassignedCases: Boolean&#xA;}&#xA;(...)&#xA;</code></pre>&#xA;<p>I have a searchbar inside my <strong>index.js</strong>, which fetches results from the const <strong>getIssuesPaginationQuery</strong>.&#xA;The query contains option arguments for a case and pagination (<strong>Pagination/CaseArgs.ts</strong>) with an appropriate schema (like <strong>searchValue</strong>). I address the wanted property through keys written in a constant.js that leads to the the query named CaseManagerDashboard, in order to allow input options as explained above (input arguments).</p>&#xA;<p><strong>searchValue</strong> uses the user's input (as String) in order to search within fetched data.&#xA;Patient full name works (first name &amp; last name), same as case number, also checkboxes to filter specific data.</p>&#xA;<p>But when I enter a Clerk's name, I get no result, altough I received everything neccessary.&#xA;I'll attach a Screenshot of the network tab too.</p>&#xA;<p>Thanks in advance&#xA;<a href=""https://i.stack.imgur.com/5djRX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5djRX.png"" alt=""networktab"" /></a></p>&#xA;",13548393,,,,2020-12-28 13:34:21,React JS (Apollo): Searchbar filters every column except clerk names from table,<reactjs><graphql>,0,3,0,2020-12-28 13:34:21
65511393,2,,59730879,3,,"<p>Sure you can sort by multiple fields. Just pass fields and sort order as an array to your query:</p>&#xA;<pre><code>query MyQuery {&#xA;    allContentfulPost(&#xA;        sort: { fields: [featured, updatedAt], order: [ASC, DESC] }) {&#xA;        edges {&#xA;            node {&#xA;               featured&#xA;               updatedAt(formatString: &quot;d MM yyyy&quot;)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",10450604,,10450604,2020-12-30 18:09:09,2020-12-30 18:09:09,"",,0,1,0,2020-12-30 17:53:45
65522560,2,,65520895,1,,"<p>The default <code>amountLimit</code> for the GraphQL plugin is 100. You can change this limit as stated <a href=""https://strapi.io/documentation/developer-docs/latest/plugins/graphql.html#configurations"" rel=""nofollow noreferrer"">here</a></p>&#xA;",5654715,,,,2020-12-31 15:10:43,"",,0,0,0,2020-12-31 15:10:43
65535447,1,65536224,,-1,983,"<p>I have a query that includes a variable $filter which is a string.</p>&#xA;<p>This variable is only relevant if the user has said they want to filter the results. If user doesn't filter, I want all results back that meet the criteria.</p>&#xA;<p>Is there a way to omit the filter variable in this query? I've tried passing null and I get an error.</p>&#xA;<pre><code>const NOTIFY_NEW_PUBLIC_FEELINGS = gql`&#xA;  subscription notifyNewPublicFeelings($page_id: uuid!, $filter: String!) {&#xA;    feelings(&#xA;      where: { is_public: { _eq: true }, page_id: {_eq: $page_id}, feeling: {_eq: $filter} }&#xA;      limit: 1&#xA;      order_by: { created_at: desc }&#xA;    ) {&#xA;      id&#xA;      created_at&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",5410576,,,,2021-01-02 05:14:04,Can I make variables optional in a GraphQL query?,<graphql><react-apollo><gql><hasura>,1,0,0,2021-01-02 02:08:38
65546883,1,,,0,450,"<p>I implemented pagination system by using <a href=""https://relay.dev/docs/en/pagination-container"" rel=""nofollow noreferrer"">pagination container</a>. It works great with one problem.</p>&#xA;<p>When i call loadMore function to get new nodes relay fetches nodes from server and adds to olds ones. But i want to delete old nodes and just want to show new ones.</p>&#xA;<p>For example $first = 10</p>&#xA;<p>When the page first loads i got 10 nodes, after loadMore i get 20 nodes. But i want to show just new fetched 10 nodes.</p>&#xA;<p>I used this <a href=""https://relay.dev/docs/en/pagination-container#pagination-example"" rel=""nofollow noreferrer"">pagination example</a></p>&#xA;<p>I could not find a way to remove old nodes after loadMore action.</p>&#xA;<p>I know relay pagination intended to use only infinite scroll, i just wonder maybe there is a way to solve this problem.</p>&#xA;",4891052,,,,2021-01-06 06:50:06,Relay Pagination - Remove old nodes from store after cursor changed,<pagination><graphql-js><relayjs><relay><react-relay>,1,0,0,2021-01-03 05:18:42
65549093,2,,65547419,1,,"<p>You have your order of operations wrong.  You have placed the loop way too early in the flow of your code, and are therefore creating all of the JSX for the entire form for each option.</p>&#xA;<p>You can declare JSX as a variable earlier in the method and then use it in your final return JSX by wrapping it in {}</p>&#xA;<p>Also, you want to put the author.name inside of the option, and your Select Author option should have an empty value; like this:</p>&#xA;<pre><code>let options = [];&#xA;for (let author in authors) {&#xA;    options.push(&lt;option key={author.id} value={author.id}&gt;author.name&lt;/option&gt;);&#xA;}&#xA;&#xA;...&#xA;&#xA;&lt;select&gt;&#xA;    &lt;option value=&quot;&quot;&gt;Select Authors&lt;/option&gt;&#xA;    {options}&#xA;&lt;/select&gt;&#xA;</code></pre>&#xA;",3347093,,,,2021-01-03 11:06:20,"",,0,1,0,2021-01-03 11:06:20
65553598,1,65553860,,0,414,"<p>I am retrieving data from graphql over a koa-server. For that, I wrote a function <code>requestData(token, queryName, cursor)</code> to call the graphql.</p>&#xA;<p>I would like to repeat the request until the cursor is null or undefined.</p>&#xA;<p>I always need to use the last cursor:</p>&#xA;<pre><code>lastCursor = edges[edges.length - 1].cursor;&#xA;</code></pre>&#xA;<p>In the terminal I am getting following outputs:</p>&#xA;<pre><code>null&#xA;eyJsYXN0X2lkIjo2MTQzNTk3ODcxMjc0LCJsYXN0X3ZhbHVlIjoiNjE0MzU5Nzg3MTI3NCJ9&#xA;</code></pre>&#xA;<p>I am getting this output even though I have more data. Can someone help me figure out what is wrong with my code?</p>&#xA;<p><strong>server.js part</strong></p>&#xA;<pre><code>  router.post('/getAllProducts', bodyParser(), async (ctx, next) =&gt; {&#xA;    let data;&#xA;    let edges;&#xA;    let lastCursor = null;&#xA;    const { accessToken } = ctx.session;&#xA;    ctx.response.status = 200;&#xA;&#xA;    requestData(accessToken, GET_ALL_PRODUCTS, lastCursor).then((res) =&gt; {&#xA;      data = res.data.data;&#xA;      edges = data.products.edges;&#xA;      lastCursor = edges[edges.length - 1].cursor;&#xA;      setTimeout(() =&gt; {&#xA;        requestData(accessToken, GET_ALL_PRODUCTS, lastCursor);&#xA;      }, 1000);&#xA;    });&#xA;  });&#xA;&#xA;  function requestData(token, queryName, cursor) {&#xA;    const variables = { after: cursor };&#xA;    console.log(cursor);&#xA;    const res = axios({&#xA;      headers: {&#xA;        'X-Shopify-Access-Token': token,&#xA;      },&#xA;      method: 'post',&#xA;      data: {&#xA;        query: queryName,&#xA;        variables: variables,&#xA;      },&#xA;      url: url,&#xA;    });&#xA;&#xA;    return res;&#xA;  }&#xA;</code></pre>&#xA;",14933415,,12035742,2021-01-04 03:14:24,2021-01-04 03:14:24,Cursor based pagination graphql,<javascript><graphql><koa>,1,1,0,2021-01-03 18:47:15
65590507,2,,50204685,2,,"<p>As the other post that mentioned having to go from int to float, this error occurs because the types set up in your graphQL schema are conflicting with the types you are trying to use when querying.</p>&#xA;<p>It's saying: 'Unknown type Int'</p>&#xA;<p>But what it really means is: 'Expected type Float but got Int' then you'd go change it where it is wrong.</p>&#xA;",13160162,,13160162,2021-01-06 05:20:53,2021-01-06 05:20:53,"",,0,0,0,2021-01-06 05:07:35
65591316,2,,65546883,0,,"<p>The Hacky/easy solution is to alway map through the last 10 items.</p>&#xA;<p>Another solution is to check the Relay store using <code>ConnectionHandler</code> and delete the edges that you don't want from the store manually.</p>&#xA;<p>Look at <code>deleteNode</code> in <a href=""https://relay.dev/docs/en/relay-store"" rel=""nofollow noreferrer"">https://relay.dev/docs/en/relay-store</a> for more info how to work with relay store.</p>&#xA;<p>Better solution is to create a re-fetch-able container and use the cursor pagination instead so every time you get the next 10 items by setting the cursor and after arguments on the connection. This way you have to query for <code>pageInfo</code> and manually check if hasNextPage.</p>&#xA;<p>Also this way you will be able to have a bi-directional pagination (Forward and backward pagination).</p>&#xA;<p>More info about cursor based pagination:</p>&#xA;<p><a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">https://relay.dev/graphql/connections.htm</a></p>&#xA;<p><a href=""https://graphql.org/learn/pagination/"" rel=""nofollow noreferrer"">https://graphql.org/learn/pagination/</a></p>&#xA;",6106583,,6106583,2021-01-06 06:50:06,2021-01-06 06:50:06,"",,0,1,0,2021-01-06 06:45:06
65596228,2,,65596169,2,,"<p>You can use :</p>&#xA;<pre><code>paste0('&quot;', input_vector, '&quot;', collapse = ',')&#xA;#[1] &quot;\&quot;string1\&quot;,\&quot;string2\&quot;&quot;&#xA;</code></pre>&#xA;<p>To view the actual string use <code>cat</code> :</p>&#xA;<pre><code>cat(paste0('&quot;', input_vector, '&quot;', collapse = ','))&#xA;#&quot;string1&quot;,&quot;string2&quot;&#xA;</code></pre>&#xA;",3962914,,,,2021-01-06 12:59:00,"",,0,0,0,2021-01-06 12:59:00
65603803,1,,,2,3710,"<p>I'm using relay and graphQL in react Typescript to fetch list of users. While I'm passing the props from ViewerUserList.tsx to UserList.tsx. I'm getting this error: Object is of type 'unknown'.ts(2571)</p>&#xA;<p>I've mentioned in below file where I'm getting the error exactly</p>&#xA;<p>This is my ViewerUserList.tsx</p>&#xA;<pre><code>import React from 'react';&#xA;import {graphql, QueryRenderer} from 'react-relay';&#xA;import UserList from './UserList'&#xA;import environment from &quot;../relayEnvironment&quot;&#xA;&#xA;export default class ViewerUserList extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;QueryRenderer&#xA;        environment={environment}&#xA;        query={graphql`&#xA;          query ViewerQuery {&#xA;            viewer {&#xA;              id&#xA;              # Re-use the fragment here&#xA;              ...UserList_userData&#xA;            }&#xA;          }&#xA;        `}&#xA;        variables={{}}&#xA;        render={({error, props}) =&gt; {&#xA;          if (error) {&#xA;            return &lt;div&gt;Error!&lt;/div&gt;;&#xA;          }&#xA;          if (!props) {&#xA;            return &lt;div&gt;Loading...&lt;/div&gt;;&#xA;          }&#xA;          return (&#xA;            &lt;div&gt;&#xA;              &lt;div&gt;list for User {props.viewer.id}:&lt;/div&gt; //I am getting error here on props&#xA;              &lt;UserList userData={props.viewer} /&gt;&#xA;            &lt;/div&gt;&#xA;          );&#xA;        }}&#xA;      /&gt;&#xA;    );&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is UserList.tsx</p>&#xA;<pre><code>// OPTIONAL: Flow type generated after running `yarn relay`, defining an Object type with shape of the fragment:&#xA;import type {UserList_userData} from './__generated__/UserList_userData.graphql';&#xA;import User from './User'&#xA;&#xA;import React from 'react';&#xA;import {graphql, createFragmentContainer} from 'react-relay';&#xA;&#xA;type Props = {&#xA;  userData: UserList_userData,&#xA;}&#xA;&#xA;class UserList extends React.Component&lt;Props&gt; {&#xA;  render() {&#xA;    const {userData: {apiVersion, users}} = this.props;&#xA;&#xA;    return (&#xA;      &lt;section&gt;&#xA;        &lt;ul&gt;&#xA;          {users!.edges!.map(edge =&gt;&#xA;            &lt;User&#xA;              key={edge!.node!.id}&#xA;              /*We pass the data required by Todo here*/&#xA;              user = {edge!.node!}&#xA;            /&gt;&#xA;          )}&#xA;        &lt;/ul&gt;&#xA;      &lt;/section&gt;&#xA;    );&#xA;  }&#xA;}&#xA;&#xA;export default createFragmentContainer(&#xA;  UserList,&#xA;  {&#xA;    userData: graphql`&#xA;      # As a convention, we name the fragment as '&lt;ComponentFileName&gt;_&lt;PropName&gt;'&#xA;      fragment UserList_userData on Query {&#xA;        users(&#xA;          first: 2147483647  # max GraphQLInt, to fetch all todos&#xA;        ) {&#xA;          edges {&#xA;            node {&#xA;              id,&#xA;              # We use the fragment defined by the child Todo component here&#xA;              ...User_user,&#xA;            },&#xA;          },&#xA;        },&#xA;        apiVersion&#xA;      }&#xA;    `,&#xA;  },&#xA;);&#xA;</code></pre>&#xA;",7516770,,,,2021-11-05 07:10:58,TypeScript: Object is of type 'unknown'.ts(2571),<reactjs><typescript><graphql><relay>,1,1,0,2021-01-06 21:47:09
65619425,1,,,0,61,"<p>So we have a People schema and a Project schema, both of which are used on separate pages where you can filter the results. We are at a point where we are realising that we need to filter something like current projects, but on the PEOPLE list. However the data for that lives in Projects, and we are having trouble in finding a clean way to cross-reference the schemas and filter on a computed value.</p>&#xA;<p>Eg. Filter the list of people by projects that are currently active (ie. the current time).</p>&#xA;<p>There doesn't seem to be any way to do this in ES - my current option is stitching these together in the front-end and doing another &quot;filter&quot; there, but that feels hacky.</p>&#xA;<p><strong>Displaying</strong> the data on the People list is no issue, it's the filtering.</p>&#xA;<p>Has anyone run into this situation before, and how did you resolve it? Appreciate any insight. THanks!</p>&#xA;",12610489,,12610489,2021-01-07 20:38:31,2021-01-11 04:08:44,Filtering computed values with Elasticsearch,<node.js><elasticsearch><graphql>,2,0,0,2021-01-07 20:24:36
65626571,2,,65619425,1,,"<p>If I understand things correctly, you have two separate indices for people and projects.</p>&#xA;<p>Unfortunately, the only way to do things right is to denormalize your data in Elasticsearch and include projects on the people list.</p>&#xA;",3680098,,,,2021-01-08 09:39:39,"",,0,2,0,2021-01-08 09:39:39
65630373,2,,65615619,0,,"<p>It's an issue with the way you pass the parameters in to <code>graphqlOperation</code> which takes in a query and the options for that query only.</p>&#xA;<pre><code>const limit = 4;&#xA;// whatever you want to filter by&#xA;const filter = {id: userID};&#xA;&#xA;const result = await API.graphql(&#xA;  graphqlOperation(getUser, {filter, limit})&#xA;);&#xA;</code></pre>&#xA;",13337635,,,,2021-01-08 13:58:52,"",,0,0,0,2021-01-08 13:58:52
65636495,1,,,1,58,"<p>My objective is to write an Apollo plugin, that can save a specific input type on my context, for <em>all</em> queries.</p>&#xA;<p>The input is called &quot;QueryOptions&quot;.</p>&#xA;<pre><code>input QueryOptions {&#xA;    tenant: ID&#xA;}&#xA;&#xA;# example query&#xA;somePath(queryOptions: {&#xA;  tenant: &quot;some-tenant&quot;&#xA;})&#xA;#example query 2&#xA;someOtherPath(queryOptions: {&#xA;  tenant: &quot;some-tenant&quot;&#xA;})&#xA;&#xA;</code></pre>&#xA;<p>Would it be able to determine the value of <code>tenant</code>, in an Apollo plugin? Maybe in the <code>didResolveOperation</code> hook?</p>&#xA;<p>Thanks for your input - currently I solve the issue by setting the tenant property on the context as the first thing on my resolvers.</p>&#xA;",3694288,,,,2021-01-08 21:13:24,Apollo nodejs server; How to get query argument in when writing a plugin?,<node.js><apollo-server>,0,0,0,2021-01-08 21:13:24
65646072,1,,,1,205,"<p>I have the following schema definition:</p>&#xA;<pre><code>enum CommunityType {&#xA;  INTEREST&#xA;  COMPANY&#xA;  INDUSTRY&#xA;}&#xA;...&#xA;extend type Mutation {&#xA;  createCommunity(name: String!, type: CommunityType): Community&#xA;}&#xA;</code></pre>&#xA;<p>And the following mutation:</p>&#xA;<pre><code>mutation CreateCommunity($name: String!, $type: CommunityType) {&#xA;  createCommunity(name: $name, type: $type) {&#xA;    id&#xA;    name&#xA;    type&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Apollo generated the correct TypeScript types for me as well:</p>&#xA;<pre><code>export interface CreateCommunity_createCommunity {&#xA;  __typename: &quot;Community&quot;;&#xA;  id: string | null;&#xA;  name: string | null;&#xA;  type: CommunityType | null;&#xA;}&#xA;&#xA;export interface CreateCommunity {&#xA;  createCommunity: CreateCommunity_createCommunity | null;&#xA;}&#xA;&#xA;export interface CreateCommunityVariables {&#xA;  name: string;&#xA;  type?: CommunityType | null;&#xA;}&#xA;</code></pre>&#xA;<p>And global types:</p>&#xA;<pre><code>/**&#xA; * CommunityType&#xA; */&#xA;export enum CommunityType {&#xA;  COMPANY = &quot;COMPANY&quot;,&#xA;  INDUSTRY = &quot;INDUSTRY&quot;,&#xA;  INTEREST = &quot;INTEREST&quot;,&#xA;  LOCATION = &quot;LOCATION&quot;,&#xA;  MINISTRY = &quot;MINISTRY&quot;,&#xA;}&#xA;</code></pre>&#xA;<p>When I use the mutation like so</p>&#xA;<pre><code> const [create, {&#xA;    loading,&#xA;    error,&#xA;  }] = useMutation&lt;CreateCommunity, CreateCommunityVariables&gt;(CREATE_COMMUNITY, {&#xA;    variables: {&#xA;      name: title,&#xA;      type: CommunityType.COMPANY,&#xA;    },&#xA;  });&#xA;</code></pre>&#xA;<p>I get this error when invoking <code>create</code>:</p>&#xA;<blockquote>&#xA;<p>GraphQL error: Expected a value of type &quot;CommunityType&quot; but received: &quot;company&quot;</p>&#xA;</blockquote>&#xA;<p>It seems like Apollo Client somehow transforms the enum value <code>COMPANY</code> to lower case.</p>&#xA;<p>I'm using apollo-client <code>2.6.8</code>. Edit: I upgraded to apollo-client <code>3.3.6</code>, same problem</p>&#xA;",1867854,,1867854,2021-01-10 15:21:38,2021-01-10 15:21:38,Unable to pass enum value to mutation,<typescript><enums><apollo><apollo-client>,0,1,0,2021-01-09 18:21:52
65671116,2,,61394632,0,,"<p>You need to add _id to the sort for the sort to work.</p>&#xA;<p>Try this:</p>&#xA;<pre><code>sort:{ _id: 1 ,lastUpdate: &quot;descending&quot;, creationDateTime:&quot;descending&quot;}&#xA;</code></pre>&#xA;",13771434,,,,2021-01-11 16:49:34,"",,0,3,0,2021-01-11 16:49:34
65688551,1,,,0,440,"<p>I need to send graphql an array of objects in the parameter but I am getting an internal error &quot;Cannot convert object to primitive value&quot;. Im not sure if this is on my backend or in the query itself. I cant find an example online where there is an array of objects in the parameter. Here is the query:</p>&#xA;<pre><code>{&#xA;  searchProfile(query:&quot;&quot;, limit: 10, sortBy: [{name: &quot;name&quot;, sortOrder: &quot;asc&quot;}]){&#xA;    items{&#xA;      id&#xA;      name&#xA;      email&#xA;    }&#xA;    context&#xA;  }&#xA;} &#xA;</code></pre>&#xA;<p>Im created a graphql wrapper for a rest api let me know if more information is needed like dataSource, or resolvers.&#xA;Schema:</p>&#xA;<pre><code>searchProfile(&#xA;  query: String&#xA;  sortBy: [JSONObject]&#xA;  cursor: String&#xA;  limit: Int&#xA;  context: JSONObject&#xA;): CustomerPagination&#xA;</code></pre>&#xA;<p>DataSource:</p>&#xA;<pre><code>async searchProfile(query, sortBy, cursor, limit, context) {&#xA;    return this.get('getProfile/search', {&#xA;      ...(query &amp;&amp; { query }),&#xA;      ...(sortBy &amp;&amp; { sortBy }),&#xA;     ...other data ommitted&#xA;    });&#xA;  }&#xA;</code></pre>&#xA;<p>Resolvers.js:</p>&#xA;<pre><code>searchCustomer: async (_, { query, sortBy, cursor, limit, context }, { dataSources }) =&gt; {&#xA;      return dataSources.api.searchProfile(query, sortBy, cursor, limit, context);&#xA;    },&#xA;</code></pre>&#xA;<p>Everything works until I added the sortBy param in the gql query.</p>&#xA;",14730784,,14730784,2021-01-12 17:14:11,2021-01-12 17:14:11,Graphql array of objects in parameter,<javascript><graphql>,0,9,0,2021-01-12 17:03:19
65708640,1,,,2,472,"<p>I'm using a GraphQL API (which I do not own) to access data.  I make extensive use of fragments and one problem I've run into more than once is that fragments don't seem to deep-merge.  Consider the following query:</p>&#xA;<pre class=""lang-graphql prettyprint-override""><code>fragment BasicInfo on Person {&#xA;    id&#xA;    name&#xA;    address {&#xA;        city&#xA;        country&#xA;    }&#xA;}&#xA;&#xA;query ProfileCard($id: ID) {&#xA;    personById(id: $id) {&#xA;        ...BasicInfo&#xA;        id&#xA;        age&#xA;        address {&#xA;            streetName&#xA;            streetNumber&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Here we run a basic query to get some information from a profile card including the person's age and some of their address (street name and number).  Another component used by the profile card also wants some info which can be found in the <code>BasicInfo</code> fragment.  This includes their name as well as their city and country.</p>&#xA;<p>Running this query returns an object that contains the following fields: <code>id</code>, <code>name</code>, <code>age</code>, <code>address.streetName</code> and <code>address.streetNumber</code>.</p>&#xA;<p><code>address.city</code> and <code>address.country</code> are both missing - it appears that the query did not deep-merge the fragment in and only inserted it at a shallow level.</p>&#xA;<p><strong>Is it possible to force my fragments to deep-merge?</strong>  Is this even the expected behavior?  Do I have to get in contact with the API owners to correct this?</p>&#xA;<p>I've had trouble finding documentation that says it should be one way or the other.</p>&#xA;",1496453,,,,2021-06-07 08:52:51,Deep merging fragments,<graphql><graphql-fragments>,2,3,0,2021-01-13 19:31:55
65739704,1,,,0,210,"<p>I want to know whether I can make use of the Mongo DB query for filtering the data in GraphiQL.</p>&#xA;<p>Actually, I made an API with PyMongo, flask &amp; GraphiQL.</p>&#xA;<p>Ex - in Mongo DB inside a collection I have the following 5 documents -:</p>&#xA;<p>Data in Mongo DB</p>&#xA;<pre><code>{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3d&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:00:00&quot;&#xA;} &#xA;&#xA;{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3l&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:01:00&quot;&#xA;} &#xA;&#xA;{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3e&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:02:00&quot;&#xA;} &#xA;&#xA;{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3z&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:03:00&quot;&#xA;} &#xA;&#xA;{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3v&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:04:00&quot;&#xA;} &#xA;</code></pre>&#xA;<p>Now without using GraphiQL I was executing this below query in MongoDB for filtering my data on the &quot;Serial_No&quot;, &quot;Time_Records&quot; between &quot;2020-05-01 06:00:00&quot; &amp; &quot;2020-05-01 06:04:00&quot;, with a Limit of size = '2' &amp; skip = '1' for pagination.</p>&#xA;<pre><code>def get_filter_data(Serial_No, from_date , to_date ,number_limit,number_skip):&#xA;    data = coll.find({&quot;Serial_No&quot;: Serial_No, &quot;Time_Record&quot; : {'$gt': from_date , '$lt': to_date}}).limit(number_limit).skip(number_skip)&#xA;    for col in data:&#xA;        pprint.pprint(col)&#xA;    print(&quot;Count is : &quot;, number_limit)&#xA;    return data&#xA;</code></pre>&#xA;<p>I am happy !!!</p>&#xA;<p>It works and gives the desired output -:</p>&#xA;<p>Correct output I got after executing the above Mongo query:</p>&#xA;<pre><code>{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3e&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:02:00&quot;&#xA;} &#xA;&#xA;{&quot;_id&quot;:{&quot;$oid&quot;:&quot;5ff6ad894d0d2a1c6ce0fc3z&quot;},&#xA;&quot;Serial_No&quot;:&quot;1111&quot;,&#xA;&quot;Time_Record&quot;:&quot;2020-05-01 06:03:00&quot;&#xA;} &#xA;</code></pre>&#xA;<p>Now I want to get the same output in GraphiQL</p>&#xA;<p>Basically, I am not sure how to make use of this query especially how to mention this part {'$gt': from_date, '$lt': to_date} in GraphiQL</p>&#xA;<pre><code>coll.find({&quot;Serial_No&quot;: Serial_No, &quot;Time_Record&quot; : {'$gt': from_date , '$lt': to_date}}).limit(number_limit).skip(number_skip)&#xA;</code></pre>&#xA;",12171000,,13302,2021-01-16 12:41:56,2021-01-22 09:58:07,Can we write Mongo DB query in GraphiQL?,<mongodb><graphql><mongodb-query><pymongo><graphiql>,1,0,0,2021-01-15 16:21:34
65744852,1,,,1,1142,"<p>I would like to have the variables I do not use be completely omitted to avoid errors like <code>&quot;Variable &quot;$eventId&quot; got invalid value &quot;&quot;; Int cannot represent non-integer value: &quot;</code></p>&#xA;<p>Take this query for example:</p>&#xA;<pre><code>//gql``&#xA;query($orderBy: [AwardsOrderBy!], $limit: Int!, $eventId: Int) {&#xA;   allAwards(first: $limit, orderBy: $orderBy, filter: { eventId: { equalTo: $eventId } }) {&#xA;&#xA;//query variables and query&#xA;limit = 40&#xA;orderBy = &quot;DATE_DESC&quot;&#xA;eventId = falsey&#xA;useQuery(AWARDS, { variables: { limit, orderBy, eventId } })&#xA;</code></pre>&#xA;<p>Now I <a href=""https://github.com/graphile-contrib/postgraphile-plugin-connection-filter/issues/58"" rel=""nofollow noreferrer"">would assume</a>, that this query would work correctly but the eventId part of the filtering would be completely ignored.</p>&#xA;<p>Is there a way round this with graphQL and postgraphile</p>&#xA;<p>Here is my current solution without having to have put any thought into it, I just needed it working right now:</p>&#xA;<pre><code>  const queryVariables = [&#xA;    ...(eventId ? [`eventId: { equalTo: $eventId}`] : []),&#xA;    ...(awardTypeId ? [`awardTypeId: { equalTo: $awardTypeId}`] : []),&#xA;  ]&#xA;  const filterVariables = [...(eventId ? [`$eventId: Int`] : []), ...(awardTypeId ? [`$awardTypeId: Int`] : [])]&#xA;&#xA;  const filter = queryVariables.length&#xA;    ? `, filter: { ${queryVariables.map((a, index) =&gt; {&#xA;        return `${a}${queryVariables.length !== index + 1 ? ', ' : ''}`&#xA;      })} }`&#xA;    : ''&#xA;&#xA;  const query = `&#xA;    query($orderBy: [AwardsOrderBy!], $limit: Int!${queryVariables.length ? `, ${filterVariables}` : ''}) {&#xA;      allAwards(first: $limit, orderBy: $orderBy${filter}) {&#xA;        edges {&#xA;&#xA;///example output:&#xA;query($orderBy: [AwardsOrderBy!], $limit: Int!, $awardTypeId: Int) {&#xA;  allAwards(first: $limit, orderBy: $orderBy, filter: { awardTypeId: { equalTo: $awardTypeId} }) {&#xA;</code></pre>&#xA;",240363,,240363,2021-01-17 23:17:10,2021-01-17 23:17:10,Graphql Conditional variables in Queries,<javascript><node.js><graphql><postgraphile>,0,7,0,2021-01-15 23:26:56
65764020,2,,65095247,1,,"<p>The data API of HotChocolate and the Dataloaders do not work well together.&#xA;These are two different approaches that cannot be mixed in the same resolver.</p>&#xA;<p>Filtering works on the resolver level whereas data loaders do run outside of the resolver execution.</p>&#xA;<p>This query contains two resolvers:</p>&#xA;<pre><code>query {&#xA;  friendlyBikeShop: customers (where: { companyName: &quot;Friendly Bike Shop&quot;}){&#xA;    firstName&#xA;    lastName&#xA;  }&#xA;  frontSportingGoods: customers (where: { companyName: &quot;Front Sporting Goods&quot;}){&#xA;    firstName&#xA;    lastName&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Therefor you can either go with filtering and projections and two queries or you go with data loaders and only execute one query.</p>&#xA;<p>As an alternative query you could also do this:</p>&#xA;<pre><code>query {&#xA;  customers (&#xA;    where: { &#xA;        companyName_in: [&#xA;            &quot;Friendly Bike Shop&quot;,&#xA;            &quot;Front Sporting Goods&quot;&#xA;      ]&#xA;  }){&#xA;    firstName&#xA;    lastName&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This would return both results in a single request</p>&#xA;",7188852,,,,2021-01-17 17:50:55,"",,0,0,0,2021-01-17 17:50:55
65766139,1,,,1,47,"<p>Taking a simple structure like this one :</p>&#xA;<pre><code>&lt;ComponentA&gt;&lt;ComponentB /&gt;&lt;/ComponentA&gt;&#xA;</code></pre>&#xA;<p>Where both components A &amp; B needs the information fetch through a react apollo hook from a server :</p>&#xA;<pre><code>const booksQuery = useGetBooks();&#xA;</code></pre>&#xA;<p>Is there any downside if components A &amp; B both separately call <code>useGetBooks()</code> ? Or would it be better if only the component A calls it, and pass the value to it child component B using the props?</p>&#xA;<p>Here are a few points :</p>&#xA;<ul>&#xA;<li>Looking at my network, I do not see duplicated calls. I'm no expert, but I guess because of the Apollo cache?</li>&#xA;<li>Duplicating the call seems to make component B easier to reuse.</li>&#xA;<li>When the structure become deep, it is somewhat painful to pass props through multiple children.</li>&#xA;</ul>&#xA;",931531,,,,2021-01-17 21:28:19,"Any downsides for calling React Apollo Hooks from every component that needs it, instead of passing data from parent to children as props?",<reactjs><react-hooks><react-apollo>,0,3,0,2021-01-17 21:28:19
65802746,1,65809165,,0,2375,"<p>I've reached out on the AWS forums but am hoping to get some attention here with a broader audience.  I'm looking for any guidance on the following <a href=""https://forums.aws.amazon.com/thread.jspa?threadID=334045&amp;tstart=0"" rel=""nofollow noreferrer"">question</a>.</p>&#xA;<p>I'll post the question below:</p>&#xA;<p>Hello, thanks in advance for any help.</p>&#xA;<p>I'm new to Amplify/GraphQL and am struggling to get mutations working. Specifically, when I add a connection to a Model, they never appear in the mock api generator. If I write them out, they say &quot;input doesn't exist&quot;. I've searched around and people seem to say &quot;Create the sub item before the main item and then update the main item&quot; but I don't want that. I have a large form that has several many-to-many relationships and they all need to be valid before I can save the main form. I don't see how I can create every sub item and then the main.</p>&#xA;<p>However, the items are listed in the available data for the response. In the example below, addresses, shareholders, boardofdirectors are all missing in the input.</p>&#xA;<p>None of the fields with '@connection' appear in the create api as inputs. I'll take any help/guidance I can get. I seem to not be understanding something core here.</p>&#xA;<p>Here's my Model:</p>&#xA;<pre><code>type Company @model(queries: { get: &quot;getEntity&quot;, list: &quot;listEntities&quot; }, subscriptions: null) {&#xA;id: ID!&#xA;name: String!&#xA;president: String&#xA;vicePresident: String&#xA;secretary: String&#xA;treasurer: String&#xA;shareholders: Shareholder @connection&#xA;boardOfDirectors: BoardMember @connection&#xA;addresses: [Address]! @connection&#xA;...&#xA;}&#xA;&#xA;type Address @model{&#xA;id: ID!&#xA;line1: String!&#xA;line2: String&#xA;city: String!&#xA;postalCode: String!&#xA;state: State!&#xA;type: AddressType!&#xA;}&#xA;&#xA;type BoardMember @model{&#xA;id: ID!&#xA;firstName: String!&#xA;lastName: String!&#xA;email: String!&#xA;}&#xA;&#xA;type Shareholder @model {&#xA;id: ID!&#xA;firstName: String!&#xA;lastName: String!&#xA;numberOfShares: String!&#xA;user: User!&#xA;}&#xA;</code></pre>&#xA;<p>----A day later----</p>&#xA;<p>I have made some progress, but still lacking some understanding of what's going on.</p>&#xA;<p>I have updated the schema to be:</p>&#xA;<pre><code>type Company @model(queries: { get: &quot;getEntity&quot;, list: &quot;listEntities&quot; }, subscriptions: null) {&#xA;id: ID!&#xA;name: String!&#xA;president: String&#xA;vicePresident: String&#xA;secretary: String&#xA;treasurer: String&#xA;...&#xA;address: Address @connection&#xA;...&#xA;}&#xA;&#xA;type Address @model{&#xA;id: ID!&#xA;line1: String!&#xA;line2: String&#xA;city: String!&#xA;postalCode: String!&#xA;state: State!&#xA;type: AddressType!&#xA;}&#xA;</code></pre>&#xA;<p>I removed the many-to-many relationship that I was attempting and now I'm limited to a company only having 1 address. I guess that's a future problem. However, now in the list of inputs a 'CompanyAddressId' is among the list of inputs. This would indicate that it expects me to save the address before the company. Address is just 1 part of the company and I don't want to save addresses if they aren't valid and some other part of the form fails and the user quits.</p>&#xA;<p>I don't get why I can't write out all the fields at once? Going along with the schema above, I'll also have shareholders, boardmembers, etc. So I have to create the list of boardmembers and shareholders before I can create the company? This seems backwards.</p>&#xA;<p>Again, any attempt to help me figure out what I'm missing would be appreciated.</p>&#xA;<p>Thanks</p>&#xA;<p>--Edit--&#xA;What I'm seeing in explorer&#xA;<a href=""https://i.stack.imgur.com/BLrGH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BLrGH.png"" alt=""enter image description here"" /></a></p>&#xA;<p>-- Edit 2--&#xA;Here is the newly generated operations based off your example.  You'll see that Company takes an address Id now -- which we discussed prior.  But it doesn't take anything about the shareholder.  In order to write out a shareholder I have to use 'createShareholder' which needs a company Id, but the company hasn't been created yet.  Thoroughly confused.</p>&#xA;<p><a href=""https://i.stack.imgur.com/n94DK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/n94DK.png"" alt=""enter image description here"" /></a></p>&#xA;<p>@engam I'm hoping you can help out the new questions.  Thank you very much!</p>&#xA;",2709028,,2709028,2021-01-27 16:15:23,2021-01-30 19:04:02,Nested GraphQL mutations with AWS Amplify/AppSync,<graphql><aws-amplify><aws-appsync>,1,0,0,2021-01-20 03:38:53
65817910,1,,,1,99,"<p>We need a way to filter a subscription in the following manner:</p>&#xA;<pre><code>type Subscription {&#xA;    onPlanningViewUpdate(prop1: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]): ReturnObject&#xA;}&#xA;&#xA;ReturnObject = {prop1: &quot;a&quot;, ...} // would pass through&#xA;&#xA;ReturnObject = {prop1: &quot;b&quot;, ...} // would pass through&#xA;&#xA;ReturnObject = {prop1: &quot;c&quot;, ...} // would pass through&#xA;&#xA;ReturnObject = {prop1: &quot;x&quot;, ...} // would NOT pass through&#xA;</code></pre>&#xA;<p>We have tried using the request and response mapping templates of a resolver with a NONE type data source, but the mappings seem to only get called once when the subscription is first opened. It looks like subscriptions only handle an exact match. We need a way to determine if a prop is contained in the array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]. If prop1 == &quot;a&quot; or prop1 == &quot;b&quot; or prop1 == &quot;c&quot; pass through.</p>&#xA;<p>Here is the actual filter we want to use:</p>&#xA;<pre><code>type Subscription {&#xA;    onPlanningViewUpdate(site_ids: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], planDate: &quot;aString&quot;, lob_ids: [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]): &#xA;ReturnObject&#xA;}&#xA;&#xA;ReturnObject = {site_ids: &quot;a&quot;, planDate: &quot;aString&quot;, lob_ids: &quot;y&quot;} // would pass through&#xA;&#xA;ReturnObject = {site_ids: &quot;a&quot;, planDate: &quot;wrongString&quot;, lob_ids: &quot;y&quot;} // would NOT pass through&#xA;</code></pre>&#xA;<p>Is there a way to do this ?</p>&#xA;<p>Thanks,</p>&#xA;<p>Warren Bell</p>&#xA;",15047794,,,,2021-01-20 21:25:29,AppSync Subscription Filters,<amazon-web-services><graphql><aws-appsync>,0,0,0,2021-01-20 21:25:29
65827480,1,65829094,,2,555,"<p>when i add the PaginationAmmountType to set the max records per page all of my models int variables get turrned into PaginatioAmount</p>&#xA;<pre><code>services.AddGraphQL(SchemaBuilder.New()&#xA;                .AddType(new PaginationAmountType(100))&#xA;                .AddQueryType&lt;Query&gt;()&#xA;                .AddMutationType&lt;Mutation&gt;()&#xA;                .AddAuthorizeDirectiveType()&#xA;            );&#xA;</code></pre>&#xA;<p>this is how it looks without the PaginationAmountType</p>&#xA;<p><a href=""https://i.stack.imgur.com/KYbSo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KYbSo.png"" alt="""" /></a></p>&#xA;<p>and then this is what it changes to when i add the PaginationAmountType</p>&#xA;<p><a href=""https://i.stack.imgur.com/8jWGj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8jWGj.png"" alt=""enter image description here"" /></a></p>&#xA;<p>How can i resolve this or what exactly am i doing wrong i need to specify a max amount of records per page but this method of doing so is messing up my models.</p>&#xA;",10462177,,,,2021-01-21 14:04:21,GraphQL HotChocolate Adding PaginationAmountType converts my int's to PaginationAmmount,<c#><graphql><hotchocolate>,1,0,0,2021-01-21 12:30:10
65829643,2,,64087500,0,,"<p>It seems <code>amplify</code> does not correctly generate the queries.</p>&#xA;<p>I assume your generated query looks something like this:</p>&#xA;<pre><code>export const listBooks = /* GraphQL */ `&#xA;  query ListBooks(&#xA;    $filter: ModelBookFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listBooks(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        picture&#xA;        genres {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        userId&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>In order to load the <code>Genre</code> as well, you need to modify the query to:</p>&#xA;<pre><code>export const listBooks = /* GraphQL */ `&#xA;  query ListBooks(&#xA;    $filter: ModelBookFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listBooks(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        picture&#xA;        genres {&#xA;          items {&#xA;            genre {&#xA;              name&#xA;            }&#xA;          }&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        userId&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p><code>genres.items</code> will load all the entities from the join table.&#xA;<code>genre</code> will then load the field on the entity, which references the <code>Genre</code> table.</p>&#xA;",2591194,,,,2021-01-21 14:32:34,"",,0,0,0,2021-01-21 14:32:34
65864224,2,,65861041,6,,"<p>For this current example you can just do</p>&#xA;<pre><code>query {&#xA;  continents(filter: {code: {eq: &quot;AF&quot;}}) {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I'd suggest to review the <a href=""https://graphql.org/learn/queries/#variables"" rel=""noreferrer"">documentation</a> regarding arguments since they explain it quite well.</p>&#xA;",8731825,,8731825,2021-01-23 23:47:55,2021-01-23 23:47:55,"",,0,2,0,2021-01-23 20:49:25
65868188,1,,,0,129,"<p>I'm new to GraphQL and Relay and I'm struggling with queries, fragments, ...spreads &amp; passing props. I think I'm unnecessarily passing props down through many, many components. I want to learn how to teleport my data objects from the QueryRenderer to deeply nested components, skipping all the ancestor components.</p>&#xA;<p>Suppose I have a component structure like this. I need a list of emojis from the 'emoji' table inside <code>EmojisList</code> component which is deep in the app. I'm not sure where to spread or pass props or when to ask for the actual scalars.</p>&#xA;<pre><code>&lt;MainApp&gt;&#xA;  &lt;QueryRenderer &#xA;    environment={environment}&#xA;    query={graphql`&#xA;        query MainAppQuery {&#xA;        currentPerson { // current user&#xA;            ...Timeline_currentPerson&#xA;        }&#xA;        allEmojis {&#xA;            ...ReactionBar_emojisList&#xA;          }&#xA;        }&#xA;    `}&#xA;  /&gt;&#xA;  &lt;Timeline currentPerson={props.currentPerson}&gt;&#xA;    &lt;PostList&gt;&#xA;      &lt;Post&gt;&#xA;        &lt;ReactionBar&gt;&#xA;          &lt;EmojisList&gt;&#xA;            // I need this list&#xA;            export default createFragmentContainer(ReactionBar, {&#xA;              emojisList: graphql`&#xA;                fragment ReactionBar_emojisList on EmojisConnection @relay(plural: true) {&#xA;                  edges {&#xA;                    node {&#xA;                      name&#xA;                      rowId&#xA;                    }&#xA;                  }&#xA;                }&#xA;              `,&#xA;            });      &#xA;          &lt;/EmojisList&gt;&#xA;        &lt;/ReactionBar&gt;&#xA;      &lt;/Post&gt;&#xA;    &lt;/PostList&gt;&#xA;  &lt;/Timeline&gt;&#xA;&lt;/MainApp&gt;&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/e5UcP.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/e5UcP.jpg"" alt=""Console error"" /></a></p>&#xA;",1704772,,1704772,2021-01-24 20:31:10,2021-01-24 20:31:10,GraphQL / Relay - do all tables need to be queried in main QueryRenderer?,<reactjs><graphql><relay><react-relay>,1,0,0,2021-01-24 07:46:49
65868363,2,,65868188,0,,"<p>You can use <a href=""https://relay.dev/docs/en/fragment-container"" rel=""nofollow noreferrer"">Fragment Container</a></p>&#xA;<p>Wrap <code>&lt;EmojiList /&gt;</code> Component with <code>createFragmentContainer</code> HOC then it will grab all of the data you need that you have fetched at the root from <code>QueryRenderer</code> .</p>&#xA;<p>The data will be accessible as props inside the component</p>&#xA;<pre><code>// EmojisList.js&#xA;import {createFragmentContainer, graphql} from 'react-relay';&#xA;&#xA;class EmojisList extends React.Component {/* code */}&#xA;&#xA;// Export a *new* React component that wraps the original `&lt;EmojisList&gt;`.&#xA;export default createFragmentContainer(EmojisList, {&#xA;  emojisList: graphql`&#xA;    fragment EmojisList_emojisList on EmojisConnection {&#xA;      edges {&#xA;        node {&#xA;         name&#xA;         rowId&#xA;        }&#xA;      }&#xA;    }&#xA;  `,&#xA;});&#xA;</code></pre>&#xA;",9402107,,,,2021-01-24 08:11:39,"",,0,1,0,2021-01-24 08:11:39
65870888,1,,,1,151,"<p>I'm trying to connect to the <a href=""https://flow.fluctuo.com/api"" rel=""nofollow noreferrer"">Fluctuo</a> (mobility data) GraphQL API with my access token. It works perfectly well using the curl Shell script, but it throws a <code>400 Client Error: Bad Request for url</code> when trying the same using the Python requests library.</p>&#xA;<p>This is the curl script that works:</p>&#xA;<pre><code>curl --request POST \&#xA;      --url https://flow-api.fluctuo.com/v1?access_token=MY_ACCESS_TOKEN \&#xA;      --header 'content-type: application/json' \&#xA;      --data '{&quot;query&quot;:&quot;query ($lat: Float!, $lng: Float!) {\n  vehicles(lat: $lat, lng: $lng) {\n\t\tid\n  }\n}&quot;,&quot;variables&quot;:{&quot;lat&quot;:48.856614,&quot;lng&quot;:2.352222}}'&#xA;</code></pre>&#xA;<p>This is the Python code that throws the error:</p>&#xA;<pre><code>url = &quot;https://flow-api.fluctuo.com/v1?access_token=&quot; + MY_ACCESS_TOKEN&#xA;head = {'content-type': 'application/json'}&#xA;query='''&#xA;query ($lat: Float!, $lng: Float!) {\n  vehicles(lat: $lat, lng: $lng) {\n\t\tid\n  }\n}&quot;,&quot;variables&quot;:{&quot;lat&quot;:48.856614,&quot;lng&quot;:2.352222}'''&#xA;&#xA;try:&#xA;    r = requests.post(url, json={'query': query},headers=head)&#xA;    r.raise_for_status()&#xA;except requests.exceptions.HTTPError as err:&#xA;    raise SystemExit(err)&#xA;</code></pre>&#xA;<p>Any ideas about what could go wrong is much appreciated.</p>&#xA;",15070751,,,,2021-01-24 16:48:24,Connecting to API works using Shell but w/ Python requests lib throws 400 Client Error: Bad Request for url,<python><api><graphql>,1,0,0,2021-01-24 13:06:57
65873318,2,,65870888,1,,"<p>I found the solution in the meantime: the POST data needed to be JSON-encoded. I dumped the query into JSON and this solved the issue. See code below.</p>&#xA;<pre><code>import requests&#xA;import json&#xA;&#xA;url = &quot;https://flow-api.fluctuo.com/v1?access_token=&quot; + MY_ACCESS_TOKEN&#xA;head = {'content-type': 'application/json'}&#xA;data = {&quot;query&quot;:&quot;query ($lat: Float!, $lng: Float!) {\n  vehicles(lat: $lat, lng: $lng) {\n\t\tid\n  }\n}&quot;,&quot;variables&quot;:{&quot;lat&quot;:48.856614,&quot;lng&quot;:2.352222}}&#xA;&#xA;try:&#xA;    r = requests.post(url, data=json.dumps(data), headers=head)&#xA;    r.raise_for_status()&#xA;except requests.exceptions.HTTPError as err:&#xA;    raise SystemExit(err)&#xA;&#xA;r.status_code&#xA;</code></pre>&#xA;",15070751,,,,2021-01-24 16:48:24,"",,0,0,0,2021-01-24 16:48:24
65876013,2,,65873962,0,,"<p>In GraphQL, every field must resolve to concrete data (like <code>Int</code>, <code>Float</code>, <code>String</code>, etc.). The error is pretty straightforward; you need to select fields on <code>xxx</code>:</p>&#xA;<pre><code>query {&#xA;  allUsers {&#xA;    edges {&#xA;      node {&#xA;        xxx {&#xA;          other&#xA;          fields&#xA;          needed&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6126373,,,,2021-01-24 21:10:33,"",,0,0,0,2021-01-24 21:10:33
65877381,2,,65861041,17,,"<p>As it turns out, there is no built-in <code>filter</code> function defined on lists/arrays! <em>GraphQL (query language) is basically about selecting <strong>fields</strong> on <strong>objects</strong></em> <a href=""https://graphql.org/learn/schema/"" rel=""noreferrer"">[Schemas and Types | GraphQL]</a>.</p>&#xA;<p>One only needs to look at the <a href=""http://countries.trevorblades.com/"" rel=""noreferrer"">GraphQL schema in question</a>:</p>&#xA;<pre><code>type Query {&#xA;  continents(filter: ContinentFilterInput): [Continent!]!&#xA;  // ...&#xA;}&#xA;type Continent {&#xA;  code: ID!&#xA;  name: String!&#xA;  countries: [Country!]!&#xA;}&#xA;input ContinentFilterInput {&#xA;  code: StringQueryOperatorInput&#xA;}&#xA;input StringQueryOperatorInput {&#xA;  eq: String&#xA;  ne: String&#xA;  in: [String]&#xA;  nin: [String]&#xA;  regex: String&#xA;  glob: String&#xA;}&#xA;// ...&#xA;</code></pre>&#xA;<p>We see that query <code>continents</code> has a parameter <code>filter</code> of input type <code>ContinentFilterInput</code>. That's enough information for us to start building our filter query:</p>&#xA;<pre><code>query {&#xA;  continents(filter: ...) {&#xA;    code&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Upon inspecting <code>ContinentFilterInput</code>, we observe that it has a single field <code>code</code> of input type <code>StringQueryOperatorInput</code>:</p>&#xA;<pre><code>query {&#xA;  continents(filter: { code: ...}) {&#xA;    code&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Finally, we find a field <code>eq</code> inside input type <code>StringQueryOperatorInput</code> which is a scalar type (<code>String</code>) and we are done:</p>&#xA;<pre><code>query {&#xA;  continents(filter: { code: { eq: &quot;AF&quot; } }) {&#xA;    code&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",6367213,,,,2021-01-25 00:10:49,"",,0,0,0,2021-01-25 00:10:49
65897294,2,,65834157,1,,"<p><code>ResolverFilterData</code> contains payload, args, context and info. So you can access that by <code> filter: ({ context }) =&gt; { ... }</code>.</p>&#xA;",5472617,,,,2021-01-26 07:25:26,"",,0,1,0,2021-01-26 07:25:26
65904893,1,65905063,,-1,235,"<p>I'm trying to pass some variables into my gql string but can't seem to get it to work. When passing in the data manually the query works.</p>&#xA;<pre><code>  const UPDATE_WEATHER = gql`&#xA;  {&#xA;    weatherByLocation(&#xA;      latitude: &quot;51.8917473&quot;&#xA;      longitude: &quot;-2.0877334999999997&quot;&#xA;    ) {&#xA;      currently {&#xA;        summary&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const WeatherInfo = ({ lat, long }) =&gt; {&#xA;  const { loading, error, data } = useQuery(UPDATE_WEATHER, {&#xA;    variables: { lat, long },&#xA;  });&#xA;&#xA;  if (loading) return null;&#xA;  if (error) return `Error! ${error}`;&#xA;&#xA;  return &lt;h1&gt;{data.weatherByLocation[0].currently.summary}&lt;/h1&gt;;&#xA;};&#xA;</code></pre>&#xA;<p>I've tried following the guide <a href=""https://www.apollographql.com/docs/react/data/queries/#caching-query-results"" rel=""nofollow noreferrer"">here</a> but with no success. Here is my updated gql with the variables</p>&#xA;<pre><code>const UPDATE_WEATHER = gql`&#xA;  query weatherByLocation($lat: String!, $long: String!) {&#xA;    weatherByLocation(latitude: $lat, longitude: $long) {&#xA;      currently {&#xA;        summary&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>However this results in a 400 bad request. Here is the request payload</p>&#xA;<pre><code>operationName: &quot;weatherByLocation&quot;&#xA;query: &quot;query weatherByLocation($lat: String!, $long: String!) {↵  weatherByLocation(latitude: $lat, longitude: $long) {↵    currently {↵      summary↵      __typename↵    }↵    __typename↵  }↵}↵&quot;&#xA;variables: {lat: 51.891751299999996, long: -2.0877779}&#xA;</code></pre>&#xA;",2836739,,,,2021-01-26 16:19:05,400 Bad request when passing in variables in gql (Apollo client),<reactjs><graphql><apollo-client>,1,1,0,2021-01-26 16:08:48
65918579,1,,,1,127,"<p>I'm learning Relay to use in a React-Relay project. After my research and learning on the internet, I've run into problems with my graphql schema and resolvers. I can't seem to figure out what resolvers do I need and how go about it correctly. If someone can point me in the right direction, that would be great. I have attached my code below. All I'm trying to do is fetch elements of a list using the relay graphql server specification.</p>&#xA;<p>Graphql Schema</p>&#xA;<pre><code>interface Node {&#xA;    id: ID!&#xA;}&#xA;&#xA;type Link implements Node {&#xA;    id: ID!&#xA;    title: String!&#xA;    description: String!&#xA;}&#xA;&#xA;type LinkConnection {&#xA;    edges: [LinkEdge]&#xA;    pageInfo: PageInfo!&#xA;}&#xA;&#xA;type LinkEdge {&#xA;    cursor: String!&#xA;    node: Link&#xA;}&#xA;&#xA;type Query {&#xA;    links(after: String, before: String, first: Int, last: Int): LinkConnection&#xA;    node(id: ID!): Node&#xA;}&#xA;&#xA;type PageInfo {&#xA;  hasNextPage: Boolean!&#xA;  hasPreviousPage: Boolean!&#xA;  startCursor: String&#xA;  endCursor: String&#xA;}&#xA;</code></pre>&#xA;<p>Resolvers</p>&#xA;<pre><code>const resolvers = {&#xA;    Query,&#xA;    Node: {&#xA;        __resolveType(node, context, info){&#xA;            if(node.title){&#xA;                return 'Link'&#xA;            }&#xA;            return null&#xA;        }&#xA;    },&#xA;}&#xA;&#xA;&#xA;</code></pre>&#xA;<p>Query Resolver</p>&#xA;<pre><code>const node = async (parent, args, {prisma}) =&gt; {&#xA;    try{&#xA;        console.log('hit')&#xA;        const data = await prisma.link.findUnique({&#xA;            where: {&#xA;                id: Number(args.id)&#xA;            }&#xA;        })&#xA;        console.log(data)&#xA;        return data&#xA;    } catch(err){&#xA;        return err&#xA;    }&#xA;}&#xA;&#xA;export default {&#xA;    node,&#xA;}&#xA;</code></pre>&#xA;<p>P.S. Im using Apollo Server and Prisma under the hood</p>&#xA;<p>Edit:</p>&#xA;<p>I solved this issue by realizing that the resolves are invoked in the same order the schema is nested. So by writing separate resolvers for each type and passing the information in parent argument, things worked.</p>&#xA;",14487075,,14487075,2021-01-27 15:46:40,2021-01-27 15:46:40,Cannot fetch data in Graphql Relay,<javascript><graphql><apollo-server><relay>,0,0,0,2021-01-27 11:51:30
65923461,1,65923794,,-1,431,"<p>Very much appreciated for reading this one! It might seem like easy for you, but I am quite new, so bear with me. I have a query in GraphQL which gives me the following results:</p>&#xA;<pre><code>  &quot;data&quot;: {&#xA;&quot;completeglobaldata&quot;: [&#xA;      {&#xA;        &quot;increasehotdays&quot;: 43,&#xA;        &quot;countryname&quot;: &quot;Afghanistan&quot;&#xA;      },&#xA;      {&#xA;        &quot;increasehotdays&quot;: 66.1,&#xA;        &quot;countryname&quot;: &quot;Angola&quot;&#xA;      },&#xA;      {&#xA;        &quot;increasehotdays&quot;: 0,&#xA;        &quot;countryname&quot;: &quot;Anguilla&quot;&#xA;      },&#xA;      {&#xA;        &quot;increasehotdays&quot;: 0,&#xA;        &quot;countryname&quot;: &quot;Åland Islands&quot;&#xA;      },&#xA;      {&#xA;        &quot;increasehotdays&quot;: 51.9,&#xA;        &quot;countryname&quot;: &quot;Albania&quot;&#xA;      },&#xA;]&#xA;}&#xA;</code></pre>&#xA;<p>Yet, now I want to sort the data in a descending way with JavaScript sort. The problem is that GraphQL will return objects and I do not understand how this would work.. I have been stuck on <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"" rel=""nofollow noreferrer"">the array/sort </a>page for some good hours now.</p>&#xA;<pre><code>export const sortDescendingHotDays = (completeglobaldata) =&gt; {&#xA;  const countryTemperatures = completeglobaldata.map((country) =&gt; ({&#xA;    ...completeglobaldata,&#xA;  }));&#xA;&#xA;  return completeglobaldata.sort((a, b) =&gt;&#xA;    a.country.increasehotdays &lt; b.country.increasehotdays ? 1 : -1&#xA;  );&#xA;};&#xA;&#xA;&#xA;</code></pre>&#xA;<p>This is obviously wrong, but it shows how lost I am. Oh, I am using React by the way. Ofcourse I could easily change the graphQL query to :</p>&#xA;<pre><code>query MyQuery {&#xA;  completeglobaldata(order_by: {increasehotdays: desc}) {&#xA;    increasehotdays&#xA;    countryname&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But this is not possible in my situation.I really need to get the data and then sort it using Javascript sort</p>&#xA;<p>Thank you for your help :)</p>&#xA;",15037366,,15037366,2021-01-27 16:44:03,2021-01-27 17:43:02,Sorting graphQL data in JavaScript,<javascript><arrays><reactjs><sorting><graphql>,2,5,0,2021-01-27 16:38:36
65923794,2,,65923461,0,,"<p>You were close!   There isn’t a country key on your individual objects, and when you’re using sort, you’re already comparing two different country objects.</p>&#xA;<pre><code>completeglobaldata.sort((a,b) =&gt; b.increasehotdays - a.increasehotdays)&#xA;</code></pre>&#xA;",11080357,,11080357,2021-01-27 17:43:02,2021-01-27 17:43:02,"",,0,9,0,2021-01-27 16:57:45
65997949,2,,64990519,2,,"<p>Was looking for a solution to the same general issue, came across your post, but then solved my issue.  My issue was a little unrelated, I was trying to sort on a non-scalar field.  In your case, you're receiving that error by trying to make a key out of a non-scalar entity.  Remove that @key from ShoppingList and you should clear your error, but let's talk through what I believe you're trying to achieve.</p>&#xA;<p>I assume you're trying to make a 1:Many relationship between ShoppingList and Products.</p>&#xA;<p>In your ShoppingList code, you have Products as a single entity but likely meant to have an array of Products:</p>&#xA;<pre><code>UPC: [Products]&#xA;</code></pre>&#xA;<p>From there you need to define your connection between UPC and Products.  You correctly called out the use of @connection, but didn't create the connection. To create the connection in a 1:Many relationship, you're going to want 1 ShoppingList and many Products.  To achieve this, you likely want the following:</p>&#xA;<pre><code>type ShoppingList @model {&#xA;    id: ID! #make sure you're specifying a PK for each object&#xA;    UPC: [Products] @connection(keyName: &quot;relatedShoppingList&quot; fields: [&quot;id&quot;])&#xA;    quantity: Int&#xA;    timestamp: Int&#xA;}&#xA;&#xA;type Products @model {&#xA;    id: ID!&#xA;    parentShoppingList: ShoppingList @connection(fields: &quot;relatedShoppingList&quot;)&#xA;    UPC: String!&#xA;    Description: String&#xA;    Name: String&#xA;    Price: Float&#xA;    ProductId: String&#xA;    combinedSearchKey: String&#xA;    Img_URL: String&#xA;    LongDescription: String&#xA;    UserForRecommendations: Boolean&#xA;    Hidden: Boolean&#xA;    TrainingImageWidthInches: Float&#xA;}&#xA;</code></pre>&#xA;<p>I foresee some additional issues with your data setup, but this should unblock your 1:many relationship between products and shopping lists.</p>&#xA;",11539976,,11539976,2021-02-02 15:51:14,2021-02-02 15:51:14,"",,0,0,0,2021-02-01 18:11:21
66011880,1,,,2,102,"<p>Thank you for help. I am trying to execute AND/OR operator in GraphQL without Database.</p>&#xA;<p>Below is Query need to execute on dataset not database. Please understand, I don't have authority to connect to any database.</p>&#xA;<pre><code>    {&#xA;    customVisualsData(_filter: {and: [{expression: {field: &quot;Country&quot;, like: &quot;Canada&quot;}},{expression: {field: &quot;Profit&quot;, gt: &quot;5000&quot;}}]}) {&#xA;    Country&#xA;    DiscountBand&#xA;    Product&#xA;    Segment&#xA;    Profit&#xA;    }&#xA;    }&#xA;</code></pre>&#xA;<p>Transform dataset/JSON Object look like this.</p>&#xA;<pre><code>   &#xA;    [&#xA;    &#xA;     {&#xA;    &quot;Country&quot;: &quot;Canada&quot;,&#xA;    &quot;DiscountBand&quot;: &quot;High&quot;,&#xA;    &quot;Product&quot;: &quot;Paseo&quot;,&#xA;    &quot;Segment&quot;: &quot;Government&quot;,&#xA;    &quot;COGS&quot;: 1477815,&#xA;    &quot;GrossSales&quot;: 2029256,&#xA;    &quot;ManufacturingPrice&quot;: 70,&#xA;    &quot;UnitsSold&quot;: 12230.5,&#xA;    &quot;Profit&quot;: 300289.99999999994&#xA;     },&#xA;     {&#xA;    &quot;Country&quot;: &quot;United States of America&quot;,&#xA;    &quot;DiscountBand&quot;: &quot;High&quot;,&#xA;    &quot;Product&quot;: &quot;VTT&quot;,&#xA;    &quot;Segment&quot;: &quot;Small Business&quot;,&#xA;    &quot;COGS&quot;: 1461250,&#xA;    &quot;GrossSales&quot;: 1753500,&#xA;    &quot;ManufacturingPrice&quot;: 750,&#xA;    &quot;UnitsSold&quot;: 5845,&#xA;    &quot;Profit&quot;: 74288&#xA;     }&#xA;    &#xA;    ]&#xA;&#xA;</code></pre>&#xA;<p>Schema Builder, I used to create GraphQL Query builder.</p>&#xA;<pre><code>var schema = buildSchema(`&#xA;        type customVisualObject {&#xA;            Country: String&#xA;            DiscountBand: String&#xA;            Product: String&#xA;            Segment: String&#xA;            COGS: Float&#xA;            GrossSales: Float&#xA;            ManufacturingPrice: Int&#xA;            UnitsSold: Float&#xA;            Profit: Float&#xA;        } &#xA;        type Query {&#xA;            customVisualsData(_filter: FilterInput): [customVisualObject]&#xA;        }&#xA;        input FilterExpressionInput {&#xA;            field: String!&#xA;            eq: String&#xA;            gt: String&#xA;            gte: String&#xA;            like: String&#xA;        }&#xA;        input FilterInput {&#xA;            expression: FilterExpressionInput&#xA;            and: [FilterInput!]&#xA;            or: [FilterInput]&#xA;            not: [FilterInput!]&#xA;        }&#xA;`);&#xA;</code></pre>&#xA;<p>Please let me know, if anyone know How to set resolver for this on graphQL?&#xA;Does anyone one know JSON-ata Or GraphQL library to execute such complex Query on JSON Object Not databse?&#xA;I appreciate your help.</p>&#xA;",14566753,,,,2021-02-02 14:39:13,Execute Logical Operator Filters On GraphQL OnlyOn JSON Objects,<graphql-js><prisma-graphql><powerbi-custom-visuals><jsonata>,0,0,0,2021-02-02 14:39:13
66024509,2,,63567457,0,,"<p>i was exactly in the same spot last week. My solution was to create the filters that I knew were included in the category as an ACF list. The problem is that you have to type all the filters you want for every category but it solves the problem of querying thousands of products when you only need 12. It looks something like that <a href=""https://i.stack.imgur.com/FKBu4.png"" rel=""nofollow noreferrer"">wordpress-category-view</a></p>&#xA;",12238329,,,,2021-02-03 09:21:28,"",,0,0,0,2021-02-03 09:21:28
66442437,1,66444604,,0,67,"<p>I'm making an app for birdwatchers. When birdwatches see a bird, they record a <code>sighting</code>. I have a query for a feed of all birdwatchers sightings:</p>&#xA;<pre><code>import { gql } from &quot;@apollo/client&quot;;&#xA;&#xA;export const GET_SIGHTINGS = gql`&#xA;  query Sightings($first: Int, $after: String) {&#xA;    sightings(first: $first, after: $after) {&#xA;      pageInfo {&#xA;        endCursor&#xA;      }&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        location&#xA;        note&#xA;        seenAt&#xA;        mapImage&#xA;        images {&#xA;          id&#xA;          url&#xA;        }&#xA;        user {&#xA;          id&#xA;          name&#xA;          emoji&#xA;        }&#xA;        bird {&#xA;          id&#xA;          commonName&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;<p>and this works great. Now i want to have a seperate feed for an individual birdwatchers sightings. (this query is working fine on the server):</p>&#xA;<pre><code>import { gql } from &quot;@apollo/client&quot;;&#xA;&#xA;export const MY_SIGHTINGS = gql`&#xA;  query MySightings($first: Int, $after: String, $userId: ID) {&#xA;    mySightings: sightings(first: $first, after: $after, userId: $userId) @connection(key: &quot;sightings&quot;, filter: [&quot;userId&quot;]) {&#xA;      pageInfo {&#xA;        endCursor&#xA;      }&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          location&#xA;          note&#xA;          seenAt&#xA;          mapImage&#xA;          images {&#xA;            id&#xA;            url&#xA;          }&#xA;          user {&#xA;            id&#xA;            name&#xA;            emoji&#xA;          }&#xA;          bird {&#xA;            id&#xA;            commonName&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>This works fine the first time the filtered query was run, however once the main feed component is rendered, the individual feed is now full of everyones sightings. How do I get the cache to descriminate between the two queries? The <code>@connection</code> directive sounded like it would be the trick but apparently not</p>&#xA;",702072,,,,2021-03-03 15:22:24,Apollo Client and filtered queries,<javascript><graphql><apollo><apollo-client>,1,1,0,2021-03-02 15:38:37
66459791,2,,65824594,0,,"<p>To follow on from the accepted answer-</p>&#xA;<p>Passing a hardcoded path did not work for me.</p>&#xA;<p>Instead , just use a glob pattern.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>loadFilesSync('**/*.gql')&#xA;&#xA;</code></pre>&#xA;<p>The linked example uses <code>graphql-let</code> config which is essentially resolving to a glob pattern similar to this.</p>&#xA;",5645292,,,,2021-03-03 15:11:58,"",,0,0,0,2021-03-03 15:11:58
66489280,2,,47454158,0,,<p>In graphCMS we can use keyword &quot;where&quot;.&#xA;I don't know if this feature is available in the standard API.</p>&#xA;<pre><code>query Sports {&#xA;   sports(where: {events_some: {}}) {&#xA;      name&#xA;      events {&#xA;         name&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;,15335299,,15335299,2021-03-10 08:22:47,2021-03-10 08:22:47,"",,0,1,0,2021-03-05 08:38:49
66496099,1,,,-2,150,<p>Couldn't find anything related to GraphQL fragments in the TypGraphQL docs. Am I missing something or is it not possible to do so.</p>&#xA;,10173616,,,,2021-03-10 08:32:04,Is there a way to define a GraphQL fragment using TypeGraphQL?,<graphql><typegraphql><graphql-fragments>,1,1,0,2021-03-05 16:25:00
66498904,2,,66355641,0,,"<p>I think I found what I was looking for: a <strong>Custom Scalar</strong>:<br />&#xA;<a href=""https://www.apollographql.com/docs/apollo-server/schema/custom-scalars/"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/apollo-server/schema/custom-scalars/</a></p>&#xA;<p>Example:</p>&#xA;<pre><code>scalar Cursor&#xA;type Query {&#xA;  getStrings(count: Int, cursor: Cursor): Result!&#xA;}&#xA;type Result {&#xA;  strings: [String]!&#xA;  nextCursor: Cursor&#xA;}&#xA;</code></pre>&#xA;<p>The custom Scalar type can be anything -- the consumer doesn’t need to know. The server decides how to handle the value (serialize, deserialize, etc).</p>&#xA;",272072,,,,2021-03-05 19:59:58,"",,0,4,0,2021-03-05 19:59:58
66506745,1,66546499,,0,188,"<p>I am building an API using GraphQL and one of the options of the API is to place an order</p>&#xA;<p>I am using Go 1.16 with <a href=""https://github.com/graphql-go/graphql"" rel=""nofollow noreferrer"">graphql-go</a> as the GraphQL backend</p>&#xA;<p>The JSON format for the PlaceOrder API call is:</p>&#xA;<pre><code>{&#xA;   &quot;order_reference&quot;:&quot;unique order reference&quot;,&#xA;   &quot;customer_order_reference&quot;:&quot;customer order reference&quot;,&#xA;   &quot;email_address&quot;:&quot;email@example.com&quot;,&#xA;   &quot;phone_number&quot;:&quot;0123456789&quot;,&#xA;   &quot;billing_address&quot;:{&#xA;      &quot;name&quot;:&quot;Billing name&quot;,&#xA;      &quot;address_line_one&quot;:&quot;Billing line one&quot;,&#xA;      &quot;address_line_two&quot;:&quot;Billing line two&quot;,&#xA;      &quot;address_line_three&quot;:&quot;Billing line three&quot;,&#xA;      &quot;address_line_four&quot;:&quot;Billing line four&quot;,&#xA;      &quot;postcode&quot;:&quot;billing postcode&quot;&#xA;   },&#xA;   &quot;delivery_address&quot;:{&#xA;      &quot;name&quot;:&quot;Delivery name&quot;,&#xA;      &quot;address_line_one&quot;:&quot;Delivery line one&quot;,&#xA;      &quot;address_line_two&quot;:&quot;Delivery line two&quot;,&#xA;      &quot;address_line_three&quot;:&quot;Delivery line three&quot;,&#xA;      &quot;address_line_four&quot;:&quot;Delivery line four&quot;,&#xA;      &quot;postcode&quot;:&quot;Delivery postcode&quot;&#xA;   },&#xA;   &quot;order_lines&quot;:[&#xA;      {&#xA;         &quot;product_code&quot;:&quot;123456&quot;,&#xA;         &quot;quantity&quot;:1&#xA;      },&#xA;      {&#xA;         &quot;product_code&quot;:&quot;654321&quot;,&#xA;         &quot;quantity&quot;:2&#xA;      }&#xA;   ]&#xA;}&#xA;</code></pre>&#xA;<p>In the Go code I have the Schema fields setup as:</p>&#xA;<pre><code>graphql.Fields{&#xA;        &quot;placeOrder&quot;: &amp;graphql.Field{&#xA;            Type: order.PlaceOrder(),&#xA;            Args: graphql.FieldConfigArgument{&#xA;                &quot;order_reference&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.String,&#xA;                },&#xA;                &quot;customer_order_reference&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.String,&#xA;                },&#xA;                &quot;email_address&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.String,&#xA;                },&#xA;                &quot;phone_number&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.String,&#xA;                },&#xA;                &quot;billing_address&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.NewObject(&#xA;                        graphql.ObjectConfig{&#xA;                            Name: &quot;BillingAddress&quot;,&#xA;                            Fields: graphql.Fields{&#xA;                                &quot;name&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_one&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_two&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_three&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_four&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;postcode&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                            },&#xA;                        },&#xA;                    ),&#xA;                },&#xA;                &quot;delivery_address&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.NewObject(&#xA;                        graphql.ObjectConfig{&#xA;                            Name: &quot;DeliveryAddress&quot;,&#xA;                            Fields: graphql.Fields{&#xA;                                &quot;name&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_one&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_two&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_three&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;address_line_four&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;postcode&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                            },&#xA;                        },&#xA;                    ),&#xA;                },&#xA;                &quot;order_lines&quot;: &amp;graphql.ArgumentConfig{&#xA;                    Type: graphql.NewList(graphql.NewObject(&#xA;                        graphql.ObjectConfig{&#xA;                            Name: &quot;Line&quot;,&#xA;                            Fields: graphql.Fields{&#xA;                                &quot;part_number&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                                &quot;quantity&quot;: &amp;graphql.Field{&#xA;                                    Type: graphql.String,&#xA;                                },&#xA;                            },&#xA;                        },&#xA;                    )),&#xA;                },&#xA;            },&#xA;            Resolve: func(p graphql.ResolveParams) (interface{}, error) {&#xA;                // Code to interact with Database and assign value to status, reference depending on result of database INSERT and return as &quot;response&quot;&#xA;                return response, nil&#xA;            },&#xA;        },&#xA;    }&#xA;</code></pre>&#xA;<p>I have tried a few different ways of passing data to the addresses and order lines but don't seem to be able to get them passed through successfully: For example I tried the below and the map[] is the result of <code>fmt.Printf(&quot;%+v\n&quot;, p.Args)</code></p>&#xA;<p>query:</p>&#xA;<pre><code>{&#xA;    placeOrder(&#xA;        order_reference:&quot;order reference&quot;&#xA;        customer_order_reference: &quot;cust order reference&quot;&#xA;        billing_address: {&#xA;           name: &quot;Billing Name&quot;&#xA;           address_line_one: &quot;Address line one&quot;&#xA;           address_line_two: &quot;Address line one&quot;&#xA;           address_line_three: &quot;Address line one&quot;&#xA;           address_line_four: &quot;Address line one&quot;&#xA;           postcode: &quot;Post code&quot;&#xA;        }&#xA;        delivery_address: {&#xA;           name: &quot;Delivery Name&quot;&#xA;           address_line_one: &quot;Address line one&quot;&#xA;           address_line_two: &quot;Address line one&quot;&#xA;           address_line_three: &quot;Address line one&quot;&#xA;           address_line_four: &quot;Address line one&quot;&#xA;           postcode: &quot;Post code&quot;&#xA;        }&#xA;        order_lines: [&#xA;            {&#xA;                part_number: &quot;123456&quot;&#xA;                quantity: 1&#xA;            }&#xA;        ]&#xA;        ){&#xA;            status,&#xA;            reference&#xA;        }&#xA;}&#xA;</code></pre>&#xA;<p>result:</p>&#xA;<pre><code>map[&#xA;customer_order_reference:cust order reference&#xA;order_lines:[&lt;nil&gt;]&#xA;order_reference:order reference&#xA;]&#xA;</code></pre>&#xA;",9174921,,13302,2021-03-06 15:04:46,2021-03-09 12:01:14,GraphQL - Use Object as argument,<graphql><graphql-go>,1,2,0,2021-03-06 14:28:06
66509873,1,70299311,,1,709,"<p>I'm using DjangoFilterConnectionField with a django-graphene and django-filter. and I'd like to know if it's possible to get all the records via a query?</p>&#xA;<p>Consider the following code:</p>&#xA;<pre><code>class Query(graphene.AbstractType):&#xA;    txt = graphene.Field(LocalizedTxtType)&#xA;    all_txts = DjangoFilterConnectionField(LocalizedLocalizedTxtType)&#xA;</code></pre>&#xA;<p>How can I get all records with no filter (i.e. allTxts) ?&#xA;Do I need to add a resolve_all myself , or does DjangoFilterConnectionField provide a way to query for all records?</p>&#xA;",1059549,,3702377,2021-03-14 11:42:12,2021-12-10 03:11:36,DjangoFilterConnectionField query for all records,<django><graphql><django-filter><graphene-python><graphene-django>,2,0,0,2021-03-06 19:35:01
66531291,1,,,3,187,<p>would like to declare a default binary value in the resulting sql migration file.</p>&#xA;<p>I have tried using <code>@default(dbgenerated(“UUID_TO_BIN(uuid())”)</code> but the expression does not get implemented in the resulting SQL file.</p>&#xA;,13482737,,,,2022-11-25 10:17:45,How do you declare a database default in prisma using @default and degenerated()?,<javascript><mysql><node.js><prisma-graphql><prisma2>,1,1,0,2021-03-08 14:05:25
66547129,2,,66535520,0,,"<p>Passing this [page queried] data to root provider doesn't make a sense [neither in gatsby nor in apollo] - data duplication, not required in all pages/etc.</p>&#xA;<p>... this data is <strong>fetched at build time</strong> then no need to check length/loading/etc</p>&#xA;<p>... you can render provider in page component to pass data to child components using context (without props drilling).</p>&#xA;",6124657,,,,2021-03-09 12:44:07,"",,0,9,0,2021-03-09 12:44:07
66549213,1,,,1,114,"<p>I'm new to Relay and trying to follow along with the docs. In the below fragment, it seems they are querying on a user and then getting the users friends. I presume the same model is being used for the queried user and their friends.</p>&#xA;<pre><code>fragment FriendsListComponent_user on User&#xA;@refetchable(queryName: &quot;FriendsListPaginationQuery&quot;) {&#xA;    name&#xA;    friends(first: $count, after: $cursor)&#xA;    @connection(key: &quot;FriendsList_user_friends&quot;) {&#xA;        edges {&#xA;            node {&#xA;                name&#xA;                age&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>However, I can't figure out how to create this connection in my Graphene schema.&#xA;I have this simple user class:</p>&#xA;<pre><code>class UserNode(graphene.ObjectType):&#xA;    class Meta:&#xA;        interfaces = (relay.Node, )&#xA;&#xA;    name = graphene.String()&#xA;    friends = relay.ConnectionField(FriendConnection)&#xA;</code></pre>&#xA;<p>and this connection:</p>&#xA;<pre><code>class FriendConnection(relay.Connection):&#xA;    class Meta:&#xA;        node = UserNode&#xA;</code></pre>&#xA;<p>but none of them can go before the other!</p>&#xA;<p>Am I missing something here? How would I define such a connection, if it's even possible?</p>&#xA;",13549008,,,,2021-03-09 14:52:57,How to connect node to itself using Relay Connection (Graphene Python)?,<python><graphql><relay><graphene-python>,0,0,0,2021-03-09 14:52:57
66580023,2,,47367601,6,,<p>Remove the curly brackets.</p>&#xA;<p>Instead of:</p>&#xA;<pre><code>import { gql } from 'graphql-tag';&#xA;</code></pre>&#xA;<p>Do</p>&#xA;<pre><code>import gql from 'graphql-tag';&#xA;</code></pre>&#xA;,6683217,,,,2021-03-11 09:47:21,"",,0,0,0,2021-03-11 09:47:21
66581373,1,66581479,,0,223,"<p>I have the following query and i would like it to return the items with a specific parent name</p>&#xA;<pre><code>query categorias ($name: String) {&#xA;  categories(level: 1, first: 13 ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        level&#xA;        parent {&#xA;          name: $name&#xA;        }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Can't quite understand how to make this work. I've tried the following as well but &quot;it's not a valid argument&quot;</p>&#xA;<pre><code>    query categorias ($name: String) {&#xA;      categories(level: 1, first: 13 ) {&#xA;        edges {&#xA;          node {&#xA;            id&#xA;            name&#xA;            level&#xA;            parent (name:$name{&#xA;              name&#xA;            }&#xA;            }&#xA;          }&#xA;        }&#xA;      &#xA;&#xA;}&#xA;</code></pre>&#xA;",13631122,,,,2021-03-11 11:16:56,How to pass variables in Graphql Apollo Query,<reactjs><graphql><apollo-client>,1,0,0,2021-03-11 11:10:40
66581479,2,,66581373,1,,"<p>You need to pass the <code>name</code> variable to the actual query i.e <code>categories</code>.Not sure what the schema is but the basic idea is below. <code>categorias</code> is the name given by you (so that you can use multiple queries) not the actual query. Something like this.</p>&#xA;<pre><code>query categorias ($name: String) {&#xA;  categories(name: $name, level: 1, first: 13 ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;        level&#xA;        parent {&#xA;          name: $name&#xA;        }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;",6483121,,,,2021-03-11 11:16:56,"",,0,0,0,2021-03-11 11:16:56
66590076,1,,,0,559,"<p>Using react 17 and relay-modern 11 I want to build a list, with which, when one reaches the end, they can click a button that says load more and it adds more entries to the list. Here is what I have so far. The rows are name and cursor</p>&#xA;<p><a href=""https://i.stack.imgur.com/IS61W.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IS61W.png"" alt=""enter image description here"" /></a></p>&#xA;<p>see I should click load more and it should add an extra 5 rows of data. This is what happens when I click load more</p>&#xA;<p><a href=""https://i.stack.imgur.com/VQ5lw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VQ5lw.png"" alt=""enter image description here"" /></a></p>&#xA;<p>See it did fetch 5 new nodes. I can tell because the cursors are unique. However it did not append it to the list like I wanted.</p>&#xA;<p>How can I get this list to continue to build all the time as I keep clicking load more, until there is no more data?</p>&#xA;<p>Here is my code:</p>&#xA;<p>the root of the component:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// index.js&#xA;import React, { useState } from &quot;react&quot;;&#xA;import { Text, View } from &quot;react-native&quot;;&#xA;import { QueryRenderer, useRelayEnvironment } from &quot;react-relay&quot;;&#xA;import PaginatedProfilesListContainer from &quot;./PaginatedProfilesListContainer&quot;;&#xA;&#xA;const ProfilesList = () =&gt; {&#xA;  const environment = useRelayEnvironment();&#xA;  const [count, setCount] = useState(5);&#xA;  const [name, setName] = useState(&quot;&quot;);&#xA;&#xA;  const query = graphql`&#xA;    query ProfilesListQuery(&#xA;      $count: Int!&#xA;      $cursor: String&#xA;      $filter: ProfileFilter&#xA;    ) {&#xA;      ...PaginatedProfilesListContainer_list&#xA;    }&#xA;  `;&#xA;&#xA;  const filter = {&#xA;    name,&#xA;  };&#xA;  const variables = {&#xA;    count: 5,&#xA;    cursor: null,&#xA;    filter,&#xA;  };&#xA;&#xA;  const render = ({ error, props, retry }) =&gt; {&#xA;    if (error) {&#xA;      return (&#xA;        &lt;View&gt;&#xA;          &lt;Text&gt;{error.message}&lt;/Text&gt;&#xA;        &lt;/View&gt;&#xA;      );&#xA;    } else if (props) {&#xA;      return (&#xA;        &lt;View&gt;&#xA;          &lt;PaginatedProfilesListContainer&#xA;            pagination={props}&#xA;            count={count}&#xA;            setCount={setCount}&#xA;            name={name}&#xA;            setName={setName}&#xA;            filter={filter}&#xA;          /&gt;&#xA;        &lt;/View&gt;&#xA;      );&#xA;    } else {&#xA;      return (&#xA;        &lt;View&gt;&#xA;          &lt;Text&gt;loading profiles list...&lt;/Text&gt;&#xA;        &lt;/View&gt;&#xA;      );&#xA;    }&#xA;  };&#xA;  console.log(&quot;vriable&quot;, variables)&#xA;&#xA;  return (&#xA;    &lt;QueryRenderer&#xA;      environment={environment}&#xA;      query={query}&#xA;      variables={variables}&#xA;      render={render}&#xA;    /&gt;&#xA;  );&#xA;};&#xA;&#xA;export default ProfilesList;&#xA;</code></pre>&#xA;<p>here is the component that should be listing the object</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// PaginatedProfilesListContainer.js&#xA;import React from &quot;react&quot;;&#xA;import { Text, View } from &quot;react-native&quot;;&#xA;import { Button } from &quot;react-native-paper&quot;;&#xA;import { createPaginationContainer } from &quot;react-relay&quot;;&#xA;import { FadoTextInput } from &quot;../forms/fadoTextInput&quot;;&#xA;&#xA;const PaginatedProfilesListContainer = (props) =&gt; {&#xA;  console.log(props);&#xA;  console.log(&quot;createPaginationContainer&quot;, createPaginationContainer)&#xA;  // console.log(pagination)&#xA;  const { pagination, count, setCount, name, setName, relay, filter } = props;&#xA;  const { hasMore, loadMore, refetchConnection } = relay;&#xA;  console.log(loadMore)&#xA;  const { profiles } = pagination;&#xA;  const { edges, pageInfo } = profiles;&#xA;  return (&#xA;    &lt;View&gt;&#xA;      &lt;View&gt;&#xA;        &lt;FadoTextInput&#xA;          dense={true}&#xA;          isNumeric={true}&#xA;          graphqlErrors={[]}&#xA;          label=&quot;count&quot;&#xA;          errorKey=&quot;count&quot;&#xA;          // savedValue={price.amount}&#xA;          value={count}&#xA;          onChangeText={setCount}&#xA;        /&gt;&#xA;        &lt;FadoTextInput&#xA;          dense={true}&#xA;          isNumeric={false}&#xA;          graphqlErrors={[]}&#xA;          label=&quot;name&quot;&#xA;          errorKey=&quot;name&quot;&#xA;          // savedValue={price.amount}&#xA;          value={name}&#xA;          onChangeText={setName}&#xA;        /&gt;&#xA;      &lt;/View&gt;&#xA;      {edges.map(({ cursor, node: { name } }) =&gt; (&#xA;        &lt;View key={cursor} style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;}}&gt;&#xA;          &lt;Text&gt;{name}&lt;/Text&gt;&#xA;          &lt;Text&gt;{cursor}&lt;/Text&gt;&#xA;        &lt;/View&gt;&#xA;      ))}&#xA;      &lt;Button disabled={!hasMore()} onPress={() =&gt; loadMore(count, (error) =&gt; { error &amp;&amp;  console.log(&quot;error&quot;, error); })}&gt;&#xA;        Load More&#xA;      &lt;/Button&gt;&#xA;    &lt;/View&gt;&#xA;  );&#xA;};&#xA;export default createPaginationContainer(&#xA;  PaginatedProfilesListContainer,&#xA;  {&#xA;    pagination: graphql`&#xA;      fragment PaginatedProfilesListContainer_list on RootQueryType {&#xA;        profiles(first: $count, after: $cursor, filter: $filter)&#xA;          @connection(key: &quot;PaginatedProfilesListContainer_profiles&quot;) {&#xA;          pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;            hasPreviousPage&#xA;            startCursor&#xA;          }&#xA;          edges {&#xA;            cursor&#xA;            node {&#xA;              name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  },&#xA;  {&#xA;    direction: 'forward',&#xA;    query: graphql`&#xA;      query PaginatedProfilesListContainerQuery(&#xA;        $count: Int!&#xA;        $cursor: String&#xA;        $filter: ProfileFilter&#xA;      ) {&#xA;        ...PaginatedProfilesListContainer_list&#xA;      }&#xA;    `,&#xA;    getConnectionFromProps(props) {&#xA;      console.log(props)&#xA;      return props.pagination?.profiles&#xA;    },&#xA;    getFragmentVariables(prevVars, totalCount) {&#xA;      return {&#xA;        ...prevVars,&#xA;        count: totalCount,&#xA;      };&#xA;    },&#xA;    getVariables(props, { count, cursor }, fragmentVariables) {&#xA;      return {&#xA;        count,&#xA;        cursor,&#xA;        filter: {},&#xA;      };&#xA;    },&#xA;  }&#xA;);&#xA;</code></pre>&#xA;<p>I got the inspiration for this approach from <a href=""https://github.com/facebook/relay/issues/1705"" rel=""nofollow noreferrer"">https://github.com/facebook/relay/issues/1705</a></p>&#xA;<p>Note: I tried to use the @stream_connection, but the Elixir Absinthe on the backend doesn't seem tpo support it.</p>&#xA;<p>I know this is long so please any help appreciated :)</p>&#xA;",8896573,,,,2021-03-11 20:27:22,infinite scroll relay modern (v11) using the pagination container and loadMore,<reactjs><graphql><relay><relaymodern><react-relay>,0,5,0,2021-03-11 20:27:22
66595535,2,,66586063,0,,"<p>I did this and it worked (and I pass an array of objects in the $data):</p>&#xA;<pre><code>const CREATE_QUOTE = gql`&#xA;  mutation CREATE_QUOTE(&#xA;    $date: String!&#xA;    $total: Int!&#xA;    $data: [CartItemCreateInput]&#xA;  ) {&#xA;    createQuote(&#xA;      data: { date: $date, total: $total, cartItems: { create: $data } }&#xA;    ) {&#xA;      id&#xA;      date&#xA;      total&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",15376879,,,,2021-03-12 06:56:03,"",,0,0,0,2021-03-12 06:56:03
66609750,1,,,2,167,"<p>In a normal cursor pagination, I would filter and sort the documents based on <code>created</code> field, which is pretty simple. like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// `cursor` is a string&#xA;const books = await this.BooksModel.find({&#xA;    ...(cursor ? { created: { $lt: new Date(cursor) } } : null),&#xA;})&#xA;    .sort({ created: -1 })&#xA;    .limit(first)&#xA;</code></pre>&#xA;<p>Meanwhile when implementing search, I (think I) have to sort and filter the documents based on <code>textScore</code> metadata, which could have a duplicates. To prevent this I need another field to filter, which is <code>_id</code>. I imagine it would be something like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// `cursor` is { id: string, score: number }&#xA;const books = await this.BooksModel.aggregate(&#xA;    [&#xA;        { $match: { _id: { $ne: ObjectId(cursor.id) }, $text: { $search: 'sed' } } },&#xA;        { $project: { title: 1, score: { $meta: 'textScore' } } },&#xA;        { $match: { score: { $lt: cursor.score } } }&#xA;    ]&#xA;)&#xA;</code></pre>&#xA;<p>To achieve the example above, I need the cursor to contain not only the document <code>_id</code> (like a normal pagination) but also the <code>score</code>. I imagine the length of the cursor (decoded) would be very long compared to the normal one. Moreover, the cursor now contains an object instead of just string, which is pretty weird to a noob like me. Is this really the way to build cursor-based search pagination?</p>&#xA;",10930293,,10930293,2021-03-13 03:17:27,2021-03-13 03:17:27,GraphQL MongoDB: Implementing cursor-based $text $search pagination,<mongodb><pagination><graphql><database-cursor>,0,2,0,2021-03-13 03:07:09
66610370,1,,,1,510,"<p>I am new to using Relay and wondering how it is best to structure when a new query is required further down the DOM tree.</p>&#xA;<p>Relay provides a <a href=""https://relay.dev/docs/guided-tour/rendering/queries"" rel=""nofollow noreferrer"">great guide to writing queries</a>, which suggests to have a very limited number of queries and to compose the data you need using fragments. I totally agree with this approach however haven't found a great way of using this flow when different queries are needed at varying levels of the DOM tree.</p>&#xA;<p>For example:</p>&#xA;<ol>&#xA;<li>On the root of the app I query for the user data</li>&#xA;<li>The direct children of the root define which user data they need using fragments</li>&#xA;<li>A child way further down the tree (say 5+ levels deep) needs address information which is available via a different query (eg so that they have state/country options to edit their address)</li>&#xA;</ol>&#xA;<p>I often find situations like the above example in two scenarios:</p>&#xA;<ol>&#xA;<li>There is an interaction that causes it the address data be required (eg they press &quot;edit address&quot;), in this case use the &quot;render-as-you-fetch&quot; pattern to make a new query to fetch the data</li>&#xA;<li>The address information is always going to be required so it should be fetched with the user query</li>&#xA;</ol>&#xA;<p>The first scenario is straight forward as it makes sense to have this as a separate query. However, in the second scenario is where I find I often run into the same two problems:</p>&#xA;<ul>&#xA;<li>Adding the queries to the root query and passing down the data via props quickly becomes unpractical when the DOM tree is deep or complicated.</li>&#xA;<li>Having multiple queries often leads to a waterfall of loaders and additional wait time, this is annoying as this could be avoided by querying all of the data at once.</li>&#xA;</ul>&#xA;<p>Another semi-unrelated situation where I find this comes up is if there is additional queries I need to make in a component that is using a fragment. For example I have a list of items, in the item component I have a fragment defined to declare the data I need for an item, however I also need to get other data via a new query. Ideally it'll be nice to add this additional query to my fragment.</p>&#xA;<p>One solution I occasionally use is to run all of the queries at the root level and feed their data into a context, which I then consume in the apps that need it. While this does work, it doesn't follow the idea of colocation which Relay promotes, I would prefer to see the data next to the component that is uses it.</p>&#xA;<p>Potentially something like this would be better:</p>&#xA;<pre><code>  query UserQuery {&#xA;    getUser(id: &quot;aaa&quot;) {&#xA;      name&#xA;      ...UserProfile_user&#xA;      ...UserAddress_user&#xA;    }&#xA;    ...AddressQuery&#xA;  }&#xA;</code></pre>&#xA;<pre><code>  query AddressQuery {&#xA;    queryAddress {&#xA;      state {&#xA;        id&#xA;        name&#xA;      }&#xA;      country {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Where the <code>AddressQuery</code> would live in the component that is consuming that data. Understanding that this approach would very likely result incasing down the data via props to this child, or use the pattern of passing the data into a context (as mentioned before).</p>&#xA;<p>Am I missing something obvious about combining GraphQL queries? Is there a better way to solve this problem?</p>&#xA;",10141904,,10141904,2021-03-23 04:24:42,2021-03-23 04:24:42,How to combine queries in Relay,<reactjs><graphql><graphql-js><relay>,0,0,0,2021-03-13 05:19:15
66632553,2,,66390137,0,,"<p>This question has answers on <a href=""https://community.prismic.io/t/filtering-out-unfilled-fields-with-gatsby-graphql-gatsby-source-prismic/4323"" rel=""nofollow noreferrer"">prismic community forum</a></p>&#xA;<blockquote>&#xA;<p>Yes, you can use the ne <a href=""https://www.gatsbyjs.com/docs/graphql-reference/#complete-list-of-possible-operators"" rel=""nofollow noreferrer"">operator</a>; to filter the response with <a href=""https://prismic.io/docs/technologies/arguments-filter-sort-limit-skip-gatsby#filter-using-prismic-fields"" rel=""nofollow noreferrer"">Prismic fields</a>.</p>&#xA;</blockquote>&#xA;<p>I'm using <code>allPrismicBlogpost</code> and have a similar query and problem. I think something like this would work for you (changed sort to <a href=""https://prismic.io/docs/technologies/order-your-results-graphql#first-publication-date"" rel=""nofollow noreferrer""><code>first_publication_date</code></a>).</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const query = graphql`&#xA;query AnnouncementCardQuery {&#xA; allPrismicAnnouncement(filter: {data: {quote: {text: {ne: null}}}}, sort: { order: DESC, fields: first_publication_date}) {&#xA;  edges {&#xA;   node {&#xA;   uid&#xA;    id&#xA;     data {&#xA;      quote {&#xA;        text&#xA;       }&#xA;      subtitle1 {&#xA;     text&#xA;     }&#xA;    }&#xA;   }&#xA;  }&#xA; }&#xA;}&#xA;`&#xA;</code></pre>&#xA;",3441106,,,,2021-03-15 04:53:06,"",,0,0,0,2021-03-15 04:53:06
66646818,1,,,0,99,"<p>I have the following defined in my apollo server instance</p>&#xA;<pre><code>input FilterInput {&#xA;  menuOneId: Int!&#xA;  menuTwoId: Int!&#xA;  menuThreeId: Int!&#xA;  menuFourId: Int!&#xA;  menuFiveId: Int!&#xA;  menuSixId: Int!&#xA;  dateFrom: String&#xA;  dateTo: String&#xA;}&#xA;</code></pre>&#xA;<p>and when I query inside apollo playground, like so it works like you would expect</p>&#xA;<pre><code>query getMenuItems($input: FilterInput!) {&#xA;  getMenutems(input: $input) {&#xA;    menuOne&#xA;    menuTwo&#xA;    menuThree&#xA;    menuFour&#xA;    menuFive&#xA;    menuSix&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Query Variables are as such</p>&#xA;<pre><code>{&#xA; &quot;input&quot;: {&#xA;  &quot;menuOneId&quot;: 1,&#xA;  &quot;menuTwoId&quot;: 3,&#xA;  &quot;menuThreeId&quot;: 2,&#xA;  &quot;menuFourId&quot;: 6,&#xA;  &quot;menuFiveId&quot;: 4,&#xA;  &quot;menuSixId&quot;: 5,&#xA;  &quot;dateFrom&quot;: &quot;2020-03-01&quot;,&#xA;  &quot;dateTo&quot;: &quot;2020-03-15&quot;&#xA; }&#xA;}&#xA;</code></pre>&#xA;<p>So my question is how to I mimic this in my front end react application to use on defined set of Filters per all the queries I have setup since the all use the same set of FilterInput items.</p>&#xA;<p>I defined what I thought was correct as follows in my <strong>lib/graphql/queries</strong> file</p>&#xA;<pre><code>export const filter = gql`&#xA;input FilterInput {&#xA;   menuOneId: Int!&#xA;   menuTwoId: Int!&#xA;   menuThreeId: Int!&#xA;   menuFourId: Int!&#xA;   menuFiveId: Int!&#xA;   menuSixId: Int!&#xA;   dateFrom: String&#xA;   dateTo: String&#xA;}&#xA;`;&#xA;</code></pre>&#xA;<p>and then the saved query</p>&#xA;<pre><code>export const getMenuItems = gql`&#xA;   query ($input: filter){ // have also tried FilterInput!&#xA;    getMenuItems(input: $input) {&#xA;        menuOne&#xA;        menuTwo&#xA;        menuThree&#xA;        menuFour&#xA;        menuFive&#xA;        menuSix&#xA;    }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;<p>these are the two different results that were generated when attempting to get this working</p>&#xA;<pre><code>{&#xA;    &quot;variables&quot;: {&#xA;        &quot;menuOneId&quot;: 0,&#xA;        &quot;menuTwoId&quot;: 0,&#xA;        &quot;menuThreeId&quot;: 0,&#xA;        &quot;menuFourId&quot;: 0,&#xA;        &quot;menuFiveId&quot;: 0,&#xA;        &quot;menuSixId&quot;: 0,&#xA;        &quot;dateFrom&quot;: &quot;2020-03-01&quot;,&#xA;        &quot;dateTo&quot;: &quot;2020-03-15&quot;&#xA;    },&#xA;    &quot;query&quot;: &quot;query ($input: FilterInput!) {\n  getMenuItems(input: $input) {\n    MenuOne\n    MenuTwo\n    MenuThree\n    MenuFour\n    MenuFive\n    MenuSix\n }\n}\n&quot;&#xA;}&#xA;- and -&#xA;{&#xA;    &quot;variables&quot;: {&#xA;        &quot;menuOneId&quot;: 0,&#xA;        &quot;menuTwoId&quot;: 0,&#xA;        &quot;menuThreeId&quot;: 0,&#xA;        &quot;menuFourId&quot;: 0,&#xA;        &quot;menuFiveId&quot;: 0,&#xA;        &quot;menuSixId&quot;: 0,&#xA;        &quot;dateFrom&quot;: &quot;2020-03-01&quot;,&#xA;        &quot;dateTo&quot;: &quot;2020-03-15&quot;&#xA;    },&#xA;    &quot;query&quot;: &quot;query ($input: filter) {\n  getMenuItems(input: $input) {\n    MenuOne\n    MenuTwo\n    MenuThree\n    MenuFour\n    MenuFive\n    MenuSix\n }\n}\n&quot;&#xA;}&#xA;</code></pre>&#xA;<p>as opposed two when I run it the normal way like</p>&#xA;<pre><code>{&#xA;    &quot;variables&quot;: {&#xA;        &quot;menuOneId&quot;: 0,&#xA;        &quot;menuTwoId&quot;: 0,&#xA;        &quot;menuThreeId&quot;: 0,&#xA;        &quot;menuFourId&quot;: 0,&#xA;        &quot;menuFiveId&quot;: 0,&#xA;        &quot;menuSixId&quot;: 0,&#xA;        &quot;dateFrom&quot;: &quot;2020-01-01&quot;,&#xA;        &quot;dateTo&quot;: &quot;2020-01-30&quot;&#xA;    },&#xA;    &quot;query&quot;: &quot;query ($menuOneId: Int!, $menuTwoId: Int!, $menuThreeId: Int!, $menuFourId: Int!, $menuFiveId: Int!, $menuSix: Int!, $dateFrom: String!, $dateTo: String!) {\n  getMenuItems(\n    input: {menuOneId: $menuOneId, menuTwoId: $menuTwoId, menuThreeId: $menuThreeId, menuFourId: $menuFourId, menuFiveId: $menuFiveId, menuSixId: $menuSixId, dateFrom: $dateFrom, dateTo: $dateTo}\n  ) {\n    MenuOne\n    MenuTwo\n    MenuThree\n    MenuFour\n    MenuFive\n    MenuSix\n  }\n}\n&quot;&#xA;}&#xA;</code></pre>&#xA;<p>Is it even possible to do it from react using a single defined set of input filters, just can't figure out how to put it all together at this point.</p>&#xA;",1210328,,,,2021-03-15 22:56:59,"use input filter constant pass to all queries graphql, apollo-client, react",<reactjs><graphql><apollo-client><react-apollo><react-gql>,0,2,0,2021-03-15 22:56:59
66677888,2,,66675721,2,,"<p>Contentful DevRel here. </p>&#xA;<p>Currently, that's not possible. But what you can do is flip the query around and filter on the <code>categoryCollection</code> and then use <code>linkedFrom</code> to request the items linking to it.</p>&#xA;<pre><code>query {&#xA;  categoryCollection(where: {&#xA;    key: &quot;fashion&#xA;  }) {&#xA;    items {&#xA;      title&#xA;      linkedFrom {&#xA;        eventCollection {&#xA;          items {&#xA;            slug&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4253183,,,,2021-03-17 17:06:03,"",,0,0,0,2021-03-17 17:06:03
66705991,1,,,2,98,"<p>I want to make it possible to filter on all scalar types of a object type. But I don't want to specificy a input filter for every object type to create filters for the scalar types.</p>&#xA;<p>Currently I have the following code:</p>&#xA;<pre><code>type Product {&#xA;id: Int!&#xA;name: String!&#xA;description: String!&#xA;price: Float!&#xA;weight: Float!&#xA;size: String!&#xA;quantity: Int!&#xA;URL: String&#xA;categories (filter: CategoryFilter): [Category!]&#xA;manufacturers: [Manufacturer!]&#xA;}&#xA;&#xA;input CategoryFilter {&#xA;id: Int&#xA;name: String&#xA;description: String&#xA;}&#xA;&#xA;type Category {&#xA;id: Int!&#xA;name: String!&#xA;description: String&#xA;}&#xA;</code></pre>&#xA;<p>To filter on every field of category. I created a CategoryFilter. But I don't want to create a filter for every object type. I just want to create one filter, that I can apply to all object types to filter on the scalar types of that object type.</p>&#xA;<p>Is this possible?</p>&#xA;",11480465,,,,2021-03-19 09:56:11,GraphQL - using generic filters,<java><graphql>,0,0,0,2021-03-19 09:56:11
66720228,1,,,0,49,"<p>I am building a GraphQL layer on top of an existing REST api. In the schema, I have a key, &quot;steps&quot; that returns an array of differently shaped objects, of which one is an array of objects, like this</p>&#xA;<pre><code> &quot;steps&quot;: [&#xA;       {&#xA;        &quot;created_at&quot;: &quot;a string&quot;,&#xA;        &quot;created_by&quot;: &quot;a string&quot;,&#xA;        &quot;event_name&quot;: &quot;a string&quot;,&#xA;        &quot;reason&quot;: &quot;failed&quot;,&#xA;      &#xA;      },&#xA;      {&#xA;        &quot;components&quot;: [&#xA;          {&#xA;            &quot;condition&quot;: false,&#xA;            &quot;data&quot;: {&#xA;              &quot;address&quot;: &quot;foo&quot;,&#xA;              &quot;address_city&quot;: &quot;bar&quot;,&#xA;              &quot;address_state&quot;: &quot;baz&quot;,&#xA;            &#xA;            },&#xA;        &#xA;          }&#xA;        ],&#xA;</code></pre>&#xA;<p>I am able to get the first object returning, but am struggling with how to type this in order to access the components array, which is coming back as null in the graphQL playground. In my typeDefs, I am typing like this</p>&#xA;<pre><code>  type Steps {&#xA;    event_name: String&#xA;    reason: String&#xA;    created_at: String&#xA;    created_by: String&#xA;    step_date: String&#xA;    step_name: String&#xA;    components: [Components]&#xA;  }&#xA;</code></pre>&#xA;<p>I understand WHY it's failing, as components is nested one extra level in it's own object, but I'm not sure what the fix is, since I can't just use a nested object in the type declaration and the individual objects in the steps array don't have keys.</p>&#xA;<p>Reading around the GraphQL docs, I can't see anything that explains how to type this sort of structure?</p>&#xA;",8952250,,,,2021-03-20 09:57:23,"Apollo Server, typing an array of differently shaped objects",<graphql><apollo><apollo-server>,0,3,0,2021-03-20 09:57:23
66807962,2,,66804363,0,,"<p>what you're asking for is almost impossible if you don't want to change the type definition for <code>Entities</code>.</p>&#xA;<p>This: </p>&#xA;<pre class=""lang-js prettyprint-override""><code>Entity: id: int! name: String&#xA;entities(): [Entity]&#xA;</code></pre>&#xA;<p>returns an array of objects with keys <code>name</code> and <code>id</code>.</p>&#xA;<p>To achieve what you're asking you either change <code>Entity</code> to be just a string or have your client reduce that object to an array of just <code>Entity names</code> when they receive it.</p>&#xA;<p>They could do something like this:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const data = {&#xA;  entities: [&#xA;    {&#xA;      name: 'Name1',&#xA;    },&#xA;    {&#xA;      name: 'Name2',&#xA;    },&#xA;  ],&#xA;};&#xA;&#xA;const entityNames = data.entities.reduce(&#xA;  (acc, curr) =&gt; [...acc, curr.name],&#xA;  []&#xA;);&#xA;&#xA;console.log(entityNames);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",5589405,,,,2021-03-25 21:38:38,"",,0,0,0,2021-03-25 21:38:38
66830662,1,,,0,473,"<p>I using aws amplify and reactjs as front end.</p>&#xA;<pre><code>const [nextToken, setNextToken] = useState(&quot;&quot;);&#xA;&#xA; const fetchData = async () =&gt;{&#xA;    try{&#xA;      // console.log(listPictures);&#xA;      let varjson={}&#xA;      if(page==1){&#xA;        varjson = {limit: perPage}&#xA;      }else{&#xA;        varjson = {limit: perPage, nextToken: nextToken}&#xA;      }&#xA;      const pictureData = await API.graphql(graphqlOperation(listPictures, varjson));&#xA;      console.log('nextToken:', pictureData.data.listPictures.nextToken);&#xA;      setNextToken(pictureData.data.listPictures.nextToken);&#xA;  ....&#xA;</code></pre>&#xA;<p>I find my first page is the same as my second page.&#xA;How to initialize the nextToken, when I list the first page?&#xA;I do not know the nextToken at first.</p>&#xA;",504909,,,,2022-03-31 14:21:57,How to initializate nextToken for first page of pagination?,<graphql><aws-amplify><graphql-js>,1,1,0,2021-03-27 11:12:42
66835066,1,,,-1,473,"<p>I tried to setup successfully graphQL with Laravel 8 using Lighthouse 5.3.0</p>&#xA;<p>I am having issue when I pass auth token in header with graphiQL</p>&#xA;<p>Here is my query schema</p>&#xA;<pre><code>     type Query {&#xA;          user(id: ID! @eq): User  @guard(with: [&quot;api&quot;]) @find&#xA;          users: [User!]!  @paginate(type: &quot;paginator&quot; model: &quot;App\\Models\\User&quot;)&#xA;          product(id: ID! @eq): Product @find&#xA;          all_products: [Product!]! @paginate&#xA;          user_products(user_id: Int! @eq): [Product!]! @paginate&#xA;        }&#xA;</code></pre>&#xA;<p>and running query below</p>&#xA;<pre><code>query fetchUserObj($user_id:ID!){&#xA;  user(id:$user_id){&#xA;      id&#xA;      name&#xA;      email&#xA;  }&#xA;}&#xA;&#xA;{&#xA;  &quot;user_id&quot; : 1&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>with bearer token,</p>&#xA;<pre><code>{&#xA;  &quot;error&quot;: {&#xA;    &quot;message&quot;: &quot;Call to undefined method App\\Models\\User::withAccessToken()&quot;,&#xA;    &quot;exception&quot;: &quot;BadMethodCallException&quot;,&#xA;    &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Support\\Traits\\ForwardsCalls.php&quot;,&#xA;    &quot;line&quot;: 50,&#xA;    &quot;trace&quot;: [&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Support\\Traits\\ForwardsCalls.php&quot;,&#xA;        &quot;line&quot;: 36,&#xA;        &quot;function&quot;: &quot;throwBadMethodCallException&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Database\\Eloquent\\Model&quot;,&#xA;        &quot;type&quot;: &quot;::&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Database\\Eloquent\\Model.php&quot;,&#xA;        &quot;line&quot;: 1890,&#xA;        &quot;function&quot;: &quot;forwardCallTo&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Database\\Eloquent\\Model&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\passport\\src\\Guards\\TokenGuard.php&quot;,&#xA;        &quot;line&quot;: 182,&#xA;        &quot;function&quot;: &quot;__call&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Database\\Eloquent\\Model&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\passport\\src\\Guards\\TokenGuard.php&quot;,&#xA;        &quot;line&quot;: 110,&#xA;        &quot;function&quot;: &quot;authenticateViaBearerToken&quot;,&#xA;        &quot;class&quot;: &quot;Laravel\\Passport\\Guards\\TokenGuard&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\passport\\src\\PassportServiceProvider.php&quot;,&#xA;        &quot;line&quot;: 308,&#xA;        &quot;function&quot;: &quot;user&quot;,&#xA;        &quot;class&quot;: &quot;Laravel\\Passport\\Guards\\TokenGuard&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;function&quot;: &quot;Laravel\\Passport\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Laravel\\Passport\\PassportServiceProvider&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Auth\\RequestGuard.php&quot;,&#xA;        &quot;line&quot;: 58,&#xA;        &quot;function&quot;: &quot;call_user_func&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Auth\\GuardHelpers.php&quot;,&#xA;        &quot;line&quot;: 60,&#xA;        &quot;function&quot;: &quot;user&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Auth\\RequestGuard&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\nuwave\\lighthouse\\src\\Support\\Http\\Middleware\\AttemptAuthentication.php&quot;,&#xA;        &quot;line&quot;: 45,&#xA;        &quot;function&quot;: &quot;check&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Auth\\RequestGuard&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\nuwave\\lighthouse\\src\\Support\\Http\\Middleware\\AttemptAuthentication.php&quot;,&#xA;        &quot;line&quot;: 30,&#xA;        &quot;function&quot;: &quot;attemptAuthentication&quot;,&#xA;        &quot;class&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Middleware\\AttemptAuthentication&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Middleware\\AttemptAuthentication&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\nuwave\\lighthouse\\src\\Support\\Http\\Middleware\\AcceptJson.php&quot;,&#xA;        &quot;line&quot;: 27,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Middleware\\AcceptJson&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 103,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Routing\\Router.php&quot;,&#xA;        &quot;line&quot;: 695,&#xA;        &quot;function&quot;: &quot;then&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Routing\\Router.php&quot;,&#xA;        &quot;line&quot;: 670,&#xA;        &quot;function&quot;: &quot;runRouteWithinStack&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Routing\\Router&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Routing\\Router.php&quot;,&#xA;        &quot;line&quot;: 636,&#xA;        &quot;function&quot;: &quot;runRoute&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Routing\\Router&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Routing\\Router.php&quot;,&#xA;        &quot;line&quot;: 625,&#xA;        &quot;function&quot;: &quot;dispatchToRoute&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Routing\\Router&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Kernel.php&quot;,&#xA;        &quot;line&quot;: 166,&#xA;        &quot;function&quot;: &quot;dispatch&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Routing\\Router&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 128,&#xA;        &quot;function&quot;: &quot;Illuminate\\Foundation\\Http\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest.php&quot;,&#xA;        &quot;line&quot;: 21,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest.php&quot;,&#xA;        &quot;line&quot;: 21,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize.php&quot;,&#xA;        &quot;line&quot;: 27,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance.php&quot;,&#xA;        &quot;line&quot;: 86,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\fruitcake\\laravel-cors\\src\\HandleCors.php&quot;,&#xA;        &quot;line&quot;: 57,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Fruitcake\\Cors\\HandleCors&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\fideloper\\proxy\\src\\TrustProxies.php&quot;,&#xA;        &quot;line&quot;: 57,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 167,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Fideloper\\Proxy\\TrustProxies&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Pipeline\\Pipeline.php&quot;,&#xA;        &quot;line&quot;: 103,&#xA;        &quot;function&quot;: &quot;Illuminate\\Pipeline\\{closure}&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Kernel.php&quot;,&#xA;        &quot;line&quot;: 141,&#xA;        &quot;function&quot;: &quot;then&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Pipeline\\Pipeline&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Http\\Kernel.php&quot;,&#xA;        &quot;line&quot;: 110,&#xA;        &quot;function&quot;: &quot;sendRequestThroughRouter&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\public\\index.php&quot;,&#xA;        &quot;line&quot;: 52,&#xA;        &quot;function&quot;: &quot;handle&quot;,&#xA;        &quot;class&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel&quot;,&#xA;        &quot;type&quot;: &quot;-&gt;&quot;&#xA;      },&#xA;      {&#xA;        &quot;file&quot;: &quot;E:\\wamp\\www\\laravel-graphql\\server.php&quot;,&#xA;        &quot;line&quot;: 21,&#xA;        &quot;function&quot;: &quot;require_once&quot;&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>How can I pass bearer token in request.</p>&#xA;",15495958,,12892553,2021-06-15 02:16:14,2021-06-15 02:16:14,Laravel 8 with Lighthouse 5.3.0 : Having issue with pass auth token in headers,<laravel><graphql><laravel-lighthouse>,1,2,0,2021-03-27 18:59:05
66857612,1,,,2,411,"<p>This query works when I am querying the database directly but when I use python gql, I keep getting this error. I can not find how to stop getting that error anywhere.</p>&#xA;<pre><code>query = f&quot;&quot;&quot;query{{&#xA;   addresses(line1: &quot;{street}&quot;, city: &quot;{city}&quot;, zip: &quot;{zip}&quot;, subdivision: {state}){{&#xA;     entities{{&#xA;       id&#xA;     }}&#xA;   }}&#xA; }}&quot;&quot;&quot;&#xA;&#xA;GraphQL = sonar.execute(query=query, variable_values=None)&#xA;&#xA;Output: TypeError: Not an AST Node: 'query{\n  addresses(line1:............&#xA;</code></pre>&#xA;",13215308,,,,2022-08-09 04:38:27,Python gql TypeError: Not an AST Node:,<python-3.x><graphql><typeerror><gql>,1,2,0,2021-03-29 16:06:35
66858542,2,,66857612,2,,"<p>I didn't wrap the query in <code>gql()</code> the above should look like:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>gql(&#xA;&quot;&quot;&quot;query{{&#xA;   addresses(line1: &quot;{street}&quot;, city: &quot;{city}&quot;, zip: &quot;{zip}&quot;, subdivision: {state}){{&#xA;     entities{{&#xA;       id&#xA;     }}&#xA;   }}&#xA; }}&quot;&quot;&quot;.format(...)&#xA;)&#xA;</code></pre>&#xA;",13215308,,16776498,2022-08-09 04:38:27,2022-08-09 04:38:27,"",,0,2,0,2021-03-29 17:07:10
66862648,1,,,1,840,"<p>I am new to GraphQL and am currently trying to implement it in my nodejs project with mongodb as my database(using mongoose). I have my schema set up as well as resolvers that handle communicating with the database and it is all working fine. Using the graphiql tool I can make queries and mutations and everything is persisting to the database perfectly. I am now trying to implement filtering and sorting to the GraphQL API but I'm getting confused. I understand that I can pass arguments to my queries and then access those in my resolvers and write the logic to put those in my mongodb queries. But I am finding myself having to define an input in my GraphQL schema for every possible filter that can be applied. For example, a portion of my schema allows me to filter products by their price:</p>&#xA;<pre><code>type Product {&#xA;    _id: ID!&#xA;    name: String!&#xA;    price: Float!&#xA;}&#xA;&#xA;input ProductFilterInput {&#xA;    price: IntFilter&#xA;}&#xA;&#xA;input IntFilter {&#xA;    eq: Float&#xA;    gt: Float&#xA;    gte: Float&#xA;    lt: Float&#xA;    lte: Float&#xA;    between: [Float]&#xA;}&#xA;&#xA;type RootQuery {&#xA;    products(filters: ProductFilterInput): [Product]&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Then in my resolver, I have to handle each possible filter argument differently. If the query argument was &quot;{price: {gt: 10}}&quot;, I have to say something like</p>&#xA;<p>&quot;Product.find({price: {$gt: 10}})&quot;.</p>&#xA;<p>Writing a bunch of different checks and logic in the resolver for each possible filter seems crazy to me. When I research this, I can find resources on using arguments to filter the GraphQL queries themselves, but I'm struggling to find documentation on how to write the schemas and resolvers. Maybe I'm overlooking something, but is there a way to write the schemas and resolvers in such a way that I don't have to explicitly define each filter and then again explicitly translate each filter in the resolver? Perhaps a way to write the resolver so I can simply plug the argument into the mongoose &quot;find&quot; method and it understands what I am asking?</p>&#xA;<p>Hopefully that all made sense, if you would like me to try to explain further, I can do my best.</p>&#xA;<p>Thank you to anyone who can help!</p>&#xA;",14727585,,14727585,2021-03-30 00:50:00,2021-03-30 00:50:00,How do I filter queries in GraphQL with mongoose?,<mongodb><mongoose><graphql>,0,2,0,2021-03-29 22:52:57
66872369,1,,,1,177,"<p>I I'm desperately trying to access the connection to update the store through a subscription. I try to follow the v11 doc of Relay <a href=""https://relay.dev/docs/guided-tour/list-data/updating-connections/"" rel=""nofollow noreferrer"">to update Connections</a>. I also specify that I followed the specifications of the relay to mount the server.</p>&#xA;<p>Here is my (simplified) <strong>graphQL schema</strong> :</p>&#xA;<pre><code>type Query {&#xA;  node(&#xA;    id: ID!&#xA;  ): Node&#xA;  viewer: User&#xA;}&#xA;&#xA;type User implements Node {&#xA;  id: ID!&#xA;  email: String&#xA;  searchCompanies(&#xA;    after: String&#xA;    first: Int&#xA;    before: String&#xA;    last: Int&#xA;  ): CompanyConnection&#xA;&#xA;type CompanyConnection {&#xA;  pageInfo: PageInfo!&#xA;  edges: [CompanyEdge]&#xA;}&#xA;&#xA;type CompanyEdge {&#xA;  node: Company&#xA;  cursor: String!&#xA;}&#xA;&#xA;type Company implements Node {&#xA;  id: ID!&#xA;  usageName: String&#xA;  createdAt: String&#xA;}&#xA;</code></pre>&#xA;<p>Here is the component responsible to <strong>make the query</strong> and <strong>update the store with the subscription</strong> :</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import React from 'react';&#xA;import { graphql } from 'babel-plugin-relay/macro';&#xA;import { useQuery } from 'relay-hooks';&#xA;import CompanyTable from './CompanyTable';&#xA;&#xA;import { SearchCompanyQuery } from './__generated__/SearchCompanyQuery.graphql';&#xA;&#xA;import {&#xA;  RecordSourceSelectorProxy,&#xA;  ROOT_ID,&#xA;  ConnectionHandler&#xA;} from 'relay-runtime';&#xA;import { useSubscription } from 'react-relay';&#xA;&#xA;const query = graphql`&#xA;  query SearchCompanyQuery(&#xA;    $count: Int!&#xA;    $cursor: String&#xA;  ) {&#xA;    viewer {&#xA;      id&#xA;      email&#xA;      ...CompanyTable_viewer&#xA;        @arguments(&#xA;          count: $count&#xA;          cursor: $cursor&#xA;        )&#xA;    }&#xA;  }&#xA;`;&#xA;const subscription = graphql`&#xA;  subscription SearchCompanyQuerySubscription {&#xA;    companyInserted {&#xA;      id&#xA;      usageName&#xA;    }&#xA;  }&#xA;`;&#xA;const subscriptionConfig = {&#xA;  variables: {},&#xA;  subscription,&#xA;  onCompleted: () =&gt; console.log('Subscription established.'),&#xA;  onNext: () =&gt; {},&#xA;  onerror: () =&gt; {},&#xA;  updater: (store: RecordSourceSelectorProxy) =&gt; {&#xA;    const rootRecordProxy = store.get(ROOT_ID); // I can access it&#xA;    const viewerRecordProxy = store.getRoot().getLinkedRecord('viewer'); // I can access it too&#xA;&#xA;    const connectionRecordA = ConnectionHandler.getConnection(&#xA;      rootRecordProxy,&#xA;      'CompanyTable_viewer_searchCompanies',&#xA;    );&#xA;&#xA;    const connectionRecordB = ConnectionHandler.getConnection(&#xA;      viewerRecordProxy,&#xA;      'CompanyTable_viewer_searchCompanies',&#xA;    );&#xA;&#xA;    console.log(connectionRecordA) // undefined&#xA;    console.log(connectionRecordB) // undefined&#xA;  }&#xA;};&#xA;&#xA;export default function SearchCompany() {&#xA;  const { data, error } = useQuery&lt;SearchCompanyQuery&gt;(query, {&#xA;    count = 10,&#xA;    cursor: null,&#xA;&#xA;  });&#xA;&#xA;  useSubscription(subscriptionConfig);&#xA;&#xA;  if (!data) {&#xA;    // return something;&#xA;  }&#xA;&#xA;  if (error) {&#xA;    // return something;&#xA;  }&#xA;&#xA;  return &lt;CompanyTable data={data} /&gt;;&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Finally here is my component responsible to <strong>display the data</strong>.</p>&#xA;<pre><code>import {&#xA;  Paper,&#xA;  Table,&#xA;  TableBody,&#xA;  TableCell,&#xA;  TableContainer,&#xA;  TableHead,&#xA;  TableRow,&#xA;  Typography&#xA;} from '@material-ui/core';&#xA;&#xA;import React from 'react';&#xA;import { graphql } from 'babel-plugin-relay/macro';&#xA;import { usePaginationFragment } from 'react-relay';&#xA;&#xA;import CompanyTableRow from './CompanyTableRow';&#xA;&#xA;import {&#xA;  SearchCompanyQuery,&#xA;  SearchCompanyQueryResponse&#xA;} from './__generated__/SearchCompanyQuery.graphql';&#xA;import { CompanyTable_viewer$key } from './__generated__/CompanyTable_viewer.graphql';&#xA;&#xA;type CompanyTableProps = {&#xA;  data: SearchCompanyQueryResponse;&#xA;};&#xA;&#xA;const companyTableSpec = graphql`&#xA;  fragment CompanyTable_viewer on User&#xA;  @argumentDefinitions(&#xA;    count: { type: &quot;Int&quot;, defaultValue: 10 }&#xA;    cursor: { type: &quot;String&quot; }&#xA;  )&#xA;  @refetchable(queryName: &quot;CompanyTablePaginationQuery&quot;) {&#xA;    searchCompanies(&#xA;      after: $cursor&#xA;      first: $count&#xA;    ) @connection(key: &quot;CompanyTable_viewer_searchCompanies&quot;) {&#xA;      edges {&#xA;        node {&#xA;          ...CompanyTableRow_companyTableRow&#xA;        }&#xA;      }&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;        startCursor&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default function CompanyTable({ data }: CompanyTableProps) {&#xA;  const { data: fragmentData, loadNext } = usePaginationFragment&lt;&#xA;    SearchCompanyQuery,&#xA;    CompanyTable_viewer$key&#xA;  &gt;(companyTableSpec, data.viewer);&#xA;&#xA;  return (&#xA;    &lt;TableContainer component={Paper}&gt;&#xA;      &lt;Table aria-label=&quot;simple table&quot;&gt;&#xA;        &lt;TableHead&gt;&#xA;          &lt;TableRow&gt;&#xA;            &lt;TableCell&gt;&#xA;              &lt;Typography&gt;&#xA;                Company Name&#xA;              &lt;/Typography&gt;&#xA;            &lt;/TableCell&gt;&#xA;            &lt;TableCell&gt;&#xA;              &lt;Typography&gt;&#xA;                Created at&#xA;              &lt;/Typography&gt;&#xA;            &lt;/TableCell&gt;&#xA;            &lt;TableCell&gt;&#xA;              &lt;Typography&gt;&#xA;                Action&#xA;              &lt;/Typography&gt;&#xA;          &lt;/TableRow&gt;&#xA;        &lt;/TableHead&gt;&#xA;        &lt;TableBody&gt;&#xA;          {(fragmentData?.searchCompanies?.edges ?? []).map((edge: any) =&gt; (&#xA;            &lt;CompanyTableRow&#xA;              key={edge.node.id}&#xA;              companyTableRow={edge.node}&#xA;            /&gt;&#xA;          ))}&#xA;        &lt;/TableBody&gt;&#xA;      &lt;/Table&gt;&#xA;    &lt;/TableContainer&gt;&#xA;  );&#xA;&#xA;}&#xA;</code></pre>&#xA;",8788732,,8788732,2021-03-30 14:06:12,2021-03-30 14:06:12,Can't update the store via a subscription because ConnectionHandler.getConnection always returns undefined,<node.js><reactjs><graphql><relay><relaymodern>,0,0,0,2021-03-30 13:57:31
66882871,2,,66821643,3,,"<p>It's a question for the database behind your AppSync. It's maybe DynamoDb, or RDS. Typically, you need only one mutation which performs a customer purchase, including</p>&#xA;<ol>&#xA;<li>Deduct money from the wallet</li>&#xA;<li>Deduct a number of items from the inventory</li>&#xA;<li>Add/Update an order record (orderId, userId, numberOfItems, status)</li>&#xA;<li>Add a purchase record (orderId, purchaseId, more purchase info)</li>&#xA;</ol>&#xA;<p>All of them are performed in a single transaction. If your DB is an RDS, then you can easily figure out the average number of items by a SQL query on the Order table. The number is aggregated in real-time, and there is no race condition.</p>&#xA;<p>On the other hand, if it's DynamoDb, there are many options in <a href=""https://stackoverflow.com/questions/44150156/how-to-do-basic-aggregation-with-dynamodb"">this answer</a>. Race conditions in DynamoDb can be a different problem, and one solution I know is <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html"" rel=""nofollow noreferrer"">conditional update</a>.</p>&#xA;<p>One mutation should be enough for your case. The mutation <code>purchaseWithoutOrder</code> is for purchases without an order.</p>&#xA;<pre><code>type Mutation {&#xA;  purchase(orderId: ID!): PurchaseResult&#xA;  purchaseWithoutOrder(input: PurchaseWithoutOrderInput!): PurchaseResult&#xA;}&#xA;&#xA;type PurchaseWithoutOrderInput {&#xA;  items: [Item!]!&#xA;}&#xA;</code></pre>&#xA;",755568,,755568,2021-03-31 06:51:10,2021-03-31 06:51:10,"",,0,1,0,2021-03-31 06:41:56
66905300,2,,58337364,7,,<p>If you are using Apollo there is also the explicit <code>getOperationName</code> which seems to be rather undocumented but has worked for all my usecases.</p>&#xA;<pre><code>import { getOperationName } from &quot;@apollo/client/utilities&quot;;&#xA;&#xA;export const AdminListItemsDocument = gql`&#xA;  query AdminListItems(&#xA;    $first: Int&#xA;    $after: String&#xA;    $before: String&#xA;    $last: Int&#xA;  ) {&#xA;    items(&#xA;      first: $first&#xA;      after: $after&#xA;      before: $before&#xA;      last: $last&#xA;    ) {&#xA;      nodes {&#xA;        id&#xA;        name&#xA;      }&#xA;      totalCount&#xA;      pageInfo {&#xA;        hasPreviousPage&#xA;        hasNextPage&#xA;        startCursor&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;getOperationName(AdminListBlockLanguagesDocument); // =&gt; &quot;AdminListItems&quot;&#xA;</code></pre>&#xA;,431715,,,,2021-04-01 13:19:58,"",,0,0,0,2021-04-01 13:19:58
66908681,2,,66896200,0,,"<p>I was able to get rid of the error by changing the fields in my Fridge class to:</p>&#xA;<pre><code>import { Field, Float, ID, ObjectType } from &quot;type-graphql&quot;;&#xA;import { prop, getModelForClass, Ref } from &quot;@typegoose/typegoose&quot;;&#xA;import { User } from './User';&#xA;&#xA;@ObjectType()&#xA;export class Fridge {&#xA;  @Field(() =&gt; ID, {nullable: true})&#xA;  _id: string&#xA;&#xA;  @Field(() =&gt; String) &#xA;  @prop({required: true})&#xA;  name: string;&#xA;&#xA;  @Field(() =&gt; String) &#xA;  @prop({required: true})&#xA;  address: string;&#xA;&#xA;  @Field(() =&gt; String) &#xA;  @prop({required: true})&#xA;  description: string;&#xA;&#xA;  @Field(() =&gt; User) &#xA;  @prop({ ref: () =&gt; User})&#xA;  public author: Ref&lt;User&gt;&#xA;&#xA;  @Field(() =&gt; Float, {nullable: true}) &#xA;  @prop()&#xA;  lat?: number&#xA;&#xA;  @Field(() =&gt; Float, {nullable: true}) &#xA;  @prop()&#xA;  lng?: number&#xA;};&#xA;&#xA;export const Fridges = getModelForClass(Fridge);&#xA;</code></pre>&#xA;<p>I don't fully understand how this would cause an unhanlded promise rejection. If anyone has any info it would be much appreciated because I was not able to find anything on my own.</p>&#xA;",15526023,,,,2021-04-01 16:56:48,"",,0,0,0,2021-04-01 16:56:48
67020265,1,,,2,854,"<p>I am new to using Typescript and finding there is a mismatch in how the types are being handled from the GraphQL schema and types generated via Relay.</p>&#xA;<p>Here is an example:</p>&#xA;<pre><code># in schema.graphql&#xA;&quot;&quot;&quot;&#xA;columns and relationships of &quot;businesses&quot;&#xA;&quot;&quot;&quot;&#xA;type businesses implements Node {&#xA;  businessId: bigint!&#xA;  name: String!&#xA;}&#xA;</code></pre>&#xA;<pre class=""lang-js prettyprint-override""><code>// in __generated__/Business_business.graphql&#xA;export type Business_business = {&#xA;    readonly name: string;&#xA;    readonly businessId: unknown;&#xA;    readonly &quot; $refType&quot;: &quot;Business_business&quot;;&#xA;};&#xA;export type Business_business$data = Business_business;&#xA;export type Business_business$key = {&#xA;    readonly &quot; $data&quot;?: Business_business$data;&#xA;    readonly &quot; $fragmentRefs&quot;: FragmentRefs&lt;&quot;Business_business&quot;&gt;;&#xA;};&#xA;</code></pre>&#xA;<pre class=""lang-js prettyprint-override""><code>const BusinessFragment = graphql`&#xA;  fragment Business_business on businesses {&#xA;    name&#xA;    businessId&#xA;  }&#xA;`&#xA;&#xA;type Props = {&#xA;  fragmentRef: Business_business$key&#xA;}&#xA;&#xA;const Business = ({ fragmentRef }: Props) =&gt; {&#xA;  const business = useFragment(BusinessFragment, fragmentRef)&#xA;  return (&#xA;    &lt;div&gt;&#xA;      &lt;p&gt;my html!&lt;/&gt;&#xA;      {/* I get the error: Type 'unknown' is not assignable to type 'number' for businessId */}&#xA;      &lt;ChildComponent businessId={business.businessId} /&gt;&#xA;    &lt;/div&gt;&#xA;  )&#xA;}&#xA;&#xA;</code></pre>&#xA;<pre class=""lang-js prettyprint-override""><code>interface Props {&#xA;  businessId: number&#xA;}&#xA;&#xA;const ChildComponent = ({ businessId }: Props) =&gt; {&#xA;&#xA;  return (&#xA;    &lt;p&gt;my business id: {businessId}&lt;/p&gt;&#xA;  )&#xA;}&#xA;</code></pre>&#xA;<p>Is there additional config I need to do to have Relay understand the Hasura types? I have followed the example via the <a href=""https://relay.dev/docs/guides/type-emission/#operationfragment-selection-set-data"" rel=""nofollow noreferrer"">relay docs</a>.</p>&#xA;<p>I have the assumption that Relay is not compiling <code>bigint</code> to <code>number</code>.</p>&#xA;<hr />&#xA;<p><strong>Update</strong></p>&#xA;<p>I have changed the column type in Hasura from <code>bigint</code> to <code>Int</code> and this solved the problem. Is there a way to tell Relay how to match types it is unfamiliar with? In this case cast <code>bigint</code> to <code>number</code> is totally fine.</p>&#xA;",10141904,,10141904,2021-04-09 12:12:26,2021-07-25 06:23:57,GraphQL types being defined as unknown in Typescript when compiled by Relay,<reactjs><typescript><graphql><relayjs><hasura>,2,0,0,2021-04-09 11:27:22
67044424,1,,,0,94,"<p>Note - I'm quite new to GraphQL and I've seen other stackoverflow questions of this error being reported but they were using Apollo. Here, I am using AWS Amplify and AppSync's own GraphQL client. So I couldn't use those solutions.</p>&#xA;<p>tldr - I'm trying to fetch a list of items from the db, but I keep getting a cryptic Network error and a store error that I don't understand. Details:-</p>&#xA;<p>This is my client definition for the AWS Appsync Client:-</p>&#xA;<pre><code>export const client = new AWSAppSyncClient({&#xA;  url: awsconfig.aws_appsync_graphqlEndpoint,&#xA;  region: awsconfig.aws_appsync_region,&#xA;  auth: {&#xA;    type: awsconfig.aws_appsync_authenticationType,&#xA;    jwtToken: async () =&gt;&#xA;      (await Auth.currentSession()).getAccessToken().getJwtToken(),&#xA;  },&#xA;});&#xA;</code></pre>&#xA;<p>This is my query method:-</p>&#xA;<pre><code>  listInstitutions = () =&gt; {&#xA;    client&#xA;      .query({&#xA;        query: queries.ListInstitutions,&#xA;      })&#xA;      .then((res: any) =&gt; {&#xA;        this.institutions = res.data.listInstitutions.items;&#xA;        console.log('this.institutions', this.institutions);&#xA;      })&#xA;      .catch((err) =&gt; {&#xA;        console.error(err);&#xA;        this.institutions = [];&#xA;      });&#xA;  };&#xA;</code></pre>&#xA;<p>This is my query definition:-</p>&#xA;<pre><code>query ListInstitutions(&#xA;  $filter: ModelInstitutionFilterInput&#xA;  $limit: Int&#xA;  $nextToken: String&#xA;) {&#xA;  listInstitutions(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      location&#xA;      city&#xA;      website&#xA;      phone&#xA;      logo&#xA;      bio&#xA;      admins {&#xA;        id&#xA;        name&#xA;        title&#xA;        bio&#xA;        createdAt&#xA;        updatedAt&#xA;        owner&#xA;      }&#xA;      classes {&#xA;        nextToken&#xA;      }&#xA;      learners {&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The error in the console looks like this:-</p>&#xA;<pre><code> Error: Network error: Error writing result to store for query:&#xA; query ListInstitutions($filter: ModelInstitutionFilterInput, $limit: Int, $nextToken: String) {&#xA;  listInstitutions(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;    items {&#xA;      id&#xA;      name&#xA;      location&#xA;      city&#xA;      website&#xA;      phone&#xA;      logo&#xA;      bio&#xA;      admins {&#xA;        id&#xA;        name&#xA;        title&#xA;        bio&#xA;        createdAt&#xA;        updatedAt&#xA;        owner&#xA;        __typename&#xA;      }&#xA;      classes {&#xA;        nextToken&#xA;        __typename&#xA;      }&#xA;      learners {&#xA;        nextToken&#xA;        __typename&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;      __typename&#xA;    }&#xA;    nextToken&#xA;    __typename&#xA;  }&#xA;}&#xA;&#xA;Store error: the application attempted to write an object with no provided id but the store already contains an id of ModelInstitutionConnection:undefined for this object. The selectionSet that was trying to be written is:&#xA;listInstitutions(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;  items {&#xA;    id&#xA;    name&#xA;    location&#xA;    city&#xA;    website&#xA;    phone&#xA;    logo&#xA;    bio&#xA;    admins {&#xA;      id&#xA;      name&#xA;      title&#xA;      bio&#xA;      createdAt&#xA;      updatedAt&#xA;      owner&#xA;      __typename&#xA;    }&#xA;    classes {&#xA;      nextToken&#xA;      __typename&#xA;    }&#xA;    learners {&#xA;      nextToken&#xA;      __typename&#xA;    }&#xA;    createdAt&#xA;    updatedAt&#xA;    __typename&#xA;  }&#xA;  nextToken&#xA;  __typename&#xA;}&#xA;    at new ApolloError (ApolloError.js:37)&#xA;    at QueryManager.js:326&#xA;    at QueryManager.js:698&#xA;    at Array.forEach (&lt;anonymous&gt;)&#xA;    at QueryManager.js:697&#xA;    at Map.forEach (&lt;anonymous&gt;)&#xA;    at QueryManager.push.lq9a.QueryManager.broadcastQueries (QueryManager.js:692)&#xA;    at QueryManager.js:275&#xA;    at ZoneDelegate.invoke (zone-evergreen.js:372)&#xA;    at Object.onInvoke (core.js:28510)&#xA;</code></pre>&#xA;<p>I have to note that this error vanishes when I add the cacheOptions configuration to the AWS Appsync client definition, like so:-</p>&#xA;<pre><code>export const client = new AWSAppSyncClient({&#xA;  url: awsconfig.aws_appsync_graphqlEndpoint,&#xA;  region: awsconfig.aws_appsync_region,&#xA;  auth: {&#xA;    type: awsconfig.aws_appsync_authenticationType,&#xA;    jwtToken: async () =&gt;&#xA;      (await Auth.currentSession()).getAccessToken().getJwtToken(),&#xA;  },&#xA;     cacheOptions: {&#xA;       dataIdFromObject: (obj: any) =&gt; `${obj.__typename}:${obj.myKey}`,&#xA;     },&#xA;});&#xA;</code></pre>&#xA;<p>But even though the error goes away, it doesn't actually fetch the items from the dynamoDB. It just always returns an empty array.</p>&#xA;<p>I don't know why I'm getting this kind of an error even though all of my graphql code is autogenerated using the aws amplify-cli and I'm following the approach as seen in the <a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js#using-aws-appsync-sdk"" rel=""nofollow noreferrer"">documentation</a></p>&#xA;<p>I just want the query to fetch the items from the database. What should I do?</p>&#xA;",7981162,,,,2021-04-12 08:49:19,Store error: the application attempted to write an object with no provided id but the store already contains an id of <connectionName> for this object,<amazon-web-services><graphql><aws-amplify><aws-appsync>,1,0,0,2021-04-11 11:26:13
67071457,2,,52635916,0,,<p>I got this exact error when my .npmrc did not have proper entries such as username and password. We are using jFrog to normalise package installation. .npmrc should be located at root with proper entries.&#xA;ex: .npmrc file which works</p>&#xA;<pre><code>@&lt;company-name&gt;:registry=&lt;registry-url&gt;&#xA;//&lt;artifactory-name&gt;:_password=${PASSWORD}&#xA;//&lt;artifactory-name&gt;:username=${JFROG_USERNAME}&#xA;//&lt;artifactory-name&gt;:email=${YOUR_EMAIL}&#xA;//&lt;artifactory-name&gt;:always-auth=true&#xA;</code></pre>&#xA;,2703920,,,,2021-04-13 08:40:21,"",,0,0,0,2021-04-13 08:40:21
67078413,2,,67063407,0,,<p>It was the issues in the graphql query which was being used more specifically the line&#xA;filter: { frontmatter: { tag: { eq: &quot;popular&quot; }}}&#xA;the issue was the &quot;popular&quot; in the MD file is in caps so by changing it to &quot;POPULAR&quot; that solved it....</p>&#xA;,11263582,,,,2021-04-13 15:59:54,"",,0,0,0,2021-04-13 15:59:54
67080130,1,,,0,163,"<p>Now my filter looks like this</p>&#xA;<pre><code>class Document(graphene.ObjectType):&#xA;&#xA;    number = graphene.relay.ConnectionField(&#xA;        ReportDocumentNumberConnection,&#xA;        doc__number__in=graphene.List(graphene.String, required=False),&#xA;        doc__supplier__delivery__in=graphene.List(graphene.String, required=False),&#xA;        doc__supplier__number__in=graphene.List(graphene.String, required=False),&#xA;    )&#xA;</code></pre>&#xA;<p>And it works fine with Query like this</p>&#xA;<pre><code>{&#xA;  allDocuments{&#xA;&#xA;    number(doc_Number_In: &quot;TVF&quot; doc_Supplier_Delivery_In: &quot;Q23&quot;) { ... }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But I want to put all my filters into one object, something like this</p>&#xA;<pre><code>{&#xA;  allDocuments{&#xA;&#xA;    number(inputFilter: {doc_Number_In: &quot;TVF&quot; doc_Supplier_Delivery_In: &quot;Q23&quot;}) { ... }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is that possible? If yes, how to do that?</p>&#xA;",5594008,,,,2021-09-06 08:09:10,"Django graphene, filtering by object",<python><django><graphql><graphene-django>,1,0,0,2021-04-13 18:01:36
67144726,2,,67128433,1,,"<p>So, this was a typical case of copy-paste... The problem was in this line:</p>&#xA;<pre><code>Range(Match(Index(&quot;facturas_by_date&quot;)), Var(&quot;before&quot;), Var(&quot;after&quot;))&#xA;</code></pre>&#xA;<p>Note that the documentation for the Range function states this: <code>Range( set, start, end )</code>.</p>&#xA;<p>So, in my UDF code, the <code>&quot;before&quot;</code> variable corresponds with the <code>start</code> parameter. So when I say after January and before March, I am saying from March to January.</p>&#xA;<p>I fixed that and it works.</p>&#xA;",6740501,,,,2021-04-18 02:38:26,"",,0,0,0,2021-04-18 02:38:26
67148042,1,67150743,,0,1087,"<p>I have a graphql query like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>query Query {&#xA;  edge_feed_posts(first: 15) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        url&#xA;        title&#xA;        edge_likes(first: 10) {&#xA;          count&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              percent&#xA;              liked_at&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I need to know whether the field <code>edges</code> exists in <code>edge_likes</code> or not?</p>&#xA;<p>for example something like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>function edge_likes_resolver(parent, args, context, graph) {&#xA;    if (graph.operation.selectionSet.hasField(&quot;edges&quot;)) {&#xA;        // do something...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",11878372,,11878372,2021-04-19 12:43:46,2021-04-19 12:43:46,How to check whether a special field exists in graphql query selection set using resolverInfo?,<graphql>,1,0,0,2021-04-18 11:31:55
67171121,1,,,0,83,"<p>I need to sort my data using ORDER BY CASE in two steps: First, I need to reverse the sort with using &quot;DESC&quot;, and after that, this sorting, need to sort alphabetically</p>&#xA;<p>I represent such code like this</p>&#xA;<pre><code>ORDER BY&#xA;  &#xA;    CASE WHEN sort_param = 'HIGH_TO_LOW'&#xA;      THEN goal_progress DESC //reverse data&#xA;      THEN LOWER(s.title) END, //sort alphabetically&#xA;...&#xA;</code></pre>&#xA;<p>But this doesn't work because of syntax error</p>&#xA;",14211625,,,,2021-04-20 01:20:49,SQL ORDER BY CASE + DESC,<sql><graphql><graphql-js>,1,0,0,2021-04-20 01:02:32
67171134,2,,67171121,0,,"<p>I would recommend that you split each condition into a separate <code>case</code>:</p>&#xA;<pre><code>ORDER BY (CASE WHEN sort_param = 'HIGH_TO_LOW' THEN goal_progress END),&#xA;        LOWER(s.title)&#xA;</code></pre>&#xA;",1144035,,1144035,2021-04-20 01:20:49,2021-04-20 01:20:49,"",,0,2,0,2021-04-20 01:03:55
67189624,2,,67189519,2,,"<p>If your GraphQL nodes are properly set, you just can:</p>&#xA;<pre><code>query MyQuery {&#xA;  allContentfulCategory(limit: 10, filter: {blog_post: {slug: {ne: null}}}) {&#xA;    edges {&#xA;      node {&#xA;        slug&#xA;        name&#xA;        blog_post {&#xA;          slug&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The <code>ne</code> (not equal) filter should do the trick.</p>&#xA;<p>Alternatively, you can filter directly using JavaScript code, since it's a <code>null</code> value, it can be easily removed from the <code>node</code> array with:</p>&#xA;<pre><code>let filtered = data.allContentfulCategory.edges.node.filter(el =&gt; el.blog_post != null);&#xA;</code></pre>&#xA;",5585371,,5585371,2021-04-22 09:46:08,2021-04-22 09:46:08,"",,0,8,0,2021-04-21 05:11:39
67195843,1,,,0,1417,"<p>I've found a lot of good info on using Date() and getting timezones, but something just isn't working. I have my GraphQL (sourcing from Sanity) set to use formatString, like this:</p>&#xA;<pre><code>export default function MinutesItemGrid() {&#xA;  const { minutes } = useStaticQuery(graphql`&#xA;    query {&#xA;      minutes: allSanityMinutes {&#xA;        nodes {&#xA;          endTime(formatString: &quot;h:mma [on] MM/DD/YYYY&quot;)&#xA;         }&#xA;      }&#xA;   }&#xA;`);&#xA;</code></pre>&#xA;<p>Then calling it in a <code>.map</code>:</p>&#xA;<pre><code>const allMinutes = minutes.nodes;&#xA;return (&#xA;    &lt;CardStyles&gt;&#xA;      {allMinutes.map((minute) =&gt; (&#xA;        &lt;ItemStyles&gt;&#xA;          &lt;div className=&quot;card&quot; key={minute.id}&gt;&#xA;            &lt;div className=&quot;content&quot;&gt;Meeting began at: {minute.endTime}&lt;/div&gt;&#xA;          &lt;/div&gt;&#xA;        &lt;/ItemStyles&gt;&#xA;     ))}&#xA;    &lt;/CardStyles&gt;&#xA;  );&#xA;</code></pre>&#xA;<p>Which displays as 11:33pm on 10/14/2020. That is 6 hours ahead of what it should be.</p>&#xA;<p>I know this returns UTC time standardly. I know how to get the local time offset (<code>new Date().getTimezoneOffset();</code>) and get the local timezone (<code>Intl.DateTimeFormat().resolvedOptions().timeZone</code>), but I don't see an option to change the timezone to display to MST (or local time) instead of UTC. I have tried subtracting the 6 hours in various ways, tried using moment.js and moment.js timezone to change the timezones based on their docs. I've just found out that Luxon is a better option now, but even in their docs I don't see a resolution when pulling the data from GraphQL.</p>&#xA;",9622568,,12289632,2021-04-21 16:06:14,2021-04-23 20:29:02,How do I change the timezone of my GraphQL time?,<javascript><graphql><timezone><sanity>,2,0,0,2021-04-21 12:20:39
67195890,1,,,0,257,"<p>I am using react(fe), Django (be) and graphql. Currently I send request when I reach bottom of my page to fetch more &quot;posts&quot; to my infinite scrolling feed.</p>&#xA;<p>In django-graphene, this would work like&#xA;Return <code>Post.objects.all() [offset, offset+limit]</code>. But what should I do if for example, my return statement weren't as easy as just fetching all posts? What if I need to return the posts in a sorted way that they aren't already in the DB? Right now, I am doing it like&#xA;Return <code>custom_sort(Post.objects.all())[offset, offset+limit]</code>. Still working, but I need to sort them on every request (I think, if Django isn't cashing it). How would one do this so I only need to sort them once, and then save those values for say a minute so I don't need to sort them every time I request?</p>&#xA;",15708982,,3979495,2021-04-21 21:55:07,2021-04-21 21:55:07,Pagination with graphql and django,<reactjs><django><pagination><graphql>,0,4,0,2021-04-21 12:24:19
67196700,2,,67195239,0,,"<h2>It's not a query or server role to normalize data.</h2>&#xA;<ul>&#xA;<li>there are no such possibilities in GraphQL specs;</li>&#xA;<li>server must return all asked fields within queried [response] structure;</li>&#xA;</ul>&#xA;<p>... but you can implement some:</p>&#xA;<ul>&#xA;<li>standarized (commonly used) pagination (relay style <code>edges</code>/<code>nodes</code>, <code>nodes</code> only or better both);</li>&#xA;<li>query [complexity] weights to promote this optimized querying style - <strong>separate problem</strong>;</li>&#xA;<li>reference dictionary field within queried type;</li>&#xA;</ul>&#xA;<pre><code>      links {&#xA;        egdes {&#xA;          node {&#xA;            id&#xA;            title&#xA;            url&#xA;            authorId&#xA;    #  possible but limited usage with heavy weights&#xA;    #       author {&#xA;    #         id&#xA;    #         email&#xA;    #       }&#xA;          }&#xA;        }&#xA;        pageInfo {&#xA;          hasNextPages&#xA;        }&#xA;        referencedUsers {&#xA;          id&#xA;          email&#xA;        }&#xA;      }&#xA;</code></pre>&#xA;<p>where:</p>&#xA;<ul>&#xA;<li><code>User</code> has <code>id</code> and <code>email</code> props;</li>&#xA;<li><code>referencedUsers</code> is <code>[User!]</code> type;</li>&#xA;<li><code>node.author</code> is <code>User</code> type;</li>&#xA;</ul>&#xA;<p>Normalizing Graphql client, like <code>Apollo</code>, can easily access cached user fields without making separate requests.</p>&#xA;<p>You can render (react?) some <code>&lt;User/&gt;</code> component (within <code>&lt;Link /&gt;</code> component) passing <code>node.authorId</code> as an argument like <code>&lt;User id={authorId} /&gt;</code>. User component can <code>useQuery</code> hook with <code>cache-only</code> policy to read user props/fields.</p>&#xA;<p>See Apollo docs for details. You should implement this for yourself and document this to help/guide API users.</p>&#xA;",6124657,,6124657,2021-04-21 13:20:55,2021-04-21 13:20:55,"",,0,3,0,2021-04-21 13:15:01
67205043,2,,67202446,1,,"<p>The string literal created a new line (<code>\n</code>) a stated a comment <code>@DIGI Byte</code>.</p>&#xA;<p>There are other ways but to keep it simple I changed structure of this</p>&#xA;<pre><code>  const mutation = gql`&#xA;    mutation($id: String!, $email: String) {&#xA;      insert_users_one(object: { user_firebase_id: $id, user_email: $email }) {&#xA;        user_firebase_id&#xA;        user_email&#xA;      }&#xA;    }&#xA;  `;&#xA;</code></pre>&#xA;<p>to</p>&#xA;<pre><code> const mutation = gql`mutation($id: String!, $email: String)\{insert_users(objects: [{user_firebase_id: $id,user_email: $email}]) {affected_rows}}`;&#xA;</code></pre>&#xA;<p>I know there has to be a more efficient way of fixing this, but if anyone else runs into a similar issue. I'll leave this here.</p>&#xA;",4021213,,,,2021-04-22 00:12:13,"",,0,0,0,2021-04-22 00:12:13
67237150,1,,,2,771,"<p>I have a GQL cursor based pagination and have implemented the frontend in react using the apollo client library. This is my current server response, and things work well when requesting the next or the previous page.</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;users&quot;: {&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;hasPreviousPage&quot;: false,&#xA;        &quot;startCursor&quot;: &quot;1&quot;,&#xA;        &quot;endCursor&quot;: &quot;6&quot;&#xA;      },&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;1&quot;&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;6&quot;&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>The issue which I have is;</strong></p>&#xA;<p>I have a page count dropdown, 20, 50 and 100, which determines the number of record to be show on a page. So, if i start with 50 records per page, and let's say record number 74 is on page 2, when i switch to 20 records per page, the apollo client does not request the server, instead loads the data from the cache. This is good as caching helps avoid additional request, but now I do not know which page record 74 belongs to.</p>&#xA;<p><strong>Solution I am after;</strong></p>&#xA;<p>I am after a solution/library that can handle pagination in react which also takes into account the fact that the server wont be contacted always and therefore should keep track of the page.</p>&#xA;",3289660,,3289660,2021-04-25 22:37:57,2021-05-08 00:11:05,Tracking page number in cursor based pagination with graphql cache in use,<reactjs><graphql><apollo><apollo-client><react-apollo>,1,0,0,2021-04-23 21:42:12
67263726,1,,,1,629,"<p>I am trying to findMany() users and orderBy their post count. I found exactly how to do it in the <a href=""https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#sort-user-by-the-posts-count"" rel=""nofollow noreferrer"">docs</a> and it works except it counts users with 0 posts as +infinity.  <code>orderBy: {posts: {count: asc}}</code></p>&#xA;<p>For example, the ordering works in ascending starting with users with 1 post up until the users with a lot of posts, but the last users have 0 posts. Vice versa when descending.</p>&#xA;<p>I am using postgres as the provider, I really don’t know how to even google for this problem, and title this question. Please help.</p>&#xA;<pre><code>model User {&#xA;  id     Int    @id @default(autoincrement())&#xA;  posts  Post[]        &#xA;}&#xA;&#xA;model Post {&#xA;  id      Int   @id @default(autoincrement())&#xA;  user    User  @relation(fields: [userID], references: [id])&#xA;  userID  Int        &#xA;}&#xA;</code></pre>&#xA;<pre><code>  await prisma.user.findMany({&#xA;    orderBy: {&#xA;      posts: {&#xA;        count: 'desc',&#xA;      },&#xA;    },&#xA;  });&#xA;</code></pre>&#xA;<p>Output of a small test in descending order. You can see the post count is ordered 0 2 1 (in ascending order its output order is 1 2 0):</p>&#xA;<pre><code>[&#xA;  { id: 3, _count: { posts: 0 } },&#xA;  { id: 1, _count: { posts: 2 } },&#xA;  { id: 2, _count: { posts: 1 } }&#xA;]&#xA;</code></pre>&#xA;",15164129,,15164129,2021-04-27 10:29:44,2021-04-27 10:29:44,Prisma findMany() - Ordering by count orders 0 count as positive infinity,<prisma><prisma-graphql><prisma2>,0,2,0,2021-04-26 09:04:23
67278491,1,,,1,986,"<p>I have a problem using GraphQL with the HotChocolate library in a C# backend. When I use filtering the whole table is loaded and after that it is filtered. This of course means an awful performance as a full table scan is performed each time.</p>&#xA;<p>This is the query</p>&#xA;<pre><code>        [UseFiltering]&#xA;        public IQueryable&lt;Person&gt; GetFilteredPersons(&#xA;            [Service] IPersonRepo repo)&#xA;        {&#xA;            return repo.GetAll().AsQueryable();&#xA;        }&#xA;</code></pre>&#xA;<p>And this is the repo</p>&#xA;<pre><code>        public IEnumerable&lt;Person&gt; GetAll()&#xA;        {&#xA;            var query = &quot;SELECT * FROM Persons&quot;;&#xA;            var param = new DynamicParameters();&#xA;            return SqlMapper.Query&lt;Person&gt;(GetConnection()&#xA;                query, param,&#xA;                commandType: CommandType.Text);&#xA;        }&#xA;</code></pre>&#xA;<p>How can I make the filters be passed to the WHERE clause? Maybe with DapperExtensions using a predicate? It would be hard anyway as the filters are not really accessible in the GraphQL query.</p>&#xA;",15773890,,,,2021-08-06 11:22:16,Lazy loading data in Dapper using HotChocolate GraphQL,<c#><sql><performance><graphql><hotchocolate>,2,0,0,2021-04-27 07:14:31
67278779,1,,,0,139,"<p>I'm building a serverless web app for the first time on my free time. I have made my whole login workflow using AWS Cognito with Amplify but now I'm embarrassed.</p>&#xA;<p>I want like to stock user related data outside of cognito (Like Birthdate, Display username, Avatar picture URL, ...Etc.) but because I setup appsync with cognito auth I cannot create the user on sign-up time (before the user validation) in the database because of authorization issues. I'm not storing those data in cognito for 2 reason :</p>&#xA;<ol>&#xA;<li>Those fields may change later (like adding or removing one) and cognito don't allow attribute removal.</li>&#xA;<li>From what I've read AWS Cognito don't allow reverse search of using using their attributes</li>&#xA;</ol>&#xA;<p>I fell like it's a whole workflow problem and I'm open to suggestions but knowing that I have some user data only at sign-up time (like the Display username or Birthdate).</p>&#xA;<p>You can find here my AppSync graphql configuration (which is very basic for the moment)</p>&#xA;<pre><code>schema {&#xA;  query: Query&#xA;  mutation: Mutation&#xA;  subscription: Subscription&#xA;}&#xA;&#xA;type Mutation {&#xA;  createUserData(input: CreateUserDataInput!): UserData&#xA;  deleteUserData(input: DeleteUserDataInput!): UserData&#xA;  updateUserData(input: UpdateUserDataInput!): UserData&#xA;}&#xA;&#xA;type Query {&#xA;  getUserData(email: String!, id: ID!): UserData&#xA;  listUserData(filter: TableUserDataFilterInput, limit: Int, nextToken: String): UserDataConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;  onCreateUserData(email: String, first_name: String, id: ID, last_name: String, pseudoname: String): UserData @aws_subscribe(mutations : [&quot;createUserData&quot;])&#xA;  onDeleteUserData(email: String, first_name: String, id: ID, last_name: String, pseudoname: String): UserData @aws_subscribe(mutations : [&quot;deleteUserData&quot;])&#xA;  onUpdateUserData(email: String, first_name: String, id: ID, last_name: String, pseudoname: String): UserData @aws_subscribe(mutations : [&quot;updateUserData&quot;])&#xA;}&#xA;&#xA;type UserData {&#xA;  avatar: String&#xA;  email: String!&#xA;  first_name: String&#xA;  id: ID!&#xA;  last_name: String&#xA;  pseudoname: String&#xA;}&#xA;&#xA;type UserDataConnection {&#xA;  items: [UserData]&#xA;  nextToken: String&#xA;}&#xA;&#xA;enum ModelAttributeTypes {&#xA;  _null&#xA;  binary&#xA;  binarySet&#xA;  bool&#xA;  list&#xA;  map&#xA;  number&#xA;  numberSet&#xA;  string&#xA;  stringSet&#xA;}&#xA;&#xA;enum ModelSortDirection {&#xA;  ASC&#xA;  DESC&#xA;}&#xA;&#xA;input CreateUserDataInput {&#xA;  avatar: String&#xA;  email: String!&#xA;  first_name: String&#xA;  id: ID!&#xA;  last_name: String&#xA;  pseudoname: String&#xA;}&#xA;&#xA;input DeleteUserDataInput {&#xA;  email: String!&#xA;  id: ID!&#xA;}&#xA;&#xA;input ModelBooleanInput {&#xA;  attributeExists: Boolean&#xA;  attributeType: ModelAttributeTypes&#xA;  eq: Boolean&#xA;  ne: Boolean&#xA;}&#xA;&#xA;input ModelFloatInput {&#xA;  attributeExists: Boolean&#xA;  attributeType: ModelAttributeTypes&#xA;  between: [Float]&#xA;  eq: Float&#xA;  ge: Float&#xA;  gt: Float&#xA;  le: Float&#xA;  lt: Float&#xA;  ne: Float&#xA;}&#xA;&#xA;input ModelIDInput {&#xA;  attributeExists: Boolean&#xA;  attributeType: ModelAttributeTypes&#xA;  beginsWith: ID&#xA;  between: [ID]&#xA;  contains: ID&#xA;  eq: ID&#xA;  ge: ID&#xA;  gt: ID&#xA;  le: ID&#xA;  lt: ID&#xA;  ne: ID&#xA;  notContains: ID&#xA;  size: ModelSizeInput&#xA;}&#xA;&#xA;input ModelIntInput {&#xA;  attributeExists: Boolean&#xA;  attributeType: ModelAttributeTypes&#xA;  between: [Int]&#xA;  eq: Int&#xA;  ge: Int&#xA;  gt: Int&#xA;  le: Int&#xA;  lt: Int&#xA;  ne: Int&#xA;}&#xA;&#xA;input ModelSizeInput {&#xA;  between: [Int]&#xA;  eq: Int&#xA;  ge: Int&#xA;  gt: Int&#xA;  le: Int&#xA;  lt: Int&#xA;  ne: Int&#xA;}&#xA;&#xA;input ModelStringInput {&#xA;  attributeExists: Boolean&#xA;  attributeType: ModelAttributeTypes&#xA;  beginsWith: String&#xA;  between: [String]&#xA;  contains: String&#xA;  eq: String&#xA;  ge: String&#xA;  gt: String&#xA;  le: String&#xA;  lt: String&#xA;  ne: String&#xA;  notContains: String&#xA;  size: ModelSizeInput&#xA;}&#xA;&#xA;input TableBooleanFilterInput {&#xA;  eq: Boolean&#xA;  ne: Boolean&#xA;}&#xA;&#xA;input TableFloatFilterInput {&#xA;  between: [Float]&#xA;  contains: Float&#xA;  eq: Float&#xA;  ge: Float&#xA;  gt: Float&#xA;  le: Float&#xA;  lt: Float&#xA;  ne: Float&#xA;  notContains: Float&#xA;}&#xA;&#xA;input TableIDFilterInput {&#xA;  beginsWith: ID&#xA;  between: [ID]&#xA;  contains: ID&#xA;  eq: ID&#xA;  ge: ID&#xA;  gt: ID&#xA;  le: ID&#xA;  lt: ID&#xA;  ne: ID&#xA;  notContains: ID&#xA;}&#xA;&#xA;input TableIntFilterInput {&#xA;  between: [Int]&#xA;  contains: Int&#xA;  eq: Int&#xA;  ge: Int&#xA;  gt: Int&#xA;  le: Int&#xA;  lt: Int&#xA;  ne: Int&#xA;  notContains: Int&#xA;}&#xA;&#xA;input TableStringFilterInput {&#xA;  beginsWith: String&#xA;  between: [String]&#xA;  contains: String&#xA;  eq: String&#xA;  ge: String&#xA;  gt: String&#xA;  le: String&#xA;  lt: String&#xA;  ne: String&#xA;  notContains: String&#xA;}&#xA;&#xA;input TableUserDataFilterInput {&#xA;  avatar: TableStringFilterInput&#xA;  email: TableStringFilterInput&#xA;  first_name: TableStringFilterInput&#xA;  id: TableIDFilterInput&#xA;  last_name: TableStringFilterInput&#xA;  pseudoname: TableStringFilterInput&#xA;}&#xA;&#xA;input UpdateUserDataInput {&#xA;  avatar: String&#xA;  email: String!&#xA;  first_name: String&#xA;  id: ID!&#xA;  last_name: String&#xA;  pseudoname: String&#xA;}&#xA;</code></pre>&#xA;",8176450,,214143,2021-06-13 20:16:25,2021-06-13 20:16:25,User data storage design pattern AWS AppSyn with GraphQL and CognitoAuth,<amazon-web-services><graphql><amazon-cognito><aws-appsync>,1,0,0,2021-04-27 07:36:19
67291378,1,67697106,,0,578,"<p>I am trying to retrieve more than 100 records for a WPGraphQL query using Apollo during getStaticProps. The wonderful WPGraphQL maker, Jason, pointed me towards using the pagination method and then combining the results into one new Array (or Object?).</p>&#xA;<p>The issue i'm having though is...well I can't get it to combine or really do anything more than getting one query. In my getStaticProps I have one query which retrieves only 100 records &amp;  works, but if I try to add another one it doesn't work, and I get a error on the data saying it doesn't exist (even though I know it exists...):</p>&#xA;<pre><code>Server Error&#xA;&#xA;TypeError: Cannot read property 'campgrounds' of undefined&#xA;This error happened while generating the page. Any console logs will be displayed in the terminal window.&#xA;Source&#xA;&#xA;pages/camps.js (355:11) @ getStaticProps&#xA;&#xA;  353 |   });&#xA;  354 | &#xA;&gt; 355 |   dataset2.campgrounds.edges.map((city) =&gt; {&#xA;      |           ^&#xA;  356 |     return cities.push({&#xA;  357 |       city: city.node.acfDetails.city,&#xA;  358 |     });&#xA;</code></pre>&#xA;<p>So i'm unsure what to do and hoping you folks can help. I'm sure i'm just missing something stupid or doing something stupid.</p>&#xA;<p>Ultimately I am trying to effectively just retrieve ~156 records from the database <em><strong>without pagination</strong></em>, which I guess the best way to do it is to split it into two queries and then combine the data. Thank you so much for any help.</p>&#xA;<p>Here's my getStaticProps code that doesn't work:</p>&#xA;<pre><code>export async function getStaticProps() {&#xA;  const { data } = await client.query({&#xA;    query: gql`&#xA;      query allCamps {&#xA;        features(first: 300) {&#xA;          nodes {&#xA;            label: name&#xA;            value: name&#xA;          }&#xA;        }&#xA;        regions(first: 300) {&#xA;          nodes {&#xA;            id&#xA;            name&#xA;            regioncoord {&#xA;              latitude&#xA;              longitude&#xA;            }&#xA;          }&#xA;        }&#xA;        ownerships(first: 300) {&#xA;          nodes {&#xA;            id&#xA;            name&#xA;          }&#xA;        }&#xA;        campgrounds(first: 200) {&#xA;          pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;            hasPreviousPage&#xA;            startCursor&#xA;          }&#xA;          edges {&#xA;            cursor&#xA;            node {&#xA;              acfDetails {&#xA;                additionalNotes&#xA;                address&#xA;                city&#xA;                closeDate&#xA;                description&#xA;                eMailAddress&#xA;                fieldGroupName&#xA;                latitude&#xA;                longitude&#xA;                maxAmps&#xA;                maximumRvLength&#xA;                numberOfSites&#xA;                openDate&#xA;                phoneNumber&#xA;                picture {&#xA;                  altText&#xA;                  mediaItemUrl&#xA;                }&#xA;                state&#xA;                website&#xA;                zipCode&#xA;              }&#xA;              id&#xA;              title&#xA;              features {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              regions {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              ownerships {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              title&#xA;              uri&#xA;              id&#xA;              link&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  });&#xA;&#xA;  const {dataset2} = await client.query({&#xA;    query: gql`&#xA;     query allCamps($endcursor: String) {&#xA;      features(first: 300) {&#xA;        nodes {&#xA;          label: name&#xA;          value: name&#xA;        }&#xA;      }&#xA;      regions(first: 300) {&#xA;        nodes {&#xA;          id&#xA;          name&#xA;          regioncoord {&#xA;            latitude&#xA;            longitude&#xA;          }&#xA;        }&#xA;      }&#xA;      ownerships(first: 300) {&#xA;        nodes {&#xA;          id&#xA;          name&#xA;        }&#xA;      }&#xA;      campgrounds(first: 100, after: $endcursor) {&#xA;        pageInfo {&#xA;          endCursor&#xA;          hasNextPage&#xA;          hasPreviousPage&#xA;          startCursor&#xA;        }&#xA;        edges {&#xA;          cursor&#xA;          node {&#xA;            acfDetails {&#xA;              additionalNotes&#xA;              address&#xA;              city&#xA;              closeDate&#xA;              description&#xA;              eMailAddress&#xA;              fieldGroupName&#xA;              latitude&#xA;              longitude&#xA;              maxAmps&#xA;              maximumRvLength&#xA;              numberOfSites&#xA;              openDate&#xA;              phoneNumber&#xA;              picture {&#xA;                altText&#xA;                mediaItemUrl&#xA;              }&#xA;              state&#xA;              website&#xA;              zipCode&#xA;            }&#xA;            id&#xA;            title&#xA;            features {&#xA;              nodes {&#xA;                name&#xA;              }&#xA;            }&#xA;            regions {&#xA;              nodes {&#xA;                name&#xA;              }&#xA;            }&#xA;            ownerships {&#xA;              nodes {&#xA;                name&#xA;              }&#xA;            }&#xA;            title&#xA;            uri&#xA;            id&#xA;            link&#xA;          }&#xA;        }&#xA;      }&#xA;    }`, variables: {endcursor: data.campgrounds.pageInfo.endCursor}&#xA;  })&#xA;&#xA;  const { features } = data;&#xA;  const cities = [];&#xA;&#xA;  data.campgrounds.edges.map((city) =&gt; {&#xA;    return cities.push({&#xA;      city: city.node.acfDetails.city,&#xA;    });&#xA;  });&#xA;&#xA;  dataset2.campgrounds.edges.map((city) =&gt; {&#xA;    return cities.push({&#xA;      city: city.node.acfDetails.city,&#xA;    })&#xA;  })&#xA;&#xA;  const object = [];&#xA;&#xA;  features.nodes.map((feature) =&gt; {&#xA;    return object.push({&#xA;      label: feature.label,&#xA;      value: feature.label,&#xA;    });&#xA;  });&#xA;&#xA;  return {&#xA;    props: {&#xA;      allCampInfo: data,&#xA;      regions: data.regions,&#xA;      camptypes: data.ownerships,&#xA;      object,&#xA;      graphCampgrounds: data.campgrounds.edges,&#xA;      cities,&#xA;      endCursor: data.campgrounds.pageInfo.endCursor,&#xA;    },&#xA;  };&#xA;}&#xA;</code></pre>&#xA;<p>And here's the code with just one query that does work:</p>&#xA;<pre><code>export async function getStaticProps() {&#xA;  const { data } = await client.query({&#xA;    query: gql`&#xA;      query allCamps {&#xA;        features(first: 300) {&#xA;          nodes {&#xA;            label: name&#xA;            value: name&#xA;          }&#xA;        }&#xA;        regions(first: 300) {&#xA;          nodes {&#xA;            id&#xA;            name&#xA;            regioncoord {&#xA;              latitude&#xA;              longitude&#xA;            }&#xA;          }&#xA;        }&#xA;        ownerships(first: 300) {&#xA;          nodes {&#xA;            id&#xA;            name&#xA;          }&#xA;        }&#xA;        campgrounds(first: 200) {&#xA;          pageInfo {&#xA;            endCursor&#xA;            hasNextPage&#xA;            hasPreviousPage&#xA;            startCursor&#xA;          }&#xA;          edges {&#xA;            cursor&#xA;            node {&#xA;              acfDetails {&#xA;                additionalNotes&#xA;                address&#xA;                city&#xA;                closeDate&#xA;                description&#xA;                eMailAddress&#xA;                fieldGroupName&#xA;                latitude&#xA;                longitude&#xA;                maxAmps&#xA;                maximumRvLength&#xA;                numberOfSites&#xA;                openDate&#xA;                phoneNumber&#xA;                picture {&#xA;                  altText&#xA;                  mediaItemUrl&#xA;                }&#xA;                state&#xA;                website&#xA;                zipCode&#xA;              }&#xA;              id&#xA;              title&#xA;              features {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              regions {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              ownerships {&#xA;                nodes {&#xA;                  name&#xA;                }&#xA;              }&#xA;              title&#xA;              uri&#xA;              id&#xA;              link&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    `,&#xA;  });&#xA;&#xA;  const { features } = data;&#xA;  const cities = [];&#xA;&#xA;  data.campgrounds.edges.map((city) =&gt; {&#xA;    return cities.push({&#xA;      city: city.node.acfDetails.city,&#xA;    });&#xA;  });&#xA;&#xA;  const object = [];&#xA;&#xA;  features.nodes.map((feature) =&gt; {&#xA;    return object.push({&#xA;      label: feature.label,&#xA;      value: feature.label,&#xA;    });&#xA;  });&#xA;&#xA;  return {&#xA;    props: {&#xA;      allCampInfo: data,&#xA;      regions: data.regions,&#xA;      camptypes: data.ownerships,&#xA;      object,&#xA;      graphCampgrounds: data.campgrounds.edges,&#xA;      cities,&#xA;      endCursor: data.campgrounds.pageInfo.endCursor,&#xA;    },&#xA;  };&#xA;}&#xA;&#xA;</code></pre>&#xA;",15006497,,,,2021-05-26 00:24:04,"NextJS, Apollo, WPGraphQL & Combining or Retrieving more than 100 Records",<reactjs><graphql><next.js><apollo><wp-graphql>,1,0,0,2021-04-27 22:20:25
67333658,2,,67333512,2,,"<p>To solve the issue:</p>&#xA;<ol>&#xA;<li>navigate to your preferences (settings)</li>&#xA;<li>go to 'Project'</li>&#xA;<li>python interpreter</li>&#xA;<li>click add on the packages list</li>&#xA;<li>in the package manager search for <code>graphene_django</code></li>&#xA;<li>install -&gt; apply</li>&#xA;</ol>&#xA;<p>and you should be good to go.</p>&#xA;<p><a href=""https://i.stack.imgur.com/vINDh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vINDh.png"" alt=""enter image description here"" /></a></p>&#xA;",6689583,,,,2021-04-30 12:10:04,"",,0,0,0,2021-04-30 12:10:04
67339388,1,,,-1,256,"<p>I am having trouble in sending a post requests in python, I want to scrape data of this url <a href=""https://www.wlw.de/de/suche/page/3?employeeCounts=200%2B_50-199&amp;q=verpackungen"" rel=""nofollow noreferrer"">https://www.wlw.de/de/suche/page/3?employeeCounts=200%2B_50-199&amp;q=verpackungen</a></p>&#xA;<p>when you click on load additional button at bottom of this page a post requests is made in network tab&#xA;and I want that post request in python, but it give me an error</p>&#xA;<p>here is my code</p>&#xA;<pre><code>import requests&#xA;&#xA;headers = {&#xA;    'authority':'www.wlw.de',&#xA;    'method':'POST',&#xA;    'path':'/unified_search_backend/graphql',&#xA;    'scheme':'https',&#xA;    'accept':'application/json, text/plain, */*',&#xA;    'accept-encoding':'gzip, deflate, br',&#xA;    'accept-language':'en-US,en;q=0.9',&#xA;    'content-type':'application/graphql',&#xA;    'cookie':'ab_testing_variants=%7B%22adEngine_2021_01%22%3A1%2C%22contact_form_page%22%3A1%2C%2242_mobileBanner_v1%22%3A0%2C%2239_shortProfile_v1%22%3A0%7D; wlw_client_id=rBEAB2BTd2qrtQDuA0v3Ag==; CookieConsent={stamp:%27mZs4JjRbQH+Y5duvSvOezU6hAh/OkfCEvrvzPwHc5dcNcsUiNE7uAQ==%27%2Cnecessary:true%2Cpreferences:true%2Cstatistics:true%2Cmarketing:true%2Cver:4%2Cutc:1616082805877%2Cregion:%27pk%27}; _ga=GA1.2.380141126.1616082808; _hjid=5740f01e-7ac9-4eb6-b4d4-1d6d8eac5a9b; aam_uuid=41781454427930149023915598636228190638; hubspotutk=a2547e1e94388ab650b0b636bdda1f38; _fbp=fb.1.1616082818609.443427339; i18n_redirected=en; ufs_session_id=4b8697cc5b2056f4f67288f7bde39ad2; _gid=GA1.2.1732485982.1619807573; AMCVS_41833DF75A550B4B0A495DA6%40AdobeOrg=1; AMCV_41833DF75A550B4B0A495DA6%40AdobeOrg=359503849%7CMCIDTS%7C18748%7CMCMID%7C41166180535232718843931056836287665940%7CMCAAMLH-1620412373%7C3%7CMCAAMB-1620412373%7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y%7CMCOPTOUT-1619814773s%7CNONE%7CvVersion%7C5.0.1; _hjIncludedInSessionSample=0; _hjTLDTest=1; _hjAbsoluteSessionInProgress=0; axd=4259004108571865363; __hstc=80469576.a2547e1e94388ab650b0b636bdda1f38.1616082816445.1616403237215.1619807575061.3; __hssrc=1; ab_testing_traffic_split_group=explore_b; _gaexp=GAX1.2.8oaBCv1OQnO_Jo4FzYdtxQ.18823.3!yUGcPeeNQI64hKsFDyWxPg.18823.0!vEscdyRLSkWhD-3KR-R8Tw.18823.0!LnHlGkhVTKW8ENYICsLX3w.18832.0!9CUCt3yLQ4eLUOs13vwPsg.18839.0; _gcl_au=1.1.1033109662.1619807603; ufs_tracking_data=%7B%22searchType%22%3A%22ufs%22%2C%22verticalSlug%22%3A%22packaging%22%2C%22concept%22%3A%22Verpackungen%22%2C%22companyPosition%22%3A61%2C%22spaceType%22%3A%22relevance%22%7D; ab_testing_variants_v2=%7B%22adEngine_2021_01%22%3A%7B%22name%22%3A%22ad_engine%22%2C%22dimension%22%3A%22wlwTestGroup%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412717%7D%2C%2239_shortProfile_v1%22%3A%7B%22name%22%3A%22none%22%2C%22dimension%22%3A%22wlwTestGroup3%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412717%7D%2C%2248_connectInSerp%22%3A%7B%22name%22%3A%22connect_funnel%22%2C%22dimension%22%3A%22wlwTestGroup4%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412717%7D%2C%2249_aaTest%22%3A%7B%22name%22%3A%2249_b%22%2C%22dimension%22%3A%22wlwTestGroup8%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412707%7D%2C%2251_exit_intent%22%3A%7B%22name%22%3A%22connect%22%2C%22dimension%22%3A%22wlwTestGroup9%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412707%7D%2C%2250_sidebar%22%3A%7B%22name%22%3A%22new_sidebar%22%2C%22dimension%22%3A%22wlwTestGroup11%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412707%7D%2C%2252_business_section%22%3A%7B%22name%22%3A%22new_business_section%22%2C%22dimension%22%3A%22wlwTestGroup10%22%2C%22active%22%3Atrue%2C%22expiry%22%3A1620412707%7D%7D; wlw_search_term=verpackungen; category_id=93737; __hssc=80469576.6.1619807575061; _gat_UA-38607859-4=1',&#xA;    'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36',&#xA;    'x-application-id':'website_wlw',&#xA;    'x-original-url':'https://www.wlw.de/de/suche?employeeCounts=200%2B_50-199&amp;q=verpackungen',&#xA;    'x-referer':'https://www.wlw.de/de/suche/page/2?employeeCounts=200%2B_50-199&amp;q=verpackungen'&#xA;}&#xA;&#xA;payload = '{&quot;query&quot;:&quot;query(\n        $ufsSessionId: String,\n        $searchMethod: String,\n        $q: String,\n        $conceptSlug: String,\n        $citySlug: String,\n        $filters: [FilterInput!],\n        $page: Int,\n        $sort: String,\n        $tracking: Boolean,\n        $disableCityExtraction: Boolean,\n        $cityExtractionRadius: String\n      ) {\n      search(\n        ufsSessionId: $ufsSessionId,\n        searchMethod: $searchMethod,\n        q: $q,\n        conceptSlug: $conceptSlug,\n        citySlug: $citySlug,\n        filters: $filters,\n        page: $page,\n        sort: $sort,\n        tracking: $tracking,\n        disableCityExtraction: $disableCityExtraction,\n        cityExtractionRadius: $cityExtractionRadius\n      ) {\n        ufsSessionId\n        paging {\n          total, currentPage, totalPages\n        }\n        companies {\n          id, uuid, name, highlightedName, description, highlightedDescription, secondaryHighlightedDescription,\n          homepage, zipcode, city, countryCode, certificates, logoPath, profilePagePath, distance, email,\n          debugData, employeeCount, foundingYear, acronym, customerId, isCustomer, fpaket, spaceType\n          pictures {\n            caption, path, position, sizes\n          }\n          logo {\n            sizes\n          }\n          filterResults {\n            key, title, value, matches\n          }\n          matchingCompanyCategory {\n            id, kpaket, toprankingPosition\n          }\n        }\n        filters {\n          key, name, static, title, type, range {\n            max, min, unit, disabled\n          }\n          values {\n            count, name, title\n          }\n          location {\n            kind\n            defaultRadiuses\n            availableRadiuses {\n              name, count\n            }\n          }\n        }\n        cities {\n          slug, title, count\n        }\n        suggestions {\n          text, score\n        }\n        extractedCity {\n          name, radius\n        }\n        toprankingPositions {\n          companyId, position\n        }\n        companyCategory {\n          id, name\n        }\n        concept {\n          title\n        }\n        recommendations {\n          text, score, slug\n        }\n        canonicalConceptSlug\n        canonicalCompanyCategorySlug\n        conceptSlugTitle\n        companyCategorySlugTitle\n        verticalSlug\n        citySlugTitle\n        seoTextHtml\n        debugData\n      }\n    }&quot;,&quot;variables&quot;:{&quot;ufsSessionId&quot;:&quot;4b8697cc5b2056f4f67288f7bde39ad2&quot;,&quot;searchMethod&quot;:&quot;direct&quot;,&quot;locale&quot;:&quot;de&quot;,&quot;q&quot;:&quot;verpackungen&quot;,&quot;filters&quot;:[{&quot;name&quot;:&quot;Mitarbeiteranzahl&quot;,&quot;selected&quot;:[&quot;200+&quot;,&quot;50-199&quot;]}],&quot;page&quot;:1,&quot;sort&quot;:&quot;ad_engine&quot;,&quot;tracking&quot;:true,&quot;disableCityExtraction&quot;:false,&quot;cityExtractionRadius&quot;:&quot;50km&quot;}}'&#xA;url = 'https://www.wlw.de/unified_search_backend/graphql'&#xA;&#xA;r = requests.post(url, headers=headers, data=json.dumps(payload))&#xA;r.content&#xA;Out[34]: b'{&quot;errors&quot;:[{&quot;message&quot;:&quot;No query string was present&quot;}]}'&#xA;</code></pre>&#xA;",15415344,,,,2021-08-03 09:46:46,Graphql queries error in python post requests,<python><web-scraping><python-requests><graphql><data-mining>,2,1,0,2021-04-30 19:19:55
67368450,1,67369022,,0,153,"<p>I am using AWS appsync for graphql server and have schema like:</p>&#xA;<pre><code>type Order {&#xA;  id: ID!&#xA;  price: Int&#xA;  refundAmount: Int&#xA;  period: String!&#xA;}&#xA;  &#xA;&#xA;query orders (userId: ID!) [Order]&#xA;&#xA;</code></pre>&#xA;<p>It is to support query orders based on user id. It responses an array of orders for different <code>time period</code>. The response could be:</p>&#xA;<pre><code>[{&#xA;  id: xxx&#xA;  price: 100&#xA;  refundAmount: 10&#xA;  period: '2021-01-01'&#xA;},{&#xA;  id: xxx&#xA;  price: 200&#xA;  refundAmount: 0&#xA;  period: '2021-01-03'&#xA;},&#xA;...&#xA;]&#xA;</code></pre>&#xA;<p>If the price and refundAmount in the <code>period</code> is 0, I won't response empty element in the array. In the above example, there is price and refundAmount on <code>2021-01-02</code>, so there is no such element in the array.</p>&#xA;<p>My problem is how can I response the data based on what frontend queries? If customer only query <code>refundAmount</code> field in the response, I don't want to response <code>2021-01-03</code> period. How do I know what fields frontend wants to show in the response?</p>&#xA;<p>e.g.</p>&#xA;<p>If clients send this query:</p>&#xA;<pre><code>query {&#xA;   orders (userId: &quot;someUserId&quot;) {&#xA;      refundAmount&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>I will response below data but I don't want the second one to be there since the value is 0.</p>&#xA;<pre><code>[{&#xA;  id: xxx&#xA;  refundAmount: 10&#xA;  period: '2021-01-01'&#xA;},{&#xA;  id: xxx&#xA;  refundAmount: 0&#xA;  period: '2021-01-03'&#xA;}&#xA;]&#xA;</code></pre>&#xA;",5421539,,5421539,2021-05-03 13:23:59,2021-05-04 00:56:10,How can I response to client based on what fields they are querying in graphql?,<graphql><aws-appsync>,1,2,0,2021-05-03 11:50:15
67369022,2,,67368450,0,,"<blockquote>&#xA;<p>My problem is how can I response the data based on what frontend&#xA;queries?</p>&#xA;</blockquote>&#xA;<p>GraphQL will do that out of the box for you provided you have the resolvers for the fields in the query. Look at <a href=""https://docs.aws.amazon.com/appsync/latest/devguide/tutorials.html"" rel=""nofollow noreferrer"">appropriate resolver</a> based on your underlying data source.</p>&#xA;<blockquote>&#xA;<p>How do I know what fields frontend wants to show in the response?</p>&#xA;</blockquote>&#xA;<p>This is what the frontend decides, it can send a different query based on the fields it is interested. A few examples below.</p>&#xA;<p>If the frontend is interested in only one field i.e. <code>refundAmount</code>, then it would send a query something like this.</p>&#xA;<pre><code>query {&#xA;   orders (userId: &quot;someUserId&quot;) {&#xA;      refundAmount&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>If it is interested in more than 1 field say <code>price</code> and <code>refundAmount</code> then the query would be something like this</p>&#xA;<pre><code>query {&#xA;   orders (userId: &quot;someUserId&quot;) {&#xA;      price,&#xA;      refundAmount&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>Update: Filter response:</p>&#xA;<p>Now based on the updated question, you need to enhance your resolver to do this additional filtering.</p>&#xA;<ul>&#xA;<li>The resolver can do this filtering always (Kind of hard coded like refundAmount &gt; 0 )</li>&#xA;<li>Support a filter criteria in the query model <code>query orders (userId: ID!, OrderFilterInput) [Order]</code> and the define the criteria based on which you want to filter. Then support those filter criteria in the resolvers to query the underlying data source. Also take the filter criteria from the client.</li>&#xA;</ul>&#xA;<p>Look at the <code>ModelPostFilterInput</code> generated model on <a href=""https://docs.amplify.aws/cli/graphql-transformer/model#generates"" rel=""nofollow noreferrer"">this</a> example.</p>&#xA;<p>Edit 2: Adds changed Schema for a filter</p>&#xA;<p>Let's say you change your Schema to support filtering and there is no additional VTL request/response mappers and you directly talk to a Lambda.</p>&#xA;<p>So this is how the Schema would look like (of course you would have your mutations and subscriptions and are omitted here.)</p>&#xA;<pre><code>input IntFilterInput { # This is all the kind of filtering you want to support for Int data types&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;}&#xA;&#xA;type Order {&#xA;    id: ID!&#xA;    price: Int&#xA;    refundAmount: Int&#xA;    period: String!&#xA;}&#xA;&#xA;input OrderFilterInput { # This only supports filter by refundAmount. You can add more filters if you need them.&#xA;    refundAmount: IntFilterInput&#xA;}&#xA;&#xA;type Query {&#xA;    orders(userId: ID!, filter: OrderFilterInput): [Order] # Here you add an optional filter input&#xA;}&#xA;&#xA;schema {&#xA;    query: Query&#xA;}&#xA;</code></pre>&#xA;<p>Let's say you attached the Lambda resolver at the Query <code>orders</code>.&#xA;In this case, the Lambda would need to return an array/list of Orders.</p>&#xA;<p>If you are further sending this query to some table/api, you need to understand the filter, and create an appropriate query or api call for the downstream system.</p>&#xA;<p>I showing a simple Lambda with hard coded response. If we bring in the Filter, this is what changes.</p>&#xA;<pre><code>const getFilterFunction = (operator, key, value) =&gt; {&#xA;    switch (operator) {&#xA;        case &quot;ne&quot;:&#xA;            return x =&gt; x[key] != value&#xA;        case &quot;eq&quot;:&#xA;            return x =&gt; x[key] == value&#xA;        case &quot;le&quot;:&#xA;            return x =&gt; x[key] &lt;= value&#xA;        case &quot;lt&quot;:&#xA;            return x =&gt; x[key] &lt; value&#xA;        case &quot;ge&quot;:&#xA;            return x =&gt; x[key] &gt;= value&#xA;        case &quot;gt&quot;:&#xA;            return x =&gt; x[key] &gt; value&#xA;        default:&#xA;            throw Error(&quot;Unsupported filter operation&quot;);&#xA;    }&#xA;}&#xA;&#xA;&#xA;exports.handler = async(event) =&gt; {&#xA;&#xA;    let response = [{&#xA;        &quot;id&quot;: &quot;xxx1&quot;,&#xA;        &quot;refundAmount&quot;: 10,&#xA;        &quot;period&quot;: '2021-01-01'&#xA;    }, {&#xA;        &quot;id&quot;: &quot;xxx2&quot;,&#xA;        &quot;refundAmount&quot;: 0,&#xA;        &quot;period&quot;: '2021-01-03'&#xA;    }]&#xA;    const filter = event.arguments.filter; &#xA;    if (filter) { // If possible send the filter to your downstream system rather handling in the Lambda&#xA;        if (filter.refundAmount) {&#xA;            const refundAmountFilters = Object.keys(filter.refundAmount)&#xA;                .map(operator =&gt; getFilterFunction(operator + &quot;&quot;, &quot;refundAmount&quot;, filter.refundAmount[operator]));&#xA;            refundAmountFilters.forEach(filterFunction =&gt; { response = response.filter(filterFunction) });&#xA;        }&#xA;    }&#xA;&#xA;    return response; // You don't have to return individual fields the query asks for. It is taken care by AppSync. Just return a list of orders.&#xA;};&#xA;</code></pre>&#xA;<p>With the above in place, you can send various queries like</p>&#xA;<pre><code>query MyQuery {&#xA;  orders(userId: &quot;1&quot;) { #without any filters&#xA;    id&#xA;    refundAmount&#xA;  }&#xA;}&#xA;&#xA;query MyQuery {&#xA;  orders(userId: &quot;1&quot;, filter: {refundAmount: {ne: 0}}) { # The filter you are interested&#xA;    id&#xA;    refundAmount&#xA;  }&#xA;}&#xA;&#xA;query MyQuery {&#xA;  orders(userId: &quot;1&quot;, filter: {refundAmount: {ne: 0, gt: 5}}) { # Mix and Match filters&#xA;    id&#xA;    refundAmount&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>You don't have to support all the operators for filtering and you can focus only on <code>ne</code> or <code>!=</code> and further simplify things. Look at <a href=""https://www.apollographql.com/blog/graphql-search-and-filter-how-to-search-and-filter-results-with-graphql/"" rel=""nofollow noreferrer"">this</a> blog for a more simple version where the filter operation is assumed.</p>&#xA;<p>Finally the other possibility to filter without modifying the Schema is to change your Lambda only to ensure it returns a filtered set of results either doing the filtering itself or sending an appropriate query/request to the underlying system to do the filtering.</p>&#xA;",4601120,,4601120,2021-05-04 00:56:10,2021-05-04 00:56:10,"",,0,8,0,2021-05-03 12:35:53
67375783,1,,,0,154,"<p>I would appreciate any help that I can get with this</p>&#xA;<p>I need to plot a pie chart with 4 standard pies: ABC, BCD, CDE and DEF&#xA;Each Pie has a data point coming in from my GraphiQL resolver which looks like this:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>{&#xA;  ""data"": {&#xA;    ""metrics"": {&#xA;      ""A"": 56147.85,&#xA;      ""B"": 116480.51,&#xA;      ""C"": 56147.85,&#xA;      ""D"": 120329.45000000001,&#xA;    }&#xA;  }&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p><strong>This is my highchart code for piechart</strong></p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>function PieChart() {&#xA;  const { loading, error, data } = useQuery(CONC, {&#xA;    variables: {&#xA;      Currency: 'USD',&#xA;      Date: {&#xA;        date: '2019-05-01',&#xA;        date_range: ['2019-05-01', '2019-06-10'],&#xA;      },&#xA;      Options: {&#xA;        a: {&#xA;          prop: '44',&#xA;          csprop: ['14', '14', '40', '60'],&#xA;        },&#xA;        d: {&#xA;          prop: '104',&#xA;          csprop: ['511', '289', '519', '62'],&#xA;        },&#xA;      },&#xA;      C: 'G',&#xA;      Incl: false,&#xA;      DFilters: [&#xA;        {&#xA;          by: 'P',&#xA;          values: [],&#xA;        },&#xA;      ],&#xA;    },&#xA;  });&#xA;&#xA;  const Top = [];&#xA;  const First = [];&#xA;  const Second = [];&#xA;  const Rest = [];&#xA;&#xA;  data &amp;&amp;&#xA;    data.metrics.forEach((e) =&gt; {&#xA;      Top.push(e['A']);&#xA;      First.push(e['B']);&#xA;      Second.push(e['C']);&#xA;      Rest.push(e['D']);&#xA;    });&#xA;&#xA;  return (&#xA;    &lt;HighchartWrapper&#xA;      chartOptions={{&#xA;        chart: {&#xA;          type: 'pie',&#xA;          height: 230,&#xA;          // width: 565,         &#xA;        },&#xA;        title: {&#xA;          text: '',&#xA;        },&#xA;        tooltip: {&#xA;          pointFormat: '{series.name}: &lt;b&gt;{point.percentage:.1f}%&lt;/b&gt;',&#xA;        },&#xA;        accessibility: {&#xA;          point: {&#xA;            valueSuffix: '%',&#xA;          },&#xA;        },&#xA;        exporting: {&#xA;          enabled: false,&#xA;        },&#xA;        plotOptions: {&#xA;          pie: {&#xA;            allowPointSelect: true,&#xA;            cursor: 'pointer',&#xA;            dataLabels: {&#xA;              enabled: true,&#xA;              format: '&lt;b&gt;{point.name}&lt;/b&gt;: {point.percentage:.1f} %',&#xA;            },&#xA;          },&#xA;        },&#xA;&#xA;        series: [&#xA;          {&#xA;            name: 'R',&#xA;            data: [&#xA;              { name: 'ABC', y: Top},            &#xA;              { name: 'BCD', y: First},&#xA;              { name: 'CDE', y: Second},&#xA;                { name: 'DEF', y: Rest},&#xA;            ],&#xA;          },&#xA;        ],&#xA;      }}&#xA;    /&gt;&#xA;  );&#xA;}&#xA;&#xA;export default memo(PieChart);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p><strong>PROBLEM:</strong></p>&#xA;<p>The GraphiQL query is generating results.</p>&#xA;<p>But I believe it's the way I am trying to push data that's giving me an empty pie chart</p>&#xA;<p>Thank you all in advance</p>&#xA;",13047607,,,,2021-05-03 21:02:49,How to add this GraphQL data to my pie chart in highcharts?,<reactjs><highcharts><graphql><react-highcharts>,0,7,0,2021-05-03 21:02:49
67411617,2,,51526079,0,,"<p><strong>Try do filter with lower case 'or'</strong></p>&#xA;<p>filter: { or: [{brand: { eq: $normalBrand }}, {brand: { eq: $normalBrand2 }},{brand: { eq: $normalBrand3 }}]}</p>&#xA;",14610073,,,,2021-05-06 03:53:36,"",,0,0,0,2021-05-06 03:53:36
67427386,2,,67425745,3,,"<p>With GraphQL, you have to select every scalar field that you want. So far, you have selected the scalar fields of <code>Issue.title</code> and <code>Issue.createdAt</code>. Comments, however, are not &quot;scalar values&quot; -- they're objects -- so to get anything out of them, you have to request deeply into the objects all the way to the scalar values.</p>&#xA;<p>Additionally, Comments are a <a href=""https://www.apollographql.com/docs/react/pagination/overview/"" rel=""nofollow noreferrer"">paginated connection</a>, so you also have to define how many you want back and go deep into the connection to get to the &quot;node&quot;, which is the object you actually want:</p>&#xA;<pre><code>query {&#xA;  repository(name:&quot;reponame&quot;, owner: &quot;ownername&quot;) {&#xA;    issue(number: 2) {&#xA;      title&#xA;      createdAt&#xA;      # first 10 results&#xA;      comments(first: 10) {&#xA;        # edges.node is where the actual `Comment` object is&#xA;        edges {&#xA;          node {&#xA;            author {&#xA;              avatarUrl&#xA;            }&#xA;            body&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",652728,,,,2021-05-06 23:58:23,"",,0,0,0,2021-05-06 23:58:23
67430279,1,67457889,,0,1141,"<p>I am implementing a webpage with React and AWS Amplify.</p>&#xA;<p>I have the following definition in my <code>schema.graphql</code> file:</p>&#xA;<pre><code>type Calendar @model {&#xA;  id: ID!&#xA;  name: String&#xA;  description: String&#xA;  url: String!&#xA;  intervals: [Interval] @connection(keyName: &quot;byCalendar&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>I would like to get a calendar from its URL string. Unfortunately, the following code throws an error:</p>&#xA;<pre><code>import { API, graphqlOperation } from &quot;aws-amplify&quot;;&#xA;import * as queries from &quot;../../graphql/queries&quot;;&#xA;&#xA;await API.graphql(graphqlOperation(queries.getCalendar, { url: &quot;some-url&quot;}));&#xA;</code></pre>&#xA;<p><code>Variable &quot;$id&quot; of required type &quot;ID!&quot; was not provided.</code></p>&#xA;<p>From the error, providing the id is mandatory. However, I would like to be able to get an object from just the url.</p>&#xA;<p>How can I do that?</p>&#xA;<p>I am using the queries automatically generated by the amplify's cli.</p>&#xA;<pre><code>/* eslint-disable */&#xA;// this is an auto generated file. This will be overwritten&#xA;&#xA;export const getCalendar = /* GraphQL */ `&#xA;  query GetCalendar($id: ID!) {&#xA;    getCalendar(id: $id) {&#xA;      id&#xA;      name&#xA;      description&#xA;      url&#xA;      intervals {&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listCalendars = /* GraphQL */ `&#xA;  query ListCalendars(&#xA;    $filter: ModelCalendarFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listCalendars(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        description&#xA;        url&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",3904557,,3904557,2021-05-07 07:04:56,2021-06-07 15:17:54,Amplify GraphQL get item from other field than ID,<reactjs><graphql><aws-amplify>,1,0,0,2021-05-07 06:56:13
67448385,2,,67445106,0,,<p>I figured it out. I have used the following code.</p>&#xA;<pre><code>const listCountries = gql`&#xA;            query listCountries {&#xA;              listCountrys(filter: {country_id: {eq: ${countryData.country_id}}}) {&#xA;                items {&#xA;                  id&#xA;                  country_id&#xA;                  country_name&#xA;                  _deleted&#xA;                }&#xA;              }&#xA;            }&#xA;          `;&#xA;</code></pre>&#xA;,10123373,,,,2021-05-08 14:02:30,"",,0,0,0,2021-05-08 14:02:30
67449773,1,72747773,,2,415,"&#xA;<p>Hello</p>&#xA;<p>When I perform my mutation to create a product, I get the following error: <code>Array to string conversion</code>. Full log stack <a href=""https://gist.github.com/SirMishaa/410c2c2e6a973f2ccc91d41be1548ddd"" rel=""nofollow noreferrer"">here</a></p>&#xA;<p>For the context, to create a <code>product</code>, it is mandatory to create / associate a <code>brand</code> and a <code>category</code>. You can also specify a <code>user</code> who submitted the product but it is not mandatory.</p>&#xA;<p>I have tried to understand the error and find solutions but I really can't find the origin of this problem.</p>&#xA;<p>Here's my schema :</p>&#xA;<pre><code>   type mutation {&#xA;      # create_brand ... (crud)&#xA;      # create_product_category ... (crud)&#xA;      &#xA;      create_product(input: CreateProductInput! @spread): Product! @create&#xA;      update_product(input: UpdateProductInput! @spread): Product! @update&#xA;      remove_product(id: ID!): Product! @delete&#xA;    }&#xA;    &#xA;  input CreateProductCategoryInput {&#xA;    name: String!&#xA;   }&#xA; &#xA; input CreateBrandInput {&#xA;    name: String!&#xA;   }&#xA;    &#xA;  input CreateProductInput {&#xA;    name: String!&#xA;    # ....&#xA;&#xA;    submitted_by: CreateUserBelongsTo&#xA;    brand: CreateBrandBelongsTo!&#xA;    product_category: CreateProductCategoryBelongsTo!&#xA;  }&#xA;&#xA; input CreateBrandBelongsTo {&#xA;    connect: ID&#xA;    create: CreateBrandInput&#xA;    update: UpdateBrandInput&#xA;    disconnect: Boolean&#xA;    delete: Boolean&#xA;  }&#xA;&#xA;input CreateProductCategoryBelongsTo {&#xA;    connect: ID&#xA;    create: CreateProductCategoryInput&#xA;    update: UpdateProductCategoryInput&#xA;    disconnect: Boolean&#xA;    delete: Boolean&#xA;  }&#xA;</code></pre>&#xA;<p>I tried without specify <code>submitted_by</code> which is optional.&#xA;My GraphQL request is executed like that :</p>&#xA;<pre><code>mutation($createProductInput: CreateProductInput!) {&#xA;  create_product(input: $createProductInput) {&#xA;    name&#xA;    description&#xA;    brand {&#xA;      name&#xA;    }&#xA;    product_category {&#xA;      name&#xA;    }&#xA;    submitted_by {&#xA;      username&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And here's, variables of the graphql request :</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;createProductInput&quot;: {&#xA;    &quot;name&quot;: &quot;RTX 3090&quot;,&#xA;    &quot;release_date&quot;: &quot;2022-05-08T15:26:35+01:00&quot;,&#xA;    &quot;cover_image&quot;: &quot;https://s3.rekk.app/media/rtx.png&quot;,&#xA;    &quot;description&quot;: &quot;Description here&quot;,&#xA;    &quot;brand&quot;: {&#xA;      &quot;create&quot;: {&quot;name&quot;: &quot;NVIDIA&quot;}&#xA;    },&#xA;    &quot;product_category&quot;: {&#xA;      &quot;create&quot;: {&quot;name&quot;: &quot;Graphical Card&quot;}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><code>Product</code>, <code>ProductCategory</code> and <code>Brand</code> models can be found here if needed : <a href=""https://gist.github.com/SirMishaa/987fd95255dee9fe19d2cba5b1d20e25"" rel=""nofollow noreferrer"">https://gist.github.com/SirMishaa/987fd95255dee9fe19d2cba5b1d20e25</a></p>&#xA;&#xA;<p><strong>Expected behavior/Solution</strong></p>&#xA;&#xA;<p><strong>Output/Logs</strong></p>&#xA;Click to expand&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;debugMessage&quot;: &quot;Array to string conversion&quot;,&#xA;      &quot;message&quot;: &quot;Internal server error&quot;,&#xA;      &quot;extensions&quot;: {&#xA;        &quot;category&quot;: &quot;internal&quot;&#xA;      },&#xA;      &quot;locations&quot;: [&#xA;        {&#xA;          &quot;line&quot;: 2,&#xA;          &quot;column&quot;: 3&#xA;        }&#xA;      ],&#xA;      &quot;path&quot;: [&#xA;        &quot;create_product&quot;&#xA;      ],&#xA;      &quot;trace&quot;: [&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Support/Str.php&quot;,&#xA;          &quot;line&quot;: 524,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Bootstrap\\HandleExceptions::handleError()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/QueryException.php&quot;,&#xA;          &quot;line&quot;: 57,&#xA;          &quot;call&quot;: &quot;Illuminate\\Support\\Str::replaceArray()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/QueryException.php&quot;,&#xA;          &quot;line&quot;: 40,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\QueryException::formatMessage()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Connection.php&quot;,&#xA;          &quot;line&quot;: 679,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\QueryException::__construct()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Connection.php&quot;,&#xA;          &quot;line&quot;: 638,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Connection::runQueryCallback()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Connection.php&quot;,&#xA;          &quot;line&quot;: 472,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Connection::run()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Connection.php&quot;,&#xA;          &quot;line&quot;: 424,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Connection::statement()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Query/Builder.php&quot;,&#xA;          &quot;line&quot;: 2838,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Connection::insert()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Builder.php&quot;,&#xA;          &quot;line&quot;: 1560,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Query\\Builder::insert()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php&quot;,&#xA;          &quot;line&quot;: 1028,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Eloquent\\Builder::__call()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php&quot;,&#xA;          &quot;line&quot;: 858,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Eloquent\\Model::performInsert()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Execution/Arguments/SaveModel.php&quot;,&#xA;          &quot;line&quot;: 76,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Eloquent\\Model::save()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Execution/Arguments/ResolveNested.php&quot;,&#xA;          &quot;line&quot;: 36,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Execution\\Arguments\\SaveModel::__invoke()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/MutationExecutorDirective.php&quot;,&#xA;          &quot;line&quot;: 89,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Execution\\Arguments\\ResolveNested::__invoke()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Support/Utils.php&quot;,&#xA;          &quot;line&quot;: 98,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\MutationExecutorDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/MutationExecutorDirective.php&quot;,&#xA;          &quot;line&quot;: 91,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Support\\Utils::applyEach()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/MutationExecutorDirective.php&quot;,&#xA;          &quot;line&quot;: 40,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\MutationExecutorDirective::executeMutation()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Database/Concerns/ManagesTransactions.php&quot;,&#xA;          &quot;line&quot;: 29,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\MutationExecutorDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/MutationExecutorDirective.php&quot;,&#xA;          &quot;line&quot;: 52,&#xA;          &quot;call&quot;: &quot;Illuminate\\Database\\Connection::transaction()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/RenameArgsDirective.php&quot;,&#xA;          &quot;line&quot;: 33,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\MutationExecutorDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/SpreadDirective.php&quot;,&#xA;          &quot;line&quot;: 34,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\RenameArgsDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/ArgTraversalDirective.php&quot;,&#xA;          &quot;line&quot;: 29,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\SpreadDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Validation/ValidateDirective.php&quot;,&#xA;          &quot;line&quot;: 60,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\ArgTraversalDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/ArgTraversalDirective.php&quot;,&#xA;          &quot;line&quot;: 29,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Validation\\ValidateDirective::Nuwave\\Lighthouse\\Validation\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Directives/TrimDirective.php&quot;,&#xA;          &quot;line&quot;: 56,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\ArgTraversalDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Schema/Factories/FieldFactory.php&quot;,&#xA;          &quot;line&quot;: 92,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Directives\\TrimDirective::Nuwave\\Lighthouse\\Schema\\Directives\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 624,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Schema\\Factories\\FieldFactory::Nuwave\\Lighthouse\\Schema\\Factories\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 550,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::resolveFieldValueOrError()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 474,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::resolveField()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 858,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::GraphQL\\Executor\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::GraphQL\\Executor\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 860,&#xA;          &quot;function&quot;: &quot;array_reduce()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 490,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::promiseReduce()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 263,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::executeFieldsSerially()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/ReferenceExecutor.php&quot;,&#xA;          &quot;line&quot;: 215,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::executeOperation()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/Executor/Executor.php&quot;,&#xA;          &quot;line&quot;: 156,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\ReferenceExecutor::doExecute()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 162,&#xA;          &quot;call&quot;: &quot;GraphQL\\Executor\\Executor::promiseToExecute()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/webonyx/graphql-php/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 94,&#xA;          &quot;call&quot;: &quot;GraphQL\\GraphQL::promiseToExecute()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 194,&#xA;          &quot;call&quot;: &quot;GraphQL\\GraphQL::executeQuery()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 145,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\GraphQL::executeQuery()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 112,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\GraphQL::executeOperation()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Support/Utils.php&quot;,&#xA;          &quot;line&quot;: 98,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\GraphQL::Nuwave\\Lighthouse\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/GraphQL.php&quot;,&#xA;          &quot;line&quot;: 111,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Support\\Utils::applyEach()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Support/Http/Controllers/GraphQLController.php&quot;,&#xA;          &quot;line&quot;: 32,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\GraphQL::executeOperationOrOperations()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php&quot;,&#xA;          &quot;line&quot;: 48,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Controllers\\GraphQLController::__invoke()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Route.php&quot;,&#xA;          &quot;line&quot;: 254,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\ControllerDispatcher::dispatch()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Route.php&quot;,&#xA;          &quot;line&quot;: 197,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Route::runController()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Router.php&quot;,&#xA;          &quot;line&quot;: 695,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Route::run()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 128,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Router::Illuminate\\Routing\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Support/Http/Middleware/AttemptAuthentication.php&quot;,&#xA;          &quot;line&quot;: 32,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Middleware\\AttemptAuthentication::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/nuwave/lighthouse/src/Support/Http/Middleware/AcceptJson.php&quot;,&#xA;          &quot;line&quot;: 27,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Nuwave\\Lighthouse\\Support\\Http\\Middleware\\AcceptJson::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 103,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Router.php&quot;,&#xA;          &quot;line&quot;: 697,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::then()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Router.php&quot;,&#xA;          &quot;line&quot;: 672,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Router::runRouteWithinStack()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Router.php&quot;,&#xA;          &quot;line&quot;: 636,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Router::runRoute()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Routing/Router.php&quot;,&#xA;          &quot;line&quot;: 625,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Router::dispatchToRoute()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php&quot;,&#xA;          &quot;line&quot;: 166,&#xA;          &quot;call&quot;: &quot;Illuminate\\Routing\\Router::dispatch()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 128,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel::Illuminate\\Foundation\\Http\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php&quot;,&#xA;          &quot;line&quot;: 21,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php&quot;,&#xA;          &quot;line&quot;: 31,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php&quot;,&#xA;          &quot;line&quot;: 21,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php&quot;,&#xA;          &quot;line&quot;: 40,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\TrimStrings::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ValidatePostSize.php&quot;,&#xA;          &quot;line&quot;: 27,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php&quot;,&#xA;          &quot;line&quot;: 86,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/fruitcake/laravel-cors/src/HandleCors.php&quot;,&#xA;          &quot;line&quot;: 52,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Fruitcake\\Cors\\HandleCors::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/fideloper/proxy/src/TrustProxies.php&quot;,&#xA;          &quot;line&quot;: 57,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 167,&#xA;          &quot;call&quot;: &quot;Fideloper\\Proxy\\TrustProxies::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php&quot;,&#xA;          &quot;line&quot;: 103,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::Illuminate\\Pipeline\\{closure}()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php&quot;,&#xA;          &quot;line&quot;: 141,&#xA;          &quot;call&quot;: &quot;Illuminate\\Pipeline\\Pipeline::then()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php&quot;,&#xA;          &quot;line&quot;: 110,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel::sendRequestThroughRouter()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/public/index.php&quot;,&#xA;          &quot;line&quot;: 52,&#xA;          &quot;call&quot;: &quot;Illuminate\\Foundation\\Http\\Kernel::handle()&quot;&#xA;        },&#xA;        {&#xA;          &quot;file&quot;: &quot;/var/www/html/server.php&quot;,&#xA;          &quot;line&quot;: 21,&#xA;          &quot;function&quot;: &quot;require_once('/var/www/html/public/index.php')&quot;&#xA;        }&#xA;      ]&#xA;    }&#xA;  ],&#xA;  &quot;data&quot;: null&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Versions</strong></p>&#xA;<ul>&#xA;<li>Lighthouse  : <code>^5.3</code> (I guess, it's using the <code>5.8.3</code>)</li>&#xA;<li>Laravel : <code>^8.12</code> (8.40)</li>&#xA;</ul>&#xA;",10230961,,,,2022-06-24 17:57:54,Array to string conversion even with types hinting in Laravel Lighthouse,<php><laravel><eloquent><graphql><laravel-lighthouse>,1,1,0,2021-05-08 16:25:49
67450312,2,,66704089,0,,"<pre><code> async findKitsWithResultNoReg() {&#xA;      try {&#xA;        const a0 = await sequelize.query(`SELECT kitID, result, resultDate from kits where result in (1,2,3) and cp = 0 and archived = 0 and not Exists(select kitID from users where kits.kitID = users.kitID) order by resultDate desc`,  { type: QueryTypes.SELECT })&#xA;        const a1 = JSON.stringify(a0)&#xA;        return a1&#xA;      } catch (error) {&#xA;        console.log(error)&#xA;      }&#xA;    },&#xA;</code></pre>&#xA;",14366549,,,,2021-05-08 17:24:48,"",,0,0,0,2021-05-08 17:24:48
67457361,2,,67436930,0,,"<blockquote>&#xA;<p>I have the same problem in the backend...</p>&#xA;</blockquote>&#xA;<p>It looks like you're responsible for API, too.</p>&#xA;<p>Your API should:</p>&#xA;<ul>&#xA;<li>use meaningful names:&#xA;<ul>&#xA;<li>an <code>isProofread</code> should be a prop [of entry];</li>&#xA;</ul>&#xA;</li>&#xA;<li><strong>definitely handle</strong> <code>undefined</code> - <strong>lack of value is a value/state, too</strong>:&#xA;<ul>&#xA;<li>e.g. <code>if (undefined != args.proofread) filters['proofread'] = args.proofread;</code></li>&#xA;</ul>&#xA;</li>&#xA;<li>support <code>where</code> variable/arg/condition:&#xA;<ul>&#xA;<li><code>where:{ proofread: { eq: false } }</code>;</li>&#xA;<li><code>where:{ proofread: { in: [false, true] } }</code> - equal to <code>undefined</code>;</li>&#xA;</ul>&#xA;</li>&#xA;</ul>&#xA;",6124657,,,,2021-05-09 11:50:18,"",,0,0,0,2021-05-09 11:50:18
67457889,2,,67430279,4,,"<p>Found the solution. I had to add a &quot;byURL&quot; key to the model like so:</p>&#xA;<pre><code>type Calendar @model @key(name: &quot;byURL&quot;, fields: [&quot;url&quot;, &quot;id&quot;], queryField: &quot;calendarByURL&quot;) {&#xA;    id: ID!&#xA;    name: String&#xA;    description: String&#xA;    url: String&#xA;    intervals: [Interval] @connection(keyName: &quot;byCalendar&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>Then write a custom query using that new key (or have amplify to regenerate the queries based on the updated schema.graphql file):</p>&#xA;<pre><code>export const getCalendarByURL = /* GraphQL */ `&#xA;    query calendarByURL($url: String!) {&#xA;        calendarByURL(url: $url) {&#xA;            items {&#xA;                id&#xA;                name&#xA;                description&#xA;                url&#xA;                intervals {&#xA;                    nextToken&#xA;                }&#xA;                createdAt&#xA;                updatedAt&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>And this would let me do:</p>&#xA;<pre><code>await API.graphql(graphqlOperation(customQueries.getCalendarByURL, { url: &quot;some-url&quot;}));&#xA;</code></pre>&#xA;",3904557,,3904557,2021-05-09 12:55:42,2021-05-09 12:55:42,"",,0,0,0,2021-05-09 12:48:55
67480751,2,,67478678,0,,"<p>Simply use:</p>&#xA;<pre><code>query MyQuery {&#xA;  mKT(data: {filter: {name: {eq: &quot;Apple&quot;}}}) {&#xA;    data {&#xA;      name&#xA;      description&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The <code>filter</code> keyword should do the trick.</p>&#xA;<p>Check the <a href=""https://www.gatsbyjs.com/docs/graphql-reference/"" rel=""nofollow noreferrer"">GraphQL Reference (in Gatsby docs)</a> for further details.</p>&#xA;",5585371,,5585371,2021-05-11 05:59:05,2021-05-11 05:59:05,"",,0,2,0,2021-05-11 04:53:26
67506150,2,,67502148,1,,"<p>Amplify, and really DynamoDB in general, requires you to think about your access patterns ahead of time. There is a lot of really good information out there to help guide you through what this thought process can look like. Particularly, I like Nader Dabit's <a href=""https://dev.to/dabit3/data-modeling-in-depth-with-graphql-aws-amplify-17-data-access-patterns-4meh"" rel=""nofollow noreferrer"">https://dev.to/dabit3/data-modeling-in-depth-with-graphql-aws-amplify-17-data-access-patterns-4meh</a></p>&#xA;<p>At first glance, I think I would add a new @key called byCountry to the User model, which will create a new Global Secondary Index on that property for you in DDB and will give you some new query methods as well. Check out <a href=""https://docs.amplify.aws/cli/graphql-transformer/key#designing-data-models-using-key"" rel=""nofollow noreferrer"">https://docs.amplify.aws/cli/graphql-transformer/key#designing-data-models-using-key</a> for more examples.</p>&#xA;<p>Once you have User.getByCountry in place, you should then be able to also bring back each user's Feedbacks.</p>&#xA;<pre><code>query USAUsersWithFeedbacks {&#xA;  listUsersByCountry(country: &quot;USA&quot;) {&#xA;    items {&#xA;      feedbacks {&#xA;        items {&#xA;          content&#xA;        }&#xA;        nextToken&#xA;      }&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Finally, you can use JavaScript to fetch all while the nextToken is not null. You will be able to re-use this function for each country you are interested in and you should be able to extend this example for other properties by adding additional @keys.</p>&#xA;",3149835,,3149835,2021-05-13 20:54:31,2021-05-13 20:54:31,"",,0,3,0,2021-05-12 14:59:36
67554184,2,,67502148,0,,"<p>Ok thanks to <a href=""https://stackoverflow.com/users/3149835/alex"">@alex</a>'s answers I implemented the following. The idea is instead of listing Feedbacks and trying to filter them by User fields, we list Users and collect their Feedbacks from the response:</p>&#xA;<ol>&#xA;<li><p>Updated schema.graphql as follows:</p>&#xA;<pre><code> type User&#xA;     @model&#xA;     @auth(rules: [{ allow: owner }])&#xA;     @key(name: &quot;byRegion&quot;, fields: [&quot;region&quot;], queryField: &quot;userByRegion&quot;) # &lt;-- added byRegion key {&#xA;     id: ID!&#xA;     email: String!&#xA;     name: String!&#xA;     region: String!&#xA;     sector: String!&#xA;     companyType: String!&#xA;     feedbacks: [Feedback] @connection # &lt;-- added feedbacks connection&#xA; }&#xA;</code></pre>&#xA;</li>&#xA;<li><p>Added userFeedbacksId parameter while calling CreateFeedback. So they will appear while listing Users.</p>&#xA;</li>&#xA;<li><p>Added custom query UserByRegionWithFeedback under src/graphql/custom-queries.graphl and used amplify codegen to build it:</p>&#xA;<pre><code> query UserByRegionWithFeedback(&#xA;     $region: String&#xA;     $sortDirection: ModelSortDirection&#xA;     $filter: ModelUserFilterInput&#xA;     $limit: Int&#xA;     $nextToken: String # &lt;-- nextToken for getting more Users&#xA;     $nextTokenFeedback: String # &lt;-- nextToken for getting more Feedbacks&#xA;    ) {&#xA;     userByRegion(&#xA;         region: $region&#xA;         sortDirection: $sortDirection&#xA;         filter: $filter&#xA;         limit: $limit&#xA;         nextToken: $nextToken&#xA;     ) {&#xA;         items {&#xA;         id&#xA;         email&#xA;         name&#xA;         region&#xA;         sector&#xA;         companyType&#xA;         feedbacks(nextToken: $nextTokenFeedback) { &#xA;             items {&#xA;             content&#xA;             createdAt&#xA;             id&#xA;             score&#xA;             }&#xA;             nextToken&#xA;         }&#xA;         createdAt&#xA;         updatedAt&#xA;         owner&#xA;         }&#xA;         nextToken&#xA;         }&#xA;      }&#xA;</code></pre>&#xA;</li>&#xA;<li><p>Now I call this API like the following:</p>&#xA;<pre><code> nextToken = {&#xA;     user: null,&#xA;     feedback: null&#xA; };&#xA; feedbacks: any;&#xA;&#xA; async listFeedbacks() {&#xA;     try {&#xA;         const res = await this.api.UserByRegionWithFeedback(&#xA;             'Turkey', // &lt;-- region: filter Users by their region, I will add UI input later&#xA;             null, // &lt;-- sortDirection&#xA;             null, // &lt;-- filter&#xA;             null, // &lt;-- limit&#xA;             this.nextToken.feedback == null ? this.nextToken.user : null, // &lt;-- User nextToken: Only send if Feedback NextToken is null&#xA;             this.nextToken.feedback // &lt;-- Feedback nextToken&#xA;         );&#xA;&#xA;         // Get User NextToken&#xA;         this.nextToken.user = res.nextToken;&#xA;         // Initialize Feedback NextToken as null&#xA;         this.nextToken.feedback = null;&#xA;         // Loop Users in the response&#xA;         res.items.map((user) =&gt; {&#xA;         // Get Feedback NextToken from User if it is not null (Or else last User in the list could overrite it)&#xA;         if (user.feedbacks.nextToken) {&#xA;             this.nextToken.feedback = user.feedbacks.nextToken;&#xA;         }&#xA;         // Push the feedback items into the list to diplay in UI&#xA;         this.feedbacks.push(...user.feedbacks.items);&#xA;         });&#xA;     } catch (error) {&#xA;         this.handleError.show(error);&#xA;     }&#xA; }&#xA;</code></pre>&#xA;</li>&#xA;<li><p>Lastly I added a Load More button in the UI which calls listFeedbacks() function. So if there is any Feedback NextToken, I send it to the API. (Note that multiple user feedbacks can have a nextToken).&#xA;If all feedbacks are ok and if there is a User NextToken, I send that to the API and repeat the process for new Users.</p>&#xA;</li>&#xA;</ol>&#xA;<p>I believe this could be much simpler with an SQL setup, but this will work for now. I hope it helps others in my situation. And if there is any ideas to make this better I'm all ears.</p>&#xA;",5043633,,,,2021-05-16 07:40:51,"",,0,0,0,2021-05-16 07:40:51
67556883,2,,67502148,1,,"<p>My former answer can still be useful for others in specific scenarios, but I found a better way to achieve nested filtering when I realized you can filter nested items in custom queries.</p>&#xA;<p>Schema:</p>&#xA;<pre><code>    type User @model {&#xA;        id: ID!&#xA;        email: String!&#xA;        name: String!&#xA;        region: String!&#xA;        sector: String!&#xA;        companyType: String!&#xA;        feedbacks: [Feedback] @connection # &lt;-- User has many feedbacks&#xA;    }&#xA;</code></pre>&#xA;<p>Custom query:</p>&#xA;<pre><code>    query ListUserWithFeedback(&#xA;        $filter: ModelUserFilterInput # &lt;-- Filter Users by Region or any other User field&#xA;        $limit: Int&#xA;        $nextToken: String&#xA;        $filterFeedback: ModelFeedbackFilterInput # &lt;-- Filter inner Feedbacks by Feedback fields&#xA;        $nextTokenFeedback: String&#xA;        ) {&#xA;        listUsers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;            items {&#xA;            id&#xA;            email&#xA;            name&#xA;            region&#xA;            sector&#xA;            companyType&#xA;            feedbacks(filter: $filterFeedback, nextToken: $nextTokenFeedback) {&#xA;                items {&#xA;                content&#xA;                createdAt&#xA;                id&#xA;                score&#xA;                }&#xA;                nextToken&#xA;            }&#xA;            createdAt&#xA;            updatedAt&#xA;            }&#xA;            nextToken&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>$filter can be something like:</p>&#xA;<pre><code>    { region: { contains: 'Turkey' } }&#xA;</code></pre>&#xA;<p>$filterFeedback can be like:</p>&#xA;<pre><code>    {&#xA;        and: [{ content: { contains: 'hello' }, score: { ge: 4 } }]&#xA;    }&#xA;</code></pre>&#xA;<p>This way both Users and Feedbacks can be filtered at the same time.</p>&#xA;",5043633,,,,2021-05-16 12:50:46,"",,0,0,0,2021-05-16 12:50:46
67556899,2,,56875895,0,,"<p>This is an addition to <a href=""https://stackoverflow.com/users/667598/hisa-py"">hisa_py's</a> answer:</p>&#xA;<pre><code>export default createFragmentContainer(ModuleName, {&#xA;  moduleName: graphql`                             // LINE 2&#xA;    fragment Link_link on Link {&#xA;      id&#xA;      description&#xA;      url&#xA;    }&#xA;  `&#xA;})&#xA;</code></pre>&#xA;<p>Notice how <strong>only</strong> the first character is to be lowercased at line 2.</p>&#xA;",11853714,,,,2021-05-16 12:52:26,"",,0,0,0,2021-05-16 12:52:26
67561387,1,,,1,55,"<p>I have an interface <code>CommonUser</code> with <code>PublicUser</code> and <code>User</code> that implements <code>CommonUser</code>.</p>&#xA;<p>I have two endpoints: one for <code>PublicUser</code> and one for <code>User</code>:</p>&#xA;<pre><code>interface CommonUser {&#xA;  id&#xA;  ...&#xA;}&#xA;&#xA;type User implements CommonUser {&#xA;  id &#xA;  ...&#xA;}&#xA;&#xA;type PublicUser implements CommonUser {&#xA;  id&#xA;  ...&#xA;}&#xA;&#xA;&#xA;extend type Query {&#xA; publicUser(id: ID!): PublicUser&#xA;}&#xA;&#xA;extend type Mutation {&#xA; fetchCreateUser(id: ID!): User!&#xA;}&#xA;</code></pre>&#xA;<p>On the front end, I want to use a fragment to share common fields,</p>&#xA;<pre><code>const COMMON_FIELDS = gql`&#xA;fragment CommonUserFields on CommonUser {&#xA;  id&#xA;  ...&#xA;}&#xA;`&#xA;&#xA;const FETCH_CREATE_USER = gql`&#xA;${COMMON_FIELDS}&#xA;mutation fetchCreateUser {&#xA;  fetchCreateUser(id: 123) {&#xA;    ...CommonUserFields&#xA;    ...&#xA;  }&#xA;}&#xA;`&#xA;&#xA;const PUBLIC_USER = gql`&#xA;${COMMON_FIELDS}&#xA;query publicUser {&#xA;  publicUser(id: 123) {&#xA;    ...CommonUserFields&#xA;    someOtherField&#xA;  }&#xA;}&#xA;`&#xA;</code></pre>&#xA;<p>When I use the <code>FETCH_CREATE_USER</code> mutation, it works as intended, returning all the common user fields.</p>&#xA;<p>However, when I use the <code>PUBLIC_USER</code> query, it only returns <code>someOtherField</code> in the response.</p>&#xA;<p>I have verified on the backend resolver that <code>graphQLFields(info)</code> does contain all the requested fields, and the object being returned contains all requested fields.</p>&#xA;",4463793,,,,2021-05-16 20:39:17,Apollo + GraphQL: Fragment on interface works for one concrete type but not on the other,<graphql><apollo>,0,1,0,2021-05-16 20:39:17
67583325,1,,,1,64,"<p>I want to filter by multiple Input Elements looking like this:&#xA;<a href=""https://i.stack.imgur.com/AqCzG.png"" rel=""nofollow noreferrer"">Input Elements</a></p>&#xA;<p>The fields seen in the image should be filtered at the same time. If one isn't used it should still filter. I can show you the code I'm currently working with.</p>&#xA;<pre><code>  let searchFilter:SearchableJobFilterInput = {&#xA;    or: [&#xA;      {&#xA;        categoryID: {&#xA;          matchPhrasePrefix: form.category&#xA;        },&#xA;        title : {&#xA;          matchPhrasePrefix: form.title&#xA;        }&#xA;      }&#xA;    ],&#xA;&#xA;    &#xA;  };&#xA;&#xA;&#xA;  this.API.SearchJobs(searchFilter).then((searchedJobs: SearchJobsQuery) =&gt; {&#xA;    if(searchedJobs != null)&#xA;    {&#xA;      this.jobs = searchedJobs.items;&#xA;      this.changeDetection.detectChanges();&#xA;      console.log(this.jobs);&#xA;    }&#xA;    else {&#xA;      console.log('No Data for Filtered Jobs!')&#xA;    }&#xA;  })&#xA;}&#xA;</code></pre>&#xA;<p>Am I using the wrong functions? Isn't searchable what I need? Or is there any other/better way to search?</p>&#xA;",14799910,,,,2021-05-18 09:16:40,How to filter by multiple elements with a searchFilter in GrapQL / Typescript,<angular><typescript><graphql><graphql-js>,0,5,0,2021-05-18 09:16:40
67586658,2,,60709951,2,,"<p>Maybe you want let the clients choose how to combine filter criteria and logic. This can be done by nesting the filter criteria in &quot;and&quot; or &quot;or, like:</p>&#xA;<pre><code>/users/?or[username]=super&amp;or[name]=john&#xA;</code></pre>&#xA;<p>This will return all users with &quot;super&quot; in their username OR &quot;john&quot; in their name. Or if you need more complex logic and multiple criteria for the same property:</p>&#xA;<pre><code>/users/?and[name]=john&amp;and[or][][email]=microsoft.com&amp;and[or][][email]=apple.com&#xA;</code></pre>&#xA;<p>This will return all users with john in their names AND (microsoft.com or apple.com in their email address). Because of the nesting of or the criteria for the description are combined together through AND with the criterium for name, which must allways be true while only one of the criteria for the email needs to be true for a user to be returned.</p>&#xA;<p>To make this work within your app create a file FilterLogic.php in your api src/Filter folder&#xA;(create this folder if you don't have one yet) with the following content:</p>&#xA;<pre><code>&lt;?php&#xA;&#xA;namespace App\Filter;&#xA;&#xA;use ApiPlatform\Core\Api\FilterCollection;&#xA;use ApiPlatform\Core\Bridge\Doctrine\Orm\Filter\AbstractContextAwareFilter;&#xA;use ApiPlatform\Core\Bridge\Doctrine\Orm\Filter\FilterInterface;&#xA;use ApiPlatform\Core\Bridge\Doctrine\Orm\Filter\OrderFilter;&#xA;use ApiPlatform\Core\Bridge\Doctrine\Orm\Util\QueryNameGeneratorInterface;&#xA;use ApiPlatform\Core\Metadata\Resource\Factory\ResourceMetadataFactoryInterface;&#xA;use ApiPlatform\Core\Exception\ResourceClassNotFoundException;&#xA;use Doctrine\ORM\QueryBuilder;&#xA;use Doctrine\ORM\Query\Expr;&#xA;use Doctrine\Persistence\ManagerRegistry;&#xA;use Psr\Container\ContainerInterface;&#xA;use Psr\Log\LoggerInterface;&#xA;use Symfony\Component\HttpFoundation\RequestStack;&#xA;use Symfony\Component\Serializer\NameConverter\NameConverterInterface;&#xA;&#xA;/**&#xA; * Combines existing API Platform ORM Filters with AND and OR.&#xA; * For usage and limitations see https://gist.github.com/metaclass-nl/790a5c8e9064f031db7d3379cc47c794&#xA; * Copyright (c) MetaClass, Groningen, 2021. MIT License&#xA; */&#xA;class FilterLogic extends AbstractContextAwareFilter&#xA;{&#xA;    /** @var ResourceMetadataFactoryInterface  */&#xA;    private $resourceMetadataFactory;&#xA;    /** @var ContainerInterface|FilterCollection  */&#xA;    private $filterLocator;&#xA;    /** @var string Filter classes must match this to be applied with logic */&#xA;    private $classExp;&#xA;&#xA;    /**&#xA;     * @param ResourceMetadataFactoryInterface $resourceMetadataFactory&#xA;     * @param ContainerInterface|FilterCollection $filterLocator&#xA;     * @param $regExp string Filter classes must match this to be applied with logic&#xA;     * {@inheritdoc}&#xA;     */&#xA;    public function __construct(ResourceMetadataFactoryInterface $resourceMetadataFactory, $filterLocator, string $classExp='//', ManagerRegistry $managerRegistry, RequestStack $requestStack=null, LoggerInterface $logger = null, array $properties = null, NameConverterInterface $nameConverter = null)&#xA;    {&#xA;        parent::__construct($managerRegistry, $requestStack, $logger, $properties, $nameConverter);&#xA;        $this-&gt;resourceMetadataFactory = $resourceMetadataFactory;&#xA;        $this-&gt;filterLocator = $filterLocator;&#xA;        $this-&gt;classExp = $classExp;&#xA;    }&#xA;&#xA;    /** {@inheritdoc } */&#xA;    public function getDescription(string $resourceClass): array&#xA;    {&#xA;        // No description&#xA;        return [];&#xA;    }&#xA;&#xA;    /**&#xA;     * {@inheritdoc}&#xA;     * @throws ResourceClassNotFoundException&#xA;     * @throws \LogicException if assumption proves wrong&#xA;     */&#xA;    protected function filterProperty(string $parameter, $value, QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, string $operationName = null, array $context = [])&#xA;    {&#xA;        $filters = $this-&gt;getFilters($resourceClass, $operationName);&#xA;&#xA;        if ($parameter == 'and') {&#xA;            $newWhere = $this-&gt;applyLogic($filters, 'and', $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $context);&#xA;            $queryBuilder-&gt;andWhere($newWhere);&#xA;        }&#xA;        if ($parameter == 'or') {&#xA;            $newWhere = $this-&gt;applyLogic($filters, 'or', $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $context);&#xA;            $queryBuilder-&gt;orWhere($newWhere);&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * Applies filters in compound logic context&#xA;     * @param FilterInterface[] $filters to apply in context of $operator&#xA;     * @param string $operator 'and' or 'or&#xA;     * @return mixed Valid argument for Expr\Andx::add and Expr\Orx::add&#xA;     * @throws \LogicException if assumption proves wrong&#xA;     */&#xA;    private function applyLogic($filters, $operator, $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $context)&#xA;    {&#xA;        $oldWhere = $queryBuilder-&gt;getDQLPart('where');&#xA;&#xA;        // replace by marker expression&#xA;        $marker = new Expr\Func('NOT', []);&#xA;        $queryBuilder-&gt;add('where', $marker);&#xA;&#xA;        $subFilters = $context['filters'][$operator];&#xA;        // print json_encode($subFilters, JSON_PRETTY_PRINT);&#xA;        $assoc = [];&#xA;        $logic = [];&#xA;        foreach ($subFilters as $key =&gt; $value) {&#xA;            if (ctype_digit((string) $key)) {&#xA;                // allows the same filter to be applied several times, usually with different arguments&#xA;                $subcontext = $context; //copies&#xA;                $subcontext['filters'] = $value;&#xA;                $this-&gt;applyFilters($filters, $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $subcontext);&#xA;&#xA;                // apply logic seperately&#xA;                if (isset($value['and'])) {&#xA;                    $logic[]['and'] =  $value['and'];&#xA;                }if (isset($value['or'])) {&#xA;                    $logic[]['or'] =  $value['or'];&#xA;                }&#xA;            } elseif (in_array($key, ['and', 'or'])) {&#xA;                $logic[][$key] = $value;&#xA;            } else {&#xA;                $assoc[$key] = $value;&#xA;            }&#xA;        }&#xA;&#xA;        // Process $assoc&#xA;        $subcontext = $context; //copies&#xA;        $subcontext['filters'] = $assoc;&#xA;        $this-&gt;applyFilters($filters, $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $subcontext);&#xA;&#xA;        $newWhere = $queryBuilder-&gt;getDQLPart('where');&#xA;        $queryBuilder-&gt;add('where', $oldWhere); //restores old where&#xA;&#xA;        // force $operator logic upon $newWhere&#xA;        if ($operator == 'and') {&#xA;            $adaptedPart = $this-&gt;adaptWhere(Expr\Andx::class, $newWhere, $marker);&#xA;        } else {&#xA;            $adaptedPart = $this-&gt;adaptWhere(Expr\Orx::class, $newWhere, $marker);&#xA;        }&#xA;&#xA;        // Process logic&#xA;        foreach ($logic as $eachLogic) {&#xA;            $subcontext = $context; //copies&#xA;            $subcontext['filters'] = $eachLogic;&#xA;            $newWhere = $this-&gt;applyLogic($filters, key($eachLogic), $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $subcontext);&#xA;            $adaptedPart-&gt;add($newWhere); // empty expressions are ignored by ::add&#xA;        }&#xA;&#xA;        return $adaptedPart; // may be empty&#xA;    }&#xA;&#xA;    private function applyFilters($filters, $queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $context)&#xA;    {&#xA;        foreach ($filters as $filter) {&#xA;            $filter-&gt;apply($queryBuilder, $queryNameGenerator, $resourceClass, $operationName, $context);&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * ASSUMPTION: filters do not use QueryBuilder::where or QueryBuilder::add&#xA;     * and create semantically complete expressions in the sense that expressions&#xA;     * added to the QueryBundle through ::andWhere or ::orWhere do not depend&#xA;     * on one another so that the intended logic is not compromised if they are&#xA;     * recombined with the others by either Doctrine\ORM\Query\Expr\Andx&#xA;     * or Doctrine\ORM\Query\Expr\Orx.&#xA;     *&#xA;     * Replace $where by an instance of $expClass.&#xA;     * andWhere and orWhere allways add their args at the end of existing or&#xA;     * new logical expressions, so we started with a marker expression&#xA;     * to become the deepest first part. The marker should not be returned&#xA;     * @param string $expClass&#xA;     * @param Expr\Andx | Expr\Orx $where Result from applying filters&#xA;     * @param Expr\Func $marker Marks the end of logic resulting from applying filters&#xA;     * @return Expr\Andx | Expr\Orx Instance of $expClass&#xA;     * @throws \LogicException if assumption proves wrong&#xA;     */&#xA;    private function adaptWhere($expClass, $where, $marker)&#xA;    {&#xA;        if ($where === $marker) {&#xA;            // Filters did nothing&#xA;             return new $expClass([]);&#xA;        }&#xA; &#xA;        if (!$where instanceof Expr\Andx &amp;&amp; !$where instanceof Expr\Orx) {&#xA;            // A filter used QueryBuilder::where or QueryBuilder::add or otherwise&#xA;            throw new \LogicException(&quot;Assumpion failure, unexpected Expression: &quot;. $where);&#xA;        }&#xA;        $parts = $where-&gt;getParts();&#xA;        if (empty($parts)) {&#xA;            // A filter used QueryBuilder::where or QueryBuilder::add or otherwise&#xA;            throw new \LogicException(&quot;Assumpion failure, marker not found&quot;);&#xA;        }&#xA;&#xA;        if ($parts[0] === $marker) {&#xA;            // Marker found, recursion ends here&#xA;            array_shift($parts);&#xA;        } else {&#xA;            $parts[0] = $this-&gt;adaptWhere($expClass, $parts[0], $marker);&#xA;        }&#xA;        return new $expClass($parts);&#xA;    }&#xA;&#xA;    /**&#xA;     * @param string $resourceClass&#xA;     * @param string $operationName&#xA;     * @return FilterInterface[] From resource except $this and OrderFilters&#xA;     * @throws ResourceClassNotFoundException&#xA;     */&#xA;    protected function getFilters($resourceClass, $operationName)&#xA;    {&#xA;        $resourceMetadata = $this-&gt;resourceMetadataFactory-&gt;create($resourceClass);&#xA;        $resourceFilters = $resourceMetadata-&gt;getCollectionOperationAttribute($operationName, 'filters', [], true);&#xA;&#xA;        $result = [];&#xA;        foreach ($resourceFilters as $filterId) {&#xA;            $filter = $this-&gt;filterLocator-&gt;has($filterId)&#xA;                ? $this-&gt;filterLocator-&gt;get($filterId)&#xA;                :  null;&#xA;            if ($filter instanceof FilterInterface&#xA;                &amp;&amp; !($filter instanceof OrderFilter)&#xA;                &amp;&amp; $filter !== $this&#xA;                &amp;&amp; preg_match($this-&gt;classExp, get_class($filter))&#xA;            ) {&#xA;                $result[$filterId] = $filter;&#xA;            }&#xA;        }&#xA;        return $result;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Then add the following service configuration to your api config/services.yml:</p>&#xA;<pre><code>'App\Filter\FilterLogic':&#xA;    class: 'App\Filter\FilterLogic'&#xA;    arguments:&#xA;        - '@api_platform.metadata.resource.metadata_factory'&#xA;        - '@api_platform.filter_locator'&#xA;    public: false&#xA;    abstract: true&#xA;    autoconfigure: false&#xA;</code></pre>&#xA;<p>Finally adapt your entity like this:</p>&#xA;<pre><code>use App\Filter\FilterLogic;&#xA;/**&#xA; * @ApiResource&#xA; * @ApiFilter(SearchFilter::class, properties={&#xA; *   &quot;name&quot;: &quot;ipartial&quot;,&#xA; *   &quot;username&quot;: &quot;ipartial&quot;,&#xA; *   &quot;email&quot;: &quot;ipartial&quot;,&#xA; * })&#xA; * @ApiFilter(FilterLogic.class)&#xA; *&#xA;</code></pre>&#xA;<p>You can apply it in other classes as well just by adding the @ApiFilter annotation.</p>&#xA;<p>You can in/exclude filters by class name by configuring classExp. For example:</p>&#xA;<pre class=""lang-php prettyprint-override""><code>* @ApiFilter(FilterLogic::class, arguments={&quot;classExp&quot;=&quot;/ApiPlatform\\Core\\Bridge\\Doctrine\\Orm\\Filter\\+/&quot;})&#xA;</code></pre>&#xA;<p>will only apply API Platform ORM Filters in logic context.</p>&#xA;<p><strong>It is important that the annotation with the FilterLogic class is the last @ApiFilter annotation.</strong> The normal filtering will still work as usual: filters decide how to apply themselves to the QueryBuilder. If all use ::andWhere, like the built in filters of Api Platform, the order of the ApiFilter attribute/annotation does not matter, but if some use other methods a different order may yield different results. FilterLogic uses orWhere for &quot;or&quot; so the order matters. If it is the last filter its logic expressions will become the topmost ones, therefore defining the primary logic.</p>&#xA;<h2>Limitations</h2>&#xA;<p>Works with built in filters of Api Platform, except for DateFilter with EXCLUDE_NULL.&#xA;<a href=""https://github.com/metaclass-nl/filter-bundle/blob/master/src/Filter/DateFilter.php"" rel=""nofollow noreferrer"">This DateFilter</a> subclass may fix it.</p>&#xA;<p>Assumes that filters create semantically complete expressions in the sense that&#xA;expressions added to the QueryBundle through ::andWhere or ::orWhere do not depend&#xA;on one another so that the intended logic is not compromised if they are recombined&#xA;with the others by either Doctrine\ORM\Query\Expr\Andx or Doctrine\ORM\Query\Expr\Orx.</p>&#xA;<p>May Fail if a filter uses QueryBuilder::where or ::add.</p>&#xA;<p>You are advised to check the code of all custom and third party Filters and&#xA;not to combine those that use QueryBuilder::where or ::add with FilterLogic&#xA;or that produce complex logic that is not semantically complete. For an&#xA;example of semantically complete and incomplete expressions see <a href=""https://github.com/metaclass-nl/filter-bundle/blob/master/tests/Filter/DateFilterTest.php"" rel=""nofollow noreferrer"">DateFilterTest</a>.</p>&#xA;<p>The built in filters of Api Platform IMHO contain a bug with respect to the JOINs they generate. As a result, combining them with OR does not work as expected with properties nested over to-many and nullable associations. My <a href=""https://github.com/metaclass-nl/filter-bundle"" rel=""nofollow noreferrer"">FilterBundle</a> provides workarounds, but they do change the behavior of ExistsFilter =false.</p>&#xA;",11797613,,11797613,2022-06-24 08:36:10,2022-06-24 08:36:10,"",,0,4,0,2021-05-18 12:56:49
67601841,1,,,2,910,"<h2>Problem definition</h2>&#xA;<p>In the project I'm currently working on we're using React with <a href=""https://www.apollographql.com/docs/react/"" rel=""nofollow noreferrer"">Apollo Client</a>.</p>&#xA;<p>On all our mutations, we have the following fields in our response:</p>&#xA;<pre><code>ok&#xA;errors {&#xA;  field&#xA;  messages&#xA;}&#xA;</code></pre>&#xA;<p>The back-end extends all mutations with these fields, hence it would be nice to have a good, short way to include these fields on all mutations in the front-end, as well as be able to change this &quot;fragment&quot; in the future.</p>&#xA;<p>Hence I'm interested in shortening these same 4 lines into 1 across all my mutations.</p>&#xA;<h2>What I've tried so far:</h2>&#xA;<p>I've tried looking into <a href=""https://www.apollographql.com/docs/react/data/fragments/"" rel=""nofollow noreferrer"">Apollo fragments</a>, however they seem to require a type that the fields are <code>on</code> or &quot;relating to&quot;, eg.</p>&#xA;<pre><code>fragment NameParts on Person {&#xA;  firstName&#xA;  lastName&#xA;}&#xA;</code></pre>&#xA;<p>Here, the frament <code>NameParts</code> is created using <code>Person</code>. However, I'm interested in extending ALL mutations.</p>&#xA;<p>It would be nice if I could make a generic fragment like so:</p>&#xA;<pre><code>fragment OkAndErrors {&#xA;  ok&#xA;  errors {&#xA;    field&#xA;    messages&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This does not seem to be possible.</p>&#xA;<p>I've also tried making a string, and importing it into my mutation like so:</p>&#xA;<pre><code>export const OK_AND_ERRORS: string = `&#xA;  ok&#xA;  errors {&#xA;    field&#xA;    messages&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<pre><code>import { gql } from &quot;apollo-boost&quot;;&#xA;import { OK_AND_ERRORS } from &quot;./OK_AND_ERRORS&quot;;&#xA;&#xA;export const CREATE_API = gql`&#xA;  mutation CreateApi($newApi: ApiCreateGenericType!) {&#xA;    createDrugapi(newDrugapi: $newDrugapi) {&#xA;      ${OK_AND_ERRORS}&#xA;      (...rest of mutation is omitted for brevity)&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>Again, it did not work.</p>&#xA;<p>I'm not sure if I can use <code>gql</code> function in a smart way with strings or JSON?</p>&#xA;<p>There's also <a href=""https://graphql.org/learn/queries/#inline-fragments"" rel=""nofollow noreferrer"">inline fragments</a> but I'm in doubt if it can be used for what I need, and the documentation of inline-fragments in Apollo is scarce.</p>&#xA;<p>In essence: Is there a smart way to extend Apollo mutations? Does generic fragments exist?</p>&#xA;",3022175,,,,2021-05-21 12:56:42,"Ability to extend all Apollo/GraphQL mutations with same fields. ""Generic fragments"" wanted",<graphql><apollo><apollo-client><react-apollo>,1,5,0,2021-05-19 10:51:37
67618812,1,,,0,246,"<p>I have these resolvers (it's a console.log dump, so you see the resolvers are really there):</p>&#xA;<pre><code>resolvers {&#xA;  job: [AsyncFunction: resolve],&#xA;  jobs: [AsyncFunction: resolve],&#xA;  Job: {&#xA;    parent: [AsyncFunction: resolve],&#xA;    children: [AsyncFunction: resolve],&#xA;    companies: [AsyncFunction: resolve],&#xA;  },&#xA;  company: [AsyncFunction: resolve],&#xA;  companies: [AsyncFunction: resolve],&#xA;  Company: {&#xA;    companies: [AsyncFunction: resolve],&#xA;    jobs: [AsyncFunction: resolve]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Thes are my SDL-type definitions:</p>&#xA;<pre><code>type Pagination {&#xA;  page: Int&#xA;  pageSize: Int&#xA;  total: Int&#xA;  pages: Int&#xA;}&#xA;input PaginationInput {&#xA;  page: Int!&#xA;  pageSize: Int!&#xA;}&#xA;&#xA;type Job {&#xA;  id: Int&#xA;  created_at: String&#xA;  updated_at: String&#xA;  title: String&#xA;  parent: Job&#xA;  children: JobList&#xA;  companies: CompanyList&#xA;}&#xA;&#xA;type JobList {&#xA;  docs: [Job]&#xA;  pagination : Pagination&#xA;}&#xA;&#xA;type Company {&#xA;  id: Int&#xA;  legal_name: String&#xA;  created_at: String&#xA;  updated_at: String&#xA;  jobs: JobList&#xA;}&#xA;&#xA;type CompanyList {&#xA;  docs: [Company]&#xA;  pagination : Pagination&#xA;}&#xA;</code></pre>&#xA;<p>Running this query</p>&#xA;<pre><code>{&#xA;  job (title: &quot;Senior&quot;) {&#xA;    title&#xA;    companies { &#xA;      docs { legal_name }&#xA;      pagination {page pageSize total pages}&#xA;    }&#xA;    children { &#xA;      docs { title }&#xA;      pagination {page pageSize total pages}&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>against against the schema renders</p>&#xA;<pre class=""lang-js prettyprint-override""><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;job&quot;: {&#xA;      &quot;title&quot;: &quot;Senior Engineer&quot;,&#xA;      &quot;companies&quot;: null,&#xA;      &quot;children&quot;: null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Neither the resolver Job.companies nor Job.children is ever being called i.e. invoked.</p>&#xA;<p>What am I doing wrong here?</p>&#xA;",716568,,,,2021-05-21 12:59:25,GraphQL field resolver never gets invoked,<graphql>,2,1,0,2021-05-20 10:42:57
67627827,1,,,2,191,"<p>I've got this data set:</p>&#xA;<pre><code>  const avengers = [&#xA;    {&#xA;      firstName: 'Tony',&#xA;      lastName: 'Stark',&#xA;      name: 'Iron Man',&#xA;      bestFriends: {&#xA;        name: 'Captain America',&#xA;      },&#xA;    },&#xA;    {&#xA;      firstName: 'Bruce',&#xA;      lastName: 'Banner',&#xA;      name: 'Hulk',&#xA;      bestFriends: {&#xA;        name: 'Black Widow',&#xA;      },&#xA;    },&#xA;    {&#xA;      firstName: 'Thor',&#xA;      lastName: 'Odinson',&#xA;      name: 'Thor',&#xA;      bestFriends: {&#xA;        name: 'Rocket',&#xA;      },&#xA;    },&#xA;]&#xA;</code></pre>&#xA;<p>and what I'm trying to accomplish in Gatsby is to extend the bestFriends node in my Gatsby Nodes and allow the bestFriend's data to be fetched via a single query. My result query would look like this:</p>&#xA;<pre><code>query myQuery {&#xA; Avenger (name: {eq: &quot;Iron Man}) {&#xA;    name&#xA;    firstName&#xA;    lastName&#xA;    bestFriends {&#xA;      name&#xA;      friendData {&#xA;        firstName&#xA;        lastName&#xA;        name&#xA;        bestFriends &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>However I'm struggling to figure out how to set up my createResolvers so that I can set a custom resolver function for the friendData node. It almost seems as if the Gatsby createResolvers API isn't able to resolve nested data sets. I assumed that this should work but when I do query the data via GraphiQL the node bestFriends returns &quot;null&quot;.</p>&#xA;<pre><code>  createResolvers({&#xA;      Avenger: {&#xA;          bestFriends: {&#xA;              type: &quot;Avenger&quot;,&#xA;              resolve: (source, args, context) =&gt; {&#xA;                  return context.nodeModel.runQuery({&#xA;                      query: {&#xA;                          filter: {&#xA;                              name: {eq: source.bestFriends.name}&#xA;                          }&#xA;                      }&#xA;                  })&#xA;              }&#xA;          }&#xA;      }&#xA;  })&#xA;};&#xA;</code></pre>&#xA;<p>Any idea how I can accomplish what I'm getting at? I imagine that this is how Facebook would set up data structures for posts and comments, where the commentor's name, profile url, profile picture, and the comment itself is visible when you look at a post.</p>&#xA;",15985653,,,,2021-05-20 20:56:02,Gatsby createResolvers for data types within other data types,<javascript><node.js><graphql><gatsby>,0,0,0,2021-05-20 20:56:02
67633230,1,,,0,267,<p>I have some problem with my graph ql. I have a function to get value from DB. It have 2 field A and B</p>&#xA;<pre><code>type A {&#xA;  id ID&#xA;  b [B]&#xA;}&#xA;&#xA;Type B {&#xA;  id ID&#xA;  somedata String&#xA;}&#xA;</code></pre>&#xA;<p>My query is</p>&#xA;<pre><code>mutation {&#xA;  type A (objID: 10167182) {&#xA;    id&#xA;    b (status: 1){&#xA;        id&#xA;        somedata&#xA;      }&#xA;  }&#xA;</code></pre>&#xA;<p>But the problem is that elements get returned which satisfy the filter on A but may have no element B. So the filters as a whole work like “outer joins”. what is the equivalent of an inner join?</p>&#xA;<p>Tks guys</p>&#xA;,8090329,,,,2021-05-21 12:32:24,How inner join in Graphql,<c#><asp.net-core><graphql>,1,0,0,2021-05-21 08:23:06
67635567,2,,61053096,13,,<p>You need to add</p>&#xA;<pre><code>import &quot;reflect-metadata&quot;;&#xA;</code></pre>&#xA;<p>at the top of your file</p>&#xA;,15991442,,,,2021-05-21 11:00:24,"",,0,0,0,2021-05-21 11:00:24
67681476,1,,,2,574,"<p>im new in graphql.&#xA;I have trouble with input type extends generic type.&#xA;Source code like this:</p>&#xA;<pre><code>function Edge&lt;T&gt;(Node: Type&lt;T&gt;) {&#xA;  class EdgeType {&#xA;    @Field(() =&gt; String)&#xA;    company: string;&#xA;&#xA;    @Field(() =&gt; String)&#xA;    lang: string;&#xA;&#xA;    @Field(() =&gt; String)&#xA;    collection: string;&#xA;&#xA;    @Field(() =&gt; String)&#xA;    user_id: string;&#xA;&#xA;    @Field(() =&gt; String, { nullable: true })&#xA;    token: string;&#xA;&#xA;    @Field(() =&gt; Node)&#xA;    condition: T;&#xA;&#xA;    @Field(() =&gt; [Node], { nullable: true })&#xA;    data: T[];&#xA;  }&#xA;  return EdgeType;&#xA;}&#xA;&#xA;@InputType()&#xA;export class EdgeMasterData extends Edge(MasterData) {&#xA;  @Field(() =&gt; String, { nullable: true })&#xA;  _key: string;&#xA;}&#xA;</code></pre>&#xA;<p>I only hay one field is <strong>_key</strong>, cannot get field in Edge..</p>&#xA;<p>Actually i did a lot of time research but didn't solve the problem</p>&#xA;<p>Need help !!!</p>&#xA;",14168813,,,,2021-05-25 03:40:21,Extends generic type in Graphql (NestJs),<graphql><nestjs>,0,0,0,2021-05-25 03:40:21
67686135,2,,67668851,0,,"<p>You need to use include to include the childs (menus) and there add the where clause. Like this:</p>&#xA;<pre><code>const result: ParentEntity = await ParentEntity.schema(tenant).findAll&lt;ParentEntity&gt;({&#xA;        include: [{&#xA;          model: ChildEntity.schema(tenant),&#xA;          where: yourConditionOnTheChildEntity&#xA;        }]&#xA;      });&#xA;</code></pre>&#xA;",534877,,,,2021-05-25 10:26:07,"",,0,1,0,2021-05-25 10:26:07
67711574,1,,,0,25,"<p>I have a data set where the 3rd, 5th and 7th line is the confidence interval of the previous lines respectively. For example:</p>&#xA;<pre><code>0.1     0.53    0.51    0.29    0.28    0.13    0.12&#xA;0.2     0.54    0.53    0.31    0.30    0.14    0.13&#xA;0.3     0.57    0.56    0.32    0.31    0.14    0.14&#xA;0.4     0.60    0.59    0.34    0.33    0.15    0.15&#xA;0.5     0.64    0.63    0.36    0.35    0.16    0.16&#xA;0.6     0.69    0.68    0.38    0.37    0.18    0.17&#xA;0.7     0.73    0.72    0.41    0.40    0.19    0.18&#xA;0.8     0.82    0.80    0.45    0.44    0.22    0.21&#xA;0.9     0.88    0.86    0.48    0.47    0.24    0.23&#xA;1.0     0.98    0.96    0.53    0.51    0.27    0.27&#xA;</code></pre>&#xA;<p>When plotting the graph, the error bar becomes very large, clearly wrong, as shown in the figure:&#xA;<a href=""https://i.stack.imgur.com/fwzPQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fwzPQ.png"" alt=""enter image description here"" /></a></p>&#xA;<p>My script is simple, but it is not working as I expected. Could someone point me the error?</p>&#xA;<p>My script:</p>&#xA;<pre><code>    reset&#xA;set termopt enhanced&#xA;set encoding iso_8859_1&#xA;set datafile missing '-'&#xA;&#xA;set ylabel 'NDT normalized by symmetrical case'&#xA;set xlabel 'Delivery probality'&#xA;&#xA;unset log                              &#xA;&#xA;unset label                           &#xA;&#xA;set ytic auto                         &#xA;set xtic auto&#xA;&#xA;set yrange [0:*]&#xA;&#xA;set terminal png size 800,600 enhanced font &quot;Arial,16&quot;  &#xA;set output 'prob_normal.png' # setando o nome da saída&#xA;&#xA;set key center top inside &#xA;&#xA;f(x) = x&#xA;&#xA;plot &quot;prob-normal.dat&quot; using ($1):($2) title &quot;DC 10.98%&quot; with linespoints ls 1, \&#xA;&quot;prob-normal.dat&quot; using ($1):($2):($3) notitle with yerrorbars,\&#xA;&quot;prob-normal.dat&quot; using ($1):($4) title &quot;DC 19.35%&quot; with linespoints ls 2, \&#xA;&quot;prob-normal.dat&quot; using ($1):($4):($5) notitle with yerrorbars,\&#xA;&quot;prob-normal.dat&quot; using ($1):($6) title &quot;DC 42.85%&quot;  with linespoints ls 3, \&#xA;&quot;prob-normal.dat&quot; using ($1):($6):($7) notitle with yerrorbars&#xA;</code></pre>&#xA;",7785731,,,,2021-05-26 19:32:51,Error bar with different behavior in GNUPlot,<graph><graphql><gnuplot>,0,2,0,2021-05-26 19:32:51
67714038,1,67714087,,0,48,"<p>So I'm trying to learn graphql I've been playing around with the <a href=""https://thegraph.com/explorer/subgraph/ensdomains/ens?selected=playground"" rel=""nofollow noreferrer"">ENS subgraph on the graph</a></p>&#xA;<p>For now I'm just trying to do some simple filtering:  I would like to be able to filter by the property name:</p>&#xA;<pre><code>{&#xA;  domains(name:&quot;cocacola.eth&quot;) {&#xA;    id&#xA;    name&#xA;    labelName&#xA;    labelhash&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>However this doesn't seem to work</p>&#xA;",1938988,,,,2021-05-27 00:00:59,Simple GraphQL Query using the Graph,<graphql>,1,0,0,2021-05-26 23:50:54
67714137,1,,,2,739,"<p>So I'm trying to learn graphql I've been playing around with the <a href=""https://thegraph.com/explorer/subgraph/ensdomains/ens?selected=playground"" rel=""nofollow noreferrer"">ENS subgraph on the graph</a></p>&#xA;<p>I've figured out how to do simple filtering but when I try to write more complex filters they do not compile.</p>&#xA;<p>I'm trying to get the top 5 transactions for the each of the top 5 domains.  (e.g for each domain I want the top 5 transactions)</p>&#xA;<pre><code>{&#xA;  #Sample Query to get the first 5 domains (not needed for question but used to validate results)&#xA;  domains(first: 5) {&#xA;    id&#xA;    name&#xA;    labelName&#xA;    labelhash&#xA;  }&#xA;&#xA;  #attempt to filter the transfer.domain.id by TOP 5 domains.id&#xA;  transfers(where: { domain { id: domains(first: 5) { id } } }) {&#xA;    id&#xA;    domain {&#xA;      id&#xA;    }&#xA;    blockNumber&#xA;    transactionID&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>EDIT</strong>  I'm going to attempt to simplify my request since I'm not sure nesting queries is possible.  How can I filter an inner query by Id:</p>&#xA;<pre><code>transfers(where: {domain.id: &quot;0x9c0fc2519ae862cee27778e5c34714d6c7e3ca21ad572df47ad9f6fe530909bd&quot;}) {&#xA;  id&#xA;  domain {&#xA;    id&#xA;  }&#xA;  blockNumber&#xA;  transactionID&#xA;}&#xA;</code></pre>&#xA;<p><strong>NOTE:</strong> Domain.Id = does not compile how would I write a filtered query like that?</p>&#xA;<p>However, My filter doesn't compile syntactically.  How can I write a query which filters by a child property?</p>&#xA;",1938988,,1938988,2021-06-08 18:09:02,2021-06-08 18:09:02,Graphql Filter by query,<graphql>,1,2,0,2021-05-27 00:12:52
67722856,1,67723190,,-1,400,"<h2>Explantion</h2>&#xA;<p>I'm passing data from this GraphQL query below to a nested map function, but I keep getting <code>node.map is not a function</code> even though it's inside an array. I can't see what I'm doing wrong here, so any guidance would be appreciated. ;)</p>&#xA;<h2>Code</h2>&#xA;<p><strong>Query</strong></p>&#xA;<pre><code>query MyQuery {&#xA;  allContentfulAwards {&#xA;    edges {&#xA;      node {&#xA;        year&#xA;        championships {&#xA;          contest&#xA;          title {&#xA;            key&#xA;            value&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Data</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;allContentfulAwards&quot;: {&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;year&quot;: &quot;2021&quot;,&#xA;            &quot;championships&quot;: [&#xA;              {&#xA;                &quot;contestName&quot;: &quot;Contest1&quot;,&#xA;                &quot;titles&quot;: [&#xA;                  {&#xA;                    &quot;key&quot;: &quot;TitleA&quot;&#xA;                  },&#xA;                  {&#xA;                    &quot;key&quot;: &quot;TitleB&quot;&#xA;                  }&#xA;                ]&#xA;              },&#xA;              {&#xA;                &quot;contestName&quot;: &quot;Contest2&quot;,&#xA;                &quot;titles&quot;: [&#xA;                  {&#xA;                    &quot;key&quot;: &quot;TitleA&quot;&#xA;                  }&#xA;                ]&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;year&quot;: &quot;2020&quot;,&#xA;            &quot;championships&quot;: [&#xA;              {&#xA;                &quot;contestName&quot;: &quot;Contest1&quot;,&#xA;                &quot;titles&quot;: [&#xA;                  {&#xA;                    &quot;key&quot;: &quot;TitleA&quot;&#xA;                  }&#xA;                ]&#xA;              }&#xA;            ]&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Nested map</strong></p>&#xA;<pre><code>{&#xA;  data.allContentfulAwards.edges.map(({node}) =&gt; (&#xA;    &lt;div&gt;&#xA;      {node.ano}&#xA;      {node.map(({championships}) =&gt; (&#xA;        &lt;AwardsCollapse name={championships.contestName}&gt;&#xA;          {championships.map(({titles}) =&gt; (&#xA;            &lt;p&gt;{titles.key}&lt;/p&gt;&#xA;          ))}&#xA;        &lt;/AwardsCollapse&gt;&#xA;      ))}&#xA;    &lt;/div&gt;&#xA;  ));&#xA;}&#xA;</code></pre>&#xA;<p>Thanks in advance,&#xA;<br>&#xA;Luiz.</p>&#xA;",5802882,,,,2021-05-28 18:51:26,Passing a GraphQL query to a nested map in React,<reactjs><graphql>,1,1,0,2021-05-27 13:10:02
67749086,2,,67733869,0,,"<p>You can simply create a view and query it like a normal table;</p>&#xA;<p>let us assume there's a <strong>people</strong> table with a <strong>first_name</strong> column. To find duplicates</p>&#xA;<pre><code>create or replace view duplicate_first_names as select p.first_name,&#xA;count(p.first_name) from people p group by(p.first_name) having&#xA;count(p.first_name) &gt; 1&#xA;</code></pre>&#xA;<p>or if you want to return the entire row of the duplicate column, you can add a sub-query:</p>&#xA;<pre><code>create or replace view duplicate_people_first_names as select * from&#xA;people p where (select count(*) from people ppl where ppl.first_name =&#xA;p.first_name) &gt; 1;&#xA;</code></pre>&#xA;",14529454,,,,2021-05-29 07:58:49,"",,0,0,0,2021-05-29 07:58:49
67760337,2,,67752629,0,,"<p>Here is my <strong>solution</strong></p>&#xA;<p><strong>Mutation</strong></p>&#xA;<pre><code>mutation updateDepartment($departmentInput: DepartmentInput!) {&#xA;  updateDepartment(id: 10,department: $departmentInput){&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Query Variables</strong></p>&#xA;<pre><code>{&#xA;  &quot;departmentInput&quot;: {&#xA;    &quot;name&quot;: &quot;Department 10 Update&quot;,&#xA;    &quot;hospitalId&quot;: 3&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5719229,,,,2021-05-30 10:55:16,"",,0,5,0,2021-05-30 10:55:16
67791209,1,67800929,,0,6937,"<p>I'm currently undergoing a rewrite of my Discord bot, and in this process I need to rewrite all of my SQL queries and convert them into Prisma queries.</p>&#xA;<p>SQL query I', trying to convert into Prisma:&#xA;<code>connection.query('SELECT inviterId, count(*) as count FROM invites where serverId = ? AND valid = 1 GROUP BY inviterId ORDER BY count DESC')</code></p>&#xA;<p>I currently have this:</p>&#xA;<pre><code>    let leaderboard = await client.prisma.invites.aggregate({&#xA;      _count: {&#xA;        inviterId: true,&#xA;      },&#xA;      where: {&#xA;        serverId: message.guildID,&#xA;        valid: true,&#xA;      },&#xA;      orderBy: {&#xA;        inviterId: &quot;desc&quot;,&#xA;      }&#xA;    });&#xA;    console.log(leaderboard);&#xA;</code></pre>&#xA;<p>This returns: <code>{ _count: { inviterId: 25 } }</code></p>&#xA;<p>However, I need to also return the data in a select query. As far as I know it is not possible to use _count in a findMany query, so I tried to use select in an aggregate query, but that doesn't work either.</p>&#xA;<p>I am unsure how I can select the data to be returned, and sorted by largest count. Any help would be greatly appreciated.</p>&#xA;",15238951,,,,2021-06-02 07:46:15,Using _count in a select query with Prisma,<sql><typescript><prisma><prisma-graphql>,1,0,0,2021-06-01 14:54:30
67800608,1,67801879,,0,692,"<p>I have connected the usQuery graphql hook</p>&#xA;<p>app.js:</p>&#xA;<pre><code>function App() {&#xA;&#xA;    const GET_RES = gql`&#xA;&#xA;    query ($input: GetRaceResultsInput, $before: String, $after: String, $first: Int, $last: Int) {&#xA;        get_race_results(before: $before, after: $after, first: $first, last: $last, input: $input) {&#xA;            edges {&#xA;                cursor&#xA;                node {&#xA;                   country&#xA;                   city&#xA;                }&#xA;            }&#xA;            pageInfo {&#xA;                startCursor&#xA;                endCursor&#xA;                hasNextPage&#xA;                hasPreviousPage&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;&#xA;const { loading, error, data } = useQuery(GET_RES,{variables: {&#xA;    &quot;first&quot;: 2,&#xA;    &quot;input&quot;: {&#xA;        &quot;onlyMyRacehorses&quot;: false,&#xA;        &quot;distance&quot;: {&#xA;            &quot;from&quot;: 1000,&#xA;            &quot;to&quot;: 2400&#xA;        }&#xA;    }&#xA;}});&#xA;console.log(&quot; ~ file: App.js ~ line 16 ~ loading&quot;, loading)&#xA;console.log(&quot; ~ file: App.js ~ line 16 ~ error&quot;, error)&#xA;console.log(&quot; ~ file: App.js ~ line 16 ~ data&quot;, data);&#xA;&#xA;  return (&#xA;    &lt;div className=&quot;view view-main&quot;&gt;&#xA;      &lt;div className=&quot;pages&quot;&gt;&#xA;        &lt;div data-page=&quot;about&quot; className=&quot;page&quot;&gt;&#xA;          &lt;div className=&quot;page-content&quot;&gt;&#xA;            &#xA;              &lt;AppRouter /&gt;&#xA;          &lt;/div&gt;&#xA;        &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;  );&#xA;}&#xA;&#xA;export default App;&#xA;</code></pre>&#xA;<p>Continuously getting this error :</p>&#xA;<blockquote>&#xA;<p>{&quot;errors&quot;:[{&quot;locations&quot;:[{&quot;column&quot;:2,&quot;line&quot;:1}],&quot;message&quot;:&quot;syntax error before: &quot;\&quot;variables\&quot;&quot;&quot;}]}</p>&#xA;</blockquote>&#xA;<p>Any idea what's I am missing here?</p>&#xA;<p>And on insomnia getting this</p>&#xA;<p><a href=""https://i.stack.imgur.com/fRpBK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fRpBK.png"" alt=""enter image description here"" /></a></p>&#xA;<p>server network tab&#xA;<a href=""https://i.stack.imgur.com/GrMzb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GrMzb.png"" alt=""enter image description here"" /></a></p>&#xA;",244546,,13302,2021-06-13 13:53:48,2021-06-13 13:53:48,"Graphql error : ""syntax error before: \""\\\""variables\\\""\""""",<reactjs><graphql><react-hooks><apollo-client>,1,9,0,2021-06-02 07:21:51
67801879,2,,67800608,1,,"<p>In query, should be getRaceResults(before: .......) instead of get_race_results(before.....)</p>&#xA;<p>Try:</p>&#xA;<pre><code>query ($input: GetRaceResultsInput, $before: String, $after: String, $first: Int, $last: Int) {&#xA;      getRaceResults(before: $before, after: $after, first: $first, last: $last, input: $input) {&#xA;        edges {&#xA;          cursor&#xA;          node {&#xA;            country&#xA;            city&#xA;          }&#xA;        }&#xA;        pageInfo {&#xA;          startCursor&#xA;          endCursor&#xA;          hasNextPage&#xA;          hasPreviousPage&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>variable:</p>&#xA;<pre><code>{&#xA;    &quot;first&quot;: 2,&#xA;    &quot;input&quot;: {&#xA;        &quot;onlyMyRacehorses&quot;: false,&#xA;        &quot;distance&quot;: {&#xA;            &quot;from&quot;: 1000,&#xA;            &quot;to&quot;: 2400&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",653328,,653328,2021-06-02 09:59:24,2021-06-02 09:59:24,"",,0,6,0,2021-06-02 08:49:32
67815985,2,,62474374,1,,"<p>Add a <code>numFilmssQueried</code> field to the context which you set at the end of the fields query. Then as you call each field resolver for actors, tally another field on context called <code>numFilmsLoadedIntoActorsDataloader</code>. When &quot;numFieldsQueried&quot; equals <code>numFieldsLoadedIntoActorsDataloader</code>, dispatch your DataLoader.</p>&#xA;",16113367,,6112907,2021-06-04 03:24:28,2021-06-04 03:24:28,"",,0,0,0,2021-06-03 05:43:56
67821585,1,67822303,,0,911,<p>I am using nestjs-typeorm and want to filter out nested data based on some reference. The code loads the whole database first and then filters the required result. How can I filter out the required data without loading entire table of the database making it more efficient and fast?</p>&#xA;<p>service.ts</p>&#xA;<pre><code>public async uploadedFiles(fileReferenceParams: ReferenceFilterParams): Promise&lt;UploadedFilesEntity[]&gt; {&#xA;    try {&#xA;      const manager = getManager();&#xA;      const trees = await manager.getTreeRepository(UploadedFilesEntity).findTrees();&#xA;      this.uploadedFilesRepository.createQueryBuilder()&#xA;      const rootFiles = trees.filter(tree =&gt; ( tree.isDeleted==false||null &amp;&amp; tree.referenceID == fileReferenceParams.referenceID &amp;&amp; tree.referenceType == fileReferenceParams.referenceType));&#xA;      return rootFiles;&#xA;    } catch (error) {&#xA;      return error;&#xA;    }&#xA;  }&#xA;&#xA;</code></pre>&#xA;,15375246,,68587,2021-06-03 12:36:21,2021-06-03 13:22:15,How can I filter data without loading it first?,<typescript><graphql><nestjs><typeorm><tree-structure>,1,0,0,2021-06-03 12:35:05
67822303,2,,67821585,0,,"<p>You can use the <code>createQueryBuilder</code> of TypeORM to filter in SQL without a  post query filter.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const trees = await this.repository.createQueryBuilder('tree')&#xA;    .where('tree.isDeleted IS FALSE OR NULL')&#xA;    .andWhere('tree.referenceID = :referenceId', { referenceId: fileReferenceParams.referenceID })&#xA;    .andWhere('tree.referenceType = :referenceType', { referenceType: fileReferenceParams.referenceType })&#xA;    .getMany();&#xA;</code></pre>&#xA;<p>Learn more about query builder on the <a href=""https://typeorm.io/#/select-query-builder"" rel=""nofollow noreferrer"">TypeORM documentation</a> to execute query with SQL search parameters</p>&#xA;",9885430,,,,2021-06-03 13:22:15,"",,0,0,0,2021-06-03 13:22:15
67835836,1,68406623,,1,826,"<p>On Django-Graphene, I have this model:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>class Entry(models.Model):&#xA;    STATE_CHOICES = [&#xA;        (&quot;Open&quot;, &quot;Open&quot;),&#xA;        (&quot;Processing&quot;, &quot;Processing&quot;),&#xA;        (&quot;Closed&quot;, &quot;Closed&quot;),&#xA;        (&quot;Deleted&quot;, &quot;Deleted&quot;),&#xA;    ]&#xA;&#xA;    # ...&#xA;    state = models.CharField(max_length=10, choices=STATE_CHOICES,&#xA;                             default=&quot;Open&quot;)&#xA;</code></pre>&#xA;<p>With the following Graphene schema:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>class EntryType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = models.Entry&#xA;&#xA;class Query(graphene.ObjectType):&#xA;    entries = graphene.List(EntryType)&#xA;&#xA;    def resolve_entries(self, info):&#xA;        return models.Entry.objects.all()&#xA;</code></pre>&#xA;<p>But when I use the next query:</p>&#xA;<pre><code>query AllEntries{&#xA;  entries{&#xA;    id&#xA;    state&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I get this error:</p>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;Expected a value of type \&quot;EntryState\&quot; but received: OPEN&quot;,&#xA;      &quot;path&quot;: [&#xA;        &quot;entries&quot;,&#xA;        1,&#xA;        &quot;state&quot;&#xA;      ]&#xA;    }&#xA;  ],&#xA;}&#xA;</code></pre>&#xA;<p>Can someone explain me what I'm doing wrong ?</p>&#xA;",10830699,,,,2021-07-16 09:23:17,"Django-Graphene: On a model ChoiceField, graphene expects a Type but got a value",<python><django><graphql><graphene-django>,1,0,0,2021-06-04 10:40:15
67842707,2,,67838446,0,,"<p>I think the issue with picking the subtypes is the optional properties. If you make the object non-nullish, TypeScript can pick out the subtype.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type Departments = Required&lt;GetCompanyChartQuery&gt;[&quot;generateOrgChart&quot;][&quot;departments&quot;]&#xA;</code></pre>&#xA;",2758250,,,,2021-06-04 19:01:16,"",,0,0,0,2021-06-04 19:01:16
67846781,1,67846896,,-1,61,"<p>Hey please don't roast me. So i have a JSON data like this</p>&#xA;<pre><code>data&quot;: {&#xA;    &quot;person&quot;: [&#xA;      {&#xA;        &quot;id&quot;: &quot;xx1&quot;,&#xA;        &quot;name&quot;: &quot;John DOe&quot;,&#xA;      },&#xA;     ],&#xA;    &quot;person&quot;: [&#xA;      {&#xA;        &quot;id&quot;: &quot;xx2&quot;,&#xA;        &quot;name&quot;: &quot;John Snow&quot;,&#xA;      },&#xA;     ],&#xA;}&#xA;</code></pre>&#xA;<p>For example, I want to store every person data whose name contains &quot;o&quot;. How could I do that? Thank you</p>&#xA;",13547416,,,,2021-06-05 06:21:10,Categorise JSON Data,<javascript><json><reactjs><graphql>,1,2,0,2021-06-05 06:03:37
67846896,2,,67846781,1,,"<p>JSON object ,if have duplicate keys, it will replace the first one with the most bottom one .</p>&#xA;<p>In your sample data, there is two &quot;person&quot; keys. Therefore, at the end, your said data will succumb to this.</p>&#xA;<pre><code>{&quot;data&quot;:{&quot;person&quot;:[{&quot;id&quot;:&quot;xx2&quot;,&quot;name&quot;:&quot;John Snow&quot;}]}}&#xA;</code></pre>&#xA;<p>Therefore, to clarify your data, IMHO, this is supposed to be like this in the first place.</p>&#xA;<pre><code>&quot;data&quot;: {&#xA;    &quot;person&quot;: [&#xA;      {&#xA;        &quot;id&quot;: &quot;xx1&quot;,&#xA;        &quot;name&quot;: &quot;John DOe&quot;,&#xA;      },&#xA;      {&#xA;        &quot;id&quot;: &quot;xx2&quot;,&#xA;        &quot;name&quot;: &quot;John Snow&quot;,&#xA;      },&#xA;     ]&#xA;}&#xA;</code></pre>&#xA;<p>Then you can treat <code>data.person</code> as an array and use <strong>Array.prototype</strong> function to <code>filter</code> out your desired details.</p>&#xA;<p>The filter method should be</p>&#xA;<pre><code>const personWithNameO = data.person.filter((v) =&gt; v.name.includes(&quot;o&quot;) );&#xA;console.log(personWithNameO);&#xA;</code></pre>&#xA;",13068635,,,,2021-06-05 06:21:10,"",,0,1,0,2021-06-05 06:21:10
67859367,1,,,-1,157,"<p>i am using <a href=""https://github.com/99designs/gqlgen"" rel=""nofollow noreferrer"">https://github.com/99designs/gqlgen</a> in golang for graphql, want to create an api that returns tree like structure, however i want to give a depth control instead of writing nested selections in the queries. is there a way to achieve this?&#xA;Want to achieve some thing like this,</p>&#xA;<pre><code>query listAll{&#xA;  node: getNodes(parentId: &quot;1235&quot;) {&#xA;    ID&#xA;    Name&#xA;    node: Children @recursive(depth: 10) {&#xA;        ID&#xA;        Name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2382443,,,,2021-06-06 14:40:12,recursion in graphql using golang,<go><recursion><graphql>,1,0,0,2021-06-06 12:54:23
67868630,2,,65708640,0,,<p>Try using alias instead. Something like</p>&#xA;<pre><code>fragment BasicInfo on Person {&#xA;      id&#xA;      name&#xA;      cityCountryAddress: address {&#xA;          city&#xA;          country&#xA;      }&#xA;  }&#xA;</code></pre>&#xA;,8341600,,,,2021-06-07 08:52:51,"",,0,0,0,2021-06-07 08:52:51
67878996,2,,67878405,0,,"<p>I think you'll need to pass it as an argument like first, last, before, after etc...</p>&#xA;<p>try to run your query like this and see if you're getting the results.</p>&#xA;<pre><code>query {&#xA;  PostsQuery(first: 5){&#xA;    pageInfo{&#xA;      endCursor&#xA;      startCursor&#xA;      hasPreviousPage&#xA;      hasNextPage&#xA;    }&#xA;    edge{&#xA;      cursor&#xA;      node{&#xA;        id&#xA;        title&#xA;        content&#xA;        published&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;OR&#xA;&#xA;query {&#xA;  PostsQuery(first: 5, after: &quot;ABC&quot;){&#xA;    edge{&#xA;      cursor&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5922155,,,,2021-06-07 21:38:15,"",,0,1,0,2021-06-07 21:38:15
67909482,2,,67878405,1,,"<p>I figured it out. The answer, for posterity, is that the graphql-ruby gem handles it transparently.</p>&#xA;<p>For example, if you execute this query:</p>&#xA;<pre><code>{&#xA;  posts(first:10, after:&quot;Mw&quot;) {&#xA;    pageInfo {&#xA;      startCursor&#xA;      endCursor&#xA;    }&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        author&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The graphql-ruby gem alters my existing <code>posts = Post.all</code> ActiveRecord call by adding the LIMIT and OFFSET to it behind the scenes:</p>&#xA;<pre><code>  Parameters: {&quot;query&quot;=&gt;&quot;{\n  posts(first:10, after:\&quot;Mw\&quot;) {\n    pageInfo {\n      startCursor\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        id\n        author\n      }\n    }\n  }\n}&quot;, &quot;variables&quot;=&gt;nil, &quot;graphql&quot;=&gt;{&quot;query&quot;=&gt;&quot;{\n  posts(first:10, after:\&quot;Mw\&quot;) {\n    pageInfo {\n      startCursor\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        id\n        author\n      }\n    }\n  }\n}&quot;, &quot;variables&quot;=&gt;nil}}&#xA;   (0.2ms)  SELECT COUNT(*) FROM &quot;posts&quot;&#xA;  ↳ app/graphql/queries/posts_query.rb:8:in `resolve'&#xA;20&#xA;  Post Load (0.3ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; LIMIT ? OFFSET ?  [[&quot;LIMIT&quot;, 10], [&quot;OFFSET&quot;, 3]]&#xA;  ↳ app/controllers/graphql_controller.rb:15:in `execute'&#xA;Completed 200 OK in 10ms (Views: 0.6ms | ActiveRecord: 0.4ms | Allocations: 4947)&#xA;&#xA;</code></pre>&#xA;",2177,,2177,2021-06-09 19:19:20,2021-06-09 19:19:20,"",,0,0,0,2021-06-09 17:59:25
67915636,1,,,0,258,"<p>We are trying for GraphQL Analytics API of cloudflare, we are trying to post this query through HttpClient</p>&#xA;<p>In response we are getting the error</p>&#xA;<blockquote>&#xA;<p>json: cannot unmarshal string into Go value of type graphql.httpPostBody</p>&#xA;</blockquote>&#xA;<p>This is the query we are getting after the SerializeObject</p>&#xA;<pre><code>&quot;query{viewer {zones(filter: { zoneTag: \&quot;XYZ\&quot;}) {httpRequests1dGroups(orderBy: [date_ASC], limit: 1000, filter: { date_gt: \&quot;2021-06-09\&quot;}) {date: dimensions {date}sum {cachedBytes bytes}}}}}&quot;&#xA;</code></pre>&#xA;<p>What is that we need to correct here, any ideas ?</p>&#xA;",1923173,,,,2021-06-21 05:34:17,json: cannot unmarshal string into Go value of type graphql.httpPostBody,<json><graphql><httpclient><cloudflare>,1,0,0,2021-06-10 06:09:27
67943676,2,,67940998,0,,"<p>I think you can do this by using the xs prop on the Row component. It would only be a single row, but every 4 columns would wrap to a new line.</p>&#xA;<p>If you really want to separate every 4 columns to a new  then you should transform the array into a nested array structure to allow for this.</p>&#xA;",16201861,,,,2021-06-11 21:34:00,"",,0,0,0,2021-06-11 21:34:00
67944107,2,,67942151,4,,"<p>DynamoDB does not excel in supporting ad-hoc queries among an arbitrary list of attributes.  If you want to fetch the same item using an undefined (or large) number of attributes(e.g. fetch student by mathMarks, socialMarks, scienceMarks, name, gender, etc) you will be better off using something other than DynamoDB.</p>&#xA;<p>EDIT:</p>&#xA;<p>You've updated your question with information that fundamentally changes the access pattern.  You initially said</p>&#xA;<blockquote>&#xA;<p>I want to fetch records of all male or female students from dynamodb who have secured more than x1 marks in maths, more than x2 marks in science, less than y1 marks in social and less than y2 marks in English...</p>&#xA;</blockquote>&#xA;<p>and later changed this access pattern to say (emphasis mine)</p>&#xA;<blockquote>&#xA;<p>I want to fetch records of all male or female students <strong>from class 5 to class 11</strong> who have secured between x1 and x2 marks in maths, between y1 and y2 marks in science, between z1 and z2 marks in english and between w1 and w2 marks in social</p>&#xA;</blockquote>&#xA;<p>Partitioning your data on gender and class range <em>might</em> allow you to implement this access pattern.  You also removed <code>... other variables</code> from your example schema, suggesting you might have a fixed list of marks include math, science, social, and English.  This is less important than gender and class, but hear me out :)</p>&#xA;<p>You didn't mention it in your original question, but your data suggests you have a <code>fetch Student by ID</code> access pattern.  So I started by defining students by ID:</p>&#xA;<p><a href=""https://i.stack.imgur.com/0SLI4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0SLI4.png"" alt=""enter image description here"" /></a></p>&#xA;<p>The partition key is STUDENT#student_id and the sort key is <code>A</code>.  I sometimes use &quot;METADATA&quot; or &quot;META&quot; as the sort key, but &quot;A&quot; is nice and short.</p>&#xA;<p>To support your primary access pattern, I created a global secondary index named <code>GSI1</code>, with PK and SK attributes of <code>GSI1PK</code> and <code>GSI1SK</code>.  I assigned GSI1PK <code>STUDENTS#gender</code> and GSISK is the <code>class</code> attribute.</p>&#xA;<p><a href=""https://i.stack.imgur.com/jwLXl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jwLXl.png"" alt=""enter image description here"" /></a></p>&#xA;<p>This partitions your data by gender and class.  To narrow your results even further, you'd need to use filters on the various marks.  For example, if you wanted to fetch all make students between class 5 and 9 with specific marks, you could do the following (in DynamoDB pseudocode):</p>&#xA;<pre><code>QUERY from GSI1 where PK=STUDENTS#M SK BETWEEN 05 and 09&#xA;      FILTER englishMark BETWEEN 009 and 050 AND&#xA;             mathsMark BETWEEN 050 and 075 AND&#xA;             scienceMark BETWEEN 045 and 065 AND&#xA;             socialMark BETWEEN 020 and 035 AND&#xA;&#xA;</code></pre>&#xA;<p>Filtering in DynamoDB doesn't work like most people think.  When filtering, DynamoDB:</p>&#xA;<ol>&#xA;<li>Read items from the table</li>&#xA;<li>Apply filter to remove items that don't match</li>&#xA;<li>Return items</li>&#xA;</ol>&#xA;<p>This can lead to awful performance (and cost) if you have a large table and are filtering for a very small set of data.  For example, if you're executing a <code>scan</code> operation on terabytes of data and applying filters to identify a single item, you're going to have a bad time.</p>&#xA;<p>However, there are circumstances where filtering is a fine solution.  One example is when you can use the Partition Key and Sort Key to narrow the set of data you're working with <em>before</em> applying a filter.  In the above example, I'm dividing your data by gender (perhaps dividing your search space in half) before further narrowing the items by class.  The amount of data you're left with might be small enough to filter out the remaining items effectively.</p>&#xA;<p>However, I'll point out that gender has rather <em>low</em> cardinality.  Perhaps there are more specifics about your access pattern that could help with that.  For example, maybe you could group students by primary/secondary school and create a PK of STUDENTS#F#1-5.  Maybe you could group them by the school district, or zip code?  No detail about access patterns is too specific when working with NoSQL databases!</p>&#xA;<p>The point of this exercise is to illustrate two points:</p>&#xA;<ol>&#xA;<li>Filtering in DynamoDB is best achieved by selecting a good primary key.</li>&#xA;<li>Using the DynamoDB filtering mechanism is best used on smaller subsets of your data.  Don't be afraid to use it in the right places!</li>&#xA;</ol>&#xA;",13549664,,13549664,2021-06-12 23:32:39,2021-06-12 23:32:39,"",,0,3,0,2021-06-11 22:31:27
67956806,1,,,1,532,"<p>Links first</p>&#xA;<ul>&#xA;<li><a href=""https://docs.github.com/en/graphql/overview/explorer"" rel=""nofollow noreferrer"">https://docs.github.com/en/graphql/overview/explorer</a></li>&#xA;<li><a href=""https://github.com/advisories"" rel=""nofollow noreferrer"">https://github.com/advisories</a></li>&#xA;<li><a href=""https://docs.github.com/en/graphql/reference/"" rel=""nofollow noreferrer"">https://docs.github.com/en/graphql/reference/</a></li>&#xA;</ul>&#xA;<p>I am trying</p>&#xA;<pre><code>{&#xA;    securityAdvisories(first: 100, ecosystem: nuget) {&#xA;    totalCount&#xA;    pageInfo {&#xA;        endCursor&#xA;        startCursor&#xA;    }&#xA;    nodes {&#xA;        description&#xA;        summary&#xA;        cvss {&#xA;        vectorString&#xA;        }&#xA;        databaseId&#xA;        identifiers {&#xA;        type&#xA;        value&#xA;        }&#xA;        ghsaId&#xA;    }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>I am getting Field 'securityAdvisories' doesn't accept argument 'ecosystem'&quot;&#xA;I see the field ecosystem in the <a href=""https://docs.github.com/en/graphql/reference/objects#securityadvisorypackage"" rel=""nofollow noreferrer"">https://docs.github.com/en/graphql/reference/objects#securityadvisorypackage</a></p>&#xA;<p>How do I filter by &quot;ecosystem&quot;?</p>&#xA;<p>This is possible, because I can do <a href=""https://github.com/advisories?query=ecosystem%3Anuget"" rel=""nofollow noreferrer"">https://github.com/advisories?query=ecosystem%3Anuget</a>&#xA;How do I get all 113 advisories?</p>&#xA;<p>Update</p>&#xA;<p>I can filter vulnerabilities belonging to an advisory by ecosystem.</p>&#xA;<pre><code>  vulnerabilities(first: 10, ecosystem: NUGET) {&#xA;    edges {&#xA;      node {&#xA;        advisory {&#xA;          id&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>Update 2&#xA;I crawl the UI first</p>&#xA;<pre><code>page=1;while [ 1 ];do  curl &quot;https://github.com/advisories?page=$count&amp;query=ecosystem%3Anuget&quot; -o $count.txt;count=$((count+1));done&#xA;find -maxdepth 1 -name &quot;*.txt&quot; | xargs grep -oE &quot;GHSA-\w{4}-\w{4}-\w{4}&quot; &#xA;</code></pre>&#xA;<p>After I have the list of GHSA I run this a bit cryptic Python</p>&#xA;<pre><code>import requests&#xA;import easyargs&#xA;&#xA;template=&quot;&quot;&quot;&#xA;{&quot;query&quot;: &quot;query securityAdvisory(ghsaId: \\&quot;GHSA_VALUE\\&quot;) {     id     description     ghsaId     permalink     summary     identifiers {       type       value     }     references {       url     }     origin     cwes(first: 10) {       nodes {         name         id         description         cweId       }     }     cvss {       score       vectorString     }     databaseId     publishedAt     notificationsPermalink     updatedAt     severity     withdrawnAt     vulnerabilities(first: 50) {       edges {         node {           severity           updatedAt           vulnerableVersionRange         }       }     }   } } &quot;}&#xA;&quot;&quot;&quot;&#xA;&#xA;# get token from https://github.com/settings/tokens&#xA;# ghsas is a list of GHSAs&#xA;@easyargs&#xA;def main(token=str, ghsas=str):&#xA;    with open(ghsas) as f:&#xA;        lines = f.readlines()&#xA;&#xA;    for s in lines:&#xA;        s = s.strip()&#xA;        data=template.replace(&quot;GHSA_VALUE&quot;, s, 1)&#xA;        r = requests.post(url=&quot;https://api.github.com/graphql&quot;, data=data, headers={&quot;Authorization&quot;:f&quot;bearer {token}&quot;})&#xA;        print(r.text)&#xA;&#xA;if __name__ == '__main__':&#xA;    main()&#xA;</code></pre>&#xA;<p>I am sure there is a better solution. <strong>In the perfect world I would have a single line curl returning a JSON containing 113 Nuget related security avisories</strong>. I can't figure out how to query the GraphQL.</p>&#xA;",2352611,,2352611,2021-06-18 04:51:20,2021-06-18 04:51:20,How to filter advisories from GitHub GraphQL by ecosystem,<api><github><graphql>,1,0,0,2021-06-13 09:35:23
67967846,2,,67929298,0,,"<p>You don't need <code>clientMutationId</code> in the recent relay.  Have a look at Sibelius' workshop: <a href=""https://github.com/sibelius/relay-workshop"" rel=""nofollow noreferrer"">https://github.com/sibelius/relay-workshop</a>.</p>&#xA;<p>Or an updated step-by-step guide for the newly created documentation on Relay v11: <a href=""https://relay.dev/docs/getting-started/step-by-step-guide/"" rel=""nofollow noreferrer"">https://relay.dev/docs/getting-started/step-by-step-guide/</a></p>&#xA;",3650708,,,,2021-06-14 09:30:04,"",,0,0,0,2021-06-14 09:30:04
67977385,1,,,0,227,"<p>I am looking to specify a certain required combination of parameters in a graphQL query.</p>&#xA;<p>The query should be valid either without any params and return all cats or filter by size AND species.</p>&#xA;<pre><code>extend type Query {&#xA;    cats(size: String, species: String): [Cat]&#xA;}&#xA;</code></pre>&#xA;<p>Is the only way to do this via the resolver (throw error if one arg is passed) or is there a neater way?</p>&#xA;",14483229,,,,2021-06-14 21:54:28,graphql query with certain combination of parameters,<graphql>,1,0,0,2021-06-14 21:24:27
67977665,2,,67977385,1,,"<p>I don't believe that this is defined in the spec. You could define a new input type and then use this though.</p>&#xA;<pre><code>input CatFilter {&#xA;    size: String!&#xA;    species: String!&#xA;}&#xA;&#xA;extend type Query {&#xA;    cats(filter: CatFilter): [Cat]&#xA;}&#xA;</code></pre>&#xA;<p>That way the parameter is optional, but if given, both properties are required.</p>&#xA;",1386873,,,,2021-06-14 21:54:28,"",,0,0,0,2021-06-14 21:54:28
67984194,1,67989119,,0,1304,"<p>Graphql Schema :</p>&#xA;<pre><code>type Media @model&#xA;{&#xA;  id: ID!&#xA;  title: String&#xA;  type: String&#xA;}&#xA;</code></pre>&#xA;<p>Sample Data :</p>&#xA;<pre><code>{&#xA;      id: &quot;some ID&quot;,&#xA;      title: &quot;sample media1&quot;,&#xA;      type: &quot;image/png&quot;,&#xA;}&#xA;&#xA;{&#xA;      id: &quot;some ID&quot;,&#xA;      title: &quot;sample media2&quot;,&#xA;      type: &quot;video/mp4&quot;,&#xA;}&#xA;</code></pre>&#xA;<p>I'd like to fetch only data that its type contains string &quot;image&quot;.</p>&#xA;<blockquote>&#xA;<p>type: &quot;image/mp4&quot;</p>&#xA;</blockquote>&#xA;<p>I know that I can get some data based on title in this way.</p>&#xA;<pre><code>import { API, graphqlOperation } from &quot;aws-amplify&quot;&#xA;import * as queries from &quot;@src/graphql/queries&quot;&#xA;...&#xA;let title = &quot;sample media1&quot;&#xA;const medias = await API.graphql(&#xA;                 graphqlOperation(queries.listMedias, { filter: { title: { eq: title } } })&#xA;               )&#xA;</code></pre>&#xA;<p>Is there any similar way to get data that one of its attributes contains a specific value?</p>&#xA;<p><strong>&quot;contains&quot; not &quot;exact same&quot;</strong></p>&#xA;",14860805,,14860805,2021-06-15 13:26:53,2021-06-15 15:24:02,Filtering data from AWS Amplify Graphql API,<javascript><reactjs><graphql><aws-amplify><amazon-dynamodb>,1,0,0,2021-06-15 10:05:40
67989119,2,,67984194,1,,"<p>As stated in AWS Amplify <a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js#filtering-queries"" rel=""nofollow noreferrer"">documentation</a> you can use corresponding <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html"" rel=""nofollow noreferrer"">DynamoDB queries</a>. One of this queries is contains, but it is dependent on the type of field that your are doing filtering. List of all operators supported by DynamoDB:</p>&#xA;<ul>&#xA;<li>EQ</li>&#xA;<li>NE</li>&#xA;<li>LE</li>&#xA;<li>LT</li>&#xA;<li>GE</li>&#xA;<li>GT</li>&#xA;<li>NOT_NULL</li>&#xA;<li>NULL</li>&#xA;<li>CONTAINS</li>&#xA;<li>NOT_CONTAINS</li>&#xA;<li>BEGINS_WITH</li>&#xA;<li>IN</li>&#xA;<li>BETWEEN</li>&#xA;</ul>&#xA;<p>So in your example:</p>&#xA;<pre><code>import { API, graphqlOperation } from &quot;aws-amplify&quot;&#xA;import * as queries from &quot;@src/graphql/queries&quot;&#xA;...&#xA;let title = &quot;sample media1&quot;&#xA;const medias = await API.graphql(&#xA;                 graphqlOperation(queries.listMedias, { filter: { title: { contains: title } } })&#xA;               )&#xA;</code></pre>&#xA;",1386584,,,,2021-06-15 15:24:02,"",,0,1,0,2021-06-15 15:24:02
68004128,2,,67982243,1,,"<p><strong>Answering my own question</strong></p>&#xA;<p>As suggested by <strong>@Ambassel</strong> in the comments I ended up creating a view</p>&#xA;<pre><code>create view reportee_total_vw AS&#xA;select&#xA;    employees.manager_id,&#xA;    SUM(payrolls.salary)&#xA;from&#xA;    employees,&#xA;    payrolls&#xA;where&#xA;    payrolls.employee_id = employees.&quot;ID&quot;&#xA;group by&#xA;    employees.manager_id&#xA;</code></pre>&#xA;<p>Next I created a relationship named &quot;reportee&quot; that bound the &quot;ID&quot; from employees table with the &quot;manager_id&quot; from the view.</p>&#xA;<p>After that I could issue the underlying GQL query to get the result I wanted (although not in the exact format, but I can live with that :))</p>&#xA;<pre><code>{&#xA;  employees {&#xA;    full_name&#xA;    reportee {&#xA;      total_reportee_salary:sum&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12997302,,,,2021-06-16 13:55:39,"",,0,0,0,2021-06-16 13:55:39
68006889,2,,67956806,2,,"<p>For the arguments you can filter by you need to look at documentation for the Query type, not the Object type, i.e. <a href=""https://docs.github.com/en/graphql/reference/queries#securityadvisoryconnection"" rel=""nofollow noreferrer"">https://docs.github.com/en/graphql/reference/queries#securityadvisoryconnection</a></p>&#xA;<p>Since it doesn't have an entry for <code>ecosystem</code> you can't filter your query results by ecosystem. You can return the ecosystem though (by adding it to your <code>node</code> block), then filter the results by ecosystem once they've been returned to you.</p>&#xA;<p>The things you can filter by are stored as redundant data in the graph, which means the backend can avoid visiting the node altogether. Obviously there's a cost to that though, so it's only done for things that people will commonly want to filter by</p>&#xA;",2066474,,,,2021-06-16 16:43:42,"",,0,2,0,2021-06-16 16:43:42
68020309,1,,,0,297,"<p>I'm trying with all the latest version of apollo-ios but i'd like to solve this one lingering problem: I keep getting optional values (see image below).</p>&#xA;<p><img src=""https://user-images.githubusercontent.com/990511/122034712-5e2b0200-ce04-11eb-930b-5e3fe2c95ed8.png"" alt=""xcode"" /></p>&#xA;<p>Here's what I've explored (but still can't find whyyy)</p>&#xA;<p>When I created the table, Nullable is false. Then, I create a view which is for public to access it.</p>&#xA;<p><img src=""https://user-images.githubusercontent.com/990511/122035617-3ab48700-ce05-11eb-92bc-ea17c68fda09.png"" alt=""table"" /></p>&#xA;<p><img src=""https://user-images.githubusercontent.com/990511/122035361-f923dc00-ce04-11eb-8e7a-e851117c382b.png"" alt=""view"" /></p>&#xA;<p>With apollo schema:download command, here's the generated json: <a href=""https://github.com/vinamelody/MyApolloTest/blob/test/Apollo/schema.json"" rel=""nofollow noreferrer"">schema.json</a></p>&#xA;<p>With graphqurl command, here's the generated schema.graphql: <a href=""https://github.com/vinamelody/MyApolloTest/blob/test/Apollo/schema.graphql"" rel=""nofollow noreferrer"">schema.graphql</a>. Here's the snippet.</p>&#xA;<pre><code>&quot;&quot;&quot;&#xA;columns and relationships of &quot;schedule&quot;&#xA;&quot;&quot;&quot;&#xA;type schedule {&#xA;  activity: String&#xA;  end_at: timestamptz&#xA;  id: Int&#xA;&#xA;  &quot;&quot;&quot;An array relationship&quot;&quot;&quot;&#xA;  speakers(&#xA;    &quot;&quot;&quot;distinct select on columns&quot;&quot;&quot;&#xA;    distinct_on: [talk_speakers_view_select_column!]&#xA;&#xA;    &quot;&quot;&quot;limit the number of rows returned&quot;&quot;&quot;&#xA;    limit: Int&#xA;&#xA;    &quot;&quot;&quot;skip the first n rows. Use only with order_by&quot;&quot;&quot;&#xA;    offset: Int&#xA;&#xA;    &quot;&quot;&quot;sort the rows by one or more columns&quot;&quot;&quot;&#xA;    order_by: [talk_speakers_view_order_by!]&#xA;&#xA;    &quot;&quot;&quot;filter the rows returned&quot;&quot;&quot;&#xA;    where: talk_speakers_view_bool_exp&#xA;  ): [talk_speakers_view!]!&#xA;  start_at: timestamptz&#xA;  talk_description: String&#xA;  talk_type: String&#xA;  title: String&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>I am suspecting that it looks like <code>id: Int</code> is missing <code>!</code> in the schema, is the cause of codegen interpreting it as optional. But I could be wrong too. Here's the repo for the complete reference <a href=""https://github.com/vinamelody/MyApolloTest/tree/test"" rel=""nofollow noreferrer"">https://github.com/vinamelody/MyApolloTest/tree/test</a></p>&#xA;",1253898,,1253898,2021-06-18 02:23:29,2021-06-18 03:44:16,Apollo ios codegen generates optional values,<ios><graphql><apollo><hasura>,1,0,0,2021-06-17 13:24:28
68040207,2,,68033553,0,,"<p>The problem you are facing is that the <code>_rawX</code> fields doesn't resolve references automatically. That said, Sanity provides a way for you to tell how deep you want references to be resolved at.</p>&#xA;<pre><code>export const query = graphql`&#xA;  query peopleTemplateQuery($id: String!) {&#xA;    post: sanityPeople(id: { eq: $id }) {&#xA;      id&#xA;      publishedAt&#xA;      email&#xA;      slug {&#xA;        current&#xA;      }&#xA;      name&#xA;      jobTitle&#xA;      image {&#xA;        ...SanityImage&#xA;        alt&#xA;      }&#xA;      location {&#xA;        location&#xA;      }&#xA;      _rawBio(resolveReferences: { maxDepth: 5 })&#xA;      feeStructure&#xA;      qualification {&#xA;        qualification&#xA;      }&#xA;      specialisations {&#xA;        specialisation&#xA;      }&#xA;    }&#xA;    dictionary: allSanityDictionary {&#xA;      nodes {&#xA;        key&#xA;        value&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>You will need to specify a depth that suits your data structure.</p>&#xA;<p>Documentation: <a href=""https://www.sanity.io/docs/gatsby-source-plugin#raw-fields"" rel=""nofollow noreferrer"">https://www.sanity.io/docs/gatsby-source-plugin#raw-fields</a>.</p>&#xA;",4312438,,4312438,2022-03-06 09:33:25,2022-03-06 09:33:25,"",,0,4,0,2021-06-18 18:52:44
68050520,1,,,0,228,"<p>I am doing a code along project of GRAND stack real-estate-app &quot;https://www.youtube.com/watch?v=WB--CkjKJMQ&amp;list=PL9Hl4pk2FsvUjfSsxLolVToO5t1hwEIKK&amp;index=2&quot;</p>&#xA;<p>I have installed all the dependencies and configured the database <code>v3.5.18</code> and set the configurations in <code>.env</code> file.</p>&#xA;<p>After that I ran the <code>inferschema:write</code> script.</p>&#xA;<p>the schema.graphql file was updated with the following code</p>&#xA;<pre><code>type Property {&#xA;   _id: Long!&#xA;   AddressL_1: String&#xA;   AddressLin: String&#xA;   Assessment: String&#xA;   COUNTYCD: Int!&#xA;   CareOfTaxp: String&#xA;   Certificat: String&#xA;   CityStateZ: String&#xA;   Continuous: Float!&#xA;   CountyAbbr: String!&#xA;   CountyName: String!&#xA;   DbaName: String&#xA;   FallowAcre: Float!&#xA;   FarmsiteAc: Float!&#xA;   ForestAcre: Float!&#xA;   GISAcres: Float!&#xA;   GrazingAcr: Float!&#xA;   IrrigatedA: Float!&#xA;   LegalDescr: String&#xA;   LevyDistri: String&#xA;   NonQualAcr: Float!&#xA;   OwnerAdd_1: String&#xA;   OwnerAdd_2: String&#xA;   OwnerAddre: String&#xA;   OwnerCity: String&#xA;   OwnerName: String&#xA;   OwnerState: String&#xA;   OwnerZipCo: String&#xA;   PropType: String&#xA;   PropertyID: Int!&#xA;   Range: String&#xA;   SHAPE_Area: Float!&#xA;   SHAPE_Leng: Float!&#xA;   Section: String&#xA;   Subdivisio: String&#xA;   TaxYear: Int!&#xA;   TotalAcres: Float!&#xA;   TotalBuild: Int!&#xA;   TotalLandV: Int!&#xA;   TotalValue: Int!&#xA;   Township: String&#xA;   WildHayAcr: Float!&#xA;   id: String!&#xA;}&#xA;</code></pre>&#xA;<p>Then when I run the server, it I gives me the following error</p>&#xA;<blockquote>&#xA;<p>C:\Users&lt;path-to-folder&gt;\practice-GRAND-&gt;STACK\realEstateApp\api\node_modules\graphql-compose\lib\TypeStorage.js:44</p>&#xA;</blockquote>&#xA;<pre><code> throw new Error(`Type with name ${(0, _misc.inspect)(typeName)} does not exists`);&#xA; Error: Type with name &quot;Long&quot; does not exists&#xA;</code></pre>&#xA;",9984976,,9984976,2021-06-19 21:03:17,2021-10-04 04:47:27,"Error: Type with name ""Long"" does not exists",<neo4j><graphql><apollo><neo4j-apoc><grandstack>,1,1,0,2021-06-19 20:31:06
68074896,1,,,0,96,"<p>I have a react native application where I'm calling a graphQL API.  The GraphQL queries are structured to support a pagination operations.</p>&#xA;<p>The query is shown below. I can pass both size and skip variables to the query to allow it to retrieve data for a given number of records. For simplicity, I've ignored the userData because it's not important.</p>&#xA;<pre><code>const paginationQuery = `{&#xA;      actualDataByUser${skip ? '(where: {size: '+size+', start_position:' + skip + '})' : ''} {&#xA;        data {&#xA;          .... (IGNORE THIS)&#xA;        }&#xA;      }&#xA;    }`;&#xA;</code></pre>&#xA;<p>I'm trying to understand if hooks make sense here with different <code>size</code> and <code>skip</code> parameters? For example I can create a function <code>actualDataByUser</code> like this which runs the above query and gets the first 100 records.</p>&#xA;<pre><code>const getAllRecords = async (obj={}) =&gt; {&#xA;  return actualDataByUser(obj);&#xA;}&#xA;&#xA;The hook below will retrieve the first 100 records starting from 0.&#xA;&#xA;export default function RecordScreen() {&#xA;  &#xA;  const [recordList, setRecordList] = useState([]);&#xA;  useEffect(() =&gt; {&#xA;      const receivedRecords = getAllRecords({skip: 0, size: 100}).then(res =&gt; {&#xA;      setRecordList(receivedRecords);&#xA;  }, []);&#xA;&#xA;  &#xA;}&#xA;</code></pre>&#xA;<p>However, I'm trying to understand the best way to increment <code>skip</code> each time to allow it to keep streaming the data back.</p>&#xA;",427995,,427995,2021-06-22 05:06:10,2021-06-22 05:06:10,React native hooks and calling API with pagination,<reactjs><react-native><graphql><react-hooks>,1,1,0,2021-06-21 21:23:44
68081244,1,68081586,,0,107,"<p>I want to make a list of all unique node values and render them on my page. This is what I have:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import { graphql, Link } from &quot;gatsby&quot;&#xA;import React from &quot;react&quot;&#xA;import Layout from &quot;../layouts/Layout&quot;&#xA;const _ = require(&quot;lodash&quot;)&#xA;&#xA;export default props =&gt; {&#xA;    const majorNodes = props.item.edges.node&#xA;    let majors = []&#xA;    let major = []&#xA;    majorNodes.map(majorNode =&gt; majors.push(majorNode.major))&#xA;    majors = majors.concat(major)&#xA;    majors = _.uniq(majors)&#xA; &#xA;  return (&#xA;    &lt;Layout&gt;&#xA;      &#xA;&lt;div&gt;{majors}&lt;/div&gt;&#xA;    &lt;/Layout&gt;&#xA;  )&#xA;}&#xA;&#xA;export const query = graphql`&#xA;  query majors {&#xA;    item: allContentfulPortfolio {&#xA;      edges {&#xA;          node {&#xA;              major&#xA;          }&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>However, this gives me the following error:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>TypeError: Cannot read property 'edges' of undefined&#xA;_default&#xA;D:/Gatsby/archives/src/pages/majors.js:7&#xA;   4 | const _ = require(&quot;lodash&quot;)&#xA;   5 | &#xA;   6 | export default props =&gt; {&#xA;&gt;  7 |     const majorNodes = props.item.edges.node&#xA;   8 |     let majors = []&#xA;   9 |     let major = []&#xA;  10 |     majorNodes.map(majorNode =&gt; majors.push(majorNode.major))&#xA;</code></pre>&#xA;<p>How do I fix this? Additionally, is this how I should pass the array <code>majors</code> for rendering? I think that is where I am going wrong.</p>&#xA;",4112751,,4112751,2021-06-22 10:04:51,2021-06-22 10:17:48,Gatsby: How Do I Make a List of All Nodes?,<graphql><gatsby>,1,3,0,2021-06-22 09:45:11
68081586,2,,68081244,1,,"<p>Your nodes are stored inside <code>props.data</code> so:</p>&#xA;<pre><code>   const majorNodes = props.item.edges.node&#xA;</code></pre>&#xA;<p>Should become:</p>&#xA;<pre><code> const majorNodes = props.data.item.edges.node&#xA;</code></pre>&#xA;<blockquote>&#xA;<p>Additionally, is this how I should pass the array majors for&#xA;rendering? I think that is where I am going wrong.</p>&#xA;</blockquote>&#xA;<p><code>majors</code> is an array so printing it directly as:</p>&#xA;<pre><code>&lt;div&gt;{majors}&lt;/div&gt;&#xA;</code></pre>&#xA;<p>Won't work.</p>&#xA;<p>You should loop through each element with something like:</p>&#xA;<pre><code>&lt;div&gt;{majors.map(major =&gt; &lt;p&gt; Major element is {major}&lt;/p&gt; )}&lt;/div&gt;&#xA;</code></pre>&#xA;",5585371,,5585371,2021-06-22 10:17:48,2021-06-22 10:17:48,"",,0,1,0,2021-06-22 10:06:59
68088942,1,,,0,671,<p>I have a nested structure in my strawberry-graphql schema resolver implementation. Any suggestions on how I can limit query depth in strawberry-graphql (Django implementation)?</p>&#xA;,8676590,,8676590,2021-06-23 03:22:50,2021-06-23 16:46:36,How to limit query depth in strawberry-graphql (Django implementation)?,<django><graphql><depth>,1,0,0,2021-06-22 18:19:28
68096273,1,,,1,232,"<p>I've been doing some research on how to set up a new GraphQL API project, but am running into some basic conceptual? problems in trying to find out how to do pagination and nested database queries efficiently.</p>&#xA;<p>I'd appreciate any pointers or advice!</p>&#xA;<p>Let's say we get a graphql query like so:</p>&#xA;<pre><code>articles(limit: 10) {&#xA;  title&#xA;  content&#xA;  comments(limit: 5) {&#xA;    postedAt&#xA;    text&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>A typical ORM, assuming eager loading of the nested type, could translate this type of query into an sql query like this, and then loop over the results to manually group the comments together and hydrate it all.</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>select a.title, a.content, c.posted_at, c.text&#xA;from articles as a&#xA;left join comments as c on c.article_id = a.id&#xA;limit ???&#xA;</code></pre>&#xA;<p>But so far, I've only ever seen ORMs like Doctrine (php) and Sequelize (js) fail in doing pagination correctly in these cases. They can't correctly handle page sizes, because there's no way to express the <code>limit</code> in this sql query's setup.</p>&#xA;<ul>&#xA;<li><strong>=&gt; Am I correct in seeing this problem? Or am I missing something crucial, are ORMs able to do pagination with eagerly loaded data somehow?</strong></li>&#xA;</ul>&#xA;<p>So now I just recently came across the <code>lateral</code> join type in Postgres, which seems to solve this issue, provided we also add some json trickery:</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>select a.title, a.content, t.data as comments&#xA;from articles as a&#xA;join lateral (&#xA;  select json_agg(sub.*) as data&#xA;  from (&#xA;    select c.posted_at, c.text&#xA;    from comments as c&#xA;    where c.article_id = a.id&#xA;    limit 5&#xA;  ) sub&#xA;) t on true&#xA;limit 20;&#xA;</code></pre>&#xA;<p>(I think I've seen this kind of <code>lateral</code> + json trickery stuff in how Hasura and Postgraphile transform to sql, so I don't this it's unwarranted / bad engineering.)</p>&#xA;<ul>&#xA;<li><strong>=&gt; Is there any ORM out there (except hasura/postgraphile), possibly Postgres-specific, that use this kind of <code>lateral</code> and json stuff, instead of the typical method described above?</strong></li>&#xA;</ul>&#xA;<p>Lastly, my research has taught me that in building a graphql api, you'll typically find yourself <em>data-loading</em> (batching) nested queries, instead of eager-loading them from the &quot;parent&quot; query. So, for example, this would be without data-loading:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>class ArticleResolver {&#xA;&#xA;  comments(article) {&#xA;    db.query(&quot;select ... from comments where ... = {article.id}&quot;);&#xA;  }&#xA;</code></pre>&#xA;<p>and then this would be with data-loading:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>class ArticleResolver {&#xA;&#xA;  commentsDataLoader = new DataLoader(articleIds =&gt; {&#xA;    return db.query(&quot;select ... from comments where ... in {articleIds}&quot;);&#xA;  });&#xA;&#xA;  comments(article) {&#xA;    return this.commentsDataLoader.load(article.id);&#xA;  }&#xA;</code></pre>&#xA;<p>But, as soon as you want to start adding parameters like <code>limit: 5</code> to nested queries, this data-loading query gets as complicated as the original question, so we're back where we were :)</p>&#xA;<ul>&#xA;<li><strong>=&gt; Is there a conventional way, of some standard practices, for dealing with this setup? Is there any known way / library so easily write out resolvers like, for example, this:</strong></li>&#xA;</ul>&#xA;<pre><code>class ArticleResolver&#xA;  ...&#xA;&#xA;  comments(article, limit) {&#xA;    return db.somehowMagicallyDataloaded(&quot;select * from comments ... = {article.id} limit {limit}&quot;)&#xA;  }&#xA;</code></pre>&#xA;",710395,,905902,2021-06-23 08:58:03,2021-06-23 08:58:03,"SQL pagination issues, and specifically with GraphQL data-loading",<postgresql><orm><pagination><graphql><dataloader>,0,2,0,2021-06-23 08:29:25
68109125,2,,66322095,0,,"<p>To refetch a pagination container, use <a href=""https://relay.dev/docs/v10.1.3/pagination-container#refetchconnection"" rel=""nofollow noreferrer""><code>refetchConnection</code></a>.</p>&#xA;",1493255,,,,2021-06-24 03:05:43,"",,0,0,0,2021-06-24 03:05:43
68109894,1,,,1,1108,"<p>How to define the Action type in Hasura graphql(console) for below given API response?</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;    &quot;data&quot;: [&#xA;        {&#xA;            &quot;name&quot;: &quot;Jordan Smith&quot;,&#xA;            &quot;id&quot;: 101,&#xA;            &quot;location&quot;: &quot;Florida&quot;,            &#xA;            &quot;speciality_id&quot;: 214&#xA;        },&#xA;        {&#xA;            &quot;name&quot;: &quot;Cathy Morphy&quot;,&#xA;            &quot;id&quot;: 104,&#xA;            &quot;location&quot;: &quot;london&quot;,&#xA;            &quot;speciality_id&quot;: 214&#xA;        }&#xA;    ],&#xA;    &quot;count&quot;: 2 }&#xA;</code></pre>&#xA;",16303524,,1940850,2021-06-25 01:42:34,2021-07-01 19:28:44,How to mention array of object in hasura graphql action type?,<graphql><hasura>,1,4,0,2021-06-24 05:03:40
68122776,1,,,0,61,"<p>For context, I'm working on an API that integrates with a third-party API and has to make graphQL calls to do so.  Some of those graphQL calls get pretty complex, nesting down pretty deep to get to the information I'm actually after.</p>&#xA;<p>So I'm wondering how do you keep your classes organized with these long, long strings bloating up your classes?  Is there a best-practice I'm missing, an obvious solution I've overlooked?</p>&#xA;<p>Older style JSON APIs could have similar problems with POST bodies, but in those cases you were usually composing hashes with 'real' code that genuinely belonged in the class, even if it bulked up the class -- and often wasn't as bulky as a similar GraphQL string.  The GraphQL strings, on the other hand, are fixed, static entities, relying on variables to be provided at run-time.</p>&#xA;<p>I'm looking at one of my early classes, that only needed a single query, but that query is 40 lines, nearly half of the normal '100 line' budget rubocop suggests for classes.  A larger class, making more than a single query, could easily eat up it's entire line budget just on queries, and making a single class per query seems like it might be excessive.  Sure, I could shorten that class by stripping out most of the newlines, but then it's not very readable, or easily edited.</p>&#xA;",439778,,,,2021-06-24 21:11:04,How do you organize your graphQL queries without bloating up your classes with long strings?,<ruby-on-rails><graphql>,0,3,0,2021-06-24 21:11:04
68124241,2,,68121088,0,,"<p>What I did was create a function in graphile for the joining table. This provides a mutation on that table.</p>&#xA;<p>Then I just combined both mutation in one. One updates the connection for the direct connections, the other updates the relations:</p>&#xA;<pre><code>mutation TagDeleteTagMutation($tag:DeleteTagInput!, $messageTag:DeleteMessageTagInput!, $connections: [ID!]!) {&#xA;    deleteMessageTag(input: $messageTag) {&#xA;        messageTag {&#xA;          id @deleteEdge(connections: $connections)&#xA;      }&#xA;    }&#xA;    deleteTag(input: $tag) {&#xA;      tag {&#xA;        id @deleteEdge(connections: $connections)&#xA;      }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",11971788,,,,2021-06-25 01:02:08,"",,0,0,0,2021-06-25 01:02:08
68142851,2,,68142746,0,,"<ol>&#xA;<li>Ensure you are passing the required arguments from teh apollo client</li>&#xA;</ol>&#xA;<p>ex.</p>&#xA;<pre><code>this.queryArticles = this.apollo&#xA;      .watchQuery({&#xA;        query: ARTICLES_QUERY,&#xA;        variables: {&#xA;          start: start,&#xA;          limit: this.limit&#xA;        }&#xA;      })&#xA;      .valueChanges.subscribe(result =&gt; {&#xA;        this.data = result.data;&#xA;        this.articles = this.data.articles;&#xA;        this.loading = result.loading;&#xA;        this.errors = result.errors;&#xA;      });&#xA;  }&#xA;</code></pre>&#xA;<p>Ref: <a href=""https://www.codinghub.net/article/pagination-integration-with-strapi-angular-and-graphql"" rel=""nofollow noreferrer"">https://www.codinghub.net/article/pagination-integration-with-strapi-angular-and-graphql</a></p>&#xA;<ol start=""2"">&#xA;<li>While filtering pls use offset i.e, start index for the record index</li>&#xA;</ol>&#xA;<p>articles(start:$start, limit:$limit, sort:&quot;published_at:desc&quot;)</p>&#xA;<p>Ref: <a href=""https://www.codinghub.net/article/pagination-integration-with-strapi-angular-and-graphql"" rel=""nofollow noreferrer"">https://www.codinghub.net/article/pagination-integration-with-strapi-angular-and-graphql</a></p>&#xA;",2544810,,,,2021-06-26 13:32:54,"",,0,1,0,2021-06-26 13:32:54
68184654,1,,,0,659,"<p>I am trying to render tradingview chart using tradingview charting library and using bitquery api for datafeed.</p>&#xA;<p>Chart is being displayed but there is no data on the chart.</p>&#xA;<p><strong>I opened the inspect element and noticed this:</strong></p>&#xA;<p><a href=""https://i.stack.imgur.com/r6VBE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r6VBE.png"" alt=""enter image description here"" /></a></p>&#xA;<p>More specifically the part about <code>RangeError: Invalid time value</code> <strong>I am assuming</strong> that's what's causing the chart to not load any candlestick data?</p>&#xA;<p><strong>This is the section of the code in datafeed.js:</strong></p>&#xA;<pre><code>// This method is used by the charting library to get historical data for the symbol. &#xA;getBars: async(symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, first) =&gt;{&#xA;    try{&#xA;        if (resolution==='1D') {&#xA;            resolution = 1440;&#xA;        }&#xA;        const response2 = await axios.post(Bitquery.endpoint, {&#xA;            query: Bitquery.GET_COIN_BARS,&#xA;            variables: {&#xA;                &quot;from&quot;: new Date(from).toISOString(),&#xA;                &quot;to&quot;: new Date(to).toISOString(),&#xA;                &quot;interval&quot;: Number(resolution),&#xA;                &quot;tokenAddress&quot;: symbolInfo.ticker&#xA;            },&#xA;            &#xA;            mode: 'cors',&#xA;            headers: {&#xA;                &quot;Content-Type&quot;: &quot;application/json&quot;,&#xA;                &quot;X-API-KEY&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;&#xA;            }&#xA;            &#xA;        })&#xA;        const bars = response2.data.data.ethereum.dexTrades.map(el =&gt; ({&#xA;            time: new Date(el.timeInterval.minute).getTime(), // date string in api response&#xA;            low: el.low,&#xA;            high: el.high,&#xA;            open: Number(el.open),&#xA;            close: Number(el.close),&#xA;            volume: el.volume&#xA;        }))&#xA;&#xA;        if (bars.length){&#xA;            onHistoryCallback(bars, {noData: false}); &#xA;        }else{&#xA;            onHistoryCallback(bars, {noData: true}); &#xA;        }&#xA;&#xA;    } catch(err){&#xA;        console.log({err})&#xA;        // onErrorCallback(err)&#xA;    }&#xA;</code></pre>&#xA;<p>I am fairly new with tradingview charting library and JS, so I need suggestions to fix this.</p>&#xA;",15152125,,215552,2021-06-29 19:38:23,2021-06-29 19:38:23,How to solve RangeError: Invalid time value at Date.toISOString,<javascript><reactjs><graphql><graphql-js>,0,3,0,2021-06-29 19:34:53
68187156,2,,68064113,0,,"<p>You don't need to register your own type to get the tag urls and a pagination.</p>&#xA;<p>In the query <code>tags(first: 3)</code> sets the number of items per page. In this case 3.</p>&#xA;<pre><code>query get_links_to_tags {&#xA;  tags(first: 3) {&#xA;    nodes {&#xA;      uri&#xA;      link&#xA;    }&#xA;    pageInfo {&#xA;      endCursor&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;      startCursor&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>In the response, <code>endCursor</code> will be the last item.</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;tags&quot;: {&#xA;      &quot;nodes&quot;: [&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/apple/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/apple/&quot;&#xA;        },&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/atari/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/atari/&quot;&#xA;        },&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/sinclair/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/sinclair/&quot;&#xA;        }&#xA;      ],&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;endCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjI1MQ==&quot;,&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;hasPreviousPage&quot;: false,&#xA;        &quot;startCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjE3Ng==&quot;&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In the example above, it's <code>YXJyYXljb25uZWN0aW9uOjI1MQ==</code>. This a base64-encoded string, you can decode it on <a href=""https://www.base64decode.org/"" rel=""nofollow noreferrer"">Base64decode.org</a>, you will see that it says <code>arrayconnection:251</code>.</p>&#xA;<p>When making the next query, use the value of that cursor as <code>after</code>.</p>&#xA;<pre><code>query get_links_to_tags {&#xA;  tags(first: 3, after: &quot;YXJyYXljb25uZWN0aW9uOjI1MQ==&quot;) {&#xA;    nodes {&#xA;      uri&#xA;      link&#xA;    }&#xA;    pageInfo {&#xA;      endCursor&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;      startCursor&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This will give you the next three items back.</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;tags&quot;: {&#xA;      &quot;nodes&quot;: [&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/tandy/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/tandy/&quot;&#xA;        },&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/sun-microsystems/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/sun-microsystems/&quot;&#xA;        },&#xA;        {&#xA;          &quot;uri&quot;: &quot;/tag/xerox/&quot;,&#xA;          &quot;link&quot;: &quot;https://test.local/tag/xerox/&quot;&#xA;        }&#xA;      ],&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;endCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjI1NA==&quot;,&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;hasPreviousPage&quot;: true,&#xA;        &quot;startCursor&quot;: &quot;YXJyYXljb25uZWN0aW9uOjI1Mg==&quot;&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>As you can see, you have the <code>hasNextPage</code> and <code>hasPreviousPage</code> available for you to decide if you will put a previous-next button for the pagination.</p>&#xA;",5422759,,,,2021-06-30 00:37:09,"",,0,4,0,2021-06-30 00:37:09
68212971,1,68459648,,6,2325,"<p>I am currently trying to filter a nested list based on a given id, but don't understand the syntax required. Although I have altered the entities and properties, this is what I am attempting</p>&#xA;<pre><code>{&#xA;  companies{&#xA;    company{&#xA;      id,&#xA;      name,&#xA;      offices(where:{officeId: {eq: 2}}){&#xA;        officeId,&#xA;        address,&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In the returned data, I would like ALL companies and their offices where the office id is equal to 2. Is this possible and how would I do this?</p>&#xA;",3428422,,3428422,2021-07-15 14:52:50,2022-07-02 15:33:13,graphql - how to filter a nested list,<graphql><hotchocolate>,2,0,0,2021-07-01 15:26:07
68264512,1,,,0,216,"<p>When I try to fetch data from a graphQL endpoint, it limits the amount of data returned to 100. How do I increase it?</p>&#xA;<p>client:</p>&#xA;<pre><code>export const dexCandlesGraph = chainId =&gt; {&#xA;  const uri = DEXCANDLES_SUBGRAPH[chainId ?? ChainId.AVALANCHE]&#xA;  return new ApolloClient({&#xA;    link: createHttpLink({&#xA;      uri: uri&#xA;    }),&#xA;    cache: new InMemoryCache()&#xA;  })&#xA;}&#xA;</code></pre>&#xA;<p>query:</p>&#xA;<pre><code>export const dexCandlesQuery = gql`&#xA;  query dexCandlesQuery($token0: String!, $token1: String!, $period: Int!) {&#xA;    candles(orderBy: time, orderDirection: asc, where: { token0: $token0, token1: $token1, period: $period }) {&#xA;      time&#xA;      open&#xA;      low&#xA;      high&#xA;      close&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>Making the query:</p>&#xA;<pre><code>const results = await dexCandles.query({&#xA;  query: dexCandlesQuery,&#xA;  variables: { token0: sortedToken0, token1: sortedToken1, period }&#xA;})&#xA;// Number of maximum results returned is 100&#xA;</code></pre>&#xA;",6378530,,,,2021-07-06 04:22:06,How do i increase the 100 limit when I fetch data from an endpoint using apollo?,<apollo><apollo-client><react-apollo>,0,2,0,2021-07-06 04:22:06
68281221,1,,,2,1107,"<p>I need to call the query on status change when component mounted.&#xA;Let's say I have 5 status in array and I'm looping that array.</p>&#xA;<p>The expected output should be: that query must be called 5 times.</p>&#xA;<p>But the problem is only one time query was called for the status which is at last position in an array.</p>&#xA;<pre><code>const loadedStatus = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]&#xA;&#xA;const [listSomeData] = useLazyQuery(LIST_SOME_DATA, {&#xA;        fetchPolicy: 'network-only'&#xA;    });&#xA;&#xA;const listSomeDataHandler = async (statusId, pagination = {}, filters = {}) =&gt; {&#xA;        await listSomeData({&#xA;            variables: {&#xA;                statusId,&#xA;                page: pagination?.page,&#xA;                pageSize: pagination?.pageSize,&#xA;                ...filters&#xA;            }&#xA;        });&#xA;    };&#xA;&#xA;useEffect(async () =&gt; {&#xA;        loadedStatus &amp;&amp;&#xA;            Promise.all(&#xA;                loadedStatus.map(status =&gt; {&#xA;                    listSomeDataHandler(&#xA;                        status.id, &#xA;                        { page: 0, pageSize: 10 }, &#xA;                        filters&#xA;                     );&#xA;                })&#xA;            );&#xA;    },[loadedStatus]);&#xA;</code></pre>&#xA;",14264628,,14264628,2021-07-07 06:59:16,2021-07-07 07:46:55,How to call same query multiple times using apollo client in react js on first mount,<node.js><reactjs><graphql><apollo-client><apollo-server>,1,2,0,2021-07-07 06:42:50
68299933,1,,,1,679,"<p>why does my example below work fine with fetchPolicy “network-only”, but not with “cache-first”?</p>&#xA;<p>I’m using react, apollo-client and “relay” style cursor based paging. pageSize = 50, and I got 64 items in total. Here is my field policy:</p>&#xA;<pre><code>const typePolicies: TypedTypePolicies = {&#xA;  Query: {&#xA;    fields: {&#xA;      allRetailers: customRelayStylePagination(['filter'])&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>customRelayStylePagination is just copy-paste from <a href=""https://github.com/apollographql/apollo-client/blob/f9f8bef1ce1e66c4f7cdc2f163db9f345f41791c/src/utilities/policies/pagination.ts"" rel=""nofollow noreferrer"">relayStylePagination</a> to debug.</p>&#xA;<p>Here is my function to retrieve ALL retailers:</p>&#xA;<pre><code>const getAllRetailers = async (showInactiveRetailers: boolean, showInactiveMachines: boolean): Promise&lt;Array&lt;RetailerListItemFragment&gt;&gt; =&gt; {&#xA;  let myCursor = undefined;&#xA;  let hasNextPage = true;&#xA;  let result: Array&lt;RetailerListItemFragment&gt; = [];&#xA;&#xA;  const filter = showInactiveRetailers&#xA;    ? undefined&#xA;    : {&#xA;      machineFilter: showInactiveMachines&#xA;        ? RetailerMachineFilter.HasActiveOrInactiveMachines&#xA;        : RetailerMachineFilter.HasActiveMachines,&#xA;    };&#xA;&#xA;  try {&#xA;    console.log('start');&#xA;    while(hasNextPage) {&#xA;      const res: ApolloQueryResult&lt;GetRetailerListQuery&gt; = await apolloClient.query&lt;&#xA;        GetRetailerListQuery,&#xA;        GetRetailerListQueryVariables&#xA;        &gt;({&#xA;        variables: {&#xA;          cursor: myCursor,&#xA;          filter&#xA;        },&#xA;        query: GET_RETAILER_LIST,&#xA;        fetchPolicy: 'cache-first'&#xA;      });&#xA;      myCursor = res.data.allRetailers?.pageInfo.endCursor;&#xA;      hasNextPage = res.data.allRetailers?.pageInfo.hasNextPage || false;&#xA;      console.log('hasNext: ' + hasNextPage);&#xA;      result = res.data.allRetailers?.edges?.map(c =&gt; c.node) || [];&#xA;    }&#xA;    console.log('done', result);&#xA;    return result;&#xA;&#xA;  } catch(err) {&#xA;    console.error(err);&#xA;    throw err;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>As mentioned this works fine for “network”, but not when using “cache-first”. I get stuck in a infinite loop where hasNextPage is always true. The first GraphQL request returns 50 items. I think the second one returns 50 items too. I observe two read() where both contain 50 items.</p>&#xA;<p>What am I doing wrong here?</p>&#xA;",2201169,,,,2021-07-08 10:31:55,Apollo GraphQL relay-style cursor pagination doesn't work with cache-first fetch policy,<reactjs><graphql><apollo-client><relay>,0,2,0,2021-07-08 10:31:55
68325016,2,,68264025,13,,"<p>Great Question!</p>&#xA;<p>I was in the same boat you are…needing to implement our own execution of data retrieval without EF or IQueryable, etc. while also getting the value of projections, especially using micro-ORM or Repository pattern where we can’t and don’t want to return IQueryable using HC's deferred execution, etc…</p>&#xA;<p>It is certainly possible, unfortunately it’s just not as trivial or easy at it would seem…it can get complex, mainly due to the broad functionality defined by the GraphQL spec.</p>&#xA;<p>In a simple query, you should use the <code>IResolverContext.GetSelctions()</code> API and retrieve list of selection names; as that is the supported API to get the data needed and there are many low level reasons it must be used.</p>&#xA;<p>But it won’t take long for you to find that it is itself a low level utility, and may no longer sufficient as it gets more much complex as soon as you use an Interface Type or Union Type that result in the use of GraphQL query fragments.</p>&#xA;<p>Then when you add offset paging or cursor paging the query structure changes again so you need to handle that (or both as these are two different structures)…</p>&#xA;<p>Now to answer your question specifically on Dapper you'll have to do the following key steps:</p>&#xA;<ol>&#xA;<li>Get the full list of Selections requested by the client in the GraphQL Query.</li>&#xA;<li>Get the filter Argument from the Query (luckily this is straightforward)</li>&#xA;<li>Get the Sort Arguments if you want to apply Sorting on the SQL server level (you didn't ask about this but I'm sure you quickly will).</li>&#xA;<li>Convert these GraphQL elements into a well formed SQL query and Execute it with Dapper.</li>&#xA;</ol>&#xA;<p>For posterity I’ll post code here to show you exactly what you could implement to handle these cases as an extension method… but it’s taken directly from my open source project I’ve shared out (yes I’m the author) to make this much easier with a simplified <em>facade</em> for HC’s <code>IResolverContext</code>; it offers easier access to other important things other than selections, which is all this code below focuses on.</p>&#xA;<p>I also implemented a <a href=""https://github.com/cajuncoding/GraphQL.RepoDB"" rel=""noreferrer"">full micro-ORM wrapper using this facade for <strong>RepoDB</strong></a>, but the similar could be done with <strong>Dapper</strong> (albeit more work as <em>RepoDB</em> offers great functionality for dynamically processing the models and queries from the string selection names).</p>&#xA;<p><strong>Step 1: Get Selections</strong></p>&#xA;<p>So here's the code to get your selections and handle the types of use cases highlighted above for Union Types, Interface Types, Paging, etc. (taken from the <a href=""https://github.com/cajuncoding/GraphQL.RepoDB/tree/main/GraphQL.PreProcessingExtensions"" rel=""noreferrer"">GraphQL.PreProcessingExtensions</a> library shared on Github.</p>&#xA;<pre><code>public static class IResolverContextSelectionExtensions&#xA;{&#xA;    /// &lt;summary&gt;&#xA;    /// Similar to CollectFields in v10, this uses GetSelections but safely validates that the current context&#xA;    ///     has selections before returning them, it will safely return null if unable to do so.&#xA;    /// This is a variation of the helper method provided by HotChocolate team here: &#xA;    ///     https://github.com/ChilliCream/hotchocolate/issues/1527#issuecomment-596175928&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    public static IReadOnlyList&lt;PreProcessingSelection&gt; GetPreProcessingSelections(this IResolverContext? context)&#xA;    {&#xA;        if (context == null)&#xA;            return null!;&#xA;&#xA;        var selectionResults = new List&lt;PreProcessingSelection&gt;();&#xA;&#xA;        var selections = GatherChildSelections(context!);&#xA;        if (selections.Any())&#xA;        {&#xA;            //BBernard&#xA;            //Determine if the Selection is for a Connection, and dive deeper to get the real&#xA;            //  selections from the node {} field.&#xA;            var lookup = selections.ToLookup(s =&gt; s.SelectionName.ToString().ToLower());&#xA;&#xA;            //Handle paging cases; current Node is a Connection so we have to look for selections inside&#xA;            //  -&gt;edges-&gt;nodes, or inside the -&gt;nodes (shortcut per Relay spec); both of which may exist(?)&#xA;            if (lookup.Contains(SelectionNodeName.Nodes) || lookup.Contains(SelectionNodeName.Edges) || lookup.Contains(SelectionNodeName.Items))&#xA;            {&#xA;                //Cursor &amp; Offset Paging are mutually exclusive so this small optimization prevents unnecessary processing...&#xA;                var searchOffsetPagingEnabled = true;&#xA;&#xA;                //CURSOR PAGING SUPPORT - results are in either a 'Nodes' or 'Edges' Node!&#xA;                //NOTE: nodes and edges are not mutually exclusive per Relay spec so&#xA;                //          we gather from all if they are defined...&#xA;                if (lookup.Contains(SelectionNodeName.Nodes))&#xA;                {&#xA;                    var nodesSelectionField = lookup[SelectionNodeName.Nodes].FirstOrDefault();&#xA;                    var childSelections = GatherChildSelections(context, nodesSelectionField);&#xA;                    selectionResults.AddRange(childSelections);&#xA;&#xA;                    searchOffsetPagingEnabled = false;&#xA;                }&#xA;&#xA;                if (lookup.Contains(SelectionNodeName.Edges))&#xA;                {&#xA;                    var edgesSelectionField = lookup[SelectionNodeName.Edges].FirstOrDefault();&#xA;                    //If Edges are specified then Selections are actually inside a nested 'Node' (singular, not plural) that we need to traverse...&#xA;                    var nodesSelectionField = FindChildSelectionByName(context, SelectionNodeName.EdgeNode, edgesSelectionField);&#xA;                    var childSelections = GatherChildSelections(context, nodesSelectionField);&#xA;                    selectionResults.AddRange(childSelections);&#xA;                    &#xA;                    searchOffsetPagingEnabled = false;&#xA;                }&#xA;&#xA;                //OFFSET PAGING SUPPORT - results are in an 'Items' Node!&#xA;                if (searchOffsetPagingEnabled &amp;&amp; lookup.Contains(SelectionNodeName.Items))&#xA;                {&#xA;                    var nodesSelectionField = lookup[SelectionNodeName.Items].FirstOrDefault();&#xA;                    var childSelections = GatherChildSelections(context, nodesSelectionField);&#xA;                    selectionResults.AddRange(childSelections);&#xA;                }&#xA;            }&#xA;            //Handle Non-paging cases; current Node is an Entity...&#xA;            else&#xA;            {&#xA;                selectionResults.AddRange(selections);&#xA;            }&#xA;        }&#xA;&#xA;        return selectionResults;&#xA;    }&#xA;&#xA;    /// &lt;summary&gt;&#xA;    /// Find the selection that matches the specified name.&#xA;    /// For more info. on Node parsing logic see here:&#xA;    /// https://github.com/ChilliCream/hotchocolate/blob/a1f2438b74b19e965b560ca464a9a4a896dab79a/src/Core/Core.Tests/Execution/ResolverContextTests.cs#L83-L89&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;param name=&quot;baseSelection&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;param name=&quot;selectionFieldName&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    private static PreProcessingSelection FindChildSelectionByName(IResolverContext? context, string selectionFieldName, PreProcessingSelection? baseSelection)&#xA;    {&#xA;        if (context == null)&#xA;            return null!;&#xA;&#xA;        var childSelections = GatherChildSelections(context!, baseSelection);&#xA;        var resultSelection = childSelections?.FirstOrDefault(&#xA;            s =&gt; s.SelectionName.Equals(selectionFieldName, StringComparison.OrdinalIgnoreCase)&#xA;        )!;&#xA;&#xA;        return resultSelection!;&#xA;    }&#xA;&#xA;    /// &lt;summary&gt;&#xA;    /// Gather all child selections of the specified Selection&#xA;    /// For more info. on Node parsing logic see here:&#xA;    /// https://github.com/ChilliCream/hotchocolate/blob/a1f2438b74b19e965b560ca464a9a4a896dab79a/src/Core/Core.Tests/Execution/ResolverContextTests.cs#L83-L89&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;param name=&quot;baseSelection&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    private static List&lt;PreProcessingSelection&gt; GatherChildSelections(IResolverContext? context, PreProcessingSelection? baseSelection = null)&#xA;    {&#xA;        if (context == null)&#xA;            return null!;&#xA;&#xA;        var gathered = new List&lt;PreProcessingSelection&gt;();&#xA;&#xA;        //Initialize the optional base field selection if specified...&#xA;        var baseFieldSelection = baseSelection?.GraphQLFieldSelection;&#xA;        &#xA;        //Dynamically support re-basing to the specified baseSelection or fallback to current Context.Field&#xA;        var field = baseFieldSelection?.Field ?? context.Field;&#xA;&#xA;        //Initialize the optional SelectionSet to rebase processing as the root for GetSelections()&#xA;        //  if specified (but is optional &amp; null safe)...&#xA;        SelectionSetNode? baseSelectionSetNode = baseFieldSelection is ISelection baseISelection&#xA;            ? baseISelection.SelectionSet&#xA;            : null!;&#xA;&#xA;        //Get all possible ObjectType(s); InterfaceTypes &amp; UnionTypes will have more than one...&#xA;        var objectTypes = GetObjectTypesSafely(field.Type, context.Schema);&#xA;&#xA;        //Map all object types into PreProcessingSelection (adapter classes)...&#xA;        foreach (var objectType in objectTypes)&#xA;        {&#xA;            //Now we can process the ObjectType with the correct context (selectionSet may be null resulting&#xA;            //  in default behavior for current field.&#xA;            var childSelections = context.GetSelections(objectType, baseSelectionSetNode);&#xA;            var preprocessSelections = childSelections.Select(s =&gt; new PreProcessingSelection(objectType, s));&#xA;            gathered.AddRange(preprocessSelections);&#xA;        }&#xA;&#xA;        return gathered;&#xA;    }&#xA;&#xA;    /// &lt;summary&gt;&#xA;    /// ObjectType resolver function to get the current object type enhanced with support&#xA;    /// for InterfaceTypes &amp; UnionTypes; initially modeled after from HotChocolate source:&#xA;    /// HotChocolate.Data -&gt; SelectionVisitor`1.cs&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;param name=&quot;objectType&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;param name=&quot;schema&quot;&gt;&lt;/param&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    private static List&lt;ObjectType&gt; GetObjectTypesSafely(IType type, ISchema schema)&#xA;    {&#xA;        var results = new List&lt;ObjectType&gt;();&#xA;        switch (type)&#xA;        {&#xA;            case NonNullType nonNullType:&#xA;                results.AddRange(GetObjectTypesSafely(nonNullType.NamedType(), schema));&#xA;                break;&#xA;            case ObjectType objType:&#xA;                results.Add(objType);&#xA;                break;&#xA;            case ListType listType:&#xA;                results.AddRange(GetObjectTypesSafely(listType.InnerType(), schema));&#xA;                break;&#xA;            case InterfaceType interfaceType:&#xA;                var possibleInterfaceTypes = schema.GetPossibleTypes(interfaceType);&#xA;                var objectTypesForInterface = possibleInterfaceTypes.SelectMany(t =&gt; GetObjectTypesSafely(t, schema));&#xA;                results.AddRange(objectTypesForInterface);&#xA;                break;&#xA;            case UnionType unionType:&#xA;                var possibleUnionTypes = schema.GetPossibleTypes(unionType);&#xA;                var objectTypesForUnion = possibleUnionTypes.SelectMany(t =&gt; GetObjectTypesSafely(t, schema));&#xA;                results.AddRange(objectTypesForUnion);&#xA;                break;&#xA;        }&#xA;&#xA;        return results;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Step 2: Get Argument for Filtering</strong></p>&#xA;<p>This is a lot more straightforward for simple arguments and objects as HC does a really nice job at giving us access:</p>&#xA;<pre><code>    [GraphQLName(&quot;products&quot;)]&#xA;    public async Task&lt;IEnumerable&lt;Products&gt; GetProductsByIdAsync(&#xA;        IResolverContext context,&#xA;        [Service] ProductsService productsService,&#xA;        CancellationToken cancellationToken,&#xA;        int id&#xA;    )&#xA;    {&#xA;        //Per the Annotation based Resolver signature here HC will inject the 'id' argument for us!&#xA;        //Otherwise this is just normal Resolver stuff...&#xA;        var productId = id;&#xA;&#xA;        //Also you could get the argument from the IResolverContext...&#xA;        var productId = context.Argument&lt;int&gt;(&quot;id&quot;);. . . &#xA;    }&#xA;</code></pre>&#xA;<p><strong>Step 3: Get Sorting Arguments</strong></p>&#xA;<p><em>Note: Getting the Argument here is easy, however, sort args have both a name and a sort-direction, and those need to be mapped to model names when using a micro-orm.  So again it's not trivial, but very possible:</em></p>&#xA;<pre><code>public static class IResolverContextSortingExtensions&#xA;{&#xA;    /// &lt;summary&gt;&#xA;    /// Safely process the GraphQL context to retrieve the Order argument;&#xA;    /// matches the default name used by HotChocolate Sorting middleware (order: {{field1}: ASC, {field2}: DESC).&#xA;    /// Will return null if the order arguments/info is not available.&#xA;    /// &lt;/summary&gt;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xA;    public static List&lt;ISortOrderField&gt;? GetSortingArgsSafely(this IResolverContext context, string sortOrderArgName = null!)&#xA;    {&#xA;        var results = new List&lt;ISortOrderField&gt;();&#xA;&#xA;        //Unfortunately the Try/Catch is required to make this safe for easier coding when the argument is not specified,&#xA;        //  because the ResolverContext doesn't expose a method to check if an argument exists...&#xA;        try&#xA;        {&#xA;            var sortArgName = sortOrderArgName ?? SortConventionDefinition.DefaultArgumentName;&#xA;&#xA;            //Get Sort Argument Fields and current Values...&#xA;            //NOTE: In order to correctly be able to Map names from GraphQL Schema to property/member names&#xA;            //      we need to get both the Fields (Schema) and the current order values...&#xA;            //NOTE: Not all Queries have Fields (e.g. no Selections, just a literal result), so .Field may&#xA;            //      throw internal NullReferenceException, hence we have the wrapper Try/Catch.&#xA;            IInputField sortArgField = context.Field.Arguments[sortArgName];&#xA;            ObjectValueNode sortArgValue = context.ArgumentLiteral&lt;ObjectValueNode&gt;(sortArgName);&#xA;&#xA;            //Validate that we have some sort args specified and that the Type is correct (ListType of SortInputType values)...&#xA;            //NOTE: The Following processing logic was adapted from 'QueryableSortProvider' implementation in HotChocolate.Data core.&#xA;            //FIX: The types changed in v11.0.1/v11.0.2 the Sort Field types need to be checked with IsNull() method, and&#xA;            //      then against NonNullType.NamedType() is ISortInputType instead.&#xA;            if (!sortArgValue.IsNull()&#xA;                &amp;&amp; sortArgField.Type is ListType lt&#xA;                &amp;&amp; lt.ElementType is NonNullType nn &#xA;                &amp;&amp; nn.NamedType() is ISortInputType sortInputType)&#xA;            {&#xA;                //Create a Lookup for the Fields...&#xA;                var sortFieldLookup = sortInputType.Fields.OfType&lt;SortField&gt;().ToLookup(f =&gt; f.Name.ToString().ToLower());&#xA;&#xA;                //Now only process the values provided, but initialize with the corresponding Field (metadata) for each value...&#xA;                var sortOrderFields = sortArgValue.Fields.Select(&#xA;                    f =&gt; new SortOrderField(&#xA;                        sortFieldLookup[f.Name.ToString().ToLower()].FirstOrDefault(), &#xA;                        f.Value.ToString()&#xA;                    )&#xA;                );&#xA;&#xA;                results.AddRange(sortOrderFields);&#xA;            }&#xA;&#xA;            return results;&#xA;        }&#xA;        catch&#xA;        {&#xA;            //Always safely return at least an Empty List to help minimize Null Reference issues.&#xA;            return results;&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Step 4: Convert all of this into a valid SQL statement...</strong></p>&#xA;<p>Now you have easy to work with list of Selection names, Sort Arguments, and even a filter argument value.  But, these selection names are likely not the same thing as your C# Model names or SQL Table Field names.  So you'll probably have to implement some reflection processing to get the actual Field names in case Dapper annotations were used, etc.</p>&#xA;<p>But once you've mapped your Selection names to actual SQL Table Field names; which is implementation specific and probably needs another question to answer... then you can convert those into valid SQL.</p>&#xA;<p>There are many ways to do that, but one good way might be to pull in an awesome SQL builder package like <a href=""https://sqlkata.com/"" rel=""noreferrer""><strong>SqlKata</strong></a> which I definitely recommend as doing this correctly/safely with mitigation of SQL Injection, etc. is important and these libraries make it much much easier.</p>&#xA;<p>Then you can use the SQL built and execute it via <strong>Dapper</strong> . . . you do not have to use the SqlKata execution engine.</p>&#xA;<p>However, this is one of the <em>many</em> reasons I've moved my projects over to <em>RepoDB</em> because this processing was a easier and only uses one package -- but I'd have no concerns what-so-ever using SqlKata.</p>&#xA;<p>All of this is readily available in a <a href=""https://www.nuget.org/packages/GraphQL.PreProcessingExtensions/"" rel=""noreferrer"">Nuget package</a> to make life a lot easier...</p>&#xA;<p>Extensions and simplified facade for processing data inside the resolver using micro-ORM:&#xA;<a href=""https://github.com/cajuncoding/GraphQL.RepoDB/tree/main/GraphQL.PreProcessingExtensions"" rel=""noreferrer"">https://github.com/cajuncoding/GraphQL.RepoDB/tree/main/GraphQL.PreProcessingExtensions</a></p>&#xA;<p>And a full implementation using RepoDB:&#xA;<a href=""https://github.com/cajuncoding/GraphQL.RepoDB"" rel=""noreferrer"">https://github.com/cajuncoding/GraphQL.RepoDB</a></p>&#xA;",7293142,,7293142,2021-07-10 06:52:20,2021-07-10 06:52:20,"",,0,0,0,2021-07-10 05:38:27
68329273,1,,,3,451,"<p>Is there a way I can query for all objects where a child object is null?</p>&#xA;<p>I am trying to do something like this:</p>&#xA;<pre><code>{&#xA;GetAllAccounts (  where: { accountManager: { eq: null} })  {&#xA;    accountManagerFid,&#xA;      accountManager {&#xA;        userLastName &#xA;      }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>That doesn't work because accountManager is an object with it's own filter so it's expecting me to filter on some field on the accountManager object once I open that nested curly bracket after &quot;accountManager:&quot;.</p>&#xA;<p>I am looking for the right way to query for &quot;All Accounts where accountManager child object does not exist at all&quot;</p>&#xA;",7013906,,,,2022-05-27 20:26:27,HotChocolate GraphQL query for objects with null child object,<graphql><hotchocolate>,1,2,0,2021-07-10 15:48:10
68374912,1,,,0,211,"<p>I'm a total beginner in GraphQL. I just tryout some playgrounds and ideas.</p>&#xA;<p>But I'm interested in GraphQL and in using of logical operators in a nested way:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>query&#xA;{&#xA;  Transactions (&#xA;    where: {&#xA;      or: [&#xA;        and: [&#xA;          {apiTransactionId: {eq: &quot;AAAAA&quot;}},&#xA;          {customerFirstName: {eq: &quot;Seth&quot;}}&#xA;        ],&#xA;        and: [&#xA;          {apiTransactionId: {eq: &quot;BBBBB&quot;}},&#xA;          {customerFirstName: {eq: &quot;Terry&quot;}}&#xA;        ],&#xA;      ]&#xA;    }&#xA;  )&#xA;  {&#xA;    id,&#xA;    md5Hash&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>It throws an error on the first &quot;and: []&quot;, therefore on the second level. The error is &quot;wrong syntax&quot;.</p>&#xA;<p>It looks like, the second level of logical operators is not valid.</p>&#xA;<p>Is there no way to combine OR- and AND- operators?</p>&#xA;<p>Maybe anytime I need a complex query like that.</p>&#xA;<p>Thanks for every info about it. :)</p>&#xA;",2703052,,,,2021-07-14 08:51:14,"graphQL query with nested logical operators (and, or)",<graphql><nested><logical-operators>,0,2,0,2021-07-14 08:51:14
68409601,2,,61892306,4,,<p>Answer from @Brad Larson is correct. But contains a typo:</p>&#xA;<p>You should have <code>{&quot;0&quot;:[&quot;variables.file&quot;]}</code> instead of <code>&quot;[variables.file]&quot;</code></p>&#xA;<p>(Sorry I don't have enough reputation to comment)</p>&#xA;,2906505,,2906505,2021-11-18 14:49:48,2021-11-18 14:49:48,"",,0,0,0,2021-07-16 13:10:33
68416951,2,,68416909,0,,"<p>Have a look at this:</p>&#xA;<p><a href=""https://www.prisma.io/dataguide/datamodeling/making-connections#introduction"" rel=""nofollow noreferrer"">https://www.prisma.io/dataguide/datamodeling/making-connections#introduction</a> and</p>&#xA;<p>Seems like you are trying to create a one to many relationship :</p>&#xA;<p><a href=""https://www.prisma.io/docs/concepts/components/prisma-schema/relations/one-to-many-relations"" rel=""nofollow noreferrer"">https://www.prisma.io/docs/concepts/components/prisma-schema/relations/one-to-many-relations</a></p>&#xA;",10370262,,,,2021-07-17 02:28:43,"",,0,0,0,2021-07-17 02:28:43
68430432,1,,,1,254,"<p>I am working on <a href=""https://my.metagame.wtf"" rel=""nofollow noreferrer"">a page with configurable filters</a>. The graphql query looks like:</p>&#xA;<pre><code>query GetPlayers(&#xA;  $offset: Int&#xA;  $limit: Int&#xA;  $skillIds: [uuid!] = null&#xA;  $playerTypeIds: [Int!] = null&#xA;  $availability: Int = null&#xA;  $timezones: [String!] = null&#xA;  $search: String = null&#xA;) {&#xA;  player(&#xA;    order_by: { total_xp: desc }&#xA;    offset: $offset&#xA;    limit: $limit&#xA;    where: {&#xA;      availability_hours: { _gte: $availability }&#xA;      timezone: { _in: $timezones }&#xA;      player_type_id: { _in: $playerTypeIds }&#xA;      Player_Skills: { Skill: { id: { _in: $skillIds } } }&#xA;      _or: [&#xA;        { username: { _ilike: $search } }&#xA;        { ethereum_address: { _ilike: $search } }&#xA;      ]&#xA;    }&#xA;  ) {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I would like the default behavior to be to return all entries. I am using Hasura 1.3.3 and <code>null</code> is interpreted as <code>{}</code> which will return all entries. The only problem is the <code>Player_Skills: { Skill: { id: { _in: $skillIds } } }</code> line. There is a join table with foreign keys referring to the <code>players</code> and <code>skills</code> tables, and that line will only return players who have at least one entry in that table.</p>&#xA;<p>Is it possible to form a query that will ignore the skills filter if <code>$skillIds</code> is <code>null</code>?</p>&#xA;",264008,,,,2021-07-18 15:12:57,How to disable a graphql filter if the variable is not set?,<variables><graphql><hasura>,0,1,0,2021-07-18 15:12:57
68442911,2,,68437977,1,,<p>You should define daily and monthly summaries as array:</p>&#xA;<pre><code>@Field(() =&gt; [DrivingActivitiesDailySummaryType])&#xA;public dailySummaries: DrivingActivitiesDailySummaryType[]&#xA;&#xA;@Field(() =&gt; [DrivingActivitiesMonthlySummaryType])&#xA;public monthlySummaries: DrivingActivitiesMonthlySummaryType[]&#xA;</code></pre>&#xA;,5370109,,,,2021-07-19 15:13:52,"",,0,1,0,2021-07-19 15:13:52
68451060,1,68452828,,0,105,"<p>I am new to apollo server and I am trying really hard to understand how to make remote schemas one huge scheme, I was able to join the schemas and can now query the data, however, I cannot seem to be able to link/resolve the type, my two micro services uses the same type name for those type that are same everywhere with the <code>pk</code> being common in all of them only that one has only the <code>pk</code> and another one has some extra fields,&#xA;my shop schema looks like this</p>&#xA;<pre><code>type UserType implements Node {&#xA;  id: ID!&#xA;  shops: [ShopType]&#xA;  pk: Int&#xA;}&#xA;</code></pre>&#xA;<p>and what really matters is the <code>pk</code> in this case because it is suppose to join with my auth schema which looks like this</p>&#xA;<pre><code>type UserType implements Node {&#xA;      id: ID!&#xA;      username: String&#xA;      email: String&#xA;      pk: Int&#xA;    }&#xA;</code></pre>&#xA;<p>with so many other fields, I would like to be able to join the data fields of the two in appolo server since that is where I am merging my two schemas so that when ever I query</p>&#xA;<pre><code>{&#xA;  shops {&#xA;    shopOwner {&#xA;      username&#xA;      email&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>then even though the <code>username</code> and <code>email</code> are not in the first schema, then it can resolve those fields by <code>pk</code> from the auth schema</p>&#xA;<p>I have used something like this</p>&#xA;<pre><code>const createNewSchema = async () =&gt; {&#xA;    const schemas = await createRemoteExecutableSchemas();&#xA;    return mergeSchemas({&#xA;        schemas,&#xA;    });&#xA;};&#xA;</code></pre>&#xA;<p>to join my schemas so how do I even make the two work together as I desire? thanks so much in advance</p>&#xA;",9943875,,,,2021-07-20 09:56:46,joining schemas from remote server by batching same types,<graphql><apollo><apollo-server><graphql-tools>,1,0,0,2021-07-20 07:25:34
68472531,1,68472746,,1,70,"<p>I am dealing with a JSON response from a webservice that drops keys if the value is null. This practice is reasonable enough, but I am using the the response as a data source for a reporting component that uses the first value in the array of objects as the source of truth for all fields available within the rest of the objects.</p>&#xA;<p>The reporting component is calling a serverless javascript endpoint that I write and control. So I can process the results and potentially standardize the JSON object keys in this js code prior to send the response.</p>&#xA;<p>Making things trickier, the shape and/or fields of the data is variable. It is the result of a user supplied GraphQL query.</p>&#xA;<p>So a query like this:</p>&#xA;<pre><code>    query GetCustomersByState($state: String!) {&#xA;      Customer(where: { State: { _eq: $state } }) {&#xA;        CustomerID&#xA;        CustomerName&#xA;        Address1&#xA;        Address2&#xA;        City&#xA;        State&#xA;        Zip&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>Might result in:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>[&#xA;    {&#xA;      CustomerID: 'TENASPH',&#xA;      CustomerName: 'Tennessee Asphalt',&#xA;      Address1: '123 main st',&#xA;      City: 'Somewhere',&#xA;      State: 'TN'&#xA;    },&#xA;    {&#xA;      CustomerID: '10002',&#xA;      CustomerName: 'A&amp;N Drywall',&#xA;      Address1: '123 Drywall Ln',&#xA;      Address2: 'Suite 2',&#xA;      City: 'Somewhere',&#xA;      State: 'TN',&#xA;      Zip: '12345'&#xA;    },&#xA;    {&#xA;      CustomerID: 'JONES',&#xA;      CustomerName: 'Jones Bros Construction',&#xA;      City: 'Somewhere',&#xA;      State: 'TN',&#xA;      Zip: '37917'&#xA;    },&#xA;]&#xA;</code></pre>&#xA;<p>How can I standardize the keys across the array of objects?</p>&#xA;<p>(If helpful, the data source is a Hasura GraphQL server instance. I have looked around the Hasura interface and can't seem to find any settings that would include blanks in the response. Would be great if that did exist.)</p>&#xA;",6034835,,,,2021-07-21 15:54:33,Standardize keys in array of javascript objects,<javascript><json><graphql><hasura>,2,0,0,2021-07-21 15:41:04
68472746,2,,68472531,1,,"<p>You could set the keys ahead of time by finding all the unique ones and then validate for them in a map()</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>let response = [{&#xA;    CustomerID: 'TENASPH',&#xA;    CustomerName: 'Tennessee Asphalt',&#xA;    Address1: '123 main st',&#xA;    City: 'Somewhere',&#xA;    State: 'TN'&#xA;  },&#xA;  {&#xA;    CustomerID: '10002',&#xA;    CustomerName: 'A&amp;N Drywall',&#xA;    Address1: '123 Drywall Ln',&#xA;    Address2: 'Suite 2',&#xA;    City: 'Somewhere',&#xA;    State: 'TN',&#xA;    Zip: '12345'&#xA;  },&#xA;  {&#xA;    CustomerID: 'JONES',&#xA;    CustomerName: 'Jones Bros Construction',&#xA;    City: 'Somewhere',&#xA;    State: 'TN',&#xA;    Zip: '37917'&#xA;  },&#xA;]&#xA;&#xA;let keys = [...new Set(response.flatMap(Object.keys))];&#xA;//console.log(keys)&#xA;let standardized = response.map(e =&gt; {&#xA;  keys.forEach(k =&gt; {&#xA;    if (!e[k]) e[k] = '';&#xA;  })&#xA;  return e&#xA;})&#xA;console.log(standardized)</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",1772933,,,,2021-07-21 15:54:33,"",,0,0,0,2021-07-21 15:54:33
68477771,2,,58526383,0,,"<p>I could not sort the result by query, but I decided same question with sorting by a number in a string, by sorting the resulting array of objects:</p>&#xA;<pre><code>queryResult.sort(function(a,b){&#xA;  return Number(b.PriceString) - Number(a.PriceString);&#xA;});&#xA;</code></pre>&#xA;",5945386,,,,2021-07-22 00:09:15,"",,0,0,0,2021-07-22 00:09:15
68484555,1,68485048,,1,143,"<p>Long story short, i have and array of JSX elements, that looks something like this:</p>&#xA;<pre><code>              &lt;ChatListCard&#xA;                key={index}&#xA;                prop1={prop1}&#xA;                prop2={prop2}&#xA;                prop3={prop3}&#xA;              /&gt;&#xA;</code></pre>&#xA;<p>I get the props for these &quot;Cards&quot; from two different tables in Strapi/Graphql API, so I do something like this:</p>&#xA;<pre><code>[].concat(&#xA;  array1.map((item,index)=&gt; &lt;Card key={index} prop1={item.prop1} ... /&gt;),&#xA;  array2.map((item,index)=&gt; &lt;Card key={index} prop1={item.prop1} ... /&gt;)&#xA;)&#xA;</code></pre>&#xA;<p>The problem is that array1 and array2 contain some &quot;items&quot; that are identical, and need to be filtered out. Is there a way to do it, using JS:</p>&#xA;<pre><code>[].concat(...).filter((magic)=&gt; magic but filtered) //use the filter here&#xA;</code></pre>&#xA;<p>, or i should do it in GraphQL.&#xA;(I have already used <em>where</em> clause in there to filter out only the items that I do not need)</p>&#xA;<pre><code>query ProposalsAndRequests($input:String!){&#xA;  proposals(where: {_or:[&#xA;    {owner:{email:$input}}&#xA;    {task:{owner:{email:$input}}}&#xA;  ]},sort:&quot;created_at:desc&quot;){&#xA;    id&#xA;    ...&#xA;    }&#xA;  }&#xA;  chatRequests(where:{_or:[&#xA;    {users_permissions_user:{email:$input}}&#xA;    {task:{owner:{email:$input}}}&#xA;  ]},sort:&quot;created_at:desc&quot;){&#xA;    id&#xA;    ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<ul>&#xA;<li><em>note: chatRequests and Proposals contain identical fields, they just serve different purposes elsewhere in the site</em></li>&#xA;<li><em>the users_permissions_user and owner are also the same relation</em></li>&#xA;</ul>&#xA;",16430955,,,,2021-07-23 15:01:49,Remove duplicate JSX elements | React Strapi graphql,<reactjs><graphql><mapping><filtering><strapi>,1,3,0,2021-07-22 12:06:46
68485048,2,,68484555,1,,"<p>You can do it using the &quot;Set&quot; datastructure in js. <code>const set = new Set(arr);</code>. Sets cant have duplicates! :-) but they can have identical objects if the references are not the same.</p>&#xA;<p>For a more complex filter, use .reduce function to accumilate only uniques.</p>&#xA;<p>Or, you could remove the duplicates by bruteforce it with something like:</p>&#xA;<pre><code>const noDubs = [];&#xA;&#xA;myArr.foreach(item =&gt; {&#xA;  if(!noDubs.some(entry = entry.special.property === item.special.property) noDubs.push(item);&#xA;});&#xA;</code></pre>&#xA;",6717243,,6717243,2021-07-23 15:01:49,2021-07-23 15:01:49,"",,0,0,0,2021-07-22 12:40:58
68497875,1,,,1,473,"<p>I have a nested component in my app.</p>&#xA;<p>At the top of the page, I have a query like</p>&#xA;<pre><code>const REPOSITORY_PAGE_QUERY = gql`&#xA;  query RepositoryPageQuery($name: String!, $owner: String!) {&#xA;    repository(name: $name, owner: $owner) {&#xA;      ...RepositoryDetailsFragment&#xA;    }&#xA;  }&#xA;  ${REPOSITORY_DETAILS_FRAGMENT}&#xA;`;&#xA;</code></pre>&#xA;<p><code>RepositoryDetailsFragment</code> then includes</p>&#xA;<pre><code>// list of branches&#xA;refs(first: 2, refPrefix: &quot;refs/heads/&quot;) {&#xA;  ...BranchesFragment&#xA;}&#xA;</code></pre>&#xA;<p>and finally</p>&#xA;<pre><code>fragment BranchesFragment on RefConnection {&#xA;    totalCount&#xA;    pageInfo {&#xA;      ...PageInfoFragment&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;  ${PAGE_INFO_FRAGMENT}&#xA;</code></pre>&#xA;<p>Obviously, I am not happy, because I need to pass <code>BranchesFragment</code> info around 3 levels deep.</p>&#xA;<p>Instead, it would be great if I could read it from the cache directly in my <code>BranchesList</code> component.&#xA;I tried to use</p>&#xA;<pre><code>client.cache.readFragment({&#xA;   fragment: BRANCHES_FRAGMENT,&#xA;   fragmentName: &quot;BranchesFragment&quot;&#xA;});&#xA;</code></pre>&#xA;<p>But the problem is that this fragment does not have any id. Is there any way to deal with it and get the fragment info?</p>&#xA;",14944857,,,,2021-07-23 13:06:17,Is it possible to `readFragment` from apollo cache if it has no id?,<apollo-client><react-apollo>,1,0,0,2021-07-23 10:37:22
68505081,2,,68385714,1,,"<p>Prepare <code>filter</code> object using passed params like:</p>&#xA;<pre><code>export async function fetchItems(ref, queryName, columnName) {&#xA;     let filter = {};&#xA;     filter[columnName] = { contains: ref };&#xA;     const queryNameData = await API.graphql(graphqlOperation(queryName, { filter }))&#xA;</code></pre>&#xA;",6124657,,,,2021-07-23 21:12:21,"",,0,1,0,2021-07-23 21:12:21
68515001,2,,68427271,0,,"<pre><code>Adding a where condition was too easy but was not clear in lighthouse docs.&#xA;&#xA;projects(query: QueryCondition): [Project!]!&#xA;        @all&#xA;        @orderBy(column: &quot;id&quot;, direction: DESC)&#xA;&#xA;input QueryCondition {&#xA;    parent_id: ID @eq&#xA;}&#xA;</code></pre>&#xA;",11007880,,,,2021-07-25 01:54:44,"",,0,0,0,2021-07-25 01:54:44
68548773,1,,,0,248,"<p>I'm using Reactjs and Relay. I want to create something if &quot;this&quot; item is not created yet / array is empty. somehow, the relay query returns an empty array if the data has not been loaded, therefore it keeps created &quot;this item&quot; since it's considered empty. how do we determine if relay query data is <code>actually empty</code> or <code>not loaded</code> / pending?</p>&#xA;<p>i.e query:</p>&#xA;<pre><code>QueryRenderer(MyComponent, {&#xA;    query: graphql`&#xA;      query MyComponentQuery($id: ID!) {&#xA;        items(containerId: $id) {&#xA;          id&#xA;          title&#xA;        }&#xA;      }&#xA;    `,&#xA;    vars: ({ containerId }) =&gt; ({&#xA;      id: containerId&#xA;    })&#xA;  })&#xA;</code></pre>&#xA;<p>handle create &quot;this&quot; item:</p>&#xA;<pre><code>useEffect(() =&gt; {&#xA;    if(!props.items){&#xA;      // Create &quot;this&quot; item&#xA;    }&#xA;}, [props.items]);&#xA;&#xA;</code></pre>&#xA;",11876647,,,,2021-08-28 14:39:24,How to determine if relay query is empty or not loaded,<javascript><reactjs><graphql><relayjs><relay>,1,0,0,2021-07-27 16:39:00
68584325,2,,68567639,0,,<p>Making use of <code>[ID!]!</code></p>&#xA;<ul>&#xA;<li>states that input will be a list of Type ID that cannot have any null entries and <code>$id</code> cannot be null</li>&#xA;</ul>&#xA;<pre><code>const ADD_TO_CART_MUTATION = gql`&#xA;  mutation ADD_TO_CART_MUTATION($id: [ID!]!) {&#xA;   ...&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;,16471349,,,,2021-07-30 01:03:18,"",,0,0,0,2021-07-30 01:03:18
68620334,2,,68617213,0,,"<p>After a couple of painful hours, I finally found the solution. Maybe I don't provide enough information. I was using <code>Fastify</code> and <code>Mercurius</code>.</p>&#xA;<p>The solution is very simple, just need to add underscore (<code>_</code>) with <code>unknown</code> type in first argument and an object of desired type in second argument. For example if your query is something like this :</p>&#xA;<pre><code>type Query {&#xA;    add(x: Int, y: Int): Int&#xA;}&#xA;</code></pre>&#xA;<p>and your resolver should like this</p>&#xA;<pre><code>Query: {&#xA;    add: (_: unknown, { x, y }: { x: number, y: number }): number =&gt; {&#xA;        console.log(x, y)&#xA;        return x + y&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>So the query for my question should be this</p>&#xA;<pre><code>Query: {&#xA;        fetchCourse: async (_: unknown, { courseId }: { courseId: string }): Promise&lt;string&gt; =&gt; {&#xA;        const data = await db('course').select('*').where('c_id', courseId)&#xA;        return JSON.stringify(data)&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",11811336,,,,2021-08-02 10:50:47,"",,0,0,0,2021-08-02 10:50:47
68633616,2,,67339388,0,,"<p>Your payload is already a JSON string, so no need to call json.dumps() on it again; This double-encodes it, hence the api complains about the payload.</p>&#xA;<p>Try</p>&#xA;<pre><code>payload = '{&quot;query&quot;:&quot;query(\n        $ufsSessionId: String,\n        $searchMethod: String,\n        $q: String,\n        $conceptSlug: String,\n        $citySlug: String,\n        $filters: [FilterInput!],\n        $page: Int,\n        $sort: String,\n        $tracking: Boolean,\n        $disableCityExtraction: Boolean,\n        $cityExtractionRadius: String\n      ) {\n      search(\n        ufsSessionId: $ufsSessionId,\n        searchMethod: $searchMethod,\n        q: $q,\n        conceptSlug: $conceptSlug,\n        citySlug: $citySlug,\n        filters: $filters,\n        page: $page,\n        sort: $sort,\n        tracking: $tracking,\n        disableCityExtraction: $disableCityExtraction,\n        cityExtractionRadius: $cityExtractionRadius\n      ) {\n        ufsSessionId\n        paging {\n          total, currentPage, totalPages\n        }\n        companies {\n          id, uuid, name, highlightedName, description, highlightedDescription, secondaryHighlightedDescription,\n          homepage, zipcode, city, countryCode, certificates, logoPath, profilePagePath, distance, email,\n          debugData, employeeCount, foundingYear, acronym, customerId, isCustomer, fpaket, spaceType\n          pictures {\n            caption, path, position, sizes\n          }\n          logo {\n            sizes\n          }\n          filterResults {\n            key, title, value, matches\n          }\n          matchingCompanyCategory {\n            id, kpaket, toprankingPosition\n          }\n        }\n        filters {\n          key, name, static, title, type, range {\n            max, min, unit, disabled\n          }\n          values {\n            count, name, title\n          }\n          location {\n            kind\n            defaultRadiuses\n            availableRadiuses {\n              name, count\n            }\n          }\n        }\n        cities {\n          slug, title, count\n        }\n        suggestions {\n          text, score\n        }\n        extractedCity {\n          name, radius\n        }\n        toprankingPositions {\n          companyId, position\n        }\n        companyCategory {\n          id, name\n        }\n        concept {\n          title\n        }\n        recommendations {\n          text, score, slug\n        }\n        canonicalConceptSlug\n        canonicalCompanyCategorySlug\n        conceptSlugTitle\n        companyCategorySlugTitle\n        verticalSlug\n        citySlugTitle\n        seoTextHtml\n        debugData\n      }\n    }&quot;,&quot;variables&quot;:{&quot;ufsSessionId&quot;:&quot;4b8697cc5b2056f4f67288f7bde39ad2&quot;,&quot;searchMethod&quot;:&quot;direct&quot;,&quot;locale&quot;:&quot;de&quot;,&quot;q&quot;:&quot;verpackungen&quot;,&quot;filters&quot;:[{&quot;name&quot;:&quot;Mitarbeiteranzahl&quot;,&quot;selected&quot;:[&quot;200+&quot;,&quot;50-199&quot;]}],&quot;page&quot;:1,&quot;sort&quot;:&quot;ad_engine&quot;,&quot;tracking&quot;:true,&quot;disableCityExtraction&quot;:false,&quot;cityExtractionRadius&quot;:&quot;50km&quot;}}'&#xA;r = requests.post(url, headers=headers, data=payload)&#xA;</code></pre>&#xA;<p>To see what I mean by double encoding, compare the two payloads:</p>&#xA;<pre><code>print(repr(payload))&#xA;print(repr(json.dumps(payload)))&#xA;</code></pre>&#xA;",13155625,,13155625,2021-08-03 09:46:46,2021-08-03 09:46:46,"",,0,0,0,2021-08-03 09:34:03
68636668,2,,68636530,0,,"<p>You can combine the queries in one query. Let me give you an example.</p>&#xA;<pre><code>query posts($month: Int!) {&#xA;  posts(month: $month) {&#xA;    id,&#xA;    name,&#xA;  }&#xA;}&#xA;&#xA;query notes($month: Int!) {&#xA;  notes(month: $month){&#xA;    id,&#xA;    name,&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>can be combined into one:</p>&#xA;<pre><code>query postsAndNotes($month: Int!) {&#xA;  posts(month: $month) {&#xA;    id,&#xA;    name,&#xA;  }&#xA;  notes(month: $month){&#xA;    id,&#xA;    name,&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Query result will have posts and notes objects.</p>&#xA;",7987910,,,,2021-08-03 13:09:14,"",,0,2,0,2021-08-03 13:09:14
68637096,1,69019602,,1,119,"<p>I have a small graphQL structure like this for AWS but when I try to push it throws me an error saying</p>&#xA;<blockquote>&#xA;<p>✖ An error occurred when pushing the resources to the cloud</p>&#xA;<p>@connection must be on an @model object type field.</p>&#xA;</blockquote>&#xA;<p>Please help to understand where I am making mistakes.</p>&#xA;<p>Is there any VS code extension to debug this?</p>&#xA;<pre><code>type Store {&#xA;  id: ID!&#xA;  products: [Product] @connection(name: &quot;StoreProducts&quot;)&#xA;}&#xA;&#xA;type Product @model @searchable {&#xA;  id: ID!&#xA;  name: String!&#xA;  description: String!&#xA;  price: Float!&#xA;  isOnCourse: Boolean!&#xA;  isOnOutlet: Boolean!&#xA;  store: Store @connection(name: &quot;StoreProducts&quot;, sortField: &quot;crearedAt&quot;)&#xA;  file: S3Object!&#xA;}&#xA;&#xA;type S3Object {&#xA;  bucket: String!&#xA;  region: String!&#xA;  key: String!&#xA;}&#xA;&#xA;type User&#xA;  @model(&#xA;    queries: { get: &quot;getUser&quot; }&#xA;    mutations: { create: &quot;registredUser&quot;, update: &quot;updateUser&quot; }&#xA;    subscriptions: null&#xA;  ) {&#xA;  id: ID!&#xA;  username: String!&#xA;  email: String!&#xA;  phoneNumber: String!&#xA;  registred: Boolean&#xA;  orders: [Order] @connection(name: &quot;UserOrders&quot;, sortField: &quot;createdAt&quot;)&#xA;}&#xA;&#xA;type Order&#xA;  @model(&#xA;    queries: null&#xA;    mutations: { create: &quot;createOrder&quot; }&#xA;    subscriptions: null&#xA;  ) {&#xA;  id: ID!&#xA;  product: Product @connection&#xA;  user: User @connection(name: &quot;UserOrders&quot;)&#xA;  orderLocation: OrderLocation&#xA;  crearedAt: String&#xA;}&#xA;&#xA;type OrderLocation {&#xA;  tableNumber: String&#xA;  qrData: String&#xA;  holeNumber: String&#xA;}&#xA;</code></pre>&#xA;",0,user3697484,,,2021-09-01 19:30:09,@connection must be on an @model object type field,<amazon-web-services><graphql><aws-amplify>,1,0,0,2021-08-03 13:37:46
68643783,2,,68220702,1,,"<p>I had this same issue and can share what i found and worked for me.</p>&#xA;<p>The default resolver for the list operation has a limit:20 built in.</p>&#xA;<pre><code>{&#xA;  &quot;version&quot;: &quot;2017-02-28&quot;,&#xA;  &quot;operation&quot;: &quot;Scan&quot;,&#xA;  &quot;filter&quot;: #if($context.args.filter) $util.transform.toDynamoDBFilterExpression($ctx.args.filter) #else null #end,&#xA;  &quot;limit&quot;: $util.defaultIfNull($ctx.args.limit, 20),&#xA;  &quot;nextToken&quot;: $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null)),&#xA;}&#xA;</code></pre>&#xA;<p>I imagine you could change this or you could add a limit filter to your query like this:</p>&#xA;<pre><code>listPosts(filter: {groupID: {eq: &quot;25&quot;}}, limit:100) {&#xA;    items {&#xA;        id&#xA;        content&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>The limit should be higher than the number of records.</p>&#xA;<p>You can see that this would be an issue because it is using the scan operation meaning it inspects each record for a match. this would hurt performance. you could add pagination or you should craft a query for this. you will need to look into pagination, relations and connection.</p>&#xA;<p><a href=""https://docs.aws.amazon.com/appsync/latest/devguide/designing-your-schema.html#advanced-relations-and-pagination"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/appsync/latest/devguide/designing-your-schema.html#advanced-relations-and-pagination</a></p>&#xA;",16588769,,1839439,2021-08-03 23:32:28,2021-08-03 23:32:28,"",,0,0,0,2021-08-03 23:26:58
68676647,1,,,-1,225,"<p>I am testing <code>PermissionDetail</code> component which has graphql fragment, that is the data of node of PermissionTable component. I am getting a flow type error in this line when getting mock data from query <code>const permissionDetail = data.viewPermissionScheme?.grantGroups[0].grantHolders?.edges[0].node.permission;</code>.</p>&#xA;<p>Component hierarchy:</p>&#xA;<p>App -&gt; PermissionTable (Paginated component fragment) -&gt; PermissionDetail (fragment)</p>&#xA;<pre><code>    const TestRenderer = () =&gt; {&#xA;        const data = useLazyLoadQuery&lt;examplesPermissionQuery&gt;(&#xA;            graphql`&#xA;                query examplesPermissionQuery @relay_test_operation {&#xA;                    viewPermission(id: &quot;test-scheme-id&quot;) {&#xA;                        ... on PermissionView {&#xA;                            groups {&#xA;                                holders(first: 10) {&#xA;                                    edges {&#xA;                                        node {&#xA;                                            permission {&#xA;                                                ...permissionDetailsFragment&#xA;                                            }&#xA;                                        }&#xA;                                    }&#xA;                                }&#xA;                            }&#xA;                        }&#xA;                    }&#xA;                }&#xA;            `,&#xA;            {},&#xA;        );&#xA;&#xA;// Getting Flowtype Error here: Cannot get `data.viewPermission?.groups[0]` because an index signature declaring the expected key / value type is missing in  null or undefined [1]&#xA;    &#xA;        const permissionDetail =&#xA;         data.viewPermissionScheme?.grantGroups[0].grantHolders?.edges[0].node.permission; &#xA;    &#xA;        return permissionDetail ? (&lt;PermissionDetails permissionDetail={permissionDetail}/&gt;) : null;&#xA;    };&#xA;</code></pre>&#xA;<p>What is the correct way to test such components? I am new to flow and graphql and relay. So need to understand the best way to test this.</p>&#xA;",6149787,,13243085,2021-08-09 05:40:20,2021-08-12 14:27:35,Cannot get property because an index signature declaring the expected key / value type is missing in null or undefined [1],<graphql><flowtype><relayjs><relay><react-relay>,1,0,0,2021-08-06 05:42:13
68685068,1,68699513,,0,234,"<p>GraphQL allows you to specify whether a field is to be optional or not (add <code>!</code>)</p>&#xA;<p>Using the Node API, I cannot find that option.</p>&#xA;<p>see <a href=""https://graphql.org/graphql-js/constructing-types/"" rel=""nofollow noreferrer"">https://graphql.org/graphql-js/constructing-types/</a></p>&#xA;<p>I also went through the types without luck</p>&#xA;<p>see <a href=""https://github.com/graphql/graphql-js/blob/main/src/index.ts"" rel=""nofollow noreferrer"">https://github.com/graphql/graphql-js/blob/main/src/index.ts</a></p>&#xA;<p>What am I missing?</p>&#xA;<p>I basically want</p>&#xA;<pre><code>type MyEntity {&#xA;  uuid: ID!&#xA;  name: String!&#xA;}&#xA;</code></pre>&#xA;<p>instead of</p>&#xA;<pre><code>type MyEntity {&#xA;  uuid: ID&#xA;  name: String&#xA;}&#xA;</code></pre>&#xA;",1659569,,1659569,2021-08-06 16:59:46,2021-08-08 09:39:08,graphql node api: how can I define a field as optional?,<node.js><graphql><graphql-js>,1,1,0,2021-08-06 16:47:44
68695053,1,,,0,1048,"<p>In Gatsby, when we make a query with the <code>lt</code> or <code>gt</code> operator on a date of type <code>mdx</code> does it return the closest &quot;greater than&quot; or the closest &quot;less than&quot;?</p>&#xA;<p>I've done some quick experimentation and does look like it does, but could not find any official documentation on GraphQL or on Gatsby to explain exactly how it behaves.</p>&#xA;",16614500,,,,2021-08-09 05:50:13,"In GraphQL, how does the operator `lt` and `gt` work?",<graphql><gatsby>,1,0,0,2021-08-07 18:20:48
68699439,2,,68697356,0,,"<p>With dynamoDB you have to think about access patterns first:</p>&#xA;<ul>&#xA;<li>To get the favorite posts of a user, store a <code>postsIds</code> array in the user table</li>&#xA;<li>To get the users who like a post, store a <code>likerIds</code> array in the post table</li>&#xA;<li>To get a bidirectional link, do both of the above</li>&#xA;</ul>&#xA;<p>Please also keep in mind that:</p>&#xA;<ul>&#xA;<li>You can select fields when getting a document (only select the fields you are interested in)</li>&#xA;<li>I don't see a scenario where you would load 10k usernames and display them</li>&#xA;</ul>&#xA;<p>The above solution looks pretty good for common scenarios.</p>&#xA;<h2>More advanced solution:</h2>&#xA;<p>There could be a more powerful way to do that using range keys. For instance:</p>&#xA;<div class=""s-table-container"">&#xA;<table class=""s-table"">&#xA;<thead>&#xA;<tr>&#xA;<th>Hash Key: postID</th>&#xA;<th>range key: likerID</th>&#xA;<th>title</th>&#xA;<th>...</th>&#xA;</tr>&#xA;</thead>&#xA;<tbody>&#xA;<tr>&#xA;<td>post1</td>&#xA;<td></td>&#xA;<td>MyFancyPost</td>&#xA;<td></td>&#xA;</tr>&#xA;<tr>&#xA;<td>post1</td>&#xA;<td>user1</td>&#xA;<td></td>&#xA;<td></td>&#xA;</tr>&#xA;<tr>&#xA;<td>post1</td>&#xA;<td>user2</td>&#xA;<td></td>&#xA;<td></td>&#xA;</tr>&#xA;</tbody>&#xA;</table>&#xA;</div>&#xA;<p>This structures is more powerful, and could store a lot of connections without having any &quot;big&quot; field in the <code>post</code> model.</p>&#xA;<ul>&#xA;<li>you could easily paginate, and count the list of likers</li>&#xA;<li>can handle many more likers for only one post</li>&#xA;</ul>&#xA;",1103340,,,,2021-08-08 09:28:03,"",,0,0,0,2021-08-08 09:28:03
68707376,2,,68695053,1,,"<p>You can find the official documentation here: <a href=""https://www.gatsbyjs.com/docs/graphql-reference/#complete-list-of-possible-operators"" rel=""nofollow noreferrer"">https://www.gatsbyjs.com/docs/graphql-reference/#complete-list-of-possible-operators</a></p>&#xA;<p>So yes, <code>lt</code> is &quot;less than&quot;, <code>gt</code> is &quot;greater than&quot;. As you can also see there two more variants of this exist:</p>&#xA;<ul>&#xA;<li><code>lte</code> &quot;less than or equal&quot;</li>&#xA;<li><code>gte</code> &quot;greater than or equal&quot;</li>&#xA;</ul>&#xA;<p>But it doesn't return the &quot;closest&quot; result as you'll be filtering the result with this. So you will get multiple results if they exist.</p>&#xA;",10164092,,,,2021-08-09 05:50:13,"",,0,0,0,2021-08-09 05:50:13
68707994,2,,68704474,1,,"<p>It looks like your CSV Data Set Config setup is not very correct so the <a href=""https://jmeter.apache.org/usermanual/functions.html"" rel=""nofollow noreferrer"">JMeter Variable</a> placeholder isn't getting substituted with its respective value from the CSV file.</p>&#xA;<p>We cannot help without seeing first couple of lines of the CSV file and your CSV Data Set Config setup so far I can only suggest re-visit the configuration and cross-check it with <a href=""https://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"" rel=""nofollow noreferrer"">JMeter Documentation</a></p>&#xA;<p>You can observe JMeter Properties and Variables with their values using <a href=""https://www.blazemeter.com/blog/how-debug-your-apache-jmeter-script"" rel=""nofollow noreferrer"">Debug Sampler and View Results Tree listener combination</a>, if you don't see <code>clientid</code> line there - the variable is not set and JMeter sends it as it is, to wit <code>&quot;{clientid : ${clientid}}&quot;</code> and doesn't substitute <code>${clientid}</code> with the value from CSV</p>&#xA;",2897748,,,,2021-08-09 06:59:53,"",,0,1,0,2021-08-09 06:59:53
68732762,2,,68685933,1,,"<p>It should be possible with <code>employers.Select(name)</code>.</p>&#xA;<p>Example in LinqPad:</p>&#xA;<pre class=""lang-cs prettyprint-override""><code>void Main()&#xA;{&#xA;    Rooms.Dump();&#xA;    (Rooms.Where(r =&gt; r.Id == 3) as IQueryable).Select(&quot;new { name, RoomReservations.Select(CheckinDate) as CheckinDates }&quot;).Dump();&#xA;}&#xA;</code></pre>&#xA;<p>Results into:&#xA;<a href=""https://i.stack.imgur.com/6rfel.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6rfel.png"" alt=""enter image description here"" /></a></p>&#xA;<p>And the generated SQL looks like (only the 'name' and the 'CheckinDate' are selected in the query):</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>-- Region Parameters&#xA;DECLARE @p0 Int = 3&#xA;-- EndRegion&#xA;SELECT [t0].[Name], [t1].[CheckinDate], (&#xA;    SELECT COUNT(*)&#xA;    FROM [Reservations] AS [t2]&#xA;    WHERE [t2].[RoomId] = [t0].[Id]&#xA;    ) AS [value]&#xA;FROM [Rooms] AS [t0]&#xA;LEFT OUTER JOIN [Reservations] AS [t1] ON [t1].[RoomId] = [t0].[Id]&#xA;WHERE [t0].[Id] = @p0&#xA;ORDER BY [t0].[Id], [t1].[Id]&#xA;</code></pre>&#xA;<p>--&gt; Note that I tried to make a GraphQL library which uses DynamicLinq, however not all logic is supported. You can take a look here:&#xA;<a href=""https://github.com/StefH/GraphQL.EntityFrameworkCore.DynamicLinq"" rel=""nofollow noreferrer"">https://github.com/StefH/GraphQL.EntityFrameworkCore.DynamicLinq</a></p>&#xA;",255966,,,,2021-08-10 19:50:00,"",,0,0,0,2021-08-10 19:50:00
68734000,2,,68733466,3,,"<p>Ditch the attempt in <code>createSchemaCustomization</code> since you don't need to customize the schema here (though I believe there is a way to achieve what you want using it, it is not expected that the data in it is sourced from existing nodes, and this undeclared dependency can create caching issues).</p>&#xA;<p>Then update your <code>createResolvers</code> function to something like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>exports.createResolvers = ({ createResolvers }) =&gt; {&#xA;  createResolvers({&#xA;    SanityVideo: {&#xA;      safeUrl: {&#xA;        type: &quot;String&quot;,&#xA;        resolve: (source, args, context, info) =&gt; source.public ? source.url : null&#xA;      },&#xA;    },&#xA;  })&#xA;}&#xA;</code></pre>&#xA;<ol>&#xA;<li>I don't believe resolvers can replace schema-originated nodes (fields), hence using <code>safeUrl</code> instead of <code>url</code></li>&#xA;<li>The type you are adding a field to is <code>SanityVideo</code>, and it doesn't matter what the parent node is—this will apply to all instances of <code>SanityVideo</code> in your data</li>&#xA;</ol>&#xA;",203130,,,,2021-08-10 22:11:51,"",,0,1,0,2021-08-10 22:11:51
68741050,2,,68737927,0,,"<p>I made it work with this:</p>&#xA;<pre><code>getAll = async (sorting? : Sorting): Promise&lt;Product[]&gt; =&gt; {&#xA;    if (sorting?.parameter === &quot;createdAt&quot;) {&#xA;      return Product.find({order: {createdAt : sorting.direction}});&#xA;    } else if (sorting?.parameter === &quot;name&quot;) {&#xA;      return Product.find({order: {name : sorting.direction}});&#xA;    }&#xA;    return Product.find();&#xA;  };&#xA;</code></pre>&#xA;<p>So I split the 2 potential properties I'm expecting into if clauses, instead of accessing the sorting.properties once. A little bit ugly since I would have to adjust it whenever something changes, but I'm not sure it can be avoided it this setup.</p>&#xA;<p>The problem is that I tried to set &quot;someKey&quot; to a string in this format: Product.find(order: {someKey : someValue}), but it only accepts they keys of my entity</p>&#xA;",12868977,,,,2021-08-11 11:24:37,"",,0,0,0,2021-08-11 11:24:37
68743253,1,,,0,809,"<p>I am using the following GraphQL schema and want to find out how to get all the countries based on the continent code.</p>&#xA;<p><a href=""https://countries.trevorblades.com/"" rel=""nofollow noreferrer"">https://countries.trevorblades.com/</a></p>&#xA;<pre><code>query GetCountriesByContinent($code: String!) {&#xA;  &#xA;    countries(filter: {&#xA;      continent: {&#xA;        ???&#xA;      }&#xA;    })&#xA;  &#xA;}&#xA;</code></pre>&#xA;<p>Any ideas?</p>&#xA;<p>UPDATE: The following code works but I am not sure how continent is match against the code.</p>&#xA;<pre><code>query GetCountriesByContinent($code: String!) {&#xA;  &#xA;      countries(filter: {&#xA;        continent: { eq: $code }&#xA;      }) {&#xA;    name &#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>UPDATE 2:</p>&#xA;<p>It might be that behind the scene when you compare a type with something it always compare using the ID field.</p>&#xA;",14934238,,14934238,2021-08-11 13:51:48,2021-08-17 20:41:01,GraphQL How to get all countries based on a selected continent code,<graphql>,1,0,0,2021-08-11 13:42:09
68745075,1,,,0,279,"<p>I'm trying to cleanup relay graphql flow in my app. Atm in some places I'm still using fetchKey and record invalidation, which I'd like to change to @appendEdge/@appendNode directives. Unfortunately every time I'm trying to get the proper connection on which I'm going to use them, it ends up with warnings stating:</p>&#xA;<p><code>Warning: [Relay][Mutation] The connection with id 'client:ParentType14nif3uirdfut431431hg2rr:__ParentTypeChildrenList_children_connection' doesn't exist. </code></p>&#xA;<p>I'm using <code>ConnectionHandler.getConnectionID(&lt;id of the parent object of the fragment&gt;, &lt;connection key I've specified&gt;)</code>.</p>&#xA;<p>Does anyone know what may be the issue here? Also if I understand correctly and if that works my edge is supposed to be added to the store and relay will only determine whether everything is up-to-date without fetching that new edge from the server, right?</p>&#xA;",11569827,,11569827,2021-08-11 16:30:49,2022-08-04 02:19:28,Relay ConnectionHandler.getConnectionID() connection does not exist error,<graphql><relayjs><relaymodern><react-relay>,1,1,0,2021-08-11 15:39:36
68749177,2,,68747554,1,,"<p>Changing my query filter to instead use <code>.+</code> instead of <code>\w+</code> seems to achieve my desired results. Seems like a less explicit solution than I'd like, and I'm not sure how extensible this solution will be as my site expands, but the labor of trying to figure out the <em>exact</em> way gatsby/graphql want <code>\w+</code> formatted is too irritating for the moment.</p>&#xA;<p>final query filter: <code>filter: {slug: {regex: &quot;/adventures/.+/$/&quot;}}</code></p>&#xA;",3609711,,,,2021-08-11 21:35:25,"",,0,0,0,2021-08-11 21:35:25
68752583,1,,,0,162,<p>I have a use case where the client should be able to filter out the data required by names. The number of names could be in millions and the user should have access to all of them in a dropdown list. There are certain features that need to be implemented with this dropdown:</p>&#xA;<ol>&#xA;<li>Search the dropdown and get the filtered names according to the search string.</li>&#xA;<li>Click 'Include All' from the dropdown to include all of the filtered names.</li>&#xA;<li>Click 'Clear All' to clear all the selected ones (or a similar approach)</li>&#xA;<li>Be able to remove a few out of those selected ones</li>&#xA;</ol>&#xA;<p>The filtered names could be in millions so how should I implement the following functionality?&#xA;Obviously getting all the data on the client side in one go is not an option as the size of the data could be 100+ mb.</p>&#xA;<p>The data is being fetched by nodejs/graphql from google bigquery using standard sql queries and being sent to a react based frontend.</p>&#xA;,11387990,,11387990,2021-08-12 08:01:33,2021-08-12 08:01:33,How to handle a list of millions of items in a dropdown in React/GraphQL?,<javascript><reactjs><graphql><graphql-js>,0,22,0,2021-08-12 06:24:07
68761309,2,,68696016,0,,"<p>The double underscore (<code>__</code>) notation that you are using in <code>{airtable.data__Projects}.js</code> I think it's creating a undesired route. According to the docs:</p>&#xA;<blockquote>&#xA;<p>Using <code>__</code> (double underscore) you signify that you want to access a&#xA;nested field on a node.&#xA;You can nest as deep as necessary, e.g.&#xA;<code>src/pages/products/{Product.fields__date__createdAt}.js</code> generates the&#xA;following query:</p>&#xA;<pre><code>allProduct {&#xA;  nodes {&#xA;    id # Gatsby always queries for id&#xA;    fields {&#xA;      date {&#xA;        createdAt&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;</blockquote>&#xA;<p>In your case, I think you are trying to do <code>/projects/{airtable.data.Projects}.js</code>.</p>&#xA;<p>Alternatively (and depending on your specifications) you can create a nested JSON structure inside <code>Projects</code> using a <code>name</code> field (what will hold your <code>Mainsite</code> and <code>Backend</code> values) and suit like like <code>src/pages/projects/{Project.name}.js</code></p>&#xA;",5585371,,,,2021-08-12 16:42:48,"",,0,0,0,2021-08-12 16:42:48
68767019,2,,68714301,1,,"<p>I think you are looking for:</p>&#xA;<pre><code>export const query = graphql`&#xA;    query MyQuery {&#xA;        courses: allSanityCourses(&#xA;        filter: {&#xA;          playlist: {&#xA;            public: { eq: true }&#xA;          }&#xA;        },&#xA;        ){&#xA;            nodes {&#xA;                price&#xA;                name&#xA;                playlist {&#xA;                    title&#xA;                    url&#xA;                    public&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`&#xA;</code></pre>&#xA;<p>The <code>filter</code> filter (quite redundant) and the <code>eq</code> (equals) option should do the trick for you. Check it in the <code>localhost:8000/___graphql</code> playground the tweak/refine it if needed.</p>&#xA;<p>You can check for further filters in <a href=""https://www.gatsbyjs.com/docs/query-filters/"" rel=""nofollow noreferrer"">https://www.gatsbyjs.com/docs/query-filters/</a></p>&#xA;",5585371,,,,2021-08-13 05:02:52,"",,0,5,0,2021-08-13 05:02:52
68823781,2,,68743253,2,,"<p>To better understand your query let's break it down</p>&#xA;<pre><code>countries(filter: {&#xA;        continent: { eq: $code }&#xA;      })&#xA;</code></pre>&#xA;<ol>&#xA;<li><code>countries</code> - find all countries</li>&#xA;<li><code>filter</code> - filtered by</li>&#xA;<li><code>continent</code> - continent (field)</li>&#xA;<li><code>eq</code> - equals to</li>&#xA;<li><code>$code</code> - code (passed as argument)</li>&#xA;</ol>&#xA;<p>In this API field <code>code</code> acts as an ID so behind the scenes they compare by <code>continent.code</code>. That logic of comparison and filtering is happening on the server-side implementation. The developer of that API can choose how he wants to implement comparison</p>&#xA;<p>You can also explore docs and schema on the right-side panel in Grahpql Playground and you can see possible options:</p>&#xA;<pre><code>input CountryFilterInput {&#xA;  code: StringQueryOperatorInput&#xA;  currency: StringQueryOperatorInput&#xA;  continent: StringQueryOperatorInput&#xA;}&#xA;</code></pre>&#xA;<p>That means you can filter countries by <code>code</code> <code>currency</code> and <code>continent</code></p>&#xA;<pre><code>input StringQueryOperatorInput {&#xA;  eq: String&#xA;  ne: String&#xA;  in: [String]&#xA;  nin: [String]&#xA;  regex: String&#xA;  glob: String&#xA;}&#xA;</code></pre>&#xA;<ul>&#xA;<li><code>eq</code>: is exactly the filter value.</li>&#xA;<li><code>ne</code>: is anything except for the filter value.</li>&#xA;<li><code>in</code>: matches any element in given array</li>&#xA;<li><code>nin</code>: matches none of the elements in given array</li>&#xA;<li><code>lt</code>: is lower than the filter value</li>&#xA;<li><code>lte</code>: is lower than or equal to the filter value</li>&#xA;<li><code>gt</code>: is greater than the filter value</li>&#xA;<li><code>gte</code>: is greater than or equal to the filter value</li>&#xA;<li><code>regex</code>: matches given JavaScript regex</li>&#xA;<li><code>glob</code>: matches given micromatch pattern</li>&#xA;</ul>&#xA;<p>It looks like query filters used in Gatsby to get more details&#xA;Reference docs: <a href=""https://www.gatsbyjs.com/docs/query-filters/#supported-comparators"" rel=""nofollow noreferrer"">https://www.gatsbyjs.com/docs/query-filters/#supported-comparators</a></p>&#xA;",8370648,,,,2021-08-17 20:41:01,"",,0,1,0,2021-08-17 20:41:01
68830832,1,,,0,349,"<p>Is there any way that we can only query the required fields instead of querying the whole table every time?</p>&#xA;<p>For example, if I query like this:</p>&#xA;<pre><code>query{&#xA;        locations(id:&quot;&quot;, afterUpdatedAt:&quot;2021-08-17&quot;, limit:&quot;1&quot;, offset:&quot;1&quot;){&#xA;         &#xA;            businessName&#xA;            firstName&#xA;            lastName&#xA;            email&#xA;           &#xA;    &#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>This is the request that is made:</p>&#xA;<pre><code>Location Load (596.3ms)  SELECT &quot;locations&quot;.* FROM &quot;locations&quot; WHERE (updated_at &gt;= '2021-08-17') LIMIT $1 OFFSET $2&#xA;</code></pre>&#xA;<p>My question is that the query should be made in a way that it should only load the required fields, and not the whole table.&#xA;If anyone knows the solution, please let me know.</p>&#xA;",13954388,,10846501,2021-08-18 10:57:42,2021-08-18 10:57:42,How can i only query required fields in graphql?,<ruby-on-rails><graphql><graphql-ruby>,0,2,0,2021-08-18 10:40:08
68865730,2,,62272841,0,,"<p>It will be something like:</p>&#xA;<pre><code>prisma.menu.groupBy({&#xA;    by: ['menu_name'],&#xA;    having: {&#xA;        shop_menu  : {&#xA;            menu_name: { contains: yourVariableName }&#xA;        }&#xA;    }&#xA; })&#xA;</code></pre>&#xA;<p>But as @mazzaker said, you will have to order by rand by yourself :/</p>&#xA;",10549219,,,,2021-08-20 17:01:27,"",,0,0,0,2021-08-20 17:01:27
68867415,1,,,1,180,"<p>I am writing a GraphQL resolver that retrieves all vertices by a particular edge using the following query (created returns label person):</p>&#xA;<pre><code>software {&#xA;   created {&#xA;     name&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>Which would resolve to the following Gremlin Query for each software node found:</p>&#xA;<pre><code>g.V().hasLabel('software').has('name', 'ripple').in('created')&#xA;</code></pre>&#xA;<p>This returns a result that includes all properties of the object:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;    &quot;result&quot;: [&#xA;        {&#xA;            &quot;@type&quot;: &quot;d&quot;,&#xA;            &quot;@rid&quot;: &quot;#24:0&quot;,&#xA;            &quot;@version&quot;: 6,&#xA;            &quot;@class&quot;: &quot;person&quot;,&#xA;            &quot;in_knows&quot;: [&#xA;                &quot;#35:0&quot;&#xA;            ],&#xA;            &quot;name&quot;: &quot;josh&quot;,&#xA;            &quot;out_created&quot;: [&#xA;                &quot;#32:0&quot;,&#xA;                &quot;#33:0&quot;&#xA;            ],&#xA;            &quot;age&quot;: 32,&#xA;            &quot;@fieldTypes&quot;: &quot;in_knows=g,out_created=g&quot;&#xA;        }&#xA;    ],&#xA;    &quot;dbStats&quot;: {&#xA;        ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>I realize that this will fall foul on GraphQL's N+1 query so i'm trying to batch queries together using a Dataloader pattern. (i'm also hoping to do property selections, so i'm not asking the database to return too much info)</p>&#xA;<p>So i'm trying to craft a query like so:</p>&#xA;<pre><code>g.V().union(&#xA;    __.hasLabel('software').has('name', 'ripple').&#xA;    project('parent', 'child').by('id').&#xA;      by(__.in('created').fold()),&#xA;    __.hasLabel('software').has('name', 'lop').&#xA;    project('parent', 'child').by('id').&#xA;      by(__.in('created').fold())&#xA;  )&#xA;&#xA;</code></pre>&#xA;<p>But this results in the following where the props are missing and it just includes the id of the vertices I want:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;    &quot;result&quot;: [&#xA;        {&#xA;            &quot;parent&quot;: &quot;ripple&quot;,&#xA;            &quot;child&quot;: [&#xA;                &quot;#24:0&quot;&#xA;            ]&#xA;        },&#xA;        {&#xA;            &quot;parent&quot;: &quot;lop&quot;,&#xA;            &quot;child&quot;: [&#xA;                &quot;#22:0&quot;,&#xA;                &quot;#23:0&quot;,&#xA;                &quot;#24:0&quot;&#xA;            ]&#xA;        }&#xA;    ],&#xA;    &quot;dbStats&quot;: {&#xA;       ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>My Question is, how can I have the Gremlin query return all of the props for the found vertices and none of the other props? Should I even been doing batching this way?</p>&#xA;",2580199,,2580199,2021-08-23 15:20:29,2021-08-23 16:23:25,How to cleanly batch queries together in Gremlin,<graphql><gremlin>,1,4,0,2021-08-20 19:46:34
68878145,1,,,1,285,"<p>This is a similar question to <a href=""https://stackoverflow.com/questions/64723612/amplify-graphql-not-respecting-the-limit-on-my-query"">this one</a>, but since no one answered it I want to see if I can get some answers about it.</p>&#xA;<p>I am starting to explore graphql and amplify since firestore has some limitations that I consider to restrictive to my application. But I have come to this situation where I want to make a query with limited results and the outcome is not what I expected. My database has only 13 records. And I need to get 12 elements each time.</p>&#xA;<p>So, I if I run this query:</p>&#xA;<pre><code>query MyQuery {&#xA;  listItems(filter: {type: {eq: &quot;ropa&quot;}}) {&#xA;    items {&#xA;      price&#xA;      status&#xA;      type&#xA;      id&#xA;      name&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This will return 4 items with a type value that equals to &quot;ropa&quot;. So far so good. But if I add a limit of 12, like this:</p>&#xA;<pre><code>query MyQuery {&#xA;  listItems(filter: {type: {eq: &quot;ropa&quot;}}, limit: 12) {&#xA;    items {&#xA;      price&#xA;      status&#xA;      type&#xA;      id&#xA;      name&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I will only get 3 of those results and a nextToken, so I will have to pass the same query again but this time with the nextToken value to get the last result.</p>&#xA;<p>What I understand that is happening, is that when you limit your results, the query first takes the amount of elements specified in your limit and filters them to match your query.</p>&#xA;<p>In a scenario where I have to get 12 elements to fill the screen every time I reach the end of the list, I would have to call this query multiple times and would have to device a workaround to fill a temporary list so when it makes it to 12 items then I push them into my array and so on. And if I add a sort direction or other filters, the results reduce and the process becomes more complicated and inefficient to my perspective.</p>&#xA;<p>Is this the only way to do so?</p>&#xA;",666718,,,,2021-08-23 08:23:20,How to get correct amount of items in a single aws graphql query,<graphql><amazon-dynamodb><aws-amplify>,1,0,0,2021-08-22 02:54:10
68887524,1,,,0,215,"<p><a href=""https://github.com/jirutka/rsql-parser"" rel=""nofollow noreferrer"">RSQL</a> is a query language for parametrized filtering of entries in RESTful APIs, meaning I can do something like</p>&#xA;<pre><code>curl -X GET http://localhost:8081/api/v1/employee?search=lastName==Doe&#xA;</code></pre>&#xA;<p>where the search query param can take multiple filters -</p>&#xA;<pre><code>search=lastName==Doe;firstName==John&#xA;</code></pre>&#xA;<p>which translates to <code>select * from employee where firstName = 'John' and lastName = 'Doe'</code></p>&#xA;<p>In GraphQL I need to define a schema in <code>schema.graphqls</code> which only supports a fixed query as -</p>&#xA;<pre><code>type Query {&#xA;   employeeByLastName(lastName: String): Employee&#xA;   employeeByFirstName(firstName: String): Employee&#xA;}&#xA;</code></pre>&#xA;<p><strong>Is it possible to define a single query in GraphQL that can filter on any field without specifying the field explicitly in the schema?</strong></p>&#xA;<p>Something like -</p>&#xA;<pre><code>type Query {&#xA;   filter(params: String[]): Employee&#xA;}&#xA;</code></pre>&#xA;<p>Note: I am new to GraphQL, I am following this <a href=""https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/"" rel=""nofollow noreferrer"">link</a></p>&#xA;",355097,,,,2021-08-23 05:01:30,Is Spring-GraphQL a good replacement to RSQL?,<java><spring-boot><graphql><dynamicquery><rsql>,0,3,0,2021-08-23 05:01:30
68889395,2,,68878145,0,,"<p>I'm not sure how you connect graphql and dynamodb, so I can't really comment on that.</p>&#xA;<p>However, depending on how you've structured your dynamo tables, you have to adhere by the following strict limitation:</p>&#xA;<ul>&#xA;<li>You can query by partition key and sort key.</li>&#xA;<li>You have to specify the partition key</li>&#xA;<li>You can do some limited dynamic queries on the sort key, like begins_with, larger/smaller than, etc.</li>&#xA;</ul>&#xA;<p>If you need to do additional filtering, you can't do that &quot;server side&quot; in Dynamo. So in the cases where your dynamodb table does not match your access patterns fully, you need to fetch a bunch of extra data to the client side and do the filtering there.</p>&#xA;<p>If that becomes cumbersome and slow, you need to redesign your tables so that it fits your access patterns better and enables you to do more work in the PK/SK filtering end of the query.</p>&#xA;",26051,,,,2021-08-23 08:23:20,"",,0,0,0,2021-08-23 08:23:20
68907741,1,68925103,,0,79,"<p>I'm implementing a GraphQL query resolver for retrieving Connections in my web app according to <a href=""https://relay.dev/graphql/connections.htm#sec-Pagination-algorithm"" rel=""nofollow noreferrer"">this specification</a>. I'm using base64 encoded strings of table's unique created_at timestamps to represent opaque cursors. I'm using PostgreSQL as database server.</p>&#xA;<p>The SQL code to query posts table with below arguments is:</p>&#xA;<pre><code>-- first: 20, after: '2020-06-15 14:56:31.456'&#xA;-- last: 10, before: '2020-08-09 09:25:49.108'&#xA;-- sortBy: title&#xA;&#xA;SELECT * FROM (&#xA;    SELECT * FROM (&#xA;        SELECT * FROM posts&#xA;        WHERE title &gt; (SELECT title FROM posts WHERE created_at = '2020-06-15 14:56:31.456')&#xA;            AND title &lt; (SELECT title FROM posts WHERE created_at = '2020-08-09 09:25:49.108')&#xA;        ORDER BY title&#xA;        LIMIT 20&#xA;    ) AS forward_pagination_result&#xA;    ORDER BY title DESC&#xA;    LIMIT 10&#xA;) AS backward_pagination_result&#xA;ORDER BY title;&#xA;</code></pre>&#xA;<p>The problem is that the existence of timestamps corresponding to after or before cursors is unknown. For example querying  by these arguments (after: 'timestamp that doesn't exist', before: 'timestamp that exists'), the result of comparison will be null hence the query results, in spite of the before timestamp being valid. I could separate subqueries from the main query and build my SQL code according to the results of subqueries but that would result multiple calls to database server which is not efficient.</p>&#xA;<p>I also tried modifying the above code to include functions like COALESCE:</p>&#xA;<pre><code>SELECT * FROM (&#xA;    SELECT * FROM (&#xA;        SELECT * FROM posts&#xA;        WHERE COALESCE(title &gt; (SELECT title FROM posts WHERE created_at = '2020-06-15 14:56:31.456'), TRUE)&#xA;            AND COALESCE(title &lt; (SELECT title FROM posts WHERE created_at = '2020-08-09 09:25:49.108'), TRUE)&#xA;        ORDER BY title&#xA;        LIMIT 20&#xA;    ) AS forward_pagination_result&#xA;    ORDER BY title DESC&#xA;    LIMIT 10&#xA;) AS backward_pagination_result&#xA;ORDER BY title;&#xA;</code></pre>&#xA;<p>But that runs much slower than the one without COALESCE (120ms vs 5ms for 100k rows).</p>&#xA;<p>Can I check for null values and execute query as fast as 5ms or so both at the same time?</p>&#xA;",6418150,,6418150,2021-08-25 13:37:16,2021-08-25 14:47:43,Improving the performance of SQL code for querying GraphQL connections,<sql><postgresql><graphql>,1,0,0,2021-08-24 12:37:54
68913108,2,,68895508,0,,"<p>The index should be also created on the server, you can do this manually but not efficient, however you could create an initialization file for the database to define the index:</p>&#xA;<pre><code>connection = new Mongo();&#xA;&#xA;db = connection.getDB(&quot;database_name&quot;)&#xA;&#xA;db.users.createIndex({ location: '2dsphere' })&#xA;</code></pre>&#xA;<p>And reference the file in your config</p>&#xA;",10453610,,,,2021-08-24 19:31:07,"",,0,0,0,2021-08-24 19:31:07
68925103,2,,68907741,0,,"<p>I think the reason for the performance difference is that COALESCE function is executed for every row. If I could place it somewhere to run it once the problem would be solved. I don't know a way in standard SQL to conditionally use different WHERE clauses, for that I should probably use procedural languages like PL/pgSLQ. But if I could specify default values for sorting criterion corresponding to after and before cursors I would write:</p>&#xA;<pre><code>WHERE title &gt; COALESCE((subquery_for_after), 'least_value_for_title')&#xA;    AND title &lt; COALESCE((subquery_for_before), 'greatest_value_for_title')&#xA;</code></pre>&#xA;<p>Determining least and greatest value for integer and numeric values is easy. Also you can provide far date in past or future for dates. For text values I think empty string would be the least, and for greatest value I use some great unicode number. The complete SQL code will be then:</p>&#xA;<pre><code>SELECT * FROM (&#xA;    SELECT * FROM (&#xA;        SELECT * FROM posts&#xA;        WHERE title &gt; COALESCE((SELECT title FROM posts WHERE created_at = '2020-06-15 14:56:31.456'), '')&#xA;            AND title &lt; COALESCE((SELECT title FROM posts WHERE created_at = '2020-08-09 09:25:49.108'), U&amp;'\+10ffff')&#xA;        ORDER BY title&#xA;        LIMIT 20&#xA;    ) AS forward_pagination_result&#xA;    ORDER BY title DESC&#xA;    LIMIT 10&#xA;) AS backward_pagination_result&#xA;ORDER BY title;&#xA;</code></pre>&#xA;<p>The execution time for the above code is around 6-8ms depending on the existence of after and before cursors.</p>&#xA;",6418150,,,,2021-08-25 14:47:43,"",,0,0,0,2021-08-25 14:47:43
68937304,2,,68936388,2,,"<p><code>where</code> filter is restricted in Gatsby. Here you have a detailed <a href=""https://www.gatsbyjs.com/docs/query-filters/#comparator-details"" rel=""nofollow noreferrer"">list of comparators</a>, but they are:</p>&#xA;<ul>&#xA;<li><code>eq</code> (equals)</li>&#xA;<li><code>ne</code> (not equals)</li>&#xA;<li><code>in</code> (includes)</li>&#xA;<li><code>nin</code> (not includes)</li>&#xA;<li><code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code> (less than, equal or less than, greater than, equal or greater than respectively)</li>&#xA;<li><code>regex</code>, <code>glob</code> (regular expression)</li>&#xA;<li><code>elemMatch</code> (element matches)</li>&#xA;</ul>&#xA;<p>On the other hand, there is a list of <a href=""https://www.gatsbyjs.com/docs/graphql-reference/"" rel=""nofollow noreferrer"">filters available</a>. In your case, <a href=""https://www.gatsbyjs.com/docs/graphql-reference/#filter"" rel=""nofollow noreferrer""><code>filter</code></a> is what you are looking for. Your final query should look like:</p>&#xA;<pre><code>query test {&#xA;  allWpPage(&#xA;   filter : {uri : {ne : &quot;&quot; }}&#xA;  ) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        uri&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Of course, adapt the <code>filter</code> to your needs. <code>elemMatch</code> should work for you either.</p>&#xA;<p>You will need to add each condition for each property of the object you're trying to match.</p>&#xA;<hr />&#xA;<h2>Why is <code>where</code> restricted?</h2>&#xA;<p>Because it belonged to Sift, a library that Gatsby was using to use <a href=""https://docs.mongodb.com/manual/reference/operator/query/"" rel=""nofollow noreferrer"">MongoDB queries</a>, where <code>where</code> is available. Since <a href=""https://github.com/gatsbyjs/gatsby/compare/gatsby@2.22.22...gatsby@2.23.0"" rel=""nofollow noreferrer"">Gatsby 2.23.0</a> (June 2020) this library is not being used anymore. More details at <a href=""https://www.gatsbyjs.com/docs/query-filters/#history-and-sift"" rel=""nofollow noreferrer"">History and Sift</a>:</p>&#xA;<blockquote>&#xA;<p>For a long time Gatsby used the Sift library through which you can use&#xA;MongoDB queries in JavaScript.</p>&#xA;<p>Unfortunately Sift did not align with how Gatsby used it and so a&#xA;custom system was written to slowly replace it. This system was called&#xA;“fast filters” and as of gatsby@2.23.0 (June 2020) the Sift library is&#xA;no longer used.</p>&#xA;</blockquote>&#xA;",5585371,,5585371,2021-08-26 11:44:57,2021-08-26 11:44:57,"",,0,2,0,2021-08-26 11:01:19
68950096,1,69114628,,0,489,"<p>I am creating a query in graphql + apollo client whose filters and orders can change depending on what the customer selects in the frontend. For example:</p>&#xA;<pre><code>query (&#xA;        $orderPart: String!&#xA;        $wherePart: String!&#xA;        ) {&#xA;    getProductInfo(&#xA;        order {$orderPart}&#xA;        where {$wherePart}&#xA;    ) {&#xA;      productID&#xA;      description&#xA;      size&#xA;      model&#xA;      cathegoryNumber&#xA;    }&#xA;</code></pre>&#xA;<p>Where $orderPart will be equal to &quot;description: DESC&quot; or &quot;productID: ASC&quot; (depending what the customer selected in a momento or another). And $wherePart will be equal to &quot;cathegoryNumber: {eq: 12}&quot; or &quot;productID: {eq: 111111}&quot;.</p>&#xA;<p>I need to pass the order/filter clause completely as a parameter.</p>&#xA;<p>But it doesn't work. Syntax is error &quot;Syntax Error: Expected name, found $&quot;.</p>&#xA;<p>So my question is...</p>&#xA;<p>Is there any way to implement these dynamic filters/orders? How could this functionality be implemented? Is there any other way to implement this dynamic filters and orders?</p>&#xA;<p>Thanks.</p>&#xA;<p>Note:&#xA;In the official documentation, I found that only values can be passed as a parameters:</p>&#xA;<pre><code>query (&#xA;        $orderValue: sortEnumType! = DESC&#xA;        $whereValue: String! = &quot;description1&quot;&#xA;        ) {&#xA;    getProductInfo(&#xA;        order {productID: $orderValue}&#xA;        where {description: {eq: $whereValue} }&#xA;    ) {&#xA;      productID&#xA;      description&#xA;      size&#xA;      model&#xA;      cathegoryNumber&#xA;    }&#xA;</code></pre>&#xA;<p>But that is not what I need because always filters/orders couldn't be changed. And they could be completely different each time (prodyuct:ASC) first time, (cathegoryNumber:DESC) second time, etc...</p>&#xA;",6493901,,6681858,2021-09-05 19:05:24,2021-09-16 18:18:03,How to create/Fetch data dynamically by filters and order in GraphQL?,<graphql><apollo>,1,4,0,2021-08-27 08:13:00
68961375,1,,,0,239,"<p>Say, I have these typeDefs (just an example):</p>&#xA;<pre><code>type CityInfo {&#xA;  CityState: {&#xA;    City: String!&#xA;    State: String!    &#xA;  }&#xA;&#xA;  Zip: String!&#xA;}&#xA;&#xA;type Query {&#xA;  CitiesStatesZips: [CityInfo]&#xA;}&#xA;</code></pre>&#xA;<p>Now, say there is a rest api that gives me a list of Zip codes and there is another REST API that returns City/State by Zip code. I can write this resolver:</p>&#xA;<pre><code>const resolvers = {&#xA;  Query: {&#xA;    CitiesStatesZips: (parent, args, {dataSources}) =&gt; dataSources.ZipApi.getZipCodes()&#xA;  },&#xA;  CityInfo: {&#xA;    CityState: (parent, args, { dataSources }) =&gt; dataSources.CityStateApi(** HOW DO I PASS ZIP HERE **) &#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In <code>CityState</code> field resolver I need to pass the value of <code>Zip</code> field of the same object - how do I access it?</p>&#xA;",151200,,,,2021-09-03 20:29:14,Getting a value of a sibling field in a field resolver,<node.js><graphql><apollo><apollo-server>,1,3,0,2021-08-28 04:27:43
68965347,2,,68548773,0,,"<p>I am guessing from your snippet that <code>QueryRenderer</code> is an HOC you are using wrapping relay's QueryRender component?</p>&#xA;<p>If so, this is how you normally determine if a query is in loading state:</p>&#xA;<pre><code>// Example.js&#xA;import React from 'react';&#xA;import { QueryRenderer, graphql } from 'react-relay';&#xA;&#xA;const renderQuery = ({error, props}) =&gt; {&#xA;  if (error) {&#xA;    return &lt;div&gt;{error.message}&lt;/div&gt;;&#xA;  } else if (props) {&#xA;    return &lt;div&gt;{props.page.name} is great!&lt;/div&gt;;&#xA;  }&#xA;  return &lt;div&gt;Loading&lt;/div&gt;;&#xA;}&#xA;&#xA;const Example = (props) =&gt; {&#xA;  return (&#xA;    &lt;QueryRenderer&#xA;      environment={environment}&#xA;      query={graphql`&#xA;        query ExampleQuery($pageID: ID!) {&#xA;          page(id: $pageID) {&#xA;            name&#xA;          }&#xA;        }&#xA;      `}&#xA;      variables={{&#xA;        pageID: '110798995619330',&#xA;      }}&#xA;      render={renderQuery}&#xA;    /&gt;&#xA;  );&#xA;}&#xA;</code></pre>&#xA;<p>This snippet is taken from the <a href=""https://relay.dev/docs/v10.1.3/query-renderer/"" rel=""nofollow noreferrer"">relay.dev docs</a>.</p>&#xA;<p>Notice how the <code>render</code> renderProp is getting the <code>props</code> field once the query is no longer loading.</p>&#xA;<p>If you are using the new hooks-api, it will be different based on which of the query-hooks you are using.</p>&#xA;",4557188,,,,2021-08-28 14:39:24,"",,0,0,0,2021-08-28 14:39:24
69018205,1,69018809,,0,94,<p>Suppose I have following query:</p>&#xA;<pre><code>query a($f: Int) {&#xA;  a {&#xA;    b(f: $f) {&#xA;      c {&#xA;        d {&#xA;          e&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Can I somehow make it smaller? Sort of like this</p>&#xA;<pre><code>query a($f: Int) {&#xA;  a.b(f: $f).c.d {&#xA;    e&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,13171776,,,,2021-09-01 18:16:49,Can I shorten graphql queries?,<graphql>,2,0,0,2021-09-01 17:23:38
69019602,2,,68637096,0,,"<p>When you create a relation on type Product</p>&#xA;<pre><code>store: Store @connection(name: &quot;StoreProducts&quot;, sortField: &quot;crearedAt&quot;)&#xA;</code></pre>&#xA;<p>You have to tell server how to look for the items. by which field name. That is why you are getting this error &quot;@connection must be on an @model object type field.&quot;</p>&#xA;<p>Solution would be add <code>fields</code>. On type Product if you want to bring Store Products, you need to add &quot;id&quot; fields.</p>&#xA;<pre><code>store: Store @connection(name: &quot;StoreProducts&quot;, fields:[&quot;id&quot;] sortField: &quot;crearedAt&quot;)&#xA;</code></pre>&#xA;<p>In all other types if you want to have relation, you have to define a convenient field to query the data.</p>&#xA;",10262805,,,,2021-09-01 19:30:09,"",,0,0,0,2021-09-01 19:30:09
69038932,2,,69038594,0,,"<p>In the second hook do an early return if the required data is not available.</p>&#xA;<pre><code>export const useActivityList = () =&gt; {&#xA;  const { me, error } = useMe();&#xA;&#xA;  if (!me) {&#xA;    return null;&#xA;    // or another pattern that you may find useful is to set a flag to indicate that this query is idle e.g.&#xA;    // idle = true;&#xA;  }&#xA;&#xA;  const criteria = { assignment: { uuid: { _eq: me.profile_id } } } as appointment_bool_exp;&#xA;&#xA;  ...&#xA;</code></pre>&#xA;",12149861,,,,2021-09-03 02:43:43,"",,0,4,0,2021-09-03 02:43:43
69040911,1,69041130,,2,495,"<p>I have a course table, each course has an id, a code and a start date. Example:</p>&#xA;<pre><code>course_id    course_code    start_date&#xA;uuid1        course_a       2021-06-01&#xA;uuid2        course_a       2021-09-01&#xA;uuid3        course_b       2021-06-01&#xA;uuid4        course_b       2021-09-01&#xA;</code></pre>&#xA;<p>I want to get the latest record of each distinct course and I can do it in SQL</p>&#xA;<pre><code>SELECT DISTINCT ON (course_code)&#xA;    course_id,&#xA;    course_code,&#xA;    start_date&#xA;FROM course&#xA;ORDER BY course_code, start_date DESC&#xA;&#xA;uuid2        course_a       2021-09-01&#xA;uuid4        course_b       2021-09-01&#xA;</code></pre>&#xA;<p>But is it possible to query in graphql?</p>&#xA;",16582416,,16582416,2021-09-03 07:24:30,2021-09-03 07:36:46,Hasura order by date with distinct,<postgresql><graphql><hasura>,1,0,0,2021-09-03 07:16:28
69041130,2,,69040911,2,,"<p>Solved by adding a list of order_by condition instead of unordered object</p>&#xA;<pre><code>query MyQuery {&#xA;  course(distinct_on: course_code, order_by: [{course_code: asc}, {start_date: desc}]) {&#xA;    course_id&#xA;    course_code,&#xA;    start_date&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",16582416,,,,2021-09-03 07:36:46,"",,0,0,0,2021-09-03 07:36:46
69049751,1,69065675,,0,332,"<p>This is code section.. companyStatus: userCtx.user.category  this section is generating error in the code. This field is actually enum type field in the schema.graphql&#xA;Can anyone please help me how to write that section? companyName is working fine, but getting error from company Status.</p>&#xA;<p>ERROR : companyType has an invalid value, this is the error</p>&#xA;<pre><code>var input = {&#xA;        companyName: userCtx.user.company,&#xA;        companyStatus: userCtx.user.status &#xA;        createdAt: new Date().toISOString()&#xA;    }&#xA;</code></pre>&#xA;",16825607,,16825607,2021-09-05 17:23:31,2021-09-05 17:54:34,How to send enum Type fields to GraphQL/AWS appsync from react,<reactjs><graphql><aws-appsync>,1,4,0,2021-09-03 19:24:44
69050260,2,,68961375,2,,<p>If <code>CitiesStatesZips</code> returns an array of objects (<code>CityInfo</code> type)  with <code>zip</code> field ...</p>&#xA;<p>... then <code>zip</code> is already resolved when <code>CityState</code> resolver is called ... then you can simply use <code>parent.zip</code> as an arg for datasource call.</p>&#xA;,6124657,,,,2021-09-03 20:29:14,"",,0,0,0,2021-09-03 20:29:14
69050689,1,,,1,82,"<p>I'm working on standing up a simple Relay/GraphQL app using Node.</p>&#xA;<p>At the root level, I have a connection called 'notes' that paginates all notes in the database. On my user object, I have a notes connection that paginates all notes that user has created.</p>&#xA;<pre><code>  const rootNotesId = ConnectionHandler.getConnectionID('client:root', 'RootNotesConnection_notes');&#xA;  const userNotesId = ConnectionHandler.getConnectionID(queryData?.me?.id, 'UserNotesConnection_notes');&#xA;  &#xA;  const rootNotes = usePaginationFragment(graphql `&#xA;    fragment NotesRoot_notes on Query @refetchable(queryName: &quot;NotesRootQuery&quot;) {&#xA;      notes(first: $count, after: $cursor) @connection(key: &quot;RootNotesConnection_notes&quot;) {&#xA;        edges {&#xA;          node {&#xA;            ...Note_note&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `, queryData);&#xA;  &#xA;  const userNotes = usePaginationFragment(graphql`&#xA;    fragment NotesUser_notes on Query @refetchable(queryName: &quot;NotesUserQuery&quot;) {&#xA;      me {&#xA;        id&#xA;        notes(first: $count, after: $cursor) @connection(key: &quot;UserNotesConnection_notes&quot;) {&#xA;          edges {&#xA;            node {&#xA;              ...Note_note&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `, queryData);&#xA;</code></pre>&#xA;<p>How do I add or delete a note to both connections at once client-side? I have two different edge types and I thought this code would work:</p>&#xA;<pre><code>  const [commit, isInFlight] = useMutation(graphql `&#xA;    mutation NotesCreateMutation($input: createNoteInput!) {&#xA;      createNote(input: $input) {&#xA;        noteEdge {&#xA;          cursor,&#xA;          node {&#xA;            id&#xA;            user {&#xA;              username&#xA;            }&#xA;            content&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  `);&#xA;  &#xA;  const handleButtonClick = () =&gt; {&#xA;    if (!isInFlight) {&#xA;      commit({&#xA;        variables: {&#xA;          input: {&#xA;            content: newNoteInput&#xA;          }&#xA;        },&#xA;        updater: store =&gt; {&#xA;          const rootCon = ConnectionHandler.getConnection(store.get('client:root'), 'RootNotesConnection_notes');&#xA;          const userCon = ConnectionHandler.getConnection(store.get(userId), 'UserNotesConnection_notes');&#xA;          const payload = store.getRootField('createNote');&#xA;          const newEdge = payload.getLinkedRecord('noteEdge');&#xA;          const newNote = newEdge.getLinkedRecord('node');&#xA;          debugger;&#xA;          const newRootEdge = ConnectionHandler.createEdge(store, rootCon, newNote, 'QueryNotesEdge');&#xA;          const newUserEdge = ConnectionHandler.createEdge(store, userCon, newNote, 'UserNotesEdge');&#xA;          ConnectionHandler.insertEdgeAfter(rootCon, newRootEdge);&#xA;          ConnectionHandler.insertEdgeAfter(userCon, newUserEdge);&#xA;        }&#xA;      });&#xA;      setNewNoteInput('');&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>The only thing I can find in my debugging is that the cursor never gets set for the new edge. Stepping through this code in the debugger reveals that all variables before <code>newRootEdge</code> resolve just fine</p>&#xA;",16826122,,,,2021-09-03 22:21:58,How do I remove a shared node from two different relay connections?,<javascript><graphql><relay><relaymodern>,1,0,0,2021-09-03 21:25:03
69054303,2,,69032524,4,,"<p>So, apparently adding the arguments before the <code>@include</code> directive is the way. I tried many different ways and this worked like a charm! So if anyone is wondering how to also add arguments besides directives, this is how:</p>&#xA;<pre><code>export const GET_AUTHORIZED_USER = gql`&#xA;    query GetAuthorizedUser(&#xA;        $includeReviews: Boolean!&#xA;        $after: String&#xA;        $first: Int&#xA;    ) {&#xA;        authorizedUser {&#xA;            id&#xA;            username&#xA;            reviews(after: $after, first: $first) @include(if: $includeReviews) {&#xA;                pageInfo {&#xA;                    hasPreviousPage&#xA;                    hasNextPage&#xA;                    startCursor&#xA;                    endCursor&#xA;                }&#xA;                edges {&#xA;                    cursor&#xA;                    node {&#xA;                        id&#xA;                        repositoryId&#xA;                        rating&#xA;                        text&#xA;                        createdAt&#xA;                        user {&#xA;                            username&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;",12263641,,,,2021-09-04 10:05:39,"",,0,0,0,2021-09-04 10:05:39
69071695,1,,,4,628,"<p>I have two GraphQL schemas that define two different Types <code>User</code> which are in a one-to-one relationship. Each of them implements a set of arguments (<code>filter</code>, <code>condition</code>, ...) that are used for filtering for example.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// analyticsSchema&#xA;type User {&#xA;  id: String!&#xA;  actions: Int&#xA;}&#xA;&#xA;// metadataSchema&#xA;type User {&#xA;  id: String!&#xA;  age: Int&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>These types are merged bi-directionnaly:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const gatewaySchema = stitchSchemas({&#xA;  subschemas: [&#xA;    {&#xA;      schema: analyticsSchema,&#xA;      merge: {&#xA;        User: {&#xA;          fieldName: 'analyticsById',&#xA;          selectionSet: '{ id }',&#xA;          args: originalObject =&gt; ({ id: originalObject.id }),&#xA;        },&#xA;      },&#xA;    },&#xA;    {&#xA;      schema: metadataSchema,&#xA;      merge: {&#xA;        User: {&#xA;          fieldName: 'metadataById',&#xA;          selectionSet: '{ id }',&#xA;          args: originalObject =&gt; ({ id: originalObject.id }),&#xA;        },&#xA;      },&#xA;    },&#xA;  ],&#xA;  mergeTypes: true, &#xA;});&#xA;</code></pre>&#xA;<p>With this implementation, I do not have access to all fields for filtering:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// What I can do &#xA;query ExampleQuery {&#xA;  allUsers(filter: { actions: { greaterThan: 10 }}) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        actions&#xA;        age&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;// What I would like to do&#xA;query ExampleQuery {&#xA;  allUsers(filter: {actions: {greaterThan: 10}, age: {lessThan: 35}}) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        actions&#xA;        age&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&gt; Problem: Field &quot;age&quot; is not defined by type &quot;UserFilter&quot;.&#xA;</code></pre>&#xA;<p>My question is, is it possible to expose all filtering arguments to the resulting merged type? Or maybe I'm going the wrong way?</p>&#xA;<p>N.B: both GraphQL endpoints rely on <code>postgraphile</code> and we're using the <code>postgraphile-plugin-connection-filter</code> plugin if that matters.</p>&#xA;",8253769,,8253769,2021-09-07 07:34:55,2021-09-08 11:46:20,Merge GraphQL Types and their arguments in a stitched schema,<graphql><postgraphile>,0,1,0,2021-09-06 08:44:51
69079801,1,69113314,,1,132,"<p>In some parts of my app,&#xA;I have a component using a fragment.&#xA;but up the tree somewhere, i sometimes need to create temporary objects waiting to be synced with the server (once they will they are transformed as plain relay objects).</p>&#xA;<p>But until then, they are only a few objects passed down the tree of component.&#xA;The <code>createFragmentContainer</code> + some <code>@relay(mask: false)</code> make all this possible.&#xA;But I would like to make it a bit cleaner using <code>useFragment</code>.</p>&#xA;<p>Usefragment doesn't like at all the &quot;fake fragment&quot; data.</p>&#xA;<p>Is there a way to somewhat legibly hydrate a fragment from data not directly coming from a query?</p>&#xA;<p>or maybe another way?</p>&#xA;",5103350,,,,2021-09-09 06:35:36,hydrate Relay Fragment without Query,<reactjs><graphql><relay><react-relay>,1,0,0,2021-09-06 20:05:58
69135633,1,,,0,445,"<p>I'm working on Next.js and Amplify together, trying to get sorting to work with the database.</p>&#xA;<p>Why can't we just sort by DESC or ASC a list of queries? Why do we have to create a new key and add an additional fields to it?</p>&#xA;<p>like for example:</p>&#xA;<pre><code>type Order @model @key(fields: [&quot;customerEmail&quot;, &quot;createdAt&quot;]) {&#xA;  id: ID!  &#xA;  customerEmail: String!&#xA;  createdAt: String!&#xA;  orderId: ID!&#xA;}&#xA;</code></pre>&#xA;<p>Would allow your to get all the orders with customerEmail, and then you can do <code>sortDirection</code>, and this will only work if you have another field like <code>customerEmail</code> to populate:</p>&#xA;<pre><code>await API.graphql(listOrders, {&#xA;  customerEmail: &quot;some@email.com&quot;,&#xA;  sortDirection: &quot;DESC&quot;, // or ASC&#xA;})&#xA;</code></pre>&#xA;<p>This will give you the list of orders from <code>some@email.com</code> and it will allow you to sort.</p>&#xA;<p>Why can't we just have the <code>id</code> field, and sort:</p>&#xA;<pre><code>type Order @model @key(name: &quot;orderSort&quot;, fields: [&quot;id&quot;, &quot;createdAt&quot;], queryField: &quot;orderSort&quot;) {&#xA;  id: ID!  &#xA;  customerEmail: String!&#xA;  createdAt: String!&#xA;  orderId: ID!&#xA;}&#xA;</code></pre>&#xA;<p>and sorting the list:</p>&#xA;<pre><code>await API.graphql(orderSort, {&#xA;  sortDirection: &quot;DESC&quot;, // or ASC&#xA;})&#xA;</code></pre>&#xA;<p>I tried something similar to this, and I get an error: <code>Expression block '$[query]' requires an expression</code>.</p>&#xA;<hr />&#xA;<p>Or why can't we just do sorting even without the <code>@key</code> directive, just have the listOrders with sortDirection:</p>&#xA;<pre><code>type Order @model {&#xA;  id: ID!  &#xA;  customerEmail: String!&#xA;  createdAt: String!&#xA;  orderId: ID!&#xA;}&#xA;&#xA;await API.graphql(listOrders, {&#xA;  sortDirection: &quot;DESC&quot;, // or ASC&#xA;})&#xA;</code></pre>&#xA;",659751,,,,2021-09-11 10:26:13,Sorting a list of queries with Amplify GraphQL Data without any other fields to match,<graphql><next.js><amazon-dynamodb><aws-amplify><dynamodb-queries>,1,0,0,2021-09-10 17:00:18
69142092,2,,69135633,1,,"<p>Dynamodb <code>SCAN</code> operator doesn't guarantee the order.</p>&#xA;<p>Currently, Amplify also doesn't support sorting by default.</p>&#xA;<p>However, apparently, what most people do is adding a constant field to the model.</p>&#xA;<pre><code>type Order @model @key(name: &quot;orderSort&quot;, fields: [&quot;typename&quot;, &quot;createdAt&quot;], queryField: &quot;orderSort&quot;) {&#xA;  id: ID! &#xA;  customerEmail: String!&#xA;  typename: String! # for example, Order in this case &#xA;  createdAt: AWSDateTime!&#xA;}&#xA;</code></pre>&#xA;<pre><code>await API.graphql(orderSort, {&#xA;  typename: &quot;Order&quot;,&#xA;  sortDirection: &quot;DESC&quot;, // or ASC&#xA;})&#xA;</code></pre>&#xA;",8763264,,,,2021-09-11 10:26:13,"",,0,0,0,2021-09-11 10:26:13
69142286,2,,69127002,2,,"<p>Why adding <code>projectId</code> again in the Project model when you can use <code>id</code>?</p>&#xA;<p>I don't know about your use case, but you can use <code>filter</code>.</p>&#xA;<pre><code>type Project&#xA;  @model&#xA;  @key(&#xA;    name: &quot;byUserId&quot;&#xA;    fields: [&quot;userId&quot;]&#xA;    queryField: &quot;projectByUserId&quot;&#xA;  )&#xA;  id: ID!&#xA;  userId: ID!&#xA;  projectId: ID!&#xA;}&#xA;</code></pre>&#xA;<pre><code>import { API, graphqlOperation } from &quot;aws-amplify&quot;;&#xA;&#xA;--- &#xA;&#xA;await API.graphql(&#xA;  graphqlOperation(projectByUserId, {&#xA;    userId: props.userId,&#xA;    filter: { projectId: { eq: props.projectId } }&#xA;  })&#xA;);&#xA;</code></pre>&#xA;",8763264,,,,2021-09-11 10:52:22,"",,0,0,0,2021-09-11 10:52:22
69145517,1,69231256,,0,154,"<p>How would I get mutual friends using a GraphQL API?</p>&#xA;<p>I can find a lot of resources on how to do this in SQL or Cypher, but not GraphQL.</p>&#xA;<p>We could use <a href=""https://hasura.io/docs/latest/graphql/core/databases/postgres/queries/index.html"" rel=""nofollow noreferrer"">Hasura</a> in this example, or any GraphQL API.</p>&#xA;<p>Schema:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type Person {&#xA;  id: ID!&#xA;  name: String!&#xA;  friends: [Person]&#xA;}&#xA;</code></pre>&#xA;<p>We have two people with ids <code>01</code> and <code>02</code>.</p>&#xA;<p>What would the GraphQL for this be? Is it possible without under-the-hood functionality or child / nested filters?</p>&#xA;",271450,,229044,2021-10-04 19:38:30,2021-10-04 19:38:30,GraphQL - Get Mutual Friends,<graphql>,1,1,0,2021-09-11 18:04:07
69146961,2,,69069915,1,,"<p>GraphQL can't filter an array so if the API support filter base on <code>totalCount</code> you can pass this filter otherwise you have to filter in your code. In JS it's very easy:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const filtered = {&#xA;  ...data,&#xA;  search: {&#xA;    ...data.search,&#xA;    nodes: data.search.nodes.filter(node =&gt; node.defaultBranchRef.target.history.totalCount &gt; 0),&#xA;  }&#xA;};&#xA;</code></pre>&#xA;",5062890,,,,2021-09-11 21:49:52,"",,0,0,0,2021-09-11 21:49:52
69165089,2,,69164788,2,,"<p>You can use built in <a href=""https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype"" rel=""nofollow noreferrer"">NonNullable</a> util</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type MyType = {&#xA;    foo: {&#xA;        bar: [1, 2, 4] | null&#xA;    } | null&#xA;}&#xA;&#xA;&#xA;type GetNullable&lt;T, Prop extends keyof NonNullable&lt;T&gt;&gt; = NonNullable&lt;T&gt;[Prop]&#xA;&#xA;// [1, 2, 4] | null&#xA;type NestedData = GetNullable&lt;MyType['foo'], 'bar'&gt;&#xA;&#xA;&#xA;</code></pre>&#xA;<p><a href=""https://www.typescriptlang.org/play?#code/C4TwDgpgBAsiAq5oF4oG8CwAoKuoDMB7QgLnWz0qgCMBDAJzIG0BGAGigCYOAWAXSgAfKADsArgBsJFPAF8hoydKyzsarKEhQA4hGAA5JbWoSIAHngcACvUJgoEAB7AIIgCYBnKAGsIIQvhQ%20oQihlLGphYAfFFQqMGhRibm8FFMNnZ86gD02VCsHNxQ-AriUtia0PoQHi5uACK0wLRxOnphEhHmcIiQTADkRIT9fBz9dPT9UdhAA"" rel=""nofollow noreferrer"">Playground</a></p>&#xA;<p>OR</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type Truthy&lt;T&gt; = NonNullable&lt;T&gt;&#xA;&#xA;type GetData = Truthy&lt;Truthy&lt;MyType['foo']&gt;&gt;['bar']&#xA;</code></pre>&#xA;<p>If you need more sophisticated util, please see this <a href=""https://www.typescriptlang.org/play?#code/PTAEAsBdIBwZwFwjpAhgYwNYHsBuBTAJwDMAbbAdwDp1sBbYARwFd8UBLbAOzmADYAHH0EAGAKxjg%20UuzrsuqSPgC0XfAUJxlkbMrqpMK5l05dlMbHDjsARqXz8hAdgBMYgIwuA-F2yF8ACbs-uiQALzuAMS0dHT4XJCe7gDMfC4ALC4AnAD6gnyuHi4AsABQIBDQ8EjA6IroUHA09MAB%20Pgw5uxYZZAAnjD4oADKkITMocz%20oGGgAN5loEugqISECPOLy9sBiqgbC6Xbx8v4dDD9ACrMMPYbANoAugA0Wyfbq4SofQcrAOb4DZcZh0GxEUAAXyeb2OENAAB9QMDSKQYRCyujSr0BkMAKL2OgzUAoQjyP4AbjK2MGoAAaqhSKw4AAeS4APiJl3uhj62GIoEujyppX6NIAknAAHLqIisjmze6C0D4AAeSi4ATgoHuag0j1AXlAY1YoA2xAZcHwlKxNtFQwAguh0ESAEr4WiEALMklk54rLh9NnCu2gN0BCZEADCDNINgwmGZjvQIOYpEUfmVavimtASb9%20Mz6pz%20LO8phBdVRa1PL5uadKbTOkIBrryboqfThHu%20P1GyTDc7wZxocCEcIzJhAGl8H0tZXs1qS3RXkdlv3242M-ONVqk0S5pjtmXV0tp7PCwvQAADAAkc3kxHBAAVCNgYBCqHeH%20C3SgIVeYUNMMx2ZX9ID9YD0CjGM4ywRN6w3Ts-RfN82SDE9TVAM85yzHdry-LhH2bAAZVA-wAjCgNHKDCGjFFYITdcOybP1SJQdDtiBGVCCHcU4GuW58DlGYYQACkuC88PtNZvmZVAAw5LwYW2cT7gAcnsLg-kgcA1P1bcc2BUEiGU95DVEoywWbAytS5DT4m03ShQw95jkNc1SEtUzXKWDZjXwABKbzjj88ZAuCs0LXC21hwlXFziuG57FZSSc2kr4%20jkhT5QFdTNMcvTUq1EQW38zCPK8mKaTo2N41ZP1owaIYbOJMZfVAYiZVIIqkRBKynhy%20lGTYZlDm2e4n1AeRQBrflBQQMTJpan0tOC8zGvAZrcJzNS1OC7ZDWwgBVExuFZCaXnwuYn3-P17ioB7OoIUg-XcR4OJ83yOq6vKHJ0wqWvcfblkOmc4BO0xzqfS7bzmDb8A-O8bqvO6HqoJ7pFe97ga%20%20GESwsGIbOrlob9WH4cR67bu1NGMZe0A3o%20k4gpc5YuI0FmIXQ6khmO06uAnDDLhXbY8eWtqtKJXaReWOmessogniJaEMOPFSJJalDBkIfozzW0B4Yi0BxJ69LZPkwMcZbUSJQE5L2R6-yrYO424oSvo7aEh2Wqd1nPpdvHET5yGlzJu8Kc-OZlHcf8mf9k4Nhqhj6oNjBNtYrq2RZ%20POONjXtt3GTMu-ZslzjnOQdACVpQ0Zky8dsLnbM1Omvx4OztDq6I7vaPqfux6uqx8uK8wwOCdnImBc78m04RyOFcIPvacHhnsb9nP2aIALs-9xOYLq4WW-T77nuHpYd-P3i8RVRk2gACXYP5wDp4TZnzqtWtJSXDQkzeeJtCoAAiT4VBdhoEAfjYBaxQF7CoGcC4Hskr4AgYiKBhAYFoDge7T2VBo4oNAGgjBqAqCfG%20Pgq8ICwHENIX0eefUiD-nxhQ6BVCSFFzocZReJCAQURDJcNgkAiS4hvswe%20j9n5dWZO3AWoxxiTH8GhK%20Bt6AwGYEoZkT5FDgB6itP4fpZETEgFMfAOUDHyKGAAMk2BhCar4YBTS4KATROlHgbEgrKLW%20jjTmPQpiHmI44CpkEbMSMKi1FewEV4uRRiFFKIAOL4EgL%20IJrpqKyjUpQvYak-RjWWJ8A4wUqEPHcH6Fwfpkj6kRMiVEGFMRc2FEAA"" rel=""nofollow noreferrer"">example</a> last row and related <a href=""https://stackoverflow.com/questions/69126879/typescript-deep-keyof-of-a-nested-object-with-related-type"">answer</a></p>&#xA;<pre class=""lang-js prettyprint-override""><code>type Structure = {&#xA;    user: {&#xA;        tuple: [42],&#xA;        emptyTuple: [],&#xA;        array: { age: number }[]|null&#xA;    }&#xA;}&#xA;&#xA;type Values&lt;T&gt; = T[keyof T]&#xA;&#xA;type IsNever&lt;T&gt; = [T] extends [never] ? true : false;&#xA;&#xA;type IsTuple&lt;T&gt; =&#xA;    (T extends Array&lt;any&gt; ?&#xA;        (T['length'] extends number&#xA;            ? (number extends T['length']&#xA;                ? false&#xA;                : true)&#xA;            : true)&#xA;        : false)&#xA;&#xA;type IsEmptyTuple&lt;T extends Array&lt;any&gt;&gt; = T['length'] extends 0 ? true : false&#xA;&#xA;type HandleDot&lt;&#xA;    Cache extends string,&#xA;    Prop extends string | number&#xA;    &gt; =&#xA;    Cache extends ''&#xA;    ? `${Prop}`&#xA;    : `${Cache}.${Prop}`&#xA;&#xA;type HandleObject&lt;Obj, Cache extends string&gt; = {&#xA;    [Prop in keyof Obj]:&#xA;    | HandleDot&lt;Cache, Prop &amp; string&gt;&#xA;    | Path&lt;Obj[Prop], HandleDot&lt;Cache, Prop &amp; string&gt;&gt;&#xA;}[keyof Obj]&#xA;&#xA;type Path&lt;Obj, Cache extends string = ''&gt; =&#xA;    (Obj extends PropertyKey&#xA;        ? Cache&#xA;        : (Obj extends Array&lt;unknown&gt;&#xA;            ? (IsTuple&lt;Obj&gt; extends true&#xA;                ? (IsEmptyTuple&lt;Obj&gt; extends true&#xA;                    ? Path&lt;PropertyKey, HandleDot&lt;Cache, -1&gt;&gt;&#xA;                    : HandleObject&lt;Obj, Cache&gt;)&#xA;                : Path&lt;Obj[number], HandleDot&lt;Cache, number&gt;&gt;)&#xA;            : HandleObject&lt;Obj, Cache&gt;)&#xA;    )&#xA;&#xA;type WithDot&lt;T extends string&gt; = T extends `${string}.${string}` ? T : never&#xA;&#xA;&#xA;type Acc = Record&lt;string, any&gt;&#xA;&#xA;type ReducerCallback&lt;Accumulator extends Acc, El extends string&gt; =&#xA;    El extends keyof Accumulator ? Accumulator[El] : El extends '-1' ? never : Accumulator&#xA;&#xA;type Reducer&lt;&#xA;    Keys extends string,&#xA;    Accumulator extends Acc = {}&#xA;    &gt; =&#xA;    Keys extends `${infer Prop}.${infer Rest}`&#xA;    ? Reducer&lt;Rest, ReducerCallback&lt;Accumulator, Prop&gt;&gt;&#xA;    : Keys extends `${infer Last}`&#xA;    ? ReducerCallback&lt;Accumulator, Last&gt;&#xA;    : never&#xA;&#xA;&#xA;type BlackMagic&lt;T&gt; = T &amp; {&#xA;    [Prop in WithDot&lt;Extract&lt;Path&lt;Structure&gt;, string&gt;&gt;]: Reducer&lt;Prop, T&gt;&#xA;}&#xA;&#xA;type Result = Reducer&lt;'user.array', Structure&gt;&#xA;</code></pre>&#xA;<p><a href=""https://www.typescriptlang.org/play?#code/C4TwDgpgBAysBOBXAxsR9oF4oG8CwAUFMVIgM4TwBcuhJ9UaYANhDQNoAsATALoA0dBsQgBbMKAAqiFmyjsBQ4QEN48ZSBo4oygOZyAdolEAjSlAC%20CgD5HmzJZcIXChUJCgA1Zc0QQyADySAHxQ2JLsANYQIAD2AGZQkryuBO7QAJJkAHIQAG6UQaHY7MlQEAAewBAGACZk8gb5lLxQAPyMSNA08T4UANyp6VBZ0rJFYY4AFJLlVTX1UACCahoBygYgoW2O9DPsAOSsBrrAABYHrZXVdQ1GppS7wu1QU-dm8HM3ixFHNacXFJEZ4gjq9ZgUJ4g4g0BB%20ACUUIYsK6iOBwh6fQgaLc4EyZAAouIpDJWEEvgsGit1CB1ptgsUkodjgDLhTblAAAwvOHdKDgyEEXEeAASG1qrAAIrFgAFHABhZTIM7Qa6UqBkBAASxOgnRUAACvBYmB2YtNfAdbooNYoO9HvrigqlSqzQ0DgdHB0AAYAEhwRpNFm9jhofpwiuVEAsADp-YGwMGhnioGK6qwAPImABWEFQASz2f4UEjrrVHItVsZ%20H17ATUB1UGicUShd4VEctrTEog0tlpYgxfrADINdqTsFO4blOcCzm68awAJU%20KpTKAgOh4uoKPKxPJwQrM2ElA28mPAaZ2c50WSy7VfMK%20PrdgPU79VNC27DYvKKAANIxEiHQDkiNCfjm37UmsiAGJEBixAA7gYB7QiQHRTKMpIQDeoTlosvJIqCrxZESEggGMZKFnhj4EV0RFoS8l6zgmf4gIBIDFt2a79vexYALQAIwMgxaE0NxECFnmsqFsWA7BGijHItOs6Fuw9rwMuEl9hufF2sYHwMopjHiaukk5tJN5yfeCmODiaQpgA6lq5w6bM%20ENHuuiMu5tENOGXmxv6gXei8sw0E0BTwKkwrQEsyDIGEUAAEp5rE8C1AEXnFhsWzntAqW1CglCKvYJhKpEATxcgxiIMwM7pVBCXFgSzDfl5770K137Hok1W1fVwCNR0-WiHVDXwOwrWtDQ3UeVABxCQcLyReYNCjeNQ3RUKDkeIVxXwHK%20ocQ083ZY4G2DY183VUlOAuI6kzHTEp1%20VA4Y6vE5gJkFOCfeYqWakm%20odPtyCFIDwDFmDJU%20Mw5XIJVl0TVuJoifqNAnd%20H0GF9nwADLKEDIYgylEBFeD8ClfDFVVQlA0o1AhOaqhJARc0235VAABC9WIwAsnoWrIBM4Q7rQtb1o2zmueuBJVOo%20bMdecBIKg6AQMExYdcE7ZkxThQJsWITOFzgN1cASUw4dBzkJQMaqDSBzFqrKBoBgwRAA"" rel=""nofollow noreferrer"">Playground</a></p>&#xA;",8495254,,8495254,2021-09-15 09:13:56,2021-09-15 09:13:56,"",,0,2,0,2021-09-13 15:09:18
69180017,1,,,3,274,"<p>I'm building a GraphQL API. I'm want to allow users to specify how records should be sorted, using multiple sorts.</p>&#xA;<h3>What should be possible</h3>&#xA;<p>If I expose the ability to sort <code>monsters</code> by <code>name</code>, <code>birthdate</code>, and <code>id</code>, users should be able to get the API to sort by any combination of those, including (in SQL terms):</p>&#xA;<ul>&#xA;<li><code>ORDER BY name ASC</code></li>&#xA;<li><code>ORDER BY name ASC, birthdate DESC, id ASC</code></li>&#xA;<li>... etc</li>&#xA;</ul>&#xA;<h3>What won't work</h3>&#xA;<p>A single map, like this:</p>&#xA;<p><code>sorts: [{name: DESC, id: ASC}]</code></p>&#xA;<p>...would not tell me the order in which the sorts should be applied (maps are unordered).</p>&#xA;<h3>What works OK, but isn't ideal</h3>&#xA;<p>Currently, I accept a list of maps, like this:</p>&#xA;<p><code>sorts: [{name: DESC}, {id: ASC}]</code></p>&#xA;<p>Each map represents an input object, which has fields like <code>name</code> and <code>id</code>, which are enums with possible values <code>ASC</code> and <code>DESC</code>. <strong>I expect only one field to be filled per input object</strong>. ~But I don't know a way to enforce that.~</p>&#xA;<p>This is awkward because:</p>&#xA;<ul>&#xA;<li>It would be easy for users to typo their sort parameters as a single map</li>&#xA;<li>I can't specify a default (like <code>ASC</code> for <code>id</code>) without having it added to every input object map</li>&#xA;</ul>&#xA;<p>Is there a more idiomatic way of accepting an ordered list of sort parameters?</p>&#xA;<hr />&#xA;<h3>Update</h3>&#xA;<p>I've now added a user-facing explanatory error when there is more than one key per map. With this change, I think this strategy is OK, but I'm still happy to hear of better ways in the future if they arise.</p>&#xA;",4376,,4376,2021-09-23 13:51:45,2021-09-23 13:51:45,GraphQL: idiomatic way to accept an ordered list of sort parameters?,<graphql>,1,4,0,2021-09-14 14:51:23
69186563,1,69191573,,0,1153,"<p>I had implemented Pagination in Nextjs.&#xA;but I think It is not good method.&#xA;I implemented Pagination with JS slice method..</p>&#xA;<p>Is it bad to implement Pagination like that?</p>&#xA;<p>I'm using <code>apollo client + apollo-server + mongodb(to save blog posts)+ graphql</code> stack</p>&#xA;<p>I knew that other people did not implement Pagination like this way..</p>&#xA;<p>let me know Is is okay to implement like this way and If not so , Plz tell me right way to implement Pagination.</p>&#xA;<p>/components/pagination.tsx</p>&#xA;<pre><code>import React from 'react';&#xA;&#xA;&#xA;&#xA;interface PaginationProps {&#xA;    postsPerPage: number&#xA;    totalPosts: number&#xA;    paginate: (n: number) =&gt; void&#xA;}&#xA;&#xA;const Pagination : React.FC&lt;any&gt; = ({ postsPerPage, totalPosts, paginate } : PaginationProps) =&gt; {&#xA;    const pageNumbers : number[] = [];&#xA;    for (let i = 1; i &lt;= Math.ceil(totalPosts/postsPerPage); i++) {&#xA;        pageNumbers.push(i);&#xA;    }&#xA;&#xA;    return (&#xA;        &lt;div&gt;&#xA;            &lt;nav&gt;&#xA;                &lt;ul className=&quot;bg-purple-400 float-left mt-4 mb-4 text-center rounded-md text-white p-px&quot;&gt;&#xA;                    {pageNumbers.map(number =&gt; (&#xA;                        &lt;li key={number} className=&quot;inline-block text-base font-semibold rounded-md p-1 w-6 hover:bg-purple-500&quot;&gt;&#xA;                            &lt;span onClick={() =&gt; paginate(number)} className=&quot;text-white&quot;&gt;&#xA;                                {number}&#xA;                            &lt;/span&gt;&#xA;                        &lt;/li&gt;&#xA;                    ))}&#xA;                &lt;/ul&gt;&#xA;            &lt;/nav&gt;&#xA;        &lt;/div&gt;&#xA;    )&#xA;}&#xA;&#xA;&#xA;export default Pagination&#xA;</code></pre>&#xA;<p>/pages/index.tsx</p>&#xA;<pre><code>import type { NextPage } from 'next'&#xA;import client from &quot;../apollo-client&quot;;&#xA;import Link from 'next/link'&#xA;import Head from &quot;next/head&quot;;&#xA;import {GET_ALL_POSTS} from &quot;../lib/query&quot;;&#xA;import {useState} from &quot;react&quot;;&#xA;import Pagination from &quot;../components/pagination&quot;;&#xA;&#xA;&#xA;export async function getStaticProps() {&#xA;    const { data } = await client.query({&#xA;        query: GET_ALL_POSTS&#xA;&#xA;    })&#xA;    return {&#xA;        props : {&#xA;            posts: data.posts&#xA;        },&#xA;        revalidate: 10&#xA;    }&#xA;}&#xA;&#xA;const Home: NextPage = ({posts} : any) =&gt; {&#xA;    // Pagination&#xA;    const [currentPage, setCurrentPage] = useState(1);&#xA;    const [postsPerPage] = useState(10)&#xA;    const lastIndex = currentPage * postsPerPage;&#xA;    const firstIndex = lastIndex - postsPerPage;&#xA;    &#xA;    const currentPosts = (tmp : object[]) =&gt; {&#xA;        let currentPosts : object[] = [];&#xA;        currentPosts = tmp.slice(firstIndex, lastIndex);&#xA;        return currentPosts;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;div&gt;&#xA;          &lt;Head&gt;&#xA;              &lt;title&gt;...&lt;/title&gt;&#xA;             &#xA;          &lt;/Head&gt;&#xA;          &lt;h1 className=&quot;text-gray-550 dark:text-white&quot;&gt;전체 글({posts.length})&lt;/h1&gt;&#xA;&#xA;              &lt;div className=&quot;flex items-center flex-col justify-center list-none&quot;&gt;&#xA;                  {currentPosts(posts).map((post : any, index : any) =&gt; (&#xA;                      &lt;Link href={`/posts/${post._id}`} key={index}&gt;&#xA;                          &lt;a className=&quot;group container mt-5 p-4 border-b-2&quot;&gt;&#xA;                              &lt;h3 className=&quot;text-black text-xl dark:text-white mt-4 group-hover:text-purple-500&quot;&gt;{post.title}&lt;/h3&gt;&#xA;                              &lt;p className=&quot;text-black dark:text-white mb-4&quot;&gt;{renderDate(post.createdAt)}&lt;/p&gt;&#xA;                              {renderTags(post.tags)}&#xA;                          &lt;/a&gt;&#xA;                      &lt;/Link&gt;&#xA;                  ))}&#xA;                  &lt;Pagination postsPerPage={postsPerPage} totalPosts={posts.length} paginate={setCurrentPage}/&gt;&#xA;              &lt;/div&gt;&#xA;      &lt;/div&gt;&#xA;&#xA;&#xA;  )&#xA;}&#xA;&#xA;export default Home&#xA;</code></pre>&#xA;",13896374,,,,2021-09-15 10:43:05,Pagination in NextJS with Apollo,<pagination><graphql><next.js><apollo-client><apollo-server>,1,0,0,2021-09-15 02:51:32
69195262,2,,69162122,2,,"<p>on the response of the first request you will have the following information available:</p>&#xA;<ul>&#xA;<li>total, with the total number of entries available</li>&#xA;<li>start, the start of the next page of results</li>&#xA;<li>limit, the limit used in the request</li>&#xA;</ul>&#xA;<p>So based on that information you should do the first request exactly as you have and the next one adding the &quot;start&quot; to it like below:</p>&#xA;<pre><code>getTestPlan(issueId:&quot;${test_plan.id}&quot;){&#xA;          issueId&#xA;          tests(limit: 100 start:100) {&#xA;              results {&#xA;                  issueId&#xA;                  jira(fields: [&quot;key&quot;])&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;</code></pre>&#xA;",15434268,,1839439,2021-09-15 14:47:31,2021-09-15 14:47:31,"",,0,0,0,2021-09-15 14:42:22
69195797,1,73502015,,0,1904,"<p>I'm testing several filters (they are on backend) for a dashboard consecutevely using spy function written in <code>before(() =&gt; {...})</code> block :</p>&#xA;<pre><code>function aliasQuery(&#xA;  request: CyHttpMessages.IncomingHttpRequest,&#xA;  operationName: string,&#xA;): void {&#xA;  const { body } = request;&#xA;  if (body.operationName === operationName) {&#xA;    request.alias = operationName;&#xA;  }&#xA;}&#xA;&#xA;export function spyOnGraphQL(operationName: string): void {&#xA;  cy.fixture('hosts').then(({ graphQLHostname }) =&gt; {&#xA;    cy.intercept(ApiMethods.Post, graphQLHostname, (request) =&gt; {&#xA;      aliasQuery(request, operationName);&#xA;    });&#xA;  });&#xA;}&#xA;</code></pre>&#xA;<p>Then inside <code>for</code> loop I use</p>&#xA;<pre><code>cy.wait(`@${operationName}`).should(({response}) =&gt; {...})&#xA;</code></pre>&#xA;<p>to check filters one by one.</p>&#xA;<p>There's trouble though, after using every filter and getting results I need to reset all filters by sending another graphql request, this request's query name matches the filter's query name, so when <code>cy.wait</code> is called again it catches <strong>reset filters</strong> request which breaks everything.It  goes like this:</p>&#xA;<ul>&#xA;<li>Applying filter 1 (graphql request 1)</li>&#xA;<li>Using <code>cy.wait</code>, it catches request 1</li>&#xA;<li>Resetting filters (graphql request 2)</li>&#xA;<li>Applying filter 2 (graphql request 3)</li>&#xA;<li>Using <code>cy.wait</code>, it catches request 2  --&gt; That's where the problems begin</li>&#xA;</ul>&#xA;<p>Is there a way to clean up requests caught by <code>cy.intercept</code> before applying a new filter? Or at least distinguish reset request from filter request using request payload for instance?</p>&#xA;",13403873,,,,2022-08-26 13:57:07,How to cleanup cypress cy.intercept requests queue?,<javascript><typescript><graphql><cypress><e2e-testing>,2,0,0,2021-09-15 15:19:00
69204318,1,69205588,,1,1242,"<p>I'm currently trying to filter entries with a field <code>references, many</code>.&#xA;In other words, the field takes multiple locations with each locations consisting of <code>city</code> among other fields.</p>&#xA;<p>For my query I want to get every entry that has a location with a specific city name set.</p>&#xA;<p>The following query filters an entry that takes only on reference for location, how would it look like when having many?</p>&#xA;<pre><code>export const NEWS_ARTICLES = gql`&#xA;    query GetNewsArticles($location: String) {&#xA;        entryCollection(&#xA;            where: {&#xA;                location: { city: $location }&#xA;            }&#xA;        ) {&#xA;            items {&#xA;                location&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>Pulling GraphQL's schema all I get is  <code>locationCollection_exists</code> - is this even possible?</p>&#xA;<p>I found the following article, which seems to do what I desire, but for the Filter API and not GraphQL: <a href=""https://www.contentful.com/developers/docs/concepts/relational-queries/"" rel=""nofollow noreferrer"">https://www.contentful.com/developers/docs/concepts/relational-queries/</a></p>&#xA;",14544753,,,,2021-09-16 09:12:10,Contentful GraphQL filter with relational queries and reference fields,<graphql><contentful>,1,0,0,2021-09-16 07:45:44
69205588,2,,69204318,4,,"<p>Contentful DevRel here. </p>&#xA;<p>Filtering by a linked collection entry is not supported right now. What you can do though it flip the query around.</p>&#xA;<pre><code>export const NEWS_ARTICLES = gql`&#xA;    query GetNewsArticles($location: String) {&#xA;        cityCollection(&#xA;             # your filter&#xA;        ) {&#xA;            items {&#xA;                linkedFrom {&#xA;                    # all the entries linking to this entry&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>You can find more information about this approach <a href=""https://www.contentful.com/developers/docs/references/graphql/#links-to-a-specific-item"" rel=""nofollow noreferrer"">in the docs</a> or <a href=""https://www.contentful.com/blog/2021/06/15/filter-entries-by-linked-references-in-graphql-api/"" rel=""nofollow noreferrer"">this blogpost</a>.</p>&#xA;",4253183,,,,2021-09-16 09:12:10,"",,0,6,0,2021-09-16 09:12:10
69223155,2,,69180017,1,,"<p>I think the short answer is &quot;no&quot;.</p>&#xA;<p>Long answer: You <em>can</em> introspect your types at startup, and generate the schema dynamically according to some made-up convention using custom scalars to represent sorting directive, for example:</p>&#xA;<pre><code>monsters(sortBy: [name___ASC, birthdate___DESC, id___ASC]) { name }&#xA;</code></pre>&#xA;<p>but this is also &quot;just a convention&quot;. The &quot;list of maps&quot; (&quot;array of objects&quot;) model that you listed a <em>non-ideal</em> might be the best option at this point:</p>&#xA;<pre><code># the query&#xA;monsters( &#xA;  sortBy: [&#xA;    {name: asc},&#xA;    {birthdate: desc_nulls_last},&#xA;    {id: asc}&#xA;]&#xA;) {&#xA;  name&#xA;}&#xA;</code></pre>&#xA;<p>BUT, irrespective of which way you choose, avoid the temptation of starting hacking these things in manually - your server code will become convoluted due to this <em>cross-cutting concern</em>, as will your schema.</p>&#xA;<p>Instead, I have seen some GraphQL-to-ORM-bridging libraries make use of <a href=""https://www.graphql-tools.com/docs/schema-directives"" rel=""nofollow noreferrer"">Directives</a> to control the runtime schema generation (<a href=""https://github.com/LastDragon-ru/lara-asp-graphql#sortby-directive"" rel=""nofollow noreferrer"">one example of this</a>). That should be <strong>much</strong> more viable than hand-carving stuff like this.</p>&#xA;",23023,,,,2021-09-17 12:06:10,"",,0,0,0,2021-09-17 12:06:10
69224219,1,,,0,68,"<p>I am using GraphQl with Apollo.</p>&#xA;<p>So let's say I have a query looking like this:</p>&#xA;<pre><code>holidays(startDate, endDate, newDate) {&#xA;    price&#xA;    food&#xA;  }&#xA;</code></pre>&#xA;<p>I am trying to serialize the response using the parameter passed to the query for caching purposes, hoping to get a response looking something like:</p>&#xA;<pre><code>&quot;data&quot;: {&#xA;    `${newDate}`: {&#xA;      &quot;price&quot;: 23,&#xA;      &quot;food&quot;:['bananas']&#xA;    }&#xA; }&#xA;</code></pre>&#xA;<p>or</p>&#xA;<pre><code>  &quot;data&quot;: {&#xA;    &quot;holidays&quot;: {&#xA;      `${newDate}`: {&#xA;         &quot;price&quot;: 23,&#xA;         &quot;food&quot;:['bananas']&#xA;       }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Any idea how to go about it? Basically, using the parameter to the query to serialize the response.</p>&#xA;",12323569,,635678,2021-09-24 11:34:24,2021-09-24 11:34:24,Use parameters for serializing graphql response,<graphql><apollo>,0,3,0,2021-09-17 13:25:38
69229958,2,,69221695,0,,"<p>You always include an integer for first or last. You can also do paging, so you ask for cursors. You provide a <strong>before</strong> or <strong>after</strong>, and those can actually be nulls if you are calling the first time.</p>&#xA;<p>Note that in Shopify GQL world there is no paging, so I am not sure what you refer to, as paging is simply passing in a before or after with a cursor. I guess if you mean hasNextPage?</p>&#xA;",210841,,,,2021-09-17 22:09:00,"",,0,2,0,2021-09-17 22:09:00
69245727,1,69250641,,-4,2991,"<p>I have React page that is fetching data via Graphql.&#xA;I'm using Strapi as backend and queries are already generated.&#xA;I´m querying my data in the frontend like this</p>&#xA;<pre><code>query GetData{&#xA;  datas(limit:3){&#xA;    id&#xA;    published_at&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In the documentation I found this example about how to sort my queries by some especific order</p>&#xA;<pre><code>GET /users?_sort=email:ASC,dateField:DESC&#xA;</code></pre>&#xA;<p>but is not really clear how to use it with the query structure.&#xA;I tried something like this and other variations</p>&#xA;<pre><code>query GetPodcasts{&#xA;  podcasts?_sort=published_at:DESC(limit:3){&#xA;    id&#xA;    published_at&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>but it didn't work.</p>&#xA;<p>I may need some help understanding this.</p>&#xA;",15142235,,15142235,2021-09-20 07:46:26,2022-07-28 18:28:14,How can I query my data by published date (newest first) using Apollo and Graphql?,<sorting><graphql><apollo-server>,3,0,0,2021-09-19 17:47:32
69245811,2,,69243996,1,,"<p>SOLVED :: <code>node_modules/typeorm-typedi-extensions/cjs/container-registrations.const.js</code></p>&#xA;<p>Line 10</p>&#xA;<p><strong>FROM</strong></p>&#xA;<p><code>typedi_1.Container.set({ id: typeorm_1.ConnectionManager, type: typeorm_1.ConnectionManager });</code></p>&#xA;<p><strong>TO</strong></p>&#xA;<p><code>typedi_1.Container.set({ id: typeorm_1.ConnectionManager, type: typeorm_1.ConnectionManager, global: true });</code></p>&#xA;",14155886,,,,2021-09-19 17:57:55,"",,0,0,0,2021-09-19 17:57:55
69246363,1,69266491,,1,207,"<p>Sorry, I tried but simply cannot get my JMESPath filtering works to filter Github GraphQL for private repos.</p>&#xA;<p>Here is the Github GraphQL result I want to filter:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;repositoryOwner&quot;: {&#xA;      &quot;repositories&quot;: {&#xA;        &quot;edges&quot;: [&#xA;          {&#xA;            &quot;node&quot;: {&#xA;              &quot;name&quot;: &quot;foo&quot;,&#xA;              &quot;isFork&quot;: false,&#xA;              &quot;isPrivate&quot;: true,&#xA;              &quot;createdAt&quot;: &quot;2019-04-25T20:31:07Z&quot;,&#xA;              &quot;updatedAt&quot;: &quot;2019-04-30T03:44:30Z&quot;,&#xA;              &quot;primaryLanguage&quot;: {&#xA;                &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;              }&#xA;            }&#xA;          },&#xA;          {&#xA;            &quot;node&quot;: {&#xA;              &quot;name&quot;: &quot;bar&quot;,&#xA;              &quot;isFork&quot;: false,&#xA;              &quot;isPrivate&quot;: true,&#xA;              &quot;createdAt&quot;: &quot;2019-04-25T01:26:31Z&quot;,&#xA;              &quot;updatedAt&quot;: &quot;2019-04-28T23:16:03Z&quot;,&#xA;              &quot;primaryLanguage&quot;: {&#xA;                &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;              }&#xA;            }&#xA;          },&#xA;          {&#xA;            &quot;node&quot;: {&#xA;              &quot;name&quot;: &quot;fur&quot;,&#xA;              &quot;isFork&quot;: false,&#xA;              &quot;isPrivate&quot;: false,&#xA;              &quot;createdAt&quot;: &quot;2019-04-25T02:46:28Z&quot;,&#xA;              &quot;updatedAt&quot;: &quot;2019-06-12T15:46:30Z&quot;,&#xA;              &quot;primaryLanguage&quot;: {&#xA;                &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;              }&#xA;            }&#xA;          },&#xA;          {&#xA;            &quot;node&quot;: {&#xA;              &quot;name&quot;: &quot;blog&quot;,&#xA;              &quot;isFork&quot;: false,&#xA;              &quot;isPrivate&quot;: false,&#xA;              &quot;createdAt&quot;: &quot;2013-03-17T13:37:44Z&quot;,&#xA;              &quot;updatedAt&quot;: &quot;2019-06-08T02:58:44Z&quot;,&#xA;              &quot;primaryLanguage&quot;: null&#xA;            }&#xA;          },&#xA;          {&#xA;            &quot;node&quot;: {&#xA;              &quot;name&quot;: &quot;blogs&quot;,&#xA;              &quot;isFork&quot;: false,&#xA;              &quot;isPrivate&quot;: true,&#xA;              &quot;createdAt&quot;: &quot;2015-12-06T03:52:14Z&quot;,&#xA;              &quot;updatedAt&quot;: &quot;2016-02-27T05:17:52Z&quot;,&#xA;              &quot;primaryLanguage&quot;: {&#xA;                &quot;primaryLanguage&quot;: &quot;CSS&quot;&#xA;              }&#xA;            }&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;} &#xA;</code></pre>&#xA;<p>I've tried</p>&#xA;<pre><code>data.repositoryOwner.repositories.edges.node[?isPrivate==`true`]&#xA;data.repositoryOwner.repositories.edges[].node[?isPrivate==`true`]&#xA;data.repositoryOwner.repositories.edges[].[node[?isPrivate==`true`]]&#xA;</code></pre>&#xA;<p>But none of them give me the list I want, as every single example from <a href=""https://jmespath.org/tutorial.html"" rel=""nofollow noreferrer"">https://jmespath.org/tutorial.html</a> is about filtering on array elements, whereas mine above is not.</p>&#xA;<p>Similar situation, for</p>&#xA;<p><code>curl -s https://api.github.com/repos/golang/go/events | jp &quot;[?type=='IssuesEvent'].payload.{Title: issue.title, URL: issue.url, User: issue.user.login, Event: action}&quot;</code></p>&#xA;<p>How to further filter above on <code>payload.action=='created'</code> (in place without using pipes)?</p>&#xA;<p><em><strong>UPDATE2:</strong></em></p>&#xA;<p>The answer is,</p>&#xA;<p><code>[?type=='IssueCommentEvent' &amp;&amp; payload.action=='created'].payload.{Title: issue.title, URL: issue.url, User: issue.user.login, Event: action}</code></p>&#xA;<p>and we'll get:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>[&#xA;  {&#xA;    &quot;Title&quot;: &quot;x/website: post https://go.dev/blog/tidy-web contains a broken link&quot;,&#xA;    &quot;URL&quot;: &quot;https://api.github.com/repos/golang/go/issues/47975&quot;,&#xA;    &quot;User&quot;: &quot;ilikegolang&quot;,&#xA;    &quot;Event&quot;: &quot;created&quot;&#xA;  },&#xA;  {&#xA;    &quot;Title&quot;: &quot;cmd/compile: pointer to concrete type doesn't satisfy generic type method set&quot;,&#xA;    &quot;URL&quot;: &quot;https://api.github.com/repos/golang/go/issues/48512&quot;,&#xA;    &quot;User&quot;: &quot;DmitriyMV&quot;,&#xA;    &quot;Event&quot;: &quot;created&quot;&#xA;  },&#xA;  {&#xA;    &quot;Title&quot;: &quot;How to solve this problem, run gomobile bind-target = android to report an error &quot;,&#xA;    &quot;URL&quot;: &quot;https://api.github.com/repos/golang/go/issues/48510&quot;,&#xA;    &quot;User&quot;: &quot;ytxyyt&quot;,&#xA;    &quot;Event&quot;: &quot;created&quot;&#xA;  },&#xA;. . .&#xA;]&#xA;</code></pre>&#xA;<p>Please help.</p>&#xA;<p><strong>UPDATE:</strong></p>&#xA;<p>I asked, <em>&quot;as every single example from <a href=""https://jmespath.org/tutorial.html"" rel=""nofollow noreferrer"">https://jmespath.org/tutorial.html</a> is about filtering on array elements, whereas mine above is not&quot;</em>, and got:</p>&#xA;<blockquote>&#xA;<p>In order to filter, you will need an array.</p>&#xA;</blockquote>&#xA;<p>However, that's not what I'm expecting, as using the first one as the example, I'm expecting the filtered to be a JSON array:</p>&#xA;<pre><code>[&#xA;      {&#xA;          &quot;name&quot;: &quot;foo&quot;,&#xA;          &quot;isFork&quot;: false,&#xA;          &quot;isPrivate&quot;: true,&#xA;          &quot;createdAt&quot;: &quot;2019-04-25T20:31:07Z&quot;,&#xA;          &quot;updatedAt&quot;: &quot;2019-04-30T03:44:30Z&quot;,&#xA;          &quot;primaryLanguage&quot;: {&#xA;            &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;      },&#xA;      {&#xA;          &quot;name&quot;: &quot;bar&quot;,&#xA;          &quot;isFork&quot;: false,&#xA;          &quot;isPrivate&quot;: true,&#xA;          &quot;createdAt&quot;: &quot;2019-04-25T01:26:31Z&quot;,&#xA;          &quot;updatedAt&quot;: &quot;2019-04-28T23:16:03Z&quot;,&#xA;          &quot;primaryLanguage&quot;: {&#xA;            &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;      },&#xA;      {&#xA;          &quot;name&quot;: &quot;blogs&quot;,&#xA;          &quot;isFork&quot;: false,&#xA;          &quot;isPrivate&quot;: true,&#xA;          &quot;createdAt&quot;: &quot;2015-12-06T03:52:14Z&quot;,&#xA;          &quot;updatedAt&quot;: &quot;2016-02-27T05:17:52Z&quot;,&#xA;          &quot;primaryLanguage&quot;: {&#xA;            &quot;primaryLanguage&quot;: &quot;CSS&quot;&#xA;      }&#xA;    ]&#xA;</code></pre>&#xA;<p>I can accept &quot;no way&quot; as the answer, but that seems to be a serious design flaw, as JsonPath can easily do that.</p>&#xA;",2125837,,2125837,2021-09-21 12:24:38,2021-09-21 12:24:38,JMESPath to filter on object instead of array,<json><github><graphql><filtering><jmespath>,1,2,0,2021-09-19 19:15:03
69255464,2,,69245727,1,,"<p>In a forum some nice people also gave me an answer.&#xA;When using graphql in frontend and want to sort or filter the data, just have to use &quot;&quot; to specify the sort or filter.&#xA;In my case it just had to be:</p>&#xA;<pre><code>query GetData{&#xA;  datas(limit:3, sort:&quot;published_at:desc&quot;){&#xA;    id&#xA;    published_at&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",15142235,,,,2021-09-20 13:42:18,"",,0,1,0,2021-09-20 13:42:18
69261934,1,,,-1,1640,"<p>I am trying to follow Ben Awad's lireddit tutorial.</p>&#xA;<p>At 6.49, he demonstrates how to assign a type to an argument where it's needed to override a default expected value.</p>&#xA;<p>The resolver has:</p>&#xA;<pre><code>@Resolver()&#xA;  export class PostResolver {&#xA;    @Query(() =&gt; [Post])&#xA;    async posts(&#xA;      @Arg(&quot;limit&quot;, () =&gt; Int) limit: number,&#xA;      @Arg(&quot;cursor&quot;, () =&gt; String, { nullable: true }) cursor: string | null&#xA;    ): Promise&lt;Post[]&gt; {&#xA;      const realLimit = Math.min(50, limit);&#xA;      &#xA;      const qb = getConnection()&#xA;        .getRepository(Post)&#xA;        .createQueryBuilder(&quot;p&quot;)&#xA;        .orderBy('&quot;createdAt&quot;', &quot;DESC&quot;)&#xA;        .take(realLimit)&#xA;        &#xA;        if (cursor) {&#xA;          qb.where('&quot;createdAt&quot; &lt; :cursor',  new Date ( parseInt(cursor)) )&#xA;        }&#xA;       return qb.getMany();&#xA;    }&#xA;</code></pre>&#xA;<p>When I try to generate types with this it fails. I get errors that say:</p>&#xA;<ol>&#xA;<li>GraphQLDocumentError: Unknown type &quot;Int&quot;. [Note: Int is imported from type-graphql]</li>&#xA;<li>Unknown argument &quot;cursor&quot; on field &quot;Query.posts&quot;.</li>&#xA;<li>Unknown argument &quot;limit&quot; on field &quot;Query.posts&quot;.</li>&#xA;</ol>&#xA;<p>Can anyone help with how to get the resolver in a format that will allow graphql to generate the types? I've seen some posts on here that describe using Floats instead of Ints for numbers, but I think that's going against the grain of what the docs say I should be able to achieve.</p>&#xA;<p>Ben shows how he inspects the graphql docs to find what the query expects for argument types. I can't get the same feedback from my docs.</p>&#xA;<p><a href=""https://i.stack.imgur.com/nJgx9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nJgx9.png"" alt=""enter image description here"" /></a></p>&#xA;<p>In <a href=""https://github.com/MichalLytek/type-graphql/blob/master/examples/resolvers-inheritance/person/person.resolver.ts"" rel=""nofollow noreferrer"">this example</a>, the Arg for limit is defined slightly differently, as follows:</p>&#xA;<p>@Arg(&quot;limit&quot;, type =&gt; Int) limit: number,</p>&#xA;<p>The word 'type' doesn't appear to be defined anywhere and this use case generates an error that says 'type is declared but not used'.</p>&#xA;<p>I'm stuck now because I deleted my node_modules and dist folders in the web side, and tried to re-run yarn. The node_modules got reinstalled, but the dist folder did not get recreated (I think that might happen if I can succeed in running: &quot;graphql-codegen --config codegen.yml&quot; (that's a guess).</p>&#xA;<p>So now I can't start the server to try to run that generator again.</p>&#xA;",2860931,,2860931,2021-09-21 21:26:31,2021-09-21 21:33:07,"GraphQLDocumentError: Unknown type ""Int""",<graphql><typegraphql>,1,4,0,2021-09-20 23:47:14
69265646,1,,,1,96,"<p>I explain my situation :)</p>&#xA;<p>A server/client is sending me this query :</p>&#xA;<pre><code>query MultiTenancy__GraphQLAPI__FindMatchesQuery($name: String!, $email: String!, $registrationNumbers: [RegistrationNumberAttributes!]!, $phoneNumber: String,&#xA; $birthDate: ISO8601Date) {&#xA;  collaboratorMatches(name: $name, email: $email, nationalRegistrationNumbers: $registrationNumbers, phoneNumber: $phoneNumber, birthDate: $birthDate) {&#xA;    canCreate&#xA;    matches {&#xA;      id&#xA;      name ...&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But, my graphql server doesn't recognize the query.</p>&#xA;<p><a href=""https://i.stack.imgur.com/azfey.png"" rel=""nofollow noreferrer"">my query error</a></p>&#xA;<p>On my side, when I send the same request in local with playground or Altair, to make it work, I have to change $registrationNumbers Type and $birthDate Type like this :</p>&#xA;<pre><code>query MultiTenancy__GraphQLAPI__FindMatchesQuery($name: String!, $email: String!, $registrationNumbers: [RegistrationNumberInput!]!, &#xA;  $phoneNumber: String,$birthDate: DateTime!) &#xA;</code></pre>&#xA;<p>Do you know how I can replace these input type names? Or if there is another solution? Or if I can create my own scalar type ISO8601Date to understand the query I receive?</p>&#xA;<p>Thx all :)</p>&#xA;",16897856,,16897856,2021-09-21 08:31:42,2021-09-21 08:31:42,Is it possible to modify the type name in a query graphql,<c#><.net><types><graphql><hotchocolate>,0,1,0,2021-09-21 08:23:03
69266491,2,,69246363,2,,"<p>Your filtering have to happen on the <code>edges</code> array, still, the property you evaluate can be nested deeper in the object.<br />&#xA;So you can perfectly have a condition like <code>node.isPrivate == `true`</code>, or even simpler, since <code>node.isPrivate</code> is already a boolean, a condition that would simply read <code>node.isPrivate</code>.</p>&#xA;<p>Given the query:</p>&#xA;<pre class=""lang-none prettyprint-override""><code>data.repositoryOwner.repositories.edges[?node.isPrivate].node&#xA;</code></pre>&#xA;<p>We end up with the expect JSON:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>[&#xA;  {&#xA;    &quot;name&quot;: &quot;foo&quot;,&#xA;    &quot;isFork&quot;: false,&#xA;    &quot;isPrivate&quot;: true,&#xA;    &quot;createdAt&quot;: &quot;2019-04-25T20:31:07Z&quot;,&#xA;    &quot;updatedAt&quot;: &quot;2019-04-30T03:44:30Z&quot;,&#xA;    &quot;primaryLanguage&quot;: {&#xA;      &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;    }&#xA;  },&#xA;  {&#xA;    &quot;name&quot;: &quot;bar&quot;,&#xA;    &quot;isFork&quot;: false,&#xA;    &quot;isPrivate&quot;: true,&#xA;    &quot;createdAt&quot;: &quot;2019-04-25T01:26:31Z&quot;,&#xA;    &quot;updatedAt&quot;: &quot;2019-04-28T23:16:03Z&quot;,&#xA;    &quot;primaryLanguage&quot;: {&#xA;      &quot;primaryLanguage&quot;: &quot;JavaScript&quot;&#xA;    }&#xA;  },&#xA;  {&#xA;    &quot;name&quot;: &quot;blogs&quot;,&#xA;    &quot;isFork&quot;: false,&#xA;    &quot;isPrivate&quot;: true,&#xA;    &quot;createdAt&quot;: &quot;2015-12-06T03:52:14Z&quot;,&#xA;    &quot;updatedAt&quot;: &quot;2016-02-27T05:17:52Z&quot;,&#xA;    &quot;primaryLanguage&quot;: {&#xA;      &quot;primaryLanguage&quot;: &quot;CSS&quot;&#xA;    }&#xA;  }&#xA;]&#xA;</code></pre>&#xA;",2123530,,,,2021-09-21 09:26:52,"",,0,0,0,2021-09-21 09:26:52
69266670,2,,69266164,0,,"<p>As suggested by Arvin Jason Cabrera in the comments, the problem was I was not setting the Content-Type to application/json. In my case, I simply had to add the following line</p>&#xA;<pre><code>$I-&gt;haveHttpHeader('Content-Type', 'application/json');&#xA;</code></pre>&#xA;<p>before sending the request.</p>&#xA;",8687605,,,,2021-09-21 09:39:04,"",,0,0,0,2021-09-21 09:39:04
69291411,2,,69259846,0,,"<p>In the end I removed the not-null requirements for the <code>Command</code> object.</p>&#xA;<p>As a result, the new <code>Command</code> object is the following:</p>&#xA;<pre><code>type Command {&#xA;    commandId: ID&#xA;    createdAt: AWSDateTime&#xA;    command: String&#xA;    arguments: [String]&#xA;    deviceId: ID&#xA;    status: Int&#xA;}&#xA;</code></pre>&#xA;<p>This is not to be taken as a solution but a workaround.</p>&#xA;<p>Any more decent solutions are welcome.</p>&#xA;",3331931,,,,2021-09-22 21:21:44,"",,0,0,0,2021-09-22 21:21:44
69298700,1,,,0,189,"<p>I tried all day long to find a way to get all assets which filename contains a given string via API. Unfortunately without any luck.&#xA;I use Pimcore 6.9.6 and the Data-Hub in Version 1.0.8.&#xA;It seems like the samples in the data hub docs are not really working. I can't use getAssets and getAssetListing seems to be pretty pointless, since it only returns an empty result.&#xA;I hope someone here can point me into the right direction. Thanks in advance for any help.</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  getAssetListing(filter: &quot;{\&quot;filename\&quot;: {\&quot;$like\&quot; :\&quot;%1%\&quot;}}&quot;) {&#xA;    edges {&#xA;      node {&#xA;        __typename&#xA;        ... on asset {&#xA;          fullpath&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This GraphQL query should do the trick, but unfortunately I can't get it working. What am I missing?</p>&#xA;",326016,,326016,2021-09-23 15:41:52,2021-09-23 15:55:07,Pimcore: Get all Assets which name contain a given string via API,<graphql><pimcore>,1,0,0,2021-09-23 10:58:18
69309044,1,,,1,237,"<p><strong>Problem statement:</strong></p>&#xA;<p>Customer has multiple policies. we need to filter the customer based on policy statuses.</p>&#xA;<p>Our graphql schema like this :</p>&#xA;<pre><code>customersByPolicyStatusCriteria(&#xA;    status: [String!]!&#xA;): CustomerSearchResult!&#xA;&#xA;type CustomerSearchResult {&#xA;    dataset: [Customer]&#xA;}&#xA;&#xA;type Customer {&#xA;    clientNumber: ID!&#xA;    name: CustomerName&#xA;    policies(status: [String]): [CustomerPolicy]&#xA;}&#xA;</code></pre>&#xA;<p>As in schema , In the parent we need to filter out based on policy status. Once receive the parent data and  again we need to filter out in the child resolver.  So it is kind of redundant operation to achieve the correct result :</p>&#xA;<p><strong>example</strong> : Cx-Customer Px- PolicyStatus  C1(P1,P2) C2(P3,P1,P2) C3(P3) =&gt; (filter based on (P1,P2) ) =&gt;  Expected : C1(P1,P2) C2(P1,P2)</p>&#xA;<p>Currently i am facing two sub problem in this case :</p>&#xA;<blockquote>&#xA;<p>case 1: If i remove the parent filter =&gt; I will receive all customers&#xA;(without policy detail) who are not contain required policy status. ( eg C1(P1,P2),C2(P1,P2),C3(null))</p>&#xA;<p>Case 2: if i remove the child filter =&gt; I ll receive all policies&#xA;which are not in the required status (eg C1(P1,P2), C2(P3,P1,P2))</p>&#xA;</blockquote>&#xA;<p>I am new to the graphql. need to explore following options :</p>&#xA;<ol>&#xA;<li>Modify the schema</li>&#xA;<li>Graphql Join</li>&#xA;<li>remove the parent node(Customer) as soon as some condition happens in the child resolver (PolicyResolver)</li>&#xA;</ol>&#xA;<p>Any suggestion solve this problem effectively ?</p>&#xA;",4947520,,,,2021-09-24 03:03:09,Graphql Parent data filtering by Child resolver,<java><graphql><graphql-java>,0,0,0,2021-09-24 03:03:09
69345763,2,,69316622,1,,"<p>You do mistake when mutate Vuex state. Correct format of mutation:</p>&#xA;<pre><code>export const state = () =&gt; ({&#xA;     blogs: [],&#xA;     search: null //if you want multiselect you must use array [] with ids&#xA;})&#xA;&#xA;export const getters = {&#xA;  filterBlog(state, payload) {&#xA;    return state.search ? state.blogs.filter(blog =&gt; +blog.category_id === +state.search) : state.blogs&#xA;  }&#xA;}&#xA;&#xA;export const mutations = {&#xA;  setBlogs(state, blogs) {&#xA;    state.blogs.push(blogs)&#xA;  },&#xA;  search(state, id) {&#xA;     state.search = id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Card component:</p>&#xA;<pre><code> &lt;div v-for='blog in blogs'&gt;&#xA;&#xA;  computed: {&#xA;    blogs() {&#xA;      return this.$store.getters.filterBlog&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Dropdown component:</p>&#xA;<pre><code>update(data) {&#xA;     const id = data.blogByCategoryId[0].category_id&#xA;&#xA;     this.$store.commit('search', id)&#xA; }&#xA;</code></pre>&#xA;<p>In Vuex, you change the current state directly, rather than returning a new one like in Redux Reducer.</p>&#xA;",9294837,,9294837,2021-09-27 12:20:02,2021-09-27 12:20:02,"",,0,4,0,2021-09-27 11:24:51
69355105,1,,,1,199,"<p>When using REST data, our interfaces in Typescript React would appear like the following:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>interface User {&#xA;  id: number;&#xA;  name: string;&#xA;  credentials: UserCredentials&#xA;}&#xA;&#xA;interface UserCredentials {&#xA;  id: number;&#xA;  value: string;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>However when we obtain the graphQL data from Relay, it appears as so:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>query UserQuery {&#xA;    users {&#xA;      edges {&#xA;        node {&#xA;          id&#xA;          name&#xA;          credentials {&#xA;            edges {&#xA;              node {&#xA;                id&#xA;                value&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>I'd prefer to work with objects using the interfaces we have created, not those supplied by Relay's types. Other than creating a new User object after query retrieval, is there a better way to reconcile the differences between what Relay gives us and what we are working with? Or is everyone mapping over &quot;edges&quot; to render their data?</p>&#xA;",16710249,,,,2021-09-28 02:27:03,Using Relay with Typescript interfaces,<reactjs><typescript><graphql><relay>,0,3,0,2021-09-28 02:27:03
69414841,2,,69414049,1,,"<p>The sorting you are trying to apply will only sort strings for their length, not by the value that contains (because GraphQL doesn't interpret it as dates or timestamps).</p>&#xA;<p>I think the easiest way is using that sorting in pure JavaScript.</p>&#xA;<p>Once you get the query working, the data will be stored inside <code>props.data</code>, so:</p>&#xA;<pre><code>function convertDateObj(hhmmss){&#xA;    let date = new Date();&#xA;&#xA;    let [hours, minutes, seconds] = hhmmss.split(':'); &#xA;&#xA;    date.setHours(+hours); // set the hours, using implicit type coercion&#xA;    date.setMinutes(minutes);&#xA;    date.setSeconds(seconds);&#xA;&#xA;    return date;&#xA;}&#xA;&#xA;const SomePage = ({ data }) =&gt; {&#xA;  let filteredData= data.someNode.edges.nodes.sort((a, b) =&gt; convertDateObj(a.duration) - convertDateObj(b.duration))&#xA;&#xA;console.log(filteredData);&#xA;&#xA;  return &lt;div&gt;Whatever&lt;/div&gt;&#xA;}&#xA;</code></pre>&#xA;<p><em>Note: <code>someNode</code> will stand for your node, which has not been provided in your question. Change it accordingly. By default, this approach will sort it ascending. Change it to <code>convertDateObj(b.duration) - convertDateObj(a.duration))</code> to make it descending</em></p>&#xA;<p>Other approaches with similar use-cases:</p>&#xA;<ul>&#xA;<li><a href=""https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss"">JavaScript seconds to time string with format hh:mm:ss</a></li>&#xA;<li><a href=""https://stackoverflow.com/questions/57589534/array-sort-by-time-hhmmss"">Array Sort by time hh:mm:ss</a></li>&#xA;</ul>&#xA;<hr />&#xA;<p>Thanks to <a href=""https://stackoverflow.com/users/51685/akx"">@AKX</a> for the suggestion. This would be more efficient and it will work either way:</p>&#xA;<pre><code>function convertDateObj(hhmmss){   &#xA;    let [hours, minutes, seconds] = hhmmss.split(':'); &#xA;&#xA;    return hours * 60 * 24 + minutes * 60 + seconds;&#xA;}&#xA;</code></pre>&#xA;",5585371,,5585371,2021-10-03 06:14:57,2021-10-03 06:14:57,"",,0,2,0,2021-10-02 07:20:18
69450026,2,,37969096,8,,"<p>Actually, it is possible with the <code>filter: { pet: {ne: null} }</code> filtering:</p>&#xA;<pre><code>query allPeople(filter: { people: { pet: {ne: null} } }) {&#xA;    people {&#xA;       pet&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",6355024,,,,2021-10-05 11:57:53,"",,0,2,0,2021-10-05 11:57:53
69480343,1,,,3,272,<p>I'm using reusable fragments in <code>.gql</code> files but the resulting query will declare the fragments multiple times when using codegen. A simplified example:</p>&#xA;<pre><code># ImagesInfos.gql&#xA;fragment ImageInfos {&#xA;  url&#xA;  alt&#xA;}&#xA;</code></pre>&#xA;<pre><code>#Post.gql&#xA;#import './ImageInfos.gql'&#xA;&#xA;fragment Post {&#xA;  title&#xA;  image {&#xA;    ... ImageInfos&#xA;  }&#xA;  user {&#xA;    ... UserInfos&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;<pre><code>#User.gql&#xA;#import './ImageInfos.gql'&#xA;&#xA;fragment User {&#xA;  name&#xA;  image {&#xA;    ... ImageInfos&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But this will result in multiple occurence of the declaration of ImageInfos fragment. How can I avoid this?</p>&#xA;,1133405,,1133405,2021-10-07 16:06:14,2021-10-07 16:06:14,Apollo codegen duplicating nested fragment imports,<graphql><apollo><apollo-client><graphql-codegen><graphql-tag>,0,0,0,2021-10-07 11:30:07
69486071,1,,,1,663,"<p>I am experimenting with GraphQL, AppSync and AWS Amplify for a new project. Let's say I have the following schema:</p>&#xA;<pre><code>type Test @model {&#xA;  id: ID!&#xA;  name: String&#xA;  text_pieces: [String]&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Now, I have created this through Amplify and it automatically generates queries like <code>ListTests</code> which accepts filtering. Filtering accepts lots of useful operators such as <code>beginsWith</code> or <code>contains</code>. Let's say I have these objects as data source:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>[&#xA;  {&#xA;    &quot;name&quot;: &quot;FirstTest&quot;,&#xA;    &quot;text_pieces&quot;: [&#xA;      &quot;FirstPiece&quot;,&#xA;      &quot;SecondPiece&quot;&#xA;    ]&#xA;  },&#xA;  {&#xA;    &quot;name&quot;: &quot;SecondTest&quot;,&#xA;    &quot;text_pieces&quot;: [&#xA;      &quot;ThirdPiece&quot;,&#xA;      &quot;FourthPiece&quot;&#xA;    ]&#xA;  }&#xA;]&#xA;</code></pre>&#xA;<p>So I can build a query like:</p>&#xA;<pre><code>query FirstTests {&#xA;  listTests(filter: {name: {beginsWith: &quot;First&quot;}}) {&#xA;    items {&#xA;      name&#xA;      text_pieces&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Which returns, as expected:</p>&#xA;<pre><code>  {&#xA;    &quot;name&quot;: &quot;FirstTest&quot;,&#xA;    &quot;text_pieces&quot;: [&#xA;      &quot;FirstPiece&quot;,&#xA;      &quot;SecondPiece&quot;&#xA;    ]&#xA;  }&#xA;</code></pre>&#xA;<p>and I can also make a query like</p>&#xA;<pre><code>query FirstPieces {&#xA;  listTests(filter: {text_pieces: {contains: &quot;FirstPiece&quot;}}) {&#xA;    items {&#xA;      name&#xA;      text_pieces&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>which again returns:</p>&#xA;<pre><code>  {&#xA;    &quot;name&quot;: &quot;FirstTest&quot;,&#xA;    &quot;text_pieces&quot;: [&#xA;      &quot;FirstPiece&quot;,&#xA;      &quot;SecondPiece&quot;&#xA;    ]&#xA;  }&#xA;</code></pre>&#xA;<p>However, I'd also like to be able to use an operator like <code>beginsWith</code> <strong>with every element in the text_pieces array</strong> and filter through that. So something like</p>&#xA;<pre><code>query FirstPieces {&#xA;  listTests(filter: {text_pieces: {items { beginsWith: &quot;First&quot;}}}) {&#xA;    items {&#xA;      name&#xA;      text_pieces&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>which would still return</p>&#xA;<pre><code>  {&#xA;    &quot;name&quot;: &quot;FirstTest&quot;,&#xA;    &quot;text_pieces&quot;: [&#xA;      &quot;FirstPiece&quot;,&#xA;      &quot;SecondPiece&quot;&#xA;    ]&#xA;  }&#xA;</code></pre>&#xA;<p>Is that supported by Amplify by concatenating the already available filters? Or probably something that would need its own resolver?</p>&#xA;",6420484,,,,2021-10-07 18:22:45,How to query with filters for every element in an array?,<graphql><aws-amplify><aws-appsync>,0,1,0,2021-10-07 18:22:45
69518791,2,,47267330,0,,"<p>This may just have to do with the overall structure of your project/ file Query vs Mutation import structure.&#xA;<a href=""https://github.com/graphql-python/graphene-django/issues/569#issuecomment-883172665"" rel=""nofollow noreferrer"">https://github.com/graphql-python/graphene-django/issues/569#issuecomment-883172665</a></p>&#xA;<p>Previously I had</p>&#xA;<pre><code>from orders.graphql.mutation.customer import CMutation&#xA;from orders.graphql.mutation.store import SMutation&#xA;from orders.graphql.query import CQuery, SQuery&#xA;</code></pre>&#xA;<p>in my schema.py. and Got the error</p>&#xA;<pre><code>ImportError: Could not import 'p.schema' for Graphene setting 'SCHEMA'. AttributeError: 'NoneType' object has no attribute '_meta'.&#xA;</code></pre>&#xA;<p>after which I changed it to</p>&#xA;<pre><code>from orders.graphql.query import CQuery, SQuery&#xA;from orders.graphql.mutation.customer import CMutation&#xA;from orders.graphql.mutation.store import SMutation&#xA;&#xA;</code></pre>&#xA;<p>and problem was solved.</p>&#xA;",8676374,,,,2021-10-10 20:33:46,"",,0,0,0,2021-10-10 20:33:46
69537103,2,,69512499,0,,"<p>Here is a working query string:</p>&#xA;<pre><code>  string query=&quot;{\n&quot;&#xA;  &quot;  \&quot;operationName\&quot;: \&quot;GetAxieDetail\&quot;,\n&quot;&#xA;  &quot;  \&quot;variables\&quot;:\n&quot;&#xA;  &quot;  {\n&quot;&#xA;  &quot;    \&quot;axieId\&quot;: \&quot;5144540\&quot;\n&quot;&#xA;  &quot;  },\n&quot;&#xA;  &quot;  \&quot;query\&quot;:\n&quot;&#xA;  &quot;  \&quot;query GetAxieDetail($axieId: ID!)&quot;&#xA;  &quot;  {\\n&quot;&#xA;  &quot;    axie(axieId: $axieId)\\n&quot;&#xA;  &quot;    {\\n&quot;&#xA;  &quot;      class\\n&quot;&#xA;  &quot;    }\\n&quot;&#xA;  &quot;  }\&quot;\n&quot;&#xA;  &quot;}\n&quot;;&#xA;</code></pre>&#xA;<p>The response is:</p>&#xA;<pre><code>{&quot;data&quot;:{&quot;axie&quot;:{&quot;class&quot;:&quot;Plant&quot;}}}&#xA;</code></pre>&#xA;<p>The server insists on no line feeds in the quoted query string, but allows <code>\n</code>; the <code>\n</code>, though, makes no difference, as the response is just one line.</p>&#xA;",11793309,,,,2021-10-12 08:12:13,"",,0,0,0,2021-10-12 08:12:13
69556863,1,,,0,589,"<p>I have a problem.&#xA;I want to create query to update some fileds on multiple model,&#xA;it should looks like this:</p>&#xA;<pre><code>mutation{&#xA;    updateInternalOrder( input: {&#xA;        state: {&#xA;            connect: 1&#xA;        }&#xA;        id_internal_orders: [1,2] &lt;= here&#xA;    }){&#xA;        id_internal_orders&#xA;        qty&#xA;        state {&#xA;            id_internal_orders_states,&#xA;            name&#xA;        }&#xA;    } &#xA;}&#xA;</code></pre>&#xA;<p>In this query i would like to assign(update) id_internal_orders_states(in states)&#xA;in id_internal_orders that has id: 1 and 2.</p>&#xA;<p><strong>How to do that?</strong></p>&#xA;<p>Schema(lighthouse-php) that works only if i provide a single id, not array:</p>&#xA;<pre><code>extend type Mutation {&#xA;    updateInternalOrder(input: UpdateInternalOrders! @spread): InternalOrders @update&#xA;}&#xA;&#xA;input UpdateInternalOrders {&#xA;    id_internal_orders: Int!&#xA;    state: InternalOrdersStatesHasOne&#xA;    qty: Int&#xA;    id_supplier: Int&#xA;}&#xA;&#xA;input InternalOrdersStatesHasOne {&#xA;    connect: Int&#xA;}&#xA;</code></pre>&#xA;",12546152,,,,2021-10-14 13:00:40,update model in graphQL giving fields to update and array of id's,<graphql><laravel-lighthouse><apollo-angular>,1,0,0,2021-10-13 13:56:19
69584778,2,,69584577,3,,"<p>Instead of passing <code>localeFlagId</code> directly, you need to pass it via <code>connect</code> like this:</p>&#xA;<pre><code>localeFlag: { connect: { id: 1 } }&#xA;</code></pre>&#xA;",8874351,,,,2021-10-15 12:31:23,"",,0,2,0,2021-10-15 12:31:23
69585456,1,,,3,172,"<p>I am trying to filter my results based on a one to many relationship and outlined in the documentation for <a href=""https://github.com/graphile-contrib/postgraphile-plugin-connection-filter/blob/master/docs/examples.md#relations-root-level-one-to-many"" rel=""nofollow noreferrer"">postgraphile-plugin-connection-filter</a> that outlines how to do it. I have enabled this but the options are not showing up.</p>&#xA;<p>I have reset the server to make sure the latest has been taken, but still not luck.</p>&#xA;<p>In short, the connection filter relations is not working at all. If it were, I would see the options<a href=""https://i.stack.imgur.com/E9q9b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/E9q9b.png"" alt=""enter image description here"" /></a></p>&#xA;<h2>Config</h2>&#xA;<pre><code>postgraphile(process.env.DATABASE_URL || dbUrl, 'public', {&#xA;  appendPlugins: [ConnectionFilterPlugin],&#xA;  connectionFilterRelations: true,&#xA;  watchPg: true,&#xA;  graphiql: true,&#xA;  connectionFilterAllowNullInput: true,&#xA;  connectionFilterAllowEmptyObjectInput: true,&#xA;  enhanceGraphiql: true,&#xA;  enableQueryBatching: true,&#xA;})&#xA;</code></pre>&#xA;<p>##Query</p>&#xA;<pre><code>query ($firstname: String) {&#xA;  allArtists(filter: {firstname: {likeInsensitive: $firstname}, awardsByArtistIdExists: true }) {&#xA;    edges {&#xA;      node {&#xA;        artistId&#xA;        firstname&#xA;        nationality&#xA;</code></pre>&#xA;<h2>error</h2>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;Field \&quot;awardsByArtistIdExists\&quot; is not defined by type \&quot;ArtistFilter\&quot;.&quot;,&#xA;      &quot;locations&quot;: [&#xA;        {&#xA;          &quot;line&quot;: 2,&#xA;          &quot;column&quot;: 65&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>Here is the filter&#xA;<a href=""https://i.stack.imgur.com/dxgg3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dxgg3.png"" alt=""enter image description here"" /></a></p>&#xA;",240363,,,,2022-10-13 14:01:13,connectionFilterRelations not working with postgraphile-plugin-connection-filter,<javascript><graphql><postgraphile>,1,0,0,2021-10-15 13:26:29
69589078,2,,69588157,0,,"<p>I've found the answer finally, the required object is stored in <code>$ctx.source</code>. All I had to do is to change the <code>user</code> resolver to this (Provided the result object have PK inside it):</p>&#xA;<pre><code>{&#xA;    &quot;version&quot; : &quot;2017-02-28&quot;,&#xA;    &quot;operation&quot; : &quot;Query&quot;,&#xA;    &quot;query&quot; : {&#xA;        &quot;expression&quot; : &quot;PK = :pk AND SK = :sk&quot;,&#xA;        &#xA;        &quot;expressionValues&quot; : {&#xA;            &quot;:pk&quot;: $util.dynamodb.toDynamoDBJson($ctx.source.PK),&#xA;            &quot;:sk&quot;: $util.dynamodb.toDynamoDBJson(&quot;profile&quot;)&#xA;        }&#xA;    },&#xA;    &quot;select&quot; : &quot;ALL_ATTRIBUTES&quot;&#xA;}&#xA;</code></pre>&#xA;<p>The <code>$context.source</code> references the parent object of the current field that’s being resolved. In this example, <code>$ctx.source.PK</code> refers to the individual Post object, which is then used for the query expression. ($context and $ctx are same). It works exactly like the <code>parent</code> argument in the <code>apollo-server</code> framework.</p>&#xA;",9795654,,,,2021-10-15 18:23:27,"",,0,0,0,2021-10-15 18:23:27
69613854,2,,69595398,1,,<p>Fixed the issue. The error had to do with the data type of the date. The data type I passed initially to the date object using typeorm was just Date so it was reading the type as an Oct and not a string. So I changed the date type to new Date() and it solved the issue.</p>&#xA;<p>Instead of:</p>&#xA;<p>createdAt: Date</p>&#xA;<p>It should be:</p>&#xA;<p>createdAt: new Date()</p>&#xA;,9200287,,9200287,2022-07-13 09:45:03,2022-07-13 09:45:03,"",,0,1,0,2021-10-18 09:37:58
69633124,2,,69091564,0,,"<p>You may take a look <a href=""https://www.nrecosite.com/graphql/"" rel=""nofollow noreferrer"">NReco.GraphQL</a> (which is based on GraphQL.Net but has an additional features, like aggregation, filter, ect.). You can compose in code schema, query (or query object) and call it just in-code.</p>&#xA;",4679729,,,,2021-10-19 14:53:30,"",,0,0,0,2021-10-19 14:53:30
69645754,1,69658680,,1,248,"<p>The main question is in the topic basically but I'd like to describe the problem in a bit details. <br /><br />I'm working on the Apollo graphql pagination which is cursor-based and in my Cache, I should define the <em>merge</em> function to combine the existing and incoming data. Every data object has the common graphql pagination structure:</p>&#xA;<pre><code>{&#xA;        &quot;totalCount&quot;: ...,&#xA;        &quot;pageInfo&quot;: {&#xA;            &quot;startCursor&quot;: &quot;...&quot;,&#xA;            &quot;endCursor&quot;: &quot;...&quot;,&#xA;            &quot;hasNextPage&quot;: true,&#xA;            &quot;__typename&quot;: &quot;...&quot;&#xA;        },&#xA;        &quot;edges&quot;: [...],&#xA;}&#xA;</code></pre>&#xA;<p>I need to override the existing data like: <em>pageInfo</em>, <em>totalCount</em>, etc. by the same properties from the <em>incoming</em> but in the case of <em>edges</em> I need to carefully merge the existing and incoming items. To make it more elegant and to avoid duplicates I'd like to iterate over the incoming items and check if every item is unique. eg. if the <em>existing</em> edges don't contain items that exist in the <em>incoming</em>.</p>&#xA;<p>So I'm wondering if I can use the graphql pagination cursor that exists in every node as a comparison argument. I know that I can use the Item's ID but if it's possible to use the Cursor value as well, I could avoid to using the <em>deeper</em> property level of the edge's item</p>&#xA;<p>Here is an example of the data structure:</p>&#xA;<pre><code>{&#xA;    &quot;listArticles&quot;: {&#xA;        &quot;totalCount&quot;: 22,&#xA;        &quot;pageInfo&quot;: {&#xA;            &quot;startCursor&quot;: &quot;NjE2N2ZlMmI4N2NiNDczMGY0N2U5MGQ5&quot;,&#xA;            &quot;endCursor&quot;: &quot;NjE2ZDkzYTg0NDA5MWYyN2E0MmFkMGM5&quot;,&#xA;            &quot;hasNextPage&quot;: true,&#xA;            &quot;__typename&quot;: &quot;PageInfo&quot;&#xA;        },&#xA;        &quot;edges&quot;: [&#xA;            {&#xA;                &quot;cursor&quot;: &quot;NjE2N2ZlMmI4N2NiNDczMGY0N2U5MGQ5&quot;,&#xA;                &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;6167fe2b87cb4730f47e90d9&quot;,&#xA;                    &quot;commentsThreadId&quot;: &quot;6167fe2b87cb4730f47e90d8&quot;,&#xA;                    &quot;__typename&quot;: &quot;Article&quot;&#xA;                },&#xA;                &quot;__typename&quot;: &quot;ArticleEdge&quot;&#xA;            },&#xA;            {&#xA;                &quot;cursor&quot;: &quot;NjE2ZDkzYTg0NDA5MWYyN2E0MmFkMGM5&quot;,&#xA;                &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;616d93a844091f27a42ad0c9&quot;,&#xA;                    &quot;commentsThreadId&quot;: &quot;616d93a844091f27a42ad0c8&quot;,&#xA;                    &quot;__typename&quot;: &quot;Article&quot;&#xA;                },&#xA;                &quot;__typename&quot;: &quot;ArticleEdge&quot;&#xA;            },&#xA;        ],&#xA;        &quot;__typename&quot;: &quot;ArticleConnection&quot;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Thanks for any help!</p>&#xA;",5232122,,,,2021-10-21 08:43:51,Can I use the graphql pagination cursor as an unique indentifier?,<javascript><pagination><graphql><apollo-client>,1,0,0,2021-10-20 12:11:08
69650772,1,69653902,,1,935,"<p>I want to filter my data, base on a method on my model:</p>&#xA;<p>method in my model:</p>&#xA;<pre class=""lang-php prettyprint-override""><code>// . . .&#xA;    public function isBatched(): bool&#xA;    {&#xA;        return $this-&gt;rows()-&gt;count() &gt; 1;&#xA;    }&#xA;&#xA;</code></pre>&#xA;<p>and my qraphql:</p>&#xA;<pre><code>type Invoice&#xA;{&#xA;    globalId: ID! @globalId @method(name: &quot;getKey&quot;)&#xA;    localId: Int! @method(name: &quot;getKey&quot;)&#xA;    pdfUrl: String @method(name: &quot;getPdfUrl&quot;)&#xA;    number: String&#xA;    poNumber: String @rename(attribute: &quot;po_number&quot;)&#xA;    deposit: Deposit @hasOne&#xA;    rows: [InvoiceRow!] @hasMany&#xA;    bills: [Bill!] @belongsToMany(type: &quot;paginator&quot;, relation: &quot;bills&quot;)&#xA;    isBatched: Boolean! @method(name: &quot;isBatched&quot;)&#xA;    isCompleted: Boolean @method(name: &quot;isPaid&quot;)&#xA;    dueDate: DateTime @rename(attribute: &quot;due_date&quot;)&#xA;    total: Money @method(name: &quot;totalAmountMoney&quot;)&#xA;}&#xA;&#xA;extend type Query {&#xA;    invoices: Invoice! @paginate @cache&#xA;    invoicesb(isBatched: Boolean @eq): [Invoice]! @paginate&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>but it does not work, it says <code>isBatched</code> filed is not exist, any idea?</p>&#xA;",2043248,,,,2021-10-21 06:20:26,Laravel lighthouse Graphql filter by method on model,<laravel><graphql><laravel-lighthouse>,2,0,0,2021-10-20 17:45:55
69656230,1,,,0,101,"<p>I was trying to mutation in graphQL by using Hasura's API console. I checked in Hasura it's properly worked there. But when I was trying to add in react code it gives an error.</p>&#xA;<p><strong>Code:</strong></p>&#xA;<pre><code>Axios.post(&quot;http://domain.herokuapp.com/v1/graphql&quot;, {&#xA;      query: `&#xA;mutation createCompanyBusiness {&#xA; &#xA;        insert_appcompany(objects: { &#xA;          fullname: &quot;Company Full Name 344&quot;,  &#xA;          contact: &quot;{{\&quot;Tel\&quot;, 01}, {Email, email@test.com}}&quot;,  &#xA;          billing_floor_flat_house_no: &quot;floor 14, house 6&quot;,  &#xA;          last_update_by: 112,  &#xA;          create_by: 112, &#xA;      &#xA;          privacy: true,  &#xA;          app_property: { &#xA;            data: { &#xA;              property_name: &quot;Niketon House&quot;,  &#xA;              building_number: &quot;22C&quot;,  &#xA;              last_update_by: 122,  &#xA;              create_by: 122,  &#xA;              app_street: { &#xA;                data: { &#xA;                  street_name:  &#xA;                  &quot;Long Street&quot;,  &#xA;                  district_suburb_county_city: &quot;New City&quot;,  &#xA;                  town_city: &quot;New Town&quot;,  &#xA;                  country: &quot;Singapore&quot;,  &#xA;                  last_update_by: 122,  &#xA;                  create_by: 122 &#xA;                } &#xA;              } &#xA;            } &#xA;          } &#xA;        }) { &#xA;          returning { &#xA;            appcompany_id &#xA;          } &#xA;        } &#xA;      } &#xA;      &#xA;      &#xA;      `,&#xA;    })&#xA;      .then((result) =&gt; {&#xA;        console.log(result);&#xA;      })&#xA;      .catch((err) =&gt; {&#xA;        console.log(err);&#xA;      });&#xA;</code></pre>&#xA;<p><strong>Output Log:</strong></p>&#xA;<p><a href=""https://i.stack.imgur.com/ifGcw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ifGcw.png"" alt=""Output Log Screenshot"" /></a></p>&#xA;",17207820,,8192914,2021-10-23 16:12:29,2021-10-23 16:12:29,Mutaion in grapgql by Axios React,<reactjs><graphql><hasura>,0,2,0,2021-10-21 05:18:41
69658680,2,,69645754,2,,"<p>I wouldn't recommend using cursors as unique identifiers, although they may end up uniquely identifying nodes. They should just be used for what they are: opaque strings used to locate nodes within pages.</p>&#xA;<p>As far as I know, depending on their implementation, two nodes cannot share one same cursor, but two cursors could be used for one same node.</p>&#xA;<p>I would just go &quot;one level deeper&quot; and use the actual item ids.</p>&#xA;",1225328,,,,2021-10-21 08:43:51,"",,0,1,0,2021-10-21 08:43:51
69663262,1,,,0,539,"<p>We currently have a setup where customers can sort products on price, title, created, manual, etc. Every time there's a query like</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>`query ($handle: String!, $numProducts: Int!, $sortKey: ProductCollectionSortKeys!, $reverse: Boolean!) {&#xA;  collectionByHandle(handle: $handle) {&#xA;    id&#xA;    handle&#xA;    description&#xA;    descriptionHtml&#xA;    title&#xA;    image {&#xA;      id&#xA;      originalSrc&#xA;      altText&#xA;    }&#xA;    products(first: $numProducts, sortKey: $sortKey, reverse: $reverse) {&#xA;      pageInfo {&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;      }&#xA;      edges {...&#xA;`</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>There are 8 queries in total, one for each sortKey. The idea is to move the sorting logic to js, making a single query instead of 8.</p>&#xA;<p>The problem is, I can only do 7 types of sorting in javascript (PRICE, TITLE, CREATED (ascending and descending)), and either MANUAL or BEST_SELLING.&#xA;To get both MANUAL and BEST_SELLING, I currently will have 2 queries, which is already an improvent!&#xA;Is there a way to combine them into a single query, a bit like mySql, creating a 'virtual' field e.g. manual_sort_position: 5 to add to a product?</p>&#xA;",9556899,,9556899,2021-10-21 14:28:47,2021-10-21 14:28:47,GraphQL Shopify query and sorting,<graphql><shopify>,0,3,0,2021-10-21 13:53:29
69668128,1,,,1,34,"<p>I have this fragment</p>&#xA;<pre><code>fragment fragBooking on Booking{&#xA;    at&#xA;    on&#xA;    on_date&#xA;    price&#xA;    passengers&#xA;}&#xA;</code></pre>&#xA;<p>and as you can see there's a parameter called &quot;on&quot; which is a date, but Graphql gives me an Error</p>&#xA;<pre><code>Unsupported token `on`&#xA;</code></pre>&#xA;<p>is it possible to use it?</p>&#xA;",4252667,,,,2021-10-21 20:01:45,"Is it possiple to use ""on"" keyword in Graphql as a parameter name, and if not is there away to do it?",<android><graphql><apollo>,0,0,0,2021-10-21 20:01:45
69671575,2,,69670533,1,,"<p>It should take the filter order as it is. Are you sure that it <strong>always</strong> has the same order? Does it always contain the same information in the same order? Do they have any rules that you can use to sort them?</p>&#xA;<p>In your case, I'd try:</p>&#xA;<pre><code>  createPage({&#xA;    path: `/collections/${handle}`,&#xA;    component: path.resolve('./src/templates/collection.js'),&#xA;    context: {&#xA;      handle,&#xA;      handles.sort() // add an specific rule if any&#xA;    }&#xA;  });&#xA;</code></pre>&#xA;<p>Moreover, you can try sorting the output via GraphQL <a href=""https://www.gatsbyjs.com/docs/graphql-reference/#sort"" rel=""nofollow noreferrer""><code>sort</code></a>:</p>&#xA;<pre><code>// templates/collection.js&#xA;export const query = graphql`&#xA;  query ProductInCollection($handles: [String], $handle: String) {&#xA;    allContentfulProduct(filter: { handle: { in: $handles }, availableForSale: { eq: true } }, sort: { fields: [handle, $handles], order: ASC }) {&#xA;      edges {&#xA;        node {&#xA;          description&#xA;          handle&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;    ...&#xA;</code></pre>&#xA;<p>Despite adding the sorting in the GraphQL or JavaScript logic, I'd ensure that it has always the exact order. Additionally, if you can access the source of that array, you can try adding an <code>order</code> field to each array element.</p>&#xA;",5585371,,,,2021-10-22 04:52:03,"",,0,8,0,2021-10-22 04:52:03
69707502,1,,,1,151,"<p>I am using <a href=""https://github.com/99designs/gqlgen"" rel=""nofollow noreferrer"">gqlgen</a> to generate boilerplate for graphql queries. How do I generate a resolver for the inner nodes?</p>&#xA;<p>For instance, I have a Region schema with [school] array but I also need a filter for the school array. School schema contains classes array which again can be filtered by id. The below query would return all the schools and classes. But as mentioned I also need ability to filter the Schools and Classes in the same query.</p>&#xA;<pre><code>type Region {&#xA;  id: ID!&#xA;  name: String!&#xA;  schools: [School!]!&#xA;}  &#xA;type School {&#xA;   id: ID!&#xA;   name: String!&#xA;   classes: [class!]!&#xA;}  &#xA;&#xA;type Query {&#xA;  regions(id : ID!): [Region!]!&#xA;}&#xA;</code></pre>&#xA;",4380048,,13860,2021-10-25 11:56:36,2021-10-25 11:56:36,How to filter the inner Nodes with gqlgen,<go><graphql><gqlgen>,0,0,0,2021-10-25 11:45:19
69714074,1,,,0,649,"<p>I have the below query to be consumed using graphql dgs client. I have implemented the first query using com.netflix.graphql.dgs.client.codegen.GraphQLQueryRequest in which I have created a root object given below and a tocResourceGraphQLQuery to be passed in my GraphQLQueryRequest graphQLQueryRequest = new GraphQLQueryRequest(tocResourceGraphQLQuery,&#xA;root);&#xA;But I don't know how to implement the query inside the query using dgs client.</p>&#xA;<pre><code>TocResourceProjectionRoot root = new TocResourceProjectionRoot().data().title().id()&#xA;        .identifier().getParent().items().data().id().identifier().getParent().type().displayId()&#xA;        .orderNo().title().availabilityTypes().getRoot();&#xA;&#xA;    query {&#xA;tocResource(&#xA;    context: {&#xA;        identifier:&quot;urn:sbnet:book:tca1e_sbtest-1&quot;, type:&quot;book&quot; }, &#xA;    identifier:{&#xA;        identifier:&quot;urn:sbnet:book:tca1e_sbtest-1:chapter:2:section:1&quot;,&#xA;         type:&quot;section&quot; })&#xA;         {&#xA;        data {&#xA;            title&#xA;            id {&#xA;                identifier&#xA;                }&#xA;    items(**query**: {&#xA;        filter: {isAccessible: true,availabilityTypes: [StudyPlan]},&#xA;        paginationAndSorting: {offset: 0, limit:10}&#xA;    }) {           &#xA;        data {&#xA;            title&#xA;            id {&#xA;                 identifier&#xA;             }&#xA;        type&#xA;        displayId&#xA;        orderNo&#xA;        availabilityTypes&#xA;            }&#xA;    }&#xA;}&#xA;}&#xA;</code></pre>&#xA;<p>}</p>&#xA;",3306895,,3306895,2021-10-26 11:54:41,2021-10-26 11:54:41,Java GraphQL dgs client,<java><spring><graphql><graphql-java><netflix-dgs>,0,2,0,2021-10-25 20:01:20
69725857,2,,64158489,0,,"<p>All you need to do is update your FrameType class as follows:</p>&#xA;<pre><code>class FrameType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = models.Frame&#xA;        filterset_fields = {&#xA;            'time_offset': ['range']&#xA;        }&#xA;        interfaces = (relay.Node,)&#xA;</code></pre>&#xA;<p>You do not need a custom filterset for this.&#xA;Then you can query as follows:</p>&#xA;<pre><code>query Frame {&#xA;    frames(first: 20, timeOffset_Range: [&quot;4350&quot;, &quot;5000&quot;]) {&#xA;    edges {&#xA;      node {&#xA;        timeOffset&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",15355130,,,,2021-10-26 15:24:22,"",,0,0,0,2021-10-26 15:24:22
69731797,1,69735370,,0,44,"<p>I have a service who provided me api to use and they are using GraphQL.</p>&#xA;<p>Everything else seems working fine apart from this section.</p>&#xA;<p>I'm using the following query to create an order and it's working fine apart from when I add notifications in there</p>&#xA;<p>I'm getting this error&#xA;Argument 'notifications' on InputObject 'OrderCreateMutationInput' has an invalid value ({type: {OrderCreationNotificationEnum: {email: true}}}). Expected type '[OrderCreationNotificationEnum!]'</p>&#xA;<pre><code>mutation{&#xA;orderCreate(input: {&#xA;order: {&#xA;  externalIds:[&#xA;    {key: &quot;VRPOrderId&quot;, value: &quot;abc131&quot;}&#xA;  ]&#xA;  firstName: &quot;John&quot;&#xA;  surname: &quot;Doe&quot;&#xA;  phone: &quot;0405123456&quot;&#xA;  billingFirstName: &quot;John&quot;&#xA;  billingSurname: &quot;Doe&quot;&#xA;  &#xA;  billingEmailAddress: &quot;john@email.com&quot;&#xA;  address: {&#xA;    address: &quot;1 Bourke Street&quot;&#xA;      city: &quot;Melbourne&quot;&#xA;      country: {&#xA;        code: &quot;AU&quot;&#xA;      }&#xA;      postcode: &quot;3000&quot;&#xA;      state: {&#xA;        short: &quot;VIC&quot;&#xA;      }&#xA;  }&#xA;  billingAddress:{&#xA;    address: &quot;1 Bourke Street&quot;&#xA;      city: &quot;Melbourne&quot;&#xA;      country: {&#xA;        code: &quot;AU&quot;&#xA;      }&#xA;      postcode: &quot;3000&quot;&#xA;      state: {&#xA;        short: &quot;VIC&quot;&#xA;      }&#xA;  }&#xA;  termsAndConditionsAccepted: true&#xA;  &#xA;}&#xA;lineItems: [&#xA;  {             &#xA;    variantId: &quot;VmFyaWFudC00NzMz&quot;&#xA;    quantity: 1&#xA;    totalCents: 22500&#xA;    postageCents: 1000&#xA;    &#xA;  },&#xA;  {             &#xA;    variantId: &quot;VmFyaWFudC00NzYy&quot;&#xA;    quantity: 1&#xA;    totalCents: 22500&#xA;    postageCents: 500&#xA;    &#xA;  }&#xA;]&#xA;notifications:&#xA;{&#xA;    type: {&#xA;        OrderCreationNotificationEnum: {&#xA;            email: true&#xA;        }&#xA;    } &#xA;}&#xA;&#xA;})&#xA;{&#xA;order{&#xA;  id&#xA;  invoices{&#xA;    edges{&#xA;      node{&#xA;        id&#xA;        lineItems{&#xA;          id&#xA;          quantity&#xA;        } &#xA;      }  &#xA;    }&#xA;  }&#xA;}&#xA; status&#xA;}&#xA;}&#xA;</code></pre>&#xA;<p>I am struggling to get the notification working. I'm adding link for the instructions too. Please help.</p>&#xA;<p><a href=""https://api.marketplacer.com/graphql/ordercreationnotificationenum.doc.html"" rel=""nofollow noreferrer"">link to api document</a></p>&#xA;",3451402,,3451402,2021-10-27 01:49:37,2021-10-27 08:36:42,What is this mean in GrqphQL Expected type '[OrderCreationNotificationEnum!],<api><graphql>,1,1,0,2021-10-27 01:43:58
69739193,1,,,0,421,"<p>I am using Apollo on my Nuxt project to query the server, which is servered on Orchard-Core.&#xA;Since now I had only simple queries and it was very simple to figure out how to use them, but now I am trying to filter some informations in the queries, with bad results.</p>&#xA;<p><strong>Code</strong></p>&#xA;<p>Here is some code which I am using:</p>&#xA;<pre class=""lang-html prettyprint-override""><code>&lt;template&gt;&#xA;  &lt;div&gt;&#xA;    &lt;button @click=&quot;search&quot;&gt;search &quot;Bare Van-gogh&quot;&lt;/button&gt;&#xA;  &lt;/div&gt;&#xA;&lt;/template&gt;&#xA;</code></pre>&#xA;<pre class=""lang-js prettyprint-override""><code>&lt;script&gt;&#xA;import gql from 'graphql-tag'&#xA;&#xA;const FILTERED_PRODUCTS_QUERY = gql`&#xA;  query FILTERED_PRODUCTS ($description: String!) {&#xA;    product (filter: { description: $description }) {&#xA;      contentItemId&#xA;      displayText&#xA;      description&#xA;      badge&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;export default {&#xA;  data () {&#xA;    return {&#xA;      descriptionText: 'Van-gogh',&#xA;      searchResults: null&#xA;    }&#xA;  },&#xA;  methods: {&#xA;    async search() {&#xA;      const res = await this.$apollo.query({&#xA;        query: FILTERED_PRODUCT_QUERY,&#xA;        variables: {&#xA;          description: this.descriptionText&#xA;        }&#xA;      })&#xA;&#xA;      if (res) {&#xA;        const { results } = res.data.product&#xA;        this.searchResults = results&#xA;        alert(this.searchResults[0])&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/script&gt;&#xA;</code></pre>&#xA;<p>In my database I have 4 products and one of them has as descriptions &quot;Van-gogh&quot;, I would like to show that description in the alert, but instead I get a error page:</p>&#xA;<p><a href=""https://i.stack.imgur.com/sDAzj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sDAzj.png"" alt=""enter image description here"" /></a></p>&#xA;<p><strong>Network Tab</strong></p>&#xA;<p>Here you can see what the Network tab return me:</p>&#xA;<p>Headers:&#xA;<a href=""https://i.stack.imgur.com/LoFEQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LoFEQ.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Preview:&#xA;<a href=""https://i.stack.imgur.com/rh7jR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rh7jR.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Response:&#xA;<a href=""https://i.stack.imgur.com/7neFF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7neFF.png"" alt=""enter image description here"" /></a></p>&#xA;<p><strong>Error messages</strong></p>&#xA;<p>Here you can see the error messages I get from Orchard-Core side when I try to run the queries:</p>&#xA;<p>If I am using &quot;where&quot; I get an error on &quot;description&quot; field:&#xA;<a href=""https://i.stack.imgur.com/qXUFD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qXUFD.png"" alt=""enter image description here"" /></a></p>&#xA;<p>If I am using &quot;filter&quot; I get an error directly on filter argument:&#xA;<a href=""https://i.stack.imgur.com/f0M5Z.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/f0M5Z.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Is there someone that can help me and suggest me how to make it works?</p>&#xA;<p>Thanks in advance.</p>&#xA;",15885621,,15885621,2021-10-28 07:48:14,2021-10-28 07:48:14,Nuxt-Apollo - Network error: Server response was missing for query 'FILTERED_PRODUCT',<nuxt.js><apollo><orchardcms><apollo-client><graphiql>,0,4,0,2021-10-27 13:01:52
69743003,2,,69738509,2,,"<p>You can use the <code>orderBy</code> operator for this.</p>&#xA;<p>Here's what the query would look like for your use-case:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const data =  await prisma.items.findMany({&#xA;    where: {itemId: itemId},&#xA;    include: {&#xA;        modules: {&#xA;            orderBy: {&#xA;                number: 'asc'&#xA;            },&#xA;            include: {&#xA;                lessons: {&#xA;                    orderBy: {&#xA;                        number: 'asc'&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;})&#xA;&#xA;</code></pre>&#xA;<p>The article on <a href=""https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting"" rel=""nofollow noreferrer"">filtering and sorting</a> contains more information on this.</p>&#xA;",8855844,,,,2021-10-27 17:21:58,"",,0,0,0,2021-10-27 17:21:58
69748611,1,69749124,,-2,108,"<p>I have a JSON response from the server, &quot;IN01&quot;, &quot;IN02&quot; and &quot;2021&quot;, &quot;2022&quot; these are dynamic object keys. I want to covert this structure to some other format. How to do with javascript?</p>&#xA;<pre><code>{&#xA;  &quot;holidayCalendar&quot;: [&#xA;    {&#xA;      &quot;IN01&quot;: [&#xA;        {&#xA;          &quot;2021&quot;: [&#xA;            {&#xA;              &quot;month&quot;: &quot;1&quot;,&#xA;              &quot;value&quot;: &quot;0101111110111011011111101011110&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;2&quot;,&#xA;              &quot;value&quot;: &quot;1111110111111011111101111110&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;3&quot;,&#xA;              &quot;value&quot;: &quot;1111110111111011111101111110011&quot;&#xA;            }&#xA;          ]&#xA;        },&#xA;        {&#xA;          &quot;2022&quot;: [&#xA;            {&#xA;              &quot;month&quot;: &quot;4&quot;,&#xA;              &quot;value&quot;: &quot;0011111101111110111111011011101&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;5&quot;,&#xA;              &quot;value&quot;: &quot;1111101111110111111011111101&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;6&quot;,&#xA;              &quot;value&quot;: &quot;1111101111110111111011111101111&quot;&#xA;            }&#xA;          ]&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      &quot;IN02&quot;: [&#xA;        {&#xA;          &quot;2021&quot;: [&#xA;            {&#xA;              &quot;month&quot;: &quot;1&quot;,&#xA;              &quot;value&quot;: &quot;0101111110111011011111101011110&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;2&quot;,&#xA;              &quot;value&quot;: &quot;1111110111111011111101111110&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;3&quot;,&#xA;              &quot;value&quot;: &quot;1111110111111011111101111110011&quot;&#xA;            }&#xA;          ]&#xA;        },&#xA;        {&#xA;          &quot;2022&quot;: [&#xA;            {&#xA;              &quot;month&quot;: &quot;4&quot;,&#xA;              &quot;value&quot;: &quot;0011111101111110111111011011101&quot;&#xA;            },&#xA;            {&#xA;              &quot;month&quot;: &quot;5&quot;,&#xA;              &quot;value&quot;: &quot;1111101111110111111011111101&quot;&#xA;            }&#xA;          ]&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;&#xA;</code></pre>&#xA;<blockquote>&#xA;<p>Here key can be any value instead of &quot;IN01&quot;, &quot;IN02&quot; etc also &quot;2021&quot; ,&#xA;&quot;2021&quot;</p>&#xA;</blockquote>&#xA;<p><strong>I want to convert the above JSON data to below-mentioned format</strong></p>&#xA;<pre><code>{&#xA;    &quot;holidayCalendar&quot; : [&#xA;        {&#xA;            &quot;location&quot; : &quot;IN01&quot;,&#xA;            &quot;year&quot; : &quot;2021&quot;,&#xA;            &quot;holidays&quot; : [&#xA;                {&#xA;                    &quot;month&quot;: &quot;1&quot;,&#xA;                    &quot;value&quot;: &quot;0101111110111011011111101011110&quot;&#xA;                  },&#xA;                  {&#xA;                    &quot;month&quot;: &quot;2&quot;,&#xA;                    &quot;value&quot;: &quot;1111110111111011111101111110&quot;&#xA;                  },&#xA;                  {&#xA;                    &quot;month&quot;: &quot;3&quot;,&#xA;                    &quot;value&quot;: &quot;1111110111111011111101111110011&quot;&#xA;                  }&#xA;            ]&#xA;&#xA;        },&#xA;        {&#xA;            &quot;location&quot; : &quot;IN01&quot;,&#xA;            &quot;year&quot; : &quot;2022&quot;,&#xA;            &quot;holidays&quot; : [{&#xA;                &quot;month&quot;: &quot;4&quot;,&#xA;                &quot;value&quot;: &quot;0011111101111110111111011011101&quot;&#xA;              },&#xA;              {&#xA;                &quot;month&quot;: &quot;5&quot;,&#xA;                &quot;value&quot;: &quot;1111101111110111111011111101&quot;&#xA;              },&#xA;              {&#xA;                &quot;month&quot;: &quot;6&quot;,&#xA;                &quot;value&quot;: &quot;1111101111110111111011111101111&quot;&#xA;              }&#xA;            ]&#xA;        },&#xA;        {&#xA;            &quot;location&quot; : &quot;IN02&quot;,&#xA;            &quot;year&quot; : &quot;2021&quot;,&#xA;            &quot;holidays&quot; : [&#xA;                {&#xA;                  &quot;month&quot;: &quot;1&quot;,&#xA;                  &quot;value&quot;: &quot;0101111110111011011111101011110&quot;&#xA;                },&#xA;                {&#xA;                  &quot;month&quot;: &quot;2&quot;,&#xA;                  &quot;value&quot;: &quot;1111110111111011111101111110&quot;&#xA;                },&#xA;                {&#xA;                  &quot;month&quot;: &quot;3&quot;,&#xA;                  &quot;value&quot;: &quot;1111110111111011111101111110011&quot;&#xA;                }&#xA;              ]&#xA;&#xA;        },&#xA;        {&#xA;            &quot;location&quot; : &quot;IN02&quot;,&#xA;            &quot;year&quot; : &quot;2022&quot;,&#xA;            &quot;holidays&quot; : [&#xA;                {&#xA;                  &quot;month&quot;: &quot;4&quot;,&#xA;                  &quot;value&quot;: &quot;0011111101111110111111011011101&quot;&#xA;                },&#xA;                {&#xA;                  &quot;month&quot;: &quot;5&quot;,&#xA;                  &quot;value&quot;: &quot;1111101111110111111011111101&quot;&#xA;                }&#xA;              ]&#xA;        }&#xA;    ]&#xA;}&#xA;&#xA;&#xA;&#xA;</code></pre>&#xA;<p><em><strong>Really appreciated your help. Thank You !</strong></em></p>&#xA;",6727459,,,,2021-10-28 07:02:50,How to convert nested object to array of object in javascript?,<javascript><reactjs><graphql><apollo>,2,6,0,2021-10-28 05:13:36
69749124,2,,69748611,2,,"<p>You can easily achieve the result using <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap"" rel=""nofollow noreferrer""><code>flatMap</code></a>, <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"" rel=""nofollow noreferrer""><code>Object.entries</code></a></p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obj = {&#xA;  holidayCalendar: [&#xA;    {&#xA;      IN01: [&#xA;        {&#xA;          ""2021"": [&#xA;            {&#xA;              month: ""1"",&#xA;              value: ""0101111110111011011111101011110"",&#xA;            },&#xA;            {&#xA;              month: ""2"",&#xA;              value: ""1111110111111011111101111110"",&#xA;            },&#xA;            {&#xA;              month: ""3"",&#xA;              value: ""1111110111111011111101111110011"",&#xA;            },&#xA;          ],&#xA;        },&#xA;        {&#xA;          ""2022"": [&#xA;            {&#xA;              month: ""4"",&#xA;              value: ""0011111101111110111111011011101"",&#xA;            },&#xA;            {&#xA;              month: ""5"",&#xA;              value: ""1111101111110111111011111101"",&#xA;            },&#xA;            {&#xA;              month: ""6"",&#xA;              value: ""1111101111110111111011111101111"",&#xA;            },&#xA;          ],&#xA;        },&#xA;      ],&#xA;    },&#xA;    {&#xA;      IN02: [&#xA;        {&#xA;          ""2021"": [&#xA;            {&#xA;              month: ""1"",&#xA;              value: ""0101111110111011011111101011110"",&#xA;            },&#xA;            {&#xA;              month: ""2"",&#xA;              value: ""1111110111111011111101111110"",&#xA;            },&#xA;            {&#xA;              month: ""3"",&#xA;              value: ""1111110111111011111101111110011"",&#xA;            },&#xA;          ],&#xA;        },&#xA;        {&#xA;          ""2022"": [&#xA;            {&#xA;              month: ""4"",&#xA;              value: ""0011111101111110111111011011101"",&#xA;            },&#xA;            {&#xA;              month: ""5"",&#xA;              value: ""1111101111110111111011111101"",&#xA;            },&#xA;          ],&#xA;        },&#xA;      ],&#xA;    },&#xA;  ],&#xA;};&#xA;&#xA;const result = {&#xA;  ...obj,&#xA;  holidayCalendar: obj.holidayCalendar.flatMap((obj) =&gt;&#xA;    Object.entries(obj).flatMap(([location, v]) =&gt;&#xA;      v.flatMap((o) =&gt;&#xA;        Object.entries(o).map(([year, holidays]) =&gt; ({&#xA;          location,&#xA;          year,&#xA;          holidays,&#xA;        }))&#xA;      )&#xA;    )&#xA;  ),&#xA;};&#xA;console.log(result);</code></pre>&#xD;&#xA;<pre class=""snippet-code-css lang-css prettyprint-override""><code>/* This is not a part of answer. It is just to give the output full height. So IGNORE IT */&#xA;.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>If you want to use <code>days</code> instead of <code>value</code> then you can do as:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>const obj = {&#xA;  holidayCalendar: [&#xA;    {&#xA;      IN01: [&#xA;        {&#xA;          ""2021"": [&#xA;            {&#xA;              month: ""1"",&#xA;              value: ""0101111110111011011111101011110"",&#xA;            },&#xA;            {&#xA;              month: ""2"",&#xA;              value: ""1111110111111011111101111110"",&#xA;            },&#xA;            {&#xA;              month: ""3"",&#xA;              value: ""1111110111111011111101111110011"",&#xA;            },&#xA;          ],&#xA;        },&#xA;        {&#xA;          ""2022"": [&#xA;            {&#xA;              month: ""4"",&#xA;              value: ""0011111101111110111111011011101"",&#xA;            },&#xA;            {&#xA;              month: ""5"",&#xA;              value: ""1111101111110111111011111101"",&#xA;            },&#xA;            {&#xA;              month: ""6"",&#xA;              value: ""1111101111110111111011111101111"",&#xA;            },&#xA;          ],&#xA;        },&#xA;      ],&#xA;    },&#xA;    {&#xA;      IN02: [&#xA;        {&#xA;          ""2021"": [&#xA;            {&#xA;              month: ""1"",&#xA;              value: ""0101111110111011011111101011110"",&#xA;            },&#xA;            {&#xA;              month: ""2"",&#xA;              value: ""1111110111111011111101111110"",&#xA;            },&#xA;            {&#xA;              month: ""3"",&#xA;              value: ""1111110111111011111101111110011"",&#xA;            },&#xA;          ],&#xA;        },&#xA;        {&#xA;          ""2022"": [&#xA;            {&#xA;              month: ""4"",&#xA;              value: ""0011111101111110111111011011101"",&#xA;            },&#xA;            {&#xA;              month: ""5"",&#xA;              value: ""1111101111110111111011111101"",&#xA;            },&#xA;          ],&#xA;        },&#xA;      ],&#xA;    },&#xA;  ],&#xA;};&#xA;&#xA;const result = {&#xA;  ...obj,&#xA;  holidayCalendar: obj.holidayCalendar.flatMap((obj) =&gt;&#xA;    Object.entries(obj).flatMap(([location, v]) =&gt;&#xA;      v.flatMap((o) =&gt;&#xA;        Object.entries(o).map(([year, holidays]) =&gt; ({&#xA;          location,&#xA;          year,&#xA;          holidays: holidays.map(({ value, ...rest }) =&gt; ({&#xA;            ...rest,&#xA;            days: value,&#xA;          })),&#xA;        }))&#xA;      )&#xA;    )&#xA;  ),&#xA;};&#xA;console.log(result);</code></pre>&#xD;&#xA;<pre class=""snippet-code-css lang-css prettyprint-override""><code>/* This is not a part of answer. It is just to give the output full height. So IGNORE IT */&#xA;.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",9153448,,9153448,2021-10-28 07:02:50,2021-10-28 07:02:50,"",,0,2,0,2021-10-28 06:15:03
69774889,1,,,0,265,<p>In my project I have this feature where users can invite each other to connect.</p>&#xA;<p>My (postgres) database table structure (in Hasura) looks like this:</p>&#xA;<pre><code>id // uuid&#xA;sender_id // uuid - user id&#xA;receiver_id // uuid - user id&#xA;status // enum - pending | declined | connected&#xA;</code></pre>&#xA;<p>Inserting rows into this table works perfectly but I'm looking for a way to prevent 'duplicate' rows.</p>&#xA;<p>In my feature it would technically be possible for users to invite each other at the same time.</p>&#xA;<p>The following rows would be 'duplicates'.</p>&#xA;<pre><code>id | sender_id | receiver_id | status&#xA;--------------------------------------&#xA;0    1234        6789          pending&#xA;1    6789        1234          pending&#xA;</code></pre>&#xA;<p>I was thinking about creating some kind of composite primary key out of concatinating the <code>sender_id</code> and <code>receiver_id</code> and use that in an upsert query. When this primary key would conflict then instead of adding a new row I would update the status to 'connected'.</p>&#xA;<p>But since the <code>sender_id</code> can be the <code>receiver_id</code> and vice versa I would never have a unique primary key.</p>&#xA;<p>Another thing I thought could work would be to sort the <code>sender_id</code> and <code>receiver_id</code> UUID's and store that as a primary key. By sorting I wouldn't matter which user is the sender or the receiver because the primary key would always be the same.</p>&#xA;<p>What would be the best/most common approach for this use case if I want to make this work with Hasura's <code>on_conflict</code> argument in a mutation.</p>&#xA;,497747,,497747,2021-10-29 21:39:40,2021-10-29 21:39:40,Prevent 'duplicate' rows in a many to many table,<database><postgresql><graphql><many-to-many><hasura>,0,2,0,2021-10-29 21:20:52
69778806,2,,69778455,0,,"<p>Querying based on the date of the last message is perfectly acceptable &amp; standard.</p>&#xA;<p>DynamoDB itself doesn't provide a way to get &quot;new&quot; items (messages in this case) like you would be able to do using SQS for example - there's no way to &quot;acknowledge&quot; an item.</p>&#xA;<p>For pagination, you could use markers like <a href=""https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.Pagination.html"" rel=""nofollow noreferrer""><code>ExclusiveStartKey</code></a> however you already have a date field to filter by so there is absolutely no need to do so.</p>&#xA;<p>You're following best practices already by modeling your data correctly.</p>&#xA;",4800344,,,,2021-10-30 10:38:41,"",,0,0,0,2021-10-30 10:38:41
69799311,1,,,0,42,"<p>I am trying to make structure for GraphQl resolvers, but a bit stuck.</p>&#xA;<p>Imagine that we have different sale type entities</p>&#xA;<pre><code>type Sale {&#xA;   name: String&#xA;   value: Float&#xA;   type: Int&#xA;}&#xA;</code></pre>&#xA;<p>Currently we have a query which gets all the sales by type and compare them for different date ranges</p>&#xA;<pre><code>type SaleResult {&#xA;   name: String&#xA;   main_value: Float&#xA;   compare_value: Float&#xA;   difference: Float&#xA;   type: Int&#xA;}&#xA;&#xA;input DateParamsInput {&#xA;   start: DateTime!&#xA;   end: DateTime!&#xA;}&#xA;&#xA;input SomeFilterInput {&#xA;   dateRangeMain: DateParamsInput&#xA;   dateRangeCompare: DateParamsInput&#xA;   type: [Int]&#xA;}&#xA;&#xA;Query {&#xA; getSales(filter: SomeFilterInput) [SaleResult]&#xA;}&#xA;</code></pre>&#xA;<p>and now we were requested to add a switcher to grab data either without compare value or with it. We can add new query but I am trying to find a way to have single query for both cases</p>&#xA;<p>There is a solution, how I see it</p>&#xA;<pre><code>Query {&#xA;   getSales2(type: [Int]) {&#xA;     sale {&#xA;        name&#xA;        type&#xA;        diff(mainRange, compareRange) {&#xA;           main_value&#xA;           compare_value&#xA;           diff&#xA;        }&#xA;        value(mainRange)&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>In this case we will have 2 nested resolvers: <code>diff</code> and <code>value</code>. The first one can return data with compare value and another one for single value</p>&#xA;<p>Another way</p>&#xA;<pre><code>Query {&#xA;   getSales2(type: [Int], mainRange) {&#xA;     sale {&#xA;        name&#xA;        type&#xA;        value&#xA;        compare(compareRange) {&#xA;           value&#xA;           diff&#xA;        }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>but in this case we have to have value before compare resolver starts and I am not sure this is the working approach</p>&#xA;<p>Since I have no one to validate this, I am asking for your help. Do you have any thoughts?</p>&#xA;",2895213,,2895213,2021-11-01 16:02:23,2021-11-01 16:02:23,Need recommendations for Graphql resolvers structure,<graphql>,0,2,0,2021-11-01 15:45:52
69813666,1,69814160,,1,734,"<p>I'm trying to add a filter to the following graphql query and I'm just not able to figure out where to add the filter parameter. I went through the documentation but I'm clueless how to do it. I should also retain the limit and offset to do the pagination. I would like to filter by ID.</p>&#xA;<pre><code>const data = await axios.post(&quot;http://localhost:1337/graphql&quot;, {&#xA;        query: `query {&#xA;        newsPostsConnection(limit: ${limit}, start: ${start}) {&#xA;          values {&#xA;            id&#xA;            title&#xA;            body&#xA;            writtenBy&#xA;            imageUrl&#xA;            created_at&#xA;          }&#xA;          aggregate {&#xA;            totalCount&#xA;          }&#xA;        }&#xA;      }`&#xA;</code></pre>&#xA;",4473868,,,,2021-11-03 00:53:03,How to filter by ID in this graphql query,<reactjs><graphql><apollo-client>,1,0,0,2021-11-02 16:15:11
69819029,1,,,0,1143,"<p>The intention is to query a list of users using an array of User IDs passed into a <code>contains</code> filter. The schema below is my attempt at solving this, but the query does not return a list of users. Even passing only a single User ID results in an empty query result. This schema is being published to AWS AppSync.</p>&#xA;<p>Is it possible to query a list of users using an array of User IDs in AppSync?</p>&#xA;<p>schema.graphql</p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  username: String!&#xA;  friends: [String]&#xA;}&#xA;&#xA;type Query {&#xA;    getAllFriends(filter: ModelAllFriendsFilterInput): ModelGetAllFriends&#xA;}&#xA;&#xA;type ModelGetAllFriends {&#xA;  items: [User]&#xA;}&#xA;&#xA;input ModelAllFriendsFilterInput {&#xA;  id: ModelAllFriendsIDInput&#xA;}&#xA;&#xA;input ModelAllFriendsIDInput {&#xA;  contains: [ID]&#xA;}&#xA;</code></pre>&#xA;<p>GraphQL Query:</p>&#xA;<pre><code>query MyQuery {&#xA;  getAllFriends(filter: {id: {contains: &quot;VALID-USER-ID-HERE&quot;}}) {&#xA;    items {&#xA;      id&#xA;      username&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Query result:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;getAllFriends&quot;: null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",2149462,,,,2021-11-03 15:59:10,How to get list of objects using an array in AWS App Sync?,<graphql><aws-appsync>,1,4,0,2021-11-03 02:35:01
69856126,1,,,1,627,"<p>I don't know how to solve this problem I'm trying a long time now but I'm stuck.</p>&#xA;<p>I've tried different Libarys for GraphQL requests but nothing is working so thats why im searching for help.</p>&#xA;<p>I want to use the GraphQL request to get some details from some Axies on my wallet</p>&#xA;<p>it would be great if anybody can help me</p>&#xA;<pre><code>from gql import gql, Client&#xA;from gql.transport.requests import RequestsHTTPTransport&#xA;&#xA;&#xA;header = {&#xA;    'User-Agent': 'My User Agent 1.0',&#xA;    'From': 'youremail@domain.com',&#xA;    'Content-Type': 'application/json'&#xA;}&#xA;&#xA;&#xA;transport = RequestsHTTPTransport(url=&quot;https://graphql-gateway.axieinfinity.com/graphql&quot;,headers=header, use_json= True)&#xA;&#xA;client = Client(transport=transport, fetch_schema_from_transport= True)&#xA;&#xA;query = gql('''&#xA;{&#xA;    GetAxieBriefList{&#xA;  axies(&#xA;    auctionType: $auctionType&#xA;    criteria: $criteria&#xA;    from: $from&#xA;    sort: $sort&#xA;    size: $size&#xA;    owner: $owner&#xA;  ) {&#xA;    total&#xA;    results {&#xA;      ...AxieBrief&#xA;      __typename&#xA;    }&#xA;    __typename&#xA;  }&#xA;}&#xA;&#xA;fragment AxieBrief on Axie {&#xA;  id&#xA;  name&#xA;  stage&#xA;  class&#xA;  breedCount&#xA;  image&#xA;  title&#xA;  battleInfo {&#xA;    banned&#xA;    __typename&#xA;  }&#xA;  auction {&#xA;    currentPrice&#xA;    currentPriceUSD&#xA;    __typename&#xA;  }&#xA;  parts {&#xA;    id&#xA;    name&#xA;    class&#xA;    type&#xA;    specialGenes&#xA;    __typename&#xA;  }&#xA;  __typename&#xA;}&#xA;}&#xA;&#xA;''')&#xA;&#xA;variables = {&#xA;    &quot;from&quot;: 0,&#xA;    &quot;size&quot;: 100,&#xA;    &quot;sort&quot;: &quot;IdDesc&quot;,&#xA;    &quot;auctionType&quot;: &quot;All&quot;,&#xA;    &quot;owner&quot;: &quot;&lt;my0xAdress&gt;&quot;&#xA;    }&#xA;&#xA;response_query = client.execute(query,variables)&#xA;&#xA;print(response_query)&#xA;</code></pre>&#xA;<p>I'm getting this error and I do not know how to make the schema correctly</p>&#xA;<pre><code>    raise TypeError(&#xA;TypeError: Invalid or incomplete introspection result. Ensure that you are passing the 'data' attribute of an introspection response and no 'errors' were returned alongside: None.```&#xA;</code></pre>&#xA;",17282702,,14277722,2022-10-28 20:11:04,2022-10-28 20:11:04,GraphQL Request in Python,<python><python-requests><graphql><gql>,1,0,0,2021-11-05 16:09:12
69861195,1,70206516,,0,561,"<p>The following simple query is not returning <code>Posts</code> ordered by <code>created_at</code> -&#xA;According to the terminal, Rails is ordering by <code>id</code>, no matter what i put in <code>::Post.order(column: :direction)</code></p>&#xA;<pre><code>Post Load (0.9ms)  SELECT  `posts`.* FROM `posts ` &#xA;                ORDER BY `posts `.`id` ASC LIMIT 24&#xA;</code></pre>&#xA;<p>I can't imagine what could be reordering the query by <code>:id</code>, or blocking sort order.</p>&#xA;<p>Here's the resolver:</p>&#xA;<pre class=""lang-rb prettyprint-override""><code>module Resolvers&#xA;  class Posts &lt; Resolvers::BaseResolver&#xA;    type Types::Models::PostType.connection_type, null: false&#xA;    description &quot;List or filter all observations&quot;&#xA;&#xA;    def resolve&#xA;      ::Post.order(created_at: :desc)&#xA;    end&#xA;  end&#xA;end&#xA;</code></pre>&#xA;<p>Base resolver</p>&#xA;<pre class=""lang-rb prettyprint-override""><code>module Resolvers&#xA;  class BaseResolver &lt; GraphQL::Schema::Resolver&#xA;  end&#xA;end&#xA;</code></pre>&#xA;<p>Query type</p>&#xA;<pre class=""lang-rb prettyprint-override""><code># graphql/types/query_type.rb&#xA;require(&quot;graphql/batch&quot;)&#xA;require(&quot;loaders/record_loader&quot;)&#xA;require(&quot;search_object&quot;)&#xA;require(&quot;search_object/plugin/graphql&quot;)&#xA;&#xA;module Types&#xA;  class QueryType &lt; Types::BaseObject&#xA;    field :posts, Types::Models::PostType.connection_type, null: false, resolver: Resolvers::Posts&#xA;</code></pre>&#xA;<p>Query (using Relay style cursor pagination)</p>&#xA;<pre><code>query getPosts {&#xA;  posts {&#xA;    pageInfo {&#xA;      startCursor&#xA;      endCursor&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;    }&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        thumbImageId&#xA;        textName&#xA;        where&#xA;        when&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The app schema:</p>&#xA;<pre class=""lang-rb prettyprint-override""><code>class MyAppSchema &lt; GraphQL::Schema&#xA;  query(Types::QueryType)&#xA;  mutation(Types::MutationType)&#xA;&#xA;  default_max_page_size 24&#xA;  connections.add(ActiveRecord::Relation, GraphQL::Connections::Stable)&#xA;&#xA;  # GraphQL::Batch setup:&#xA;  use GraphQL::Batch&#xA;end&#xA;</code></pre>&#xA;<p>Background: I'm planning on using a resolver for this model query because the eventual version will have a lot of filters built with <code>search_object_graphql</code>, and while testing the sorting filters i noticed it was ignoring the sort order. So I stripped the resolver back down to the graphql schema inheritance, hardcoded the query scope with an orderby clause, and it's still not ordering the query.</p>&#xA;",3357635,,,,2021-12-02 21:13:07,"In Rails, simple graphQL-ruby queries are ignoring sort order",<ruby-on-rails><graphql><graphql-ruby>,1,0,0,2021-11-06 03:17:40
69913884,1,,,0,610,"<p>I m trying to design relay type cursor based pagination in graphql using mongoDb. I followed some of the instructions in this blog <a href=""https://www.reindex.io/blog/relay-graphql-pagination-with-mongodb/"" rel=""nofollow noreferrer"">https://www.reindex.io/blog/relay-graphql-pagination-with-mongodb/</a>.</p>&#xA;<p>so here is the thing. Normally all the tutorials and stackoverflow questions based on ObjectID of mongoDb. For example,</p>&#xA;<pre><code>Graphql Query&#xA;&#xA;product(first:10, cursor){&#xA; ...&#xA;}&#xA;&#xA;&#xA;MongoDb request&#xA;&#xA;db.product.find({_id: { $gt : ObjectId(cursor) } }).limit(first)&#xA;</code></pre>&#xA;<p>So this is fine until we are not using any sorting based on any fields. In my situation I'm using custom Ids as _id using uuid package and how can I design this relay based cursor pagination when _id is a custom string and sorting changes? How to change the cursor if I'm sorted results on product based on ratings, sales? (Each product document has a summerized sales count, ratings counts)</p>&#xA;",7553348,,,,2021-11-10 13:12:06,graphql cursor based pagination with mongodb,<node.js><mongodb><pagination><graphql>,0,0,0,2021-11-10 13:12:06
69927403,2,,69926868,0,,"<p>I solved it by adding the types.</p>&#xA;<p>So instead of returning the above array, I slightly changed the returning data into :</p>&#xA;<pre><code>    &quot;Grouped&quot;: [&#xA;  {&#xA;    &quot;Id&quot;: &quot;1&quot;,&#xA;    &quot;_data&quot;: [&#xA;      {&#xA;        &quot;x&quot;: &quot;Thu Sep 30 2021&quot;,&#xA;        &quot;y&quot;: 0.02&#xA;      }&#xA;    ]&#xA;  },&#xA;  {&#xA;    &quot;Id&quot;: &quot;172&quot;,&#xA;    &quot;_data&quot;: [&#xA;      {&#xA;        &quot;x&quot;: &quot;Mon Oct 04 2021&quot;,&#xA;        &quot;y&quot;: 2327.7599999999998&#xA;      },&#xA;      {&#xA;        &quot;x&quot;: &quot;Wed Oct 06 2021&quot;,&#xA;        &quot;y&quot;: 172.91000000000003&#xA;      }&#xA;    ]&#xA;  },&#xA;]&#xA;</code></pre>&#xA;<p>Now it is working.</p>&#xA;",4417425,,,,2021-11-11 11:19:22,"",,0,1,0,2021-11-11 11:19:22
69947847,2,,63179173,3,,<p>I was experiencing the same issue with Graphql only returning the first 10 comments. I was able to get around this issue by specifying a <code>first</code> value in my query.</p>&#xA;<pre><code>query {&#xA;    comments (first: 500) {&#xA;      ...&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>The current GraphQL Edge schema likely has 10 as a default value for <code>first</code>.</p>&#xA;,14678112,,,,2021-11-12 18:58:02,"",,0,0,0,2021-11-12 18:58:02
69983917,1,,,0,178,"<p>My app uses AppSync resolvers to fetch data from DDB and return it to our front-end. One table we have is for Notifications. A Notification can be either pending or default (non-pending). The table itself has a primary key of notification_id and we have a GSI called userIndex to grab the notifications for a user, with a sort key of timestamp.</p>&#xA;<p>In the app, I show all notifications in a list, pending first and then default. Given that a user may have many notifications, I'd like to implement pagination to fetch a batch at a time. The only way I've been able to do this is to</p>&#xA;<ol>&#xA;<li>change the query to include a <code>isPending</code> parameter, which I use as a filter expression for the query to only return notifications that are isPending or isNotPending.</li>&#xA;<li>Store two &quot;nextTokens&quot;, one for each isPending and isNotPending, along with corresponding lists.</li>&#xA;<li>Make separate queries for pending/non-pending, and use the filter to return to the appropriate list.</li>&#xA;</ol>&#xA;<p>This is obviously inefficient and I am re-reading data from DynamoDB. My question is, given my DynamoDB table/requirements, is there a way I can paginate so that I can get all the pending notifications first (sorted by timestamp) and then all the default notifications next (sorted by timestamp) by using one query and one <code>nextToken</code></p>&#xA;<p>I've seen the use of <code>@model</code> and <code>@key</code>, but I haven't been able to make it work in my app.</p>&#xA;<p>Thanks!</p>&#xA;",9307138,,,,2021-11-17 16:12:49,DynamoDB Appsync Query on multiple attributes,<graphql><amazon-dynamodb><aws-appsync>,1,0,0,2021-11-16 04:52:23
69987420,2,,69981063,4,,"<p>welcome to Stackoverflow, glad to see you are starting out with Strapi!</p>&#xA;<p>If I understand right, you are referring to V4, if you used V3 before, then as @xadm pointed out you likely are providing incorrect input for your GraphQL query filters.</p>&#xA;<p>You can always find the definition (the parameters it accepts and the format of them) for <code>StringFilterInput</code> and any other types by clicking on the green &quot;DOCS&quot; label on the right hand side of your GraphQL Playground (Screenshot below):</p>&#xA;<p><a href=""https://i.stack.imgur.com/EZ1Bq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EZ1Bq.png"" alt=""GraphQL Strapi API Docs"" /></a></p>&#xA;<p>With this in mind you may want to try querying with the below query (replacing <code>posts</code> with the Collection Type you are searching for)</p>&#xA;<p>*also note the &quot; <code>eq: </code> in <code>username</code> filter</p>&#xA;<pre><code>query {&#xA;  posts(filters: { author: { username: { eq: &quot;ann.bystry&quot; } } }) {&#xA;    data {&#xA;      id&#xA;      attributes {&#xA;        title&#xA;        # query other fields here&#xA;      }&#xA;    }&#xA;  }&#xA;} &#xA;</code></pre>&#xA;<p>Friendly suggestion for future - when you ask a question it is always useful to paste in any relevant code samples and versions of the frameworks/packages you are using :)</p>&#xA;<p>Best of luck!</p>&#xA;",4832501,,,,2021-11-16 10:25:31,"",,0,0,0,2021-11-16 10:25:31
69997200,2,,69997122,2,,"<p>I think you're looking for <a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">fragments</a>:</p>&#xA;<blockquote>&#xA;<p>GraphQL includes reusable units called fragments. Fragments let you construct sets of fields, and then include them in queries where you need to. Here's an example of how you could solve the above situation using fragments:</p>&#xA;</blockquote>&#xA;",636077,,,,2021-11-16 23:18:56,"",,0,1,0,2021-11-16 23:18:56
70006821,2,,70003812,0,,"<p>The variables object must contain key value pairs where the key matches a declared variable. In your case you declare the variable <code>id</code> but in the object you use the key <code>invoiceID</code>. Either rename the variable or the key.</p>&#xA;<p>Furthermore, you are probably confusing yourself by calling the variable <code>id</code>, even though it expects a filter input like above: <code>{ where: { id: &quot;id value&quot; } }</code>. The easiest way is probably to not pass in the object from JavaScript, but make your query take a variable of type <code>ID</code>:</p>&#xA;<pre><code>mutation deleteInvoice ($id: ID!) {&#xA;  deleteInvoice(input: { where: { id: $id } }) {&#xA;    invoice {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Now this makes mutch more sense as <code>id</code> is really an ID and not a <code>deleteInvoiceInput</code>.</p>&#xA;<p>Bringing it all together:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const [deleteInvoice] = useMutation(gql`&#xA;  mutation deleteInvoice($id: ID!) {&#xA;    deleteInvoice(input: { where: { id: $id } }) {&#xA;      invoice {&#xA;        id&#xA;      }    &#xA;    }&#xA;  }&#xA;`)&#xA;&#xA;// Usually in callback&#xA;const onDeleteClicked = (event) =&gt; {&#xA;  const id = event.currentTarget.getAttribute('data-id');&#xA;  deleteInvoice({ variables: { id } });&#xA;}&#xA;</code></pre>&#xA;",3849167,,3849167,2021-11-17 17:36:02,2021-11-17 17:36:02,"",,0,2,0,2021-11-17 15:04:47
70007901,2,,69983917,0,,"<p>No, not really. There is a hard limit on returns for a Dynamodb query - and that cannot be bypassed. the only way to make use of <code>nextToken</code> is another query.</p>&#xA;<p>However, it is also worth noting that the FilterExpression <em>happens after the data has already been retrieved</em> and is filtered client side. It does not reduce the documents pulled from the query - only whats displayed. So the next token is still going to be (relatively) the same for each query. You can instead filter it yourself after the call before the next pagination query and save yourself a little bit in terms of multiple calls.</p>&#xA;",11591758,,,,2021-11-17 16:12:49,"",,0,0,0,2021-11-17 16:12:49
70036623,1,70126116,,2,580,"<p>I've been playing with <a href=""https://docs.github.com/en/enterprise-cloud@latest/issues/trying-out-the-new-projects-experience"" rel=""nofollow noreferrer"">Projects Beta</a> using GitHub's GQL API but can't find a way to filter / search / query them.</p>&#xA;<p>For instance, I'd to get all issues in a <a href=""https://docs.github.com/en/graphql/reference/objects#projectnext"" rel=""nofollow noreferrer"">project</a> for which a <a href=""https://docs.github.com/en/graphql/reference/objects#projectnextfield"" rel=""nofollow noreferrer"">field</a> has a specific value.</p>&#xA;<p>How do I do so? Is it possible?</p>&#xA;<p>None of those objects as a filter attribute.&#xA;I've also looked at the <a href=""https://docs.github.com/en/graphql/reference/queries#searchresultitemconnection"" rel=""nofollow noreferrer"">search</a> query but that doesn't seem to support Projects or Fields as <a href=""https://docs.github.com/en/search-github/getting-started-with-searching-on-github/about-searching-on-github#types-of-searches-on-github"" rel=""nofollow noreferrer"">query</a> parmeters.</p>&#xA;<p>Thanks in advance!</p>&#xA;",826060,,,,2021-11-26 14:39:35,How to search GitHub Projects Beta with GraphQL API,<graphql><github-api>,1,0,0,2021-11-19 14:45:24
70039506,2,,49237159,2,,"<p>Taking inspiration from Simon Willison's '<a href=""https://til.simonwillison.net/github/graphql-pagination-python"" rel=""nofollow noreferrer"">Paginating through the GitHub GraphQL API with Python</a>' here's what I've been doing to paginate my queries:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>query {&#xA;  node(id: &quot;PROJECT_ID&quot;) {&#xA;    ... on ProjectNext {&#xA;      items(first: 100 after: CURSOR) {&#xA;        pageInfo {&#xA;          hasNextPage&#xA;          endCursor&#xA;        }&#xA;        nodes {&#xA;          title&#xA;          fieldValues(first: 8) {&#xA;            nodes {&#xA;              value&#xA;            }&#xA;          }&#xA;          content {&#xA;            ... on Issue {&#xA;              number&#xA;              labels(first: 50) {&#xA;                nodes {&#xA;                  name&#xA;}}}}}}}}}&#xA;</code></pre>&#xA;<p>In my Python code I'm splicing in <code>PROJECT_ID</code> with a variable set to the project ID I'm referencing.</p>&#xA;<p>For the cursor <code>after: CURSOR</code> is replaced with <code>&quot;&quot;</code> initially, and then for the next page I set <code>cursor = 'after:\\&quot;' + response[&quot;data&quot;][&quot;node&quot;][&quot;items&quot;][&quot;pageInfo&quot;][&quot;endCursor&quot;] + '\\&quot;'</code></p>&#xA;<p>My full code is in the <a href=""https://github.com/atsign-company/dump_cards/blob/main/atdumpmemex.py"" rel=""nofollow noreferrer"">atdumpmemex</a> module of my dump_cards utility.</p>&#xA;<p>The key here is to get <code>pageInfo</code> along with other relevant nodes, and then grab the <code>endCursor</code> each time <code>hasNextPage</code> is true so that it can be fed into the query for the next iteration.</p>&#xA;<p>pageInfo will look something like:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>&quot;pageInfo&quot;: {&#xA;  &quot;hasNextPage&quot;: false,&#xA;  &quot;endCursor&quot;: &quot;Y3Vyc29yOnYyOpHOAAhOsg==&quot;&#xA;}&#xA;</code></pre>&#xA;<p>At the moment the <code>endCursor</code> is base64 encoded <code>cursor:v2:XYZ</code>, but don't rely on that as GitHub have moved other IDs from being base64 encoded to other schemes.</p>&#xA;",3830789,,,,2021-11-19 18:42:20,"",,0,0,0,2021-11-19 18:42:20
70052910,2,,68277857,1,,"<p>I'm still at an early stage of getting familiar with AWS, so please take this with a grain of salt.</p>&#xA;<p>Your auto generated <code>queries.js</code> will contain a listSomething query, that looks something like this:</p>&#xA;<pre><code>export const listTodos = /* GraphQL */ `&#xA;  query ListTodos(&#xA;    $filter: ModelTodoFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        userID&#xA;        name&#xA;        description&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I created a new folder called <code>/src/customGraphQL</code> and created a file called <code>customListTodos.js</code>. I copied there the auto generated query, changed the query name, and removed the fields I didn't need.</p>&#xA;<pre><code>export const customListTodos = /* GraphQL */ `&#xA;  query CustomListTodos(&#xA;    $filter: ModelTodoFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        name&#xA;        description&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I only changed the query's name, but kept the inner function's name as <code>listTodos</code>, so I'm running a customised version of that query. If the original API is pushed to AWS, you can import and use the custom query:</p>&#xA;<pre><code>import {customListTodos} from './src/customGraphQL/customListTodos';&#xA;...&#xA;API.graphql(graphqlOperation(customListTodos ... &#xA;&#xA;</code></pre>&#xA;",7726827,,7726827,2021-11-21 09:48:34,2021-11-21 09:48:34,"",,0,0,0,2021-11-21 08:19:52
70061628,2,,70058162,1,,"<p>I agree that the ideal, cleaner and elegant solution is using a <a href=""https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/"" rel=""nofollow noreferrer"">GraphQL schema customization</a>, however, if it's not an option for you, I'm thinking of a kind of <code>key</code> value for each parent product so can be used as filter identifier. Given:</p>&#xA;<pre><code>src/posts&#xA;│&#xA;└───Product_A&#xA;│   │   index.md&#xA;</code></pre>&#xA;<p>So in the index.md:</p>&#xA;<pre><code>---&#xA;key: product A&#xA;someField: Some value&#xA;someField2: Some value 2&#xA;---&#xA;</code></pre>&#xA;<p>Then, in your query fields you can do something like:</p>&#xA;<pre><code>  allMarkdownRemark( filter: {key: {eq: &quot;product A&quot; }){&#xA;    edges {&#xA;      node {&#xA;        fileAbsolutePath&#xA;        fields{&#xA;          slug&#xA;        }&#xA;        excerpt&#xA;        frontmatter {&#xA;          title&#xA;        }&#xA;      }&#xA;  }&#xA;</code></pre>&#xA;<p>And so on for the rest.</p>&#xA;",5585371,,,,2021-11-22 06:22:13,"",,0,1,0,2021-11-22 06:22:13
70071171,1,,,1,690,"<p>Trying to filter data using GraphQL variables and Next JS. How can I pass my state to the GraphQL variable &quot;name&quot; ?</p>&#xA;<p>handleSelectedFilter will update the filter state based on the selected option. I am expecting the value of the filter state to get passed to &quot;name&quot; variable.</p>&#xA;<p>Bare in mind we cannot use react hooks inside of Next js getStaticProps function, tried state management, custom hooks ..etc doesn't work with Next JS.</p>&#xA;<p>Any kind of help is much appreciated. Thanks in advance.</p>&#xA;<pre><code>export async function getStaticProps() {&#xA;&#xA; const { data, errors } = await client.query({&#xA;    query: GET_LISTINGS,&#xA;    variables: {&#xA;        uri: '/listing/',&#xA;        name: filter?.city&#xA;    }&#xA;  })&#xA;  return {&#xA;    props: {&#xA;        data: data || [],&#xA;    },&#xA;    revalidate: 1&#xA;  }&#xA;}&#xA;&#xA;const listings = ({ data }) =&gt; {&#xA;  const [filter, setFilter] = useState({&#xA;      city: '',&#xA;      area: '',&#xA;      type: '',&#xA;  })&#xA;&#xA;  const handleSelectedFilter = e =&gt; {&#xA;    setFilter({ ...filter, [e.target.name]: e.target.value })&#xA;  }&#xA;}&#xA;export default listings&#xA;</code></pre>&#xA;<p>GrpahQL Schema below</p>&#xA;<pre><code>export const GET_LISTINGS = gql`&#xA;query GET_LISTINGS( $name: String) {&#xA;listingCategoriesL: listingCategories(where: {name: [$name]}) {&#xA;   nodes {&#xA;     id&#xA;     name&#xA;     listings {&#xA;       edges {&#xA;          node {&#xA;           id&#xA;           title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",11726672,,,,2021-11-22 21:09:44,Filter data in array using GraphQL variables and Next JS,<variables><react-hooks><graphql><next.js><graphql-schema>,1,0,0,2021-11-22 19:09:04
70125137,2,,70124648,1,,"<p>The GraphQL spec states that the interface fields have to be repeated on the type.</p>&#xA;<pre><code>interface PagedResponse {&#xA;  hasNextPage: Boolean!&#xA;  hasPreviousPage: Boolean!&#xA;  totalCount: Int!&#xA;}&#xA;&#xA;type SitesResponse implements PagedResponse {&#xA;  hasNextPage: Boolean!&#xA;  hasPreviousPage: Boolean!&#xA;  totalCount: Int!&#xA;  items: [Site]&#xA;}&#xA;</code></pre>&#xA;<p>If you look at the schema exception it essentially just tells you that:</p>&#xA;<pre><code>The field `hasNextPage` must be implement by object type `SitesResponse`. (HotChocolate.Types.ObjectType)&#xA;</code></pre>&#xA;<p>Interface Specification:&#xA;<a href=""https://spec.graphql.org/October2021/#sec-Interfaces"" rel=""nofollow noreferrer"">https://spec.graphql.org/October2021/#sec-Interfaces</a></p>&#xA;<p>Type Validation Rule:&#xA;<a href=""https://spec.graphql.org/October2021/#sec-Objects.Type-Validation"" rel=""nofollow noreferrer"">https://spec.graphql.org/October2021/#sec-Objects.Type-Validation</a></p>&#xA;",11023824,,,,2021-11-26 13:25:43,"",,0,2,0,2021-11-26 13:25:43
70126116,2,,70036623,2,,"<p>I asked about this in the <a href=""https://github.com/github/feedback/discussions/5616"" rel=""nofollow noreferrer"">Projects Beta Feedback Discussion</a>.</p>&#xA;<p>It seems that filtering hasn't been implemented (yet) and so it's necessary to do things the old fashioned way (like with the REST API) by using queries to get all the issues, then filtering after.</p>&#xA;<p>In many ways this is worse than things were with the REST API, as there's no way to get just the issues in a given column, you have to get every issue on the board, which quickly then gets you into <a href=""https://stackoverflow.com/questions/49237159/display-more-than-100-entries-through-graphql-api/70039506#70039506"">needing pagination</a>.</p>&#xA;<p>At least GraphQL queries are specifying which nodes/fields you want back, so you're not having to filter through all of everything, just some of everything.</p>&#xA;",3830789,,,,2021-11-26 14:39:35,"",,0,0,0,2021-11-26 14:39:35
70131542,1,70441912,,0,1120,"<p>I'm looking to use Hot Chocolate's Filtering to query against one data type; and then transform that filtered output to another type before returning it as an IQueryable. But I can't seem to find anyway to capture the filter input to start my transform.</p>&#xA;<p>Here's an example of what I'm trying to accomplish:</p>&#xA;<p>Given the data classes</p>&#xA;<pre><code>public class TypeA&#xA;{&#xA;    public string Foo { get; set; }&#xA;}&#xA;&#xA;public class TypeB&#xA;{&#xA;    public string Fizz { get; set; }&#xA;    public string Buzz { get; set; }&#xA;}&#xA;</code></pre>&#xA;<p>I want to be able to create a query endpoint like</p>&#xA;<pre><code>public class Query&#xA;{&#xA;    [UseDbContext(typeof(DbContext))]&#xA;    [UseFiltering(typeof(TypeA))]&#xA;    public IQueryable&lt;TypeB&gt; GetTypeB(&#xA;        [ScopedService] DbContext context,&#xA;        [SomeAttributeToCaptureTheFilter] Filter filter) // &lt;- this is the line I'm trying to figure out&#xA;    {&#xA;        IQueryable&lt;TypeA&gt; filteredTypeAs = context.TypeA.Filter(filter); // .Filter() doesn't exist, its just for example.&#xA;        IQueryable&lt;TypeB&gt; filteredTypeBs;&#xA; &#xA;        /* Complex transformation logic that populates 'filteredTypeBs' &#xA;         * requiring the 'filteredTypeAs' and additional Data from &#xA;         * the database to complete. */&#xA;&#xA;        return filteredTypeBs;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Against which, I can use a GraphQL Query like the following</p>&#xA;<pre><code>query {&#xA;  typeB(where: { foo: { eq: &quot;bar&quot; } }) {&#xA;    fizz&#xA;    buzz&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><code>where: { foo: { eq: &quot;bar&quot; } }</code> Being the filter against <code>TypeA</code>, and the</p>&#xA;<pre><code>typeB {&#xA;  fizz&#xA;  buzz&#xA;} &#xA;</code></pre>&#xA;<p>pulling the content from the transformed <code>TypeB</code>.</p>&#xA;<hr />&#xA;<p>Using <code>[UseFiltering(typeof(TypeA))]</code> does work, It sets up the schema to act as I want.</p>&#xA;<p>What I'm looking for is something to the effect of the line <code>[SomeAttributeToCaptureTheFilter] Filter filter</code>. Just some way of capturing the filter and applying it to the data within the DbContext.</p>&#xA;<p>I will also say I'm very new to GraphQL in general, so how I'm approaching this problem may be entirely wrong. Any advice would be helpful.</p>&#xA;",9101294,,,,2022-01-31 16:51:05,Hot Chocolate: Transforming results from [UseFiltering] Query,<c#><entity-framework><graphql><hotchocolate>,1,1,0,2021-11-27 01:58:35
70137060,2,,70136467,1,,"<p>The GitHub GraphQL API uses the popular <a href=""https://graphql.org/learn/pagination/#pagination-and-edges"" rel=""nofollow noreferrer"">cursor-based pagination pattern</a>.  Each record has an opaque, id-like cursor.  Return the cursor from the query. Use it as input to the next query.  <a href=""https://www.apollographql.com/docs/react/pagination/cursor-based/"" rel=""nofollow noreferrer"">Apollo Client has tools</a> to help with this.</p>&#xA;<pre><code>{&#xA;  repository(name: &quot;apollo-client&quot;, owner: &quot;apollographql&quot;) {&#xA;    issues(last: 10, after: &quot;Y3Vyc29yOnYyOpHOP2I0Sw==&quot;) {&#xA;      edges {&#xA;        node {&#xA;          createdAt&#xA;          title&#xA;        }&#xA;        cursor&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1103511,,,,2021-11-27 17:16:06,"",,0,0,0,2021-11-27 17:16:06
70137286,1,,,2,38,"<p>I wonder if there is any syntactic sugar in graphql mutation that saving me from rewriting the name of the variable? For example, my mutation looks like this (I have to repeat each variable name triple times):</p>&#xA;<p><a href=""https://i.stack.imgur.com/1iemy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1iemy.png"" alt=""The boilerplate code that I have to write"" /></a></p>&#xA;<p>I'm expecting something like the javascript's spreading operator, which might looks like this:</p>&#xA;<pre><code>mutation SaveMedia(...$payload: SaveMediaParams) {&#xA;  saveMedia(...$payload) {&#xA;    asset {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Thank you in advance!</p>&#xA;",8284338,,,,2021-11-27 17:48:08,Auto naming GraphQL mutation variables based on matching arguments,<variables><graphql><naming><boilerplate><mutation>,0,3,0,2021-11-27 17:48:08
70155992,2,,70136467,0,,"<p>You can get up to 100 nodes, but then you need to use pagination, which is done by getting <code>pageInfo</code> for <code>hasNextPage</code> and <code>endCursor</code></p>&#xA;<p>e.g. I can get my first 100 repos with:</p>&#xA;<pre><code>query ReposByUser {&#xA;  user(login: &quot;cpswan&quot;) {&#xA;    repositories(first: 100) {&#xA;      totalCount&#xA;      nodes {&#xA;        name&#xA;      }&#xA;      pageInfo {&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>and the response will end with:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>        &quot;pageInfo&quot;: {&#xA;          &quot;hasNextPage&quot;: true,&#xA;          &quot;endCursor&quot;: &quot;Y3Vyc29yOnYyOpHOFdXRZQ==&quot;&#xA;        }&#xA;</code></pre>&#xA;<p>So I can then get the next page with:</p>&#xA;<pre><code>query ReposByUser {&#xA;  user(login: &quot;cpswan&quot;) {&#xA;    repositories(first: 100 after: &quot;Y3Vyc29yOnYyOpHOFdXRZQ==&quot;) {&#xA;      totalCount&#xA;      nodes {&#xA;        name&#xA;      }&#xA;      pageInfo {&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Which this time ends with this telling me there are no further pages:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>        &quot;pageInfo&quot;: {&#xA;          &quot;hasNextPage&quot;: false,&#xA;          &quot;endCursor&quot;: &quot;Y3Vyc29yOnYyOpHOGb3wAQ==&quot;&#xA;        }&#xA;</code></pre>&#xA;",3830789,,,,2021-11-29 14:04:48,"",,0,2,0,2021-11-29 14:04:48
70158218,1,70158817,,0,834,"<p>Is it possible any input extend other input on graphql schema?</p>&#xA;<p>example below:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>input PaginationInput{&#xA;    pageSize: Int&#xA;    pageNum: Int&#xA;}&#xA;&#xA;# // example for extending input Pagination&#xA;input MyFilterInput implement_or_extend PaginationInput {&#xA;    attr1: String&#xA;}&#xA;&#xA;type Query {&#xA;&#xA;    usingMyFilter(filter: MyFilterInput): Any&#xA;}&#xA;</code></pre>&#xA;<p>Is there any way to do this?</p>&#xA;",7505687,,7505687,2021-11-29 16:51:00,2021-11-29 17:28:05,Input extend other input on graphql schema,<graphql><typegraphql>,1,0,0,2021-11-29 16:44:20
70162799,2,,40644296,1,,"<p>I just do this:</p>&#xA;<pre><code>query nameOfYourQuery {&#xA;  allEvents(filter: { id: { in: [1,2,3] } }) {&#xA;    nodes {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>If the array is a variable, then it would look like this (in Gatsby, at least):</p>&#xA;<pre><code>query nameOfYourQuery($arrayOfID: [String]) {&#xA;  allEvents(filter: { id: { in: $arrayOfID: [String] } }) {&#xA;    nodes {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",5941620,,,,2021-11-30 00:12:37,"",,0,1,0,2021-11-30 00:12:37
70166069,1,,,2,2364,"<pre><code>select * &#xA;from WeeklyChallengeCourses &#xA;where weekly_challenge_id = (select weekly_challenge_id &#xA;                             from WeeklyChallengeCourses &#xA;                             where course_id = 210);&#xA;</code></pre>&#xA;<p>Result will be the below selected one:</p>&#xA;<p><a href=""https://i.stack.imgur.com/oA9ir.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oA9ir.png"" alt=""enter image description here"" /></a></p>&#xA;<pre><code>const data = await context.prisma.weeklyChallengeCourses.findMany({&#xA;        where:{&#xA;            weekly_challenge_id: {&#xA;                ..............&#xA;            }&#xA;        },&#xA;    });&#xA;</code></pre>&#xA;",14207423,,330315,2021-11-30 10:01:24,2021-11-30 10:01:24,How to retrieve a sub query in prisma client with same table?,<node.js><postgresql><prisma><prisma-graphql>,1,0,0,2021-11-30 08:04:36
70180428,2,,70175630,1,,"<p>By default, the maximum number of posts per page returned by WPGraphQL is 100. You can override this by increasing the  <code>graphql_connection_max_query_amount</code> value.</p>&#xA;<p>From the <a href=""https://www.wpgraphql.com/filters/graphql_connection_max_query_amount/"" rel=""nofollow noreferrer""><code>graphql_connection_max_query_amount</code></a> filter documentation:</p>&#xA;<blockquote>&#xA;<p>Filter the maximum number of posts per page that should be queried.&#xA;The default is 100 to prevent queries from being exceedingly resource&#xA;intensive, however individual systems can override this for their&#xA;specific needs. This filter is intentionally applied AFTER the&#xA;query_args filter.</p>&#xA;</blockquote>&#xA;",1870780,,,,2021-12-01 07:28:54,"",,0,0,0,2021-12-01 07:28:54
70204957,1,,,4,872,"<p>I have the package versions</p>&#xA;<pre><code>...&#xA;Flask               2.0.2&#xA;Flask-GraphQL       2.0.0&#xA;Flask-Script        2.0.6&#xA;...&#xA;graphene            3.0&#xA;graphql-core        3.1.6&#xA;graphql-relay       3.1.0&#xA;graphql-server-core 1.1.1&#xA;...&#xA;</code></pre>&#xA;<p>and when I <code>import flask_graphql</code> I get</p>&#xA;<pre><code>Traceback (most recent call last):&#xA;  File &quot;/Users/Rax/Documents/Projects/Web/Sites/proj/_foo.py&quot;, line 1, in &lt;module&gt;&#xA;    import flask_graphql&#xA;  File &quot;/Users/Rax/Documents/Projects/Coding/Python/venvs/proj/lib/python3.9/site-packages/flask_graphql/__init__.py&quot;, line 1, in &lt;module&gt;&#xA;    from .blueprint import GraphQL&#xA;  File &quot;/Users/Rax/Documents/Projects/Coding/Python/venvs/proj/lib/python3.9/site-packages/flask_graphql/blueprint.py&quot;, line 5, in &lt;module&gt;&#xA;    from .graphqlview import GraphQLView&#xA;  File &quot;/Users/Rax/Documents/Projects/Coding/Python/venvs/proj/lib/python3.9/site-packages/flask_graphql/graphqlview.py&quot;, line 7, in &lt;module&gt;&#xA;    from graphql_server import (HttpQueryError, default_format_error,&#xA;  File &quot;/Users/Rax/Documents/Projects/Coding/Python/venvs/proj/lib/python3.9/site-packages/graphql_server/__init__.py&quot;, line 5, in &lt;module&gt;&#xA;    from graphql import get_default_backend&#xA;ImportError: cannot import name 'get_default_backend' from 'graphql' (/Users/Rax/Documents/Projects/Coding/Python/venvs/proj/lib/python3.9/site-packages/graphql/__init__.py)&#xA;</code></pre>&#xA;<p>How do I avoid this error. Are there different versions or version ranges I should be requiring?</p>&#xA;",656912,,400617,2021-12-02 19:20:50,2022-01-19 22:58:18,Flask GraphQL import fails,<python><graphql><graphql-python>,0,7,0,2021-12-02 18:50:35
70206516,2,,69861195,0,,"<p>Figured it out.</p>&#xA;<p>This is a documented behavior of the Search Object plugin for graphql-ruby.</p>&#xA;<p>I redid my query filters without this dependency, and sort order is working.</p>&#xA;",3357635,,,,2021-12-02 21:13:07,"",,0,0,0,2021-12-02 21:13:07
70215802,1,,,1,49,"<p>I am new to go. I am building a project using gqlgen and ent. I have schema.graphql defined as below</p>&#xA;<pre><code>type IP implements Node {&#xA;  id: ID!&#xA;  created_at: Time!&#xA;  updated_at: Time!&#xA;  response_code: String!&#xA;  ip_address: String!&#xA;  queries(after: Cursor, first: Int, before: Cursor, last: Int, orderBy: AppQueryOrder): AppQueryConnection&#xA;}&#xA;&#xA;input AppQueryOrder {&#xA;  direction: OrderDirection!&#xA;  field: AppQueryOrderField&#xA;}&#xA;&#xA;enum AppQueryOrderField {&#xA;  UPDATED_AT&#xA;  CREATED_AT&#xA;}&#xA;&#xA;type AppQueryConnection {&#xA;  totalCount: Int!&#xA;  pageInfo: PageInfo!&#xA;  edges: [AppQueryEdge]&#xA;}&#xA;&#xA;type AppQueryEdge {&#xA;  node: AppQuery&#xA;  cursor: Cursor!&#xA;}&#xA;&#xA;type AppQuery implements Node {&#xA;  id: ID!&#xA;  created_at: Time!&#xA;  updated_at: Time!&#xA;  ip: IP!&#xA;  responses(after: Cursor, first: Int, before: Cursor, last: Int): AppResponseConnection&#xA;}&#xA;&#xA;type AppResponseConnection {&#xA;  totalCount: Int!&#xA;  pageInfo: PageInfo!&#xA;  edges: [AppResponseEdge]&#xA;}&#xA;&#xA;type AppResponseEdge {&#xA;  node: AppResponse&#xA;  cursor: Cursor!&#xA;}&#xA;&#xA;type AppResponse implements Node {&#xA;  id: ID!&#xA;  created_at: Time!&#xA;  updated_at: Time!&#xA;  query: AppQuery!&#xA;  code: String!&#xA;  description: String!&#xA;}&#xA;</code></pre>&#xA;<p>After successful code generation I see that the Function for AppQueryResolver.Response and IP.queries are missing arguments for <em><strong>after: Cursor, first: Int, before: Cursor, last: Int ...</strong></em> in generated code. I have reviewed the schema based on example projects but unable see what could be causing this issue. There are no errors during code generation as well. Any pointers on where to further look to resolve this issue</p>&#xA;<pre><code>go version 1.17 &#xA;entgo.io/contrib v0.2.0 &#xA;entgo.io/ent v0.9.2&#xA;github.com/99designs/gqlgen v0.14.0&#xA;</code></pre>&#xA;",5032491,,,,2021-12-03 14:21:29,gqlgen Resolver func missing OrderBy args in generated code,<go><graphql><gqlgen><go-generate><ent>,0,0,0,2021-12-03 14:21:29
70228872,2,,70228806,0,,<p>Can answer my own question - one needs to define the variable in the first part of the query!</p>&#xA;<pre><code>query ($code: [MMSI!]) {&#xA;  vessels (mmsi: $code ){&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    nodes {&#xA;</code></pre>&#xA;,5905425,,,,2021-12-04 19:38:32,"",,0,0,0,2021-12-04 19:38:32
70231326,2,,70170480,7,,"<p>According to your question, to get the json response, You can follow  my working solution as an example. Actually, the hidden api calls json response is <a href=""https://www.walmart.com/orchestra/home/graphql/browse?affinityOverride=default&amp;page=1&amp;prg=desktop&amp;catId=3920&amp;sort=best_seller&amp;ps=40&amp;fetchMarquee=true&amp;fetchSkyline=true&amp;fetchSbaTop=false"" rel=""noreferrer"">here</a>. The interesing matter is that the request method is post but it sends query string parameters &amp; request payload/formdata and the next pages at the same time which type of response I face first time ever and I have to make both types of  parameters to get  desired json response. I've also made the pagination following json response and you can increase  or decrease it according to json response maxpage.</p>&#xA;<pre><code>import requests&#xA;import json&#xA;data= {&#xA;   &#xA;   &quot;query&quot;:&quot;query Browse( $query:String $page:Int $prg:Prg! $facet:String $sort:Sort $catId:String! $max_price:String $min_price:String $module_search:String $affinityOverride:AffinityOverride $ps:Int $ptss:String $beShelfId:String $fitmentFieldParams:JSON ={}$fitmentSearchParams:JSON ={}$rawFacet:String $seoPath:String $trsp:String $fetchMarquee:Boolean! $fetchSkyline:Boolean! $additionalQueryParams:JSON ={}){search( query:$query page:$page prg:$prg facet:$facet sort:$sort cat_id:$catId max_price:$max_price min_price:$min_price module_search:$module_search affinityOverride:$affinityOverride additionalQueryParams:$additionalQueryParams ps:$ps ptss:$ptss trsp:$trsp _be_shelf_id:$beShelfId ){query searchResult{...BrowseResultFragment}}contentLayout( channel:\&quot;WWW\&quot; pageType:\&quot;BrowsePage\&quot; tenant:\&quot;WM_GLASS\&quot; version:\&quot;v1\&quot; searchArgs:{query:$query cat_id:$catId _be_shelf_id:$beShelfId prg:$prg}){modules{...ModuleFragment configs{...on EnricherModuleConfigsV1{zoneV1}__typename...on _TempoWM_GLASSWWWSearchSortFilterModuleConfigs{facetsV1{...FacetFragment}}...on TempoWM_GLASSWWWPillsModuleConfigs{moduleSource pillsV2{...PillsModuleFragment}}...on TempoWM_GLASSWWWSearchFitmentModuleConfigs{fitments( fitmentSearchParams:$fitmentSearchParams fitmentFieldParams:$fitmentFieldParams ){...FitmentFragment sisFitmentResponse{...BrowseResultFragment}}}...on TempoWM_GLASSWWWStoreSelectionHeaderConfigs{fulfillmentMethodLabel storeDislayName}...on TempoWM_GLASSWWWBreadcrumbConfigs{_rawConfigs}...on TempoWM_GLASSWWWSponsoredProductCarouselConfigs{_rawConfigs}...PopularInModuleFragment...CopyBlockModuleFragment...BannerModuleFragment...HeroPOVModuleFragment...InlineSearchModuleFragment...MarqueeDisplayAdConfigsFragment @include(if:$fetchMarquee)...SkylineDisplayAdConfigsFragment @include(if:$fetchSkyline)...HorizontalChipModuleConfigsFragment}}...LayoutFragment pageMetadata{location{postalCode stateOrProvinceCode city storeId}pageContext}}seoBrowseMetaData( id:$catId facets:$rawFacet path:$seoPath facet_query_param:$facet _be_shelf_id:$beShelfId ){metaTitle metaDesc metaCanon h1}}fragment BrowseResultFragment on SearchInterface{title aggregatedCount...BreadCrumbFragment...DebugFragment...ItemStacksFragment...PageMetaDataFragment...PaginationFragment...RequestContextFragment...ErrorResponse modules{facetsV1{...FacetFragment}pills{...PillsModuleFragment}}}fragment ModuleFragment on TempoModule{name version type moduleId schedule{priority}matchedTrigger{zone}}fragment LayoutFragment on ContentLayout{layouts{id layout}}fragment BreadCrumbFragment on SearchInterface{breadCrumb{id name url}}fragment DebugFragment on SearchInterface{debug{sisUrl}}fragment ItemStacksFragment on SearchInterface{itemStacks{displayMessage meta{adsBeacon{adUuid moduleInfo max_ads}query stackId stackType title layoutEnum totalItemCount totalItemCountDisplay viewAllParams{query cat_id sort facet affinityOverride recall_set min_price max_price}}itemsV2{...ItemFragment...InGridMarqueeAdFragment}}}fragment ItemFragment on Product{__typename id usItemId fitmentLabel name checkStoreAvailabilityATC seeShippingEligibility brand type shortDescription imageInfo{...ProductImageInfoFragment}canonicalUrl externalInfo{url}category{path{name url}}badges{flags{...on BaseBadge{key text type id}}tags{...on BaseBadge{key text type}}}classType averageRating numberOfReviews esrb mediaRating salesUnitType sellerId sellerName hasSellerBadge availabilityStatusV2{display value}productLocation{displayValue aisle{zone aisle}}badge{type dynamicDisplayName}fulfillmentSpeed offerId preOrder{...PreorderFragment}priceInfo{...ProductPriceInfoFragment}variantCriteria{...VariantCriteriaFragment}fulfillmentBadge fulfillmentTitle fulfillmentType brand manufacturerName showAtc sponsoredProduct{spQs clickBeacon spTags}showOptions}fragment ProductImageInfoFragment on ProductImageInfo{thumbnailUrl}fragment ProductPriceInfoFragment on ProductPriceInfo{priceRange{minPrice maxPrice}currentPrice{...ProductPriceFragment}wasPrice{...ProductPriceFragment}unitPrice{...ProductPriceFragment}listPrice{...ProductPriceFragment}shipPrice{...ProductPriceFragment}subscriptionPrice{priceString subscriptionString}priceDisplayCodes{priceDisplayCondition finalCostByWeight}}fragment PreorderFragment on PreOrder{isPreOrder preOrderMessage preOrderStreetDateMessage}fragment ProductPriceFragment on ProductPrice{price priceString}fragment VariantCriteriaFragment on VariantCriterion{name type id isVariantTypeSwatch variantList{id images name rank swatchImageUrl availabilityStatus products selectedProduct{canonicalUrl usItemId}}}fragment InGridMarqueeAdFragment on MarqueePlaceholder{__typename type moduleLocation lazy}fragment PageMetaDataFragment on SearchInterface{pageMetadata{storeSelectionHeader{fulfillmentMethodLabel storeDislayName}title canonical description location{addressId}}}fragment PaginationFragment on SearchInterface{paginationV2{maxPage pageProperties}}fragment RequestContextFragment on SearchInterface{requestContext{vertical isFitmentFilterQueryApplied searchMatchType categories{id name}}}fragment ErrorResponse on SearchInterface{errorResponse{correlationId source errors{errorType statusCode statusMsg source}}}fragment PillsModuleFragment on PillsSearchInterface{title url image:imageV1{src alt}baseSeoURL}fragment BannerModuleFragment on TempoWM_GLASSWWWSearchBannerConfigs{moduleType viewConfig{title image imageAlt displayName description url urlAlt appStoreLink appStoreLinkAlt playStoreLink playStoreLinkAlt}}fragment PopularInModuleFragment on TempoWM_GLASSWWWPopularInBrowseConfigs{seoBrowseRelmData(id:$catId){relm{id name url}}}fragment CopyBlockModuleFragment on TempoWM_GLASSWWWCopyBlockConfigs{copyBlock(id:$catId){cwc}}fragment FacetFragment on Facet{name type layout min max selectedMin selectedMax unboundedMax stepSize values{id name description type itemCount isSelected baseSeoURL}}fragment FitmentFragment on Fitments{partTypeIDs result{status formId position quantityTitle extendedAttributes{...FitmentFieldFragment}labels{...LabelFragment}resultSubTitle}labels{...LabelFragment}savedVehicle{vehicleYear{...VehicleFieldFragment}vehicleMake{...VehicleFieldFragment}vehicleModel{...VehicleFieldFragment}additionalAttributes{...VehicleFieldFragment}}fitmentFields{...VehicleFieldFragment}fitmentForms{id fields{...FitmentFieldFragment}title labels{...LabelFragment}}}fragment LabelFragment on FitmentLabels{ctas{...FitmentLabelEntityFragment}messages{...FitmentLabelEntityFragment}links{...FitmentLabelEntityFragment}images{...FitmentLabelEntityFragment}}fragment FitmentLabelEntityFragment on FitmentLabelEntity{id label}fragment VehicleFieldFragment on FitmentVehicleField{id label value}fragment FitmentFieldFragment on FitmentField{id displayName value extended data{value label}dependsOn}fragment HeroPOVModuleFragment on TempoWM_GLASSWWWHeroPovConfigsV1{povCards{card{povStyle image{mobileImage{...TempoCommonImageFragment}desktopImage{...TempoCommonImageFragment}}heading{text textColor textSize}subheading{text textColor}detailsView{backgroundColor isTransparent}ctaButton{button{linkText clickThrough{value}}}logo{...TempoCommonImageFragment}links{link{linkText}}}}}fragment TempoCommonImageFragment on TempoCommonImage{src alt assetId uid clickThrough{value}}fragment InlineSearchModuleFragment on TempoWM_GLASSWWWInlineSearchConfigs{headingText placeholderText}fragment MarqueeDisplayAdConfigsFragment on TempoWM_GLASSWWWMarqueeDisplayAdConfigs{_rawConfigs ad{...DisplayAdFragment}}fragment DisplayAdFragment on Ad{...AdFragment adContent{type data{__typename...AdDataDisplayAdFragment}}}fragment AdFragment on Ad{status moduleType platform pageId pageType storeId stateCode zipCode pageContext moduleConfigs adsContext adRequestComposite}fragment AdDataDisplayAdFragment on AdData{...on DisplayAd{json status}}fragment SkylineDisplayAdConfigsFragment on TempoWM_GLASSWWWSkylineDisplayAdConfigs{_rawConfigs ad{...SkylineDisplayAdFragment}}fragment SkylineDisplayAdFragment on Ad{...SkylineAdFragment adContent{type data{__typename...SkylineAdDataDisplayAdFragment}}}fragment SkylineAdFragment on Ad{status moduleType platform pageId pageType storeId stateCode zipCode pageContext moduleConfigs adsContext adRequestComposite}fragment SkylineAdDataDisplayAdFragment on AdData{...on DisplayAd{json status}}fragment HorizontalChipModuleConfigsFragment on TempoWM_GLASSWWWHorizontalChipModuleConfigs{chipModuleSource:moduleSource chipModule{title url{linkText title clickThrough{type value}}}chipModuleWithImages{title url{linkText title clickThrough{type value}}image{alt clickThrough{type value}height src title width}}}&quot;,&#xA;   &quot;variables&quot;:{&#xA;      &quot;id&quot;:&quot;&quot;,&#xA;      &quot;affinityOverride&quot;:&quot;default&quot;,&#xA;      &quot;dealsId&quot;:&quot;&quot;,&#xA;      &quot;query&quot;:&quot;&quot;,&#xA;      &quot;page&quot;:1,&#xA;      &quot;prg&quot;:&quot;desktop&quot;,&#xA;      &quot;catId&quot;:&quot;3920&quot;,&#xA;      &quot;facet&quot;:&quot;&quot;,&#xA;      &quot;sort&quot;:&quot;best_seller&quot;,&#xA;      &quot;rawFacet&quot;:&quot;&quot;,&#xA;      &quot;seoPath&quot;:&quot;&quot;,&#xA;      &quot;ps&quot;:40,&#xA;      &quot;ptss&quot;:&quot;&quot;,&#xA;      &quot;trsp&quot;:&quot;&quot;,&#xA;      &quot;beShelfId&quot;:&quot;&quot;,&#xA;      &quot;recall_set&quot;:&quot;&quot;,&#xA;      &quot;module_search&quot;:&quot;&quot;,&#xA;      &quot;min_price&quot;:&quot;&quot;,&#xA;      &quot;max_price&quot;:&quot;&quot;,&#xA;      &quot;storeSlotBooked&quot;:&quot;&quot;,&#xA;      &quot;additionalQueryParams&quot;:None,&#xA;      &quot;fitmentFieldParams&quot;:None,&#xA;      &quot;fitmentSearchParams&quot;:{&#xA;         &quot;id&quot;:&quot;&quot;,&#xA;         &quot;affinityOverride&quot;:&quot;default&quot;,&#xA;         &quot;dealsId&quot;:&quot;&quot;,&#xA;         &quot;query&quot;:&quot;&quot;,&#xA;         &quot;page&quot;:1,&#xA;         &quot;prg&quot;:&quot;desktop&quot;,&#xA;         &quot;catId&quot;:&quot;3920&quot;,&#xA;         &quot;facet&quot;:&quot;&quot;,&#xA;         &quot;sort&quot;:&quot;best_seller&quot;,&#xA;         &quot;rawFacet&quot;:&quot;&quot;,&#xA;         &quot;seoPath&quot;:&quot;&quot;,&#xA;         &quot;ps&quot;:40,&#xA;         &quot;ptss&quot;:&quot;&quot;,&#xA;         &quot;trsp&quot;:&quot;&quot;,&#xA;         &quot;beShelfId&quot;:&quot;&quot;,&#xA;         &quot;recall_set&quot;:&quot;&quot;,&#xA;         &quot;module_search&quot;:&quot;&quot;,&#xA;         &quot;min_price&quot;:&quot;&quot;,&#xA;         &quot;max_price&quot;:&quot;&quot;,&#xA;         &quot;storeSlotBooked&quot;:&quot;&quot;,&#xA;         &quot;additionalQueryParams&quot;:None,&#xA;         &quot;cat_id&quot;:&quot;3920&quot;,&#xA;         &quot;_be_shelf_id&quot;:&quot;&quot;&#xA;      },&#xA;      &quot;fetchMarquee&quot;:True,&#xA;      &quot;fetchSkyline&quot;:True,&#xA;      &quot;fetchSbaTop&quot;:False&#xA;   }&#xA;&#xA;}&#xA;headers = {&#xA;    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',&#xA;    'content-type':'application/json',&#xA;    'wm_mp': 'true',&#xA;    'wm_page_url': 'https://www.walmart.com/browse/books/3920?sort=best_seller&amp;affinityOverride=default',&#xA;    'wm_qos.correlation_id': 'FWpup9KEKUrLFOY68gppqfprABL16K6qE76g',&#xA;    'x-apollo-operation-name': 'Browse',&#xA;    'x-enable-server-timing': '1',&#xA;    'x-latency-trace': '1',&#xA;    'x-o-ccm': 'server',&#xA;    'x-o-correlation-id': 'FWpup9KEKUrLFOY68gppqfprABL16K6qE76g',&#xA;    'x-o-gql-query': 'query Browse',&#xA;    'x-o-market': 'us',&#xA;    'x-o-platform': 'rweb',&#xA;    'x-o-platform-version': 'main-176-e8acb5',&#xA;    'x-o-segment': 'oaoh'&#xA;    }&#xA;&#xA;&#xA;params= {&#xA;    &quot;affinityOverride&quot;: &quot;default&quot;,&#xA;    &quot;page&quot;: &quot;1&quot;,&#xA;    &quot;prg&quot;: &quot;desktop&quot;,&#xA;    &quot;catId&quot;: &quot;3920&quot;,&#xA;    &quot;sort&quot;: &quot;best_seller&quot;,&#xA;    &quot;ps&quot;: &quot;40&quot;,&#xA;    &quot;fetchMarquee&quot;: &quot;true&quot;,&#xA;    &quot;fetchSkyline&quot;: &quot;true&quot;,&#xA;    &quot;fetchSbaTop&quot;: &quot;false&quot;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;for i in range(1,25,1):&#xA;    params['maxPage']=i&#xA;    api_url='https://www.walmart.com/orchestra/home/graphql/browse'&#xA;    resp = requests.post(api_url, data=json.dumps(data), headers=headers,params=params)&#xA;    r=resp.json()&#xA;    print(r)&#xA;    # items = r['data']['search']['searchResult']['itemStacks'][0]['itemsV2']&#xA;    # for item in items:&#xA;    #     price = item['priceInfo']['currentPrice']['price']&#xA;    #     print(price)&#xA;</code></pre>&#xA;<h1>Output:</h1>&#xA;<pre><code>'https://i5.walmartimages.com/asr/deaaef8d-ca7f-4fc1-b556-1209c4c9000c.c6df15d971f1b9cddde27f80f17ae80b.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Sonic-The-Hedgehog-Coloring-Book-For-Kids-Girls-Adults-Toddlers-Kids-ages-2-8-Unofficial-25-high-quality-illustrations-Pages-8-5-x-11-Paperback-9781677024223/614029660?athbdg=L1600', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': [{'key': 'BESTSELLER', 'text': 'Best seller', 'type': 'LABEL', 'id': 'L1600'}], 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': 'REGULAR', 'averageRating': 3.9, 'numberOfReviews': 8, 'esrb': None, 'mediaRating': None, 'salesUnitType': 'EACH', 'sellerId': 'F55CDC31AB754BB68FE0B39041159D63', 'sellerName': 'Walmart.com', 'hasSellerBadge': None, 'availabilityStatusV2': {'display': 'In stock', &#xA;'value': 'IN_STOCK'}, 'productLocation': None, 'badge': [{'type': 'bestSeller', 'dynamicDisplayName': None}], 'fulfillmentSpeed': None, 'offerId': '27E4BA43A8704A1DABF0B37693611D16', 'preOrder': {'isPreOrder': False, 'preOrderMessage': None, 'preOrderStreetDateMessage': None}, 'priceInfo': {'priceRange': None, 'currentPrice': {'price': 6.99, &#xA;'priceString': '$6.99'}, 'wasPrice': None, 'unitPrice': None, 'listPrice': None, 'shipPrice': None, 'subscriptionPrice': None, 'priceDisplayCodes': {'priceDisplayCondition': None, 'finalCostByWeight': None}}, 'variantCriteria': [], 'fulfillmentBadge': None, &#xA;'fulfillmentTitle': 'title_shipToHome_not_available', 'fulfillmentType': 'FC', 'manufacturerName': None, 'showAtc': True, 'sponsoredProduct': None, 'showOptions': False}, {'__typename': 'Product', 'id': '16FA2JT4ZT52', 'usItemId': '491355610', 'fitmentLabel': None, 'name': 'Bible Word Search Books: Word Search Bible Puzzle Book - Extra Large &#xA;Print: Bible Word Search Large Print Puzzles for Seniors and Adults - Beginners Edition (Large Print) (Paperback)', 'checkStoreAvailabilityATC': False, 'seeShippingEligibility': False, 'brand': None, 'type': 'REGULAR', 'shortDescription': '&lt;li&gt;Format:Paperback&lt;/li&gt;&lt;li&gt;Publication Date: 2019-11-22&lt;/li&gt;', 'imageInfo': {'thumbnailUrl': 'https://i5.walmartimages.com/asr/46269778-a1bc-4a7a-aff2-75a825e35cf9.62e71231ecd42f6cda6d3701a3281b53.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Bible-Word-Search-Books-Puzzle-Book-Extra-Large-Print-Print-Puzzles-Seniors-Adults-Beginners-Edition-Large-Print-Paperback-9781710478792/491355610', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': None, 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': 'REGULAR', 'averageRating': 4.7, 'numberOfReviews': 13, 'esrb': None, 'mediaRating': None, 'salesUnitType': 'EACH', 'sellerId': 'F55CDC31AB754BB68FE0B39041159D63', 'sellerName': 'Walmart.com', 'hasSellerBadge': None, 'availabilityStatusV2': {'display': 'In stock', 'value': 'IN_STOCK'}, 'productLocation': None, 'badge': None, 'fulfillmentSpeed': None, 'offerId': '0E3D37D69AE14435A4E83D3AE2789B7F', 'preOrder': {'isPreOrder': False, 'preOrderMessage': None, 'preOrderStreetDateMessage': None}, 'priceInfo': {'priceRange': None, 'currentPrice': {'price': 6.99, 'priceString': '$6.99'}, 'wasPrice': None, 'unitPrice': None, 'listPrice': None, 'shipPrice': None, 'subscriptionPrice': None, 'priceDisplayCodes': {'priceDisplayCondition': None, 'finalCostByWeight': None}}, 'variantCriteria': [], 'fulfillmentBadge': None, 'fulfillmentTitle': 'title_shipToHome_not_available', 'fulfillmentType': 'FC', 'manufacturerName': None, 'showAtc': True, 'sponsoredProduct': None, 'showOptions': False}, {'__typename': 'Product', 'id': '72BDRK2VT8QQ', 'usItemId': '599380007', 'fitmentLabel': None, 'name': 'Trace Letters and Numbers Workbook: Learn How to Write Alphabet Upper and Lower Case and Numbers (Series #2) (Paperback)', 'checkStoreAvailabilityATC': False, 'seeShippingEligibility': False, 'brand': None, 'type': 'REGULAR', 'shortDescription': '9781794540767', 'imageInfo': {'thumbnailUrl': 'https://i5.walmartimages.com/asr/535dff68-7946-4e20-899b-20d05015b05a_1.22a1f229111edd3725505c0db3fe1371.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Trace-Letters-and-Numbers-Workbook-Learn-How-to-Write-Alphabet-Upper-and-Lower-Case-and-Numbers-Series-2-Paperback/599380007?athbdg=L1600', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': [{'key': 'BESTSELLER', 'text': 'Best seller', 'type': 'LABEL', 'id': 'L1600'}], 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': 'REGULAR', 'averageRating': 4.7, 'numberOfReviews': 37, 'esrb': None, 'mediaRating': &#xA;None, 'salesUnitType': 'EACH', 'sellerId': 'F55CDC31AB754BB68FE0B39041159D63', 'sellerName': 'Walmart.com', 'hasSellerBadge': None, 'availabilityStatusV2': {'display': 'In &#xA;stock', 'value': 'IN_STOCK'}, 'productLocation': None, 'badge': [{'type': 'bestSeller', 'dynamicDisplayName': None}], 'fulfillmentSpeed': None, 'offerId': 'B701DAA6361D4A97A599815F29FA450D', 'preOrder': {'isPreOrder': False, 'preOrderMessage': None, 'preOrderStreetDateMessage': None}, 'priceInfo': {'priceRange': None, 'currentPrice': {'price': 6.95, 'priceString': '$6.95'}, 'wasPrice': None, 'unitPrice': None, 'listPrice': None, 'shipPrice': None, 'subscriptionPrice': None, 'priceDisplayCodes': {'priceDisplayCondition': None, 'finalCostByWeight': None}}, 'variantCriteria': [], 'fulfillmentBadge': None, 'fulfillmentTitle': 'title_shipToHome_not_available', 'fulfillmentType': 'FC', 'manufacturerName': None, 'showAtc': True, 'sponsoredProduct': None, 'showOptions': False}, {'__typename': 'Product', 'id': '72DZILK2NY05', 'usItemId': '817841366', 'fitmentLabel': None, 'name': 'Toddler Coloring Book for Kids Age 1-3 : aby Activity Book Boys or Girls, Preschool coloring for Their Fun Early Learning of First Easy Number Shape and Color (Paperback)', 'checkStoreAvailabilityATC': False, 'seeShippingEligibility': False, 'brand': None, 'type': 'REGULAR', 'shortDescription': '&lt;li&gt;Format:Paperback&lt;/li&gt;&lt;li&gt;Publication Date: 2019-08-02&lt;/li&gt;', 'imageInfo': {'thumbnailUrl': 'https://i5.walmartimages.com/asr/d2f8e8be-7fa1-4a25-a80c-e1741c6b2f6f.6392f3a67fccf0b396e1fb6ee2848b4b.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Toddler-Coloring-Book-Kids-Age-1-3-aby-Activity-Boys-Girls-Preschool-coloring-Their-Fun-Early-Learning-First-Easy-Number-Shape-Color-Paperback-9781086986501/817841366?athbdg=L1600', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': [{'key': 'BESTSELLER', 'text': 'Best seller', 'type': 'LABEL', 'id': 'L1600'}], 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': 'REGULAR', 'averageRating': 5, 'numberOfReviews': 2, 'esrb': None, 'mediaRating': None, 'salesUnitType': 'EACH', 'sellerId': 'F55CDC31AB754BB68FE0B39041159D63', 'sellerName': 'Walmart.com', 'hasSellerBadge': None, 'availabilityStatusV2': {'display': 'In stock', 'value': 'IN_STOCK'}, &#xA;'productLocation': None, 'badge': [{'type': 'bestSeller', 'dynamicDisplayName': None}], 'fulfillmentSpeed': None, 'offerId': 'D3D88022487D4BF19D540BED3742A75D', 'preOrder': {'isPreOrder': False, 'preOrderMessage': None, 'preOrderStreetDateMessage': None}, 'priceInfo': {'priceRange': None, 'currentPrice': {'price': 6.95, 'priceString': '$6.95'}, 'wasPrice': None, 'unitPrice': None, 'listPrice': None, 'shipPrice': None, 'subscriptionPrice': None, 'priceDisplayCodes': {'priceDisplayCondition': None, 'finalCostByWeight': None}}, 'variantCriteria': [], 'fulfillmentBadge': None, 'fulfillmentTitle': 'title_shipToHome_not_available', 'fulfillmentType': 'FC', 'manufacturerName': None, 'showAtc': True, 'sponsoredProduct': None, 'showOptions': False}, {'__typename': 'Product', 'id': '46CGMFA2PY1Y', 'usItemId': '56172624', 'fitmentLabel': None, 'name': 'Crystals for Beginners : The Guide to Get Started with the Healing Power of Crystals (Paperback)', 'checkStoreAvailabilityATC': False, 'seeShippingEligibility': False, 'brand': None, 'type': 'VARIANT', 'shortDescription': '&lt;li&gt;Format:Paperback&lt;/li&gt;&lt;li&gt;Publication &#xA;Date: 2017-10-17&lt;/li&gt;', 'imageInfo': {'thumbnailUrl': 'https://i5.walmartimages.com/asr/d2954574-c30c-48af-8297-900867a2458e_1.03867d2efc65af18a6fdbff418a68afa.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Crystals-for-Beginners-The-Guide-to-Get-Started-with-the-Healing-Power-of-Crystals-Paperback-9781623159917/56172624?athbdg=L1600', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': &#xA;[{'key': 'BESTSELLER', 'text': 'Best seller', 'type': 'LABEL', 'id': 'L1600'}], 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': 'VARIANT', 'averageRating': 5, 'numberOfReviews': 13, 'esrb': None, 'mediaRating': None, 'salesUnitType': 'EACH', 'sellerId': 'F55CDC31AB754BB68FE0B39041159D63', 'sellerName': 'Walmart.com', 'hasSellerBadge': None, 'availabilityStatusV2': {'display': 'In stock', 'value': 'IN_STOCK'}, 'productLocation': None, 'badge': [{'type': 'bestSeller', 'dynamicDisplayName': None}], 'fulfillmentSpeed': None, 'offerId': '5F59F4B1DE6945728E7F2EC9A3005472', 'preOrder': {'isPreOrder': False, 'preOrderMessage': None, 'preOrderStreetDateMessage': None}, 'priceInfo': {'priceRange': None, 'currentPrice': {'price': 8.99, 'priceString': '$8.99'}, 'wasPrice': None, 'unitPrice': None, 'listPrice': {'price': 14.99, 'priceString': '$14.99'}, 'shipPrice': None, 'subscriptionPrice': None, 'priceDisplayCodes': {'priceDisplayCondition': None, 'finalCostByWeight': None}}, 'variantCriteria': [], 'fulfillmentBadge': None, 'fulfillmentTitle': 'title_shipToHome_not_available', 'fulfillmentType': 'FC', 'manufacturerName': None, 'showAtc': True, 'sponsoredProduct': None, 'showOptions': False}, {'__typename': 'Product', 'id': '7FF8DA7PEPDT', 'usItemId': '136868031', 'fitmentLabel': None, 'name': 'Hack Learning: Hacking School Discipline : 9 Ways to Create a Culture of Empathy and Responsibility Using Restorative Justice (Series #22) (Paperback)', 'checkStoreAvailabilityATC': False, 'seeShippingEligibility': False, 'brand': None, 'type': 'REGULAR', 'shortDescription': '&lt;li&gt;Format:Paperback&lt;/li&gt;&lt;li&gt;Publication Date: 2019-03-12&lt;/li&gt;', 'imageInfo': {'thumbnailUrl': 'https://i5.walmartimages.com/asr/4c639aa7-2580-4782-84ce-33a428cae000.571d547af78d39ffc35bdd28f988023f.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff'}, 'canonicalUrl': '/ip/Hack-Learning-Hacking-School-Discipline-9-Ways-Create-Culture-Empathy-Responsibility-Using-Restorative-Justice-Series-22-Paperback-9781948212137/136868031?athbdg=L1600', 'externalInfo': None, 'category': {'path': None}, 'badges': {'flags': [{'key': 'BESTSELLER', 'text': 'Best seller', 'type': 'LABEL', 'id': 'L1600'}], 'tags': [{'key': 'THREE_PLUS_DAY_SHIPPING', 'text': '3+ day shipping', 'type': 'LABEL'}, {'key': 'SAVE_WITH_W_PLUS', 'text': 'Save with', 'type': 'ICON'}]}, 'classType': &#xA;</code></pre>&#xA;<h1>Output: Extracted price as example:</h1>&#xA;<pre><code>22.99&#xA;1.22&#xA;6.99&#xA;9.95&#xA;5.95&#xA;9.81&#xA;5.99&#xA;13.17&#xA;4.52&#xA;6.99&#xA;4.99&#xA;7.99&#xA;6.79&#xA;5.99&#xA;6.5&#xA;6.95&#xA;6.99&#xA;5.99&#xA;4.99&#xA;5&#xA;4.99&#xA;11.93&#xA;5.99&#xA;4.99&#xA;6.99&#xA;6.99&#xA;6.95&#xA;6.95&#xA;8.99&#xA;14.81&#xA;5.13&#xA;7.29&#xA;3.95&#xA;5.99&#xA;5.5&#xA;5.99&#xA;16.88&#xA;6.99&#xA;6.99&#xA;1.99&#xA;22.99&#xA;1.22&#xA;6.99&#xA;9.95&#xA;5.95&#xA;9.81&#xA;5.99&#xA;13.17&#xA;4.52&#xA;6.99&#xA;4.99&#xA;7.99&#xA;6.7&#xA;</code></pre>&#xA;",12848411,,12848411,2021-12-05 20:03:54,2021-12-05 20:03:54,"",,0,4,0,2021-12-05 03:46:07
70250195,2,,67234439,0,,"<p>First you need to understand that GraphQL and SQL are different tools operating at different levels. SQL is executed at the database level.&#xA;Thinking about performance I would run this at the database level with SQL. You could create a database view named Sales that build the reports you want and simply run a select statement on that view.&#xA;Since you already have an OrderItem table , this table is actually the product sold so your Sales view could fetch data&#xA;Of course, you will have to filter OrderItem from cancelled Order.&#xA;With that in place you could build a request that only query this view.&#xA;Here are some explanations:  I made the assumptions on your table as follow:</p>&#xA;<ul>&#xA;<li>OrderItem --&gt; (id, quantity, unit_price, created_at, order_id);</li>&#xA;<li>Order(id, ...).</li>&#xA;</ul>&#xA;<p>As an example you could create the Sales view like this :</p>&#xA;<pre><code>CREATE OR REPLACE VIEW Sales AS &#xA;    SELECT row_number() OVER () as id, &#xA;           SUM(oi.quantity) as products,&#xA;           COUNT(o.id) as orders,&#xA;           to_char(oi.created_at, 'MM-YYYY') as SELL_DATE,&#xA;           SUM(oi.quantity*oi.unit_price) as amount &#xA;    FROM OrderItem oi, Order o &#xA;    WHERE oi.order_id=o.id &#xA;    GROUP BY SELL_DATE&#xA;    ORDER BY SELL_DATE;&#xA;</code></pre>&#xA;<p>this line &quot;row_number() OVER () as id&quot; is here to generate id in case your API need an id column.&#xA;Once you have the view &quot;Sales&quot; in place, you can query using a simple select like this :</p>&#xA;<pre><code>SELECT * FROM Sales;&#xA;</code></pre>&#xA;",4795242,,4795242,2021-12-06 19:08:41,2021-12-06 19:08:41,"",,0,0,0,2021-12-06 18:28:08
70283319,1,70456472,,1,444,"<p>In our GraphQL Server we use relay style cursor pagination.</p>&#xA;<p>We want to add a <code>totalCount</code> field to queries. How can we do it so that the extra computations are only done if <code>totalCount</code> is queried by the user?</p>&#xA;<p>Explanation:&#xA;Our resolvers (say, <code>BigmapResolver</code>) use the filtering, sorting and pagination requested by the client to create and return a <code>BigmapConnection</code> that has relay specific fields: <code>edges</code>, <code>pageInfo</code>, <code>cursor</code>, <code>node</code>.</p>&#xA;<p>Now it's easy to add a <code>totalCount</code> fields to this, but then we have to compute it regardless of whether or not the user is querying for it.</p>&#xA;<p>What is the right way to do this in Apollo server?</p>&#xA;",742775,,,,2021-12-23 00:25:24,Returning a totalCount field in apollo and Relay pagination,<graphql><apollo><apollo-server>,1,0,0,2021-12-09 00:23:10
70286710,1,,,0,1462,"<p>I am trying to get data based on date filter in query.</p>&#xA;<p>AIM: get data where <code>date</code> is greater than equals <code>new Date()</code>.</p>&#xA;<p>What I tried?</p>&#xA;<pre><code>const AGQL = gql`&#xA;        query query($todayDate: DateTime!){&#xA;            activities(where:$todayDate) {&#xA;                name&#xA;                id&#xA;                date&#xA;            }&#xA;        }&#xA;    `;&#xA;&#xA;</code></pre>&#xA;<pre><code>let { data, loading,error } = useQuery(AGQL,{&#xA;        variables:{&#xA;            todayDate:{date:{gte:new Date().toISOString()}},&#xA;        }&#xA;        &#xA;    });&#xA;&#xA;&#xA;</code></pre>&#xA;<p>But it gives <code>400 Bad request</code></p>&#xA;<p>Query works in GraphQL play ground</p>&#xA;<pre><code># Write your query or mutation here&#xA;query {&#xA;  activities(where:{date:{gte:&quot;2021-12-09T08:05:01.147Z&quot;}}) {&#xA;    name&#xA;    id&#xA;    date&#xA;}&#xA;&#xA;</code></pre>&#xA;",17365722,,17365722,2021-12-09 08:50:07,2021-12-09 08:50:07,How to Pass Date variable to Apollo GraphQl query in react type script?,<reactjs><typescript><graphql><apollo-client>,0,6,0,2021-12-09 08:28:14
70299311,2,,66509873,1,,"<p>Duplicate of <a href=""https://stackoverflow.com/questions/66083573/how-do-i-change-relay-connection-limit-in-graphene-django"">How do I change relay connection limit in graphene django</a></p>&#xA;<p>By default the DjangoFilterConnectionField &quot;max_limit&quot; is set to 100.&#xA;If set to None, it will fetch all records:</p>&#xA;<pre><code>all_txts = DjangoFilterConnectionField(LocalizedLocalizedTxtType, max_limit=None)&#xA;</code></pre>&#xA;",5917432,,,,2021-12-10 03:11:36,"",,0,0,0,2021-12-10 03:11:36
70320658,1,,,1,281,"<p>I am trying to query using the requests library but am having trouble. I suspect it's to do with the handling of the fragment but I'm not sure.</p>&#xA;<p>When I run the code I get Response 400. Here is my code:</p>&#xA;<pre><code>import requests&#xA;import json&#xA;&#xA;query = &quot;&quot;&quot;query GetAxieTransferHistory($axieId: ID!, $from: Int!, $size: Int!) {&#xA;  axie(axieId: $axieId) {&#xA;    id&#xA;    transferHistory(from: $from, size: $size) {&#xA;      ...TransferRecords&#xA;      __typename&#xA;    }&#xA;    __typename&#xA;  }&#xA;}&#xA;&#xA;fragment TransferRecords on TransferRecords {&#xA;  total&#xA;  results {&#xA;    from&#xA;    to&#xA;    timestamp&#xA;    txHash&#xA;    withPrice&#xA;    __typename&#xA;  }&#xA;  __typename&#xA;}&quot;&quot;&quot;&#xA;&#xA;params = {&#xA;  &quot;axieId&quot;: &quot;9082310&quot;,&#xA;  &quot;from&quot;: 0,&#xA;  &quot;size&quot;: 1&#xA;}&#xA;&#xA;url = 'https://axieinfinity.com/graphql-server-v2/graphql'&#xA;&#xA;r = requests.post(url, json={&quot;query&quot;: query, &quot;params&quot;: params})&#xA;print(r.status_code)&#xA;</code></pre>&#xA;<p>Thanks in advance!</p>&#xA;",13292085,,,,2021-12-12 04:15:19,How do you handle graphql query and fragment in python?,<python><python-requests><graphql><fragment>,1,0,0,2021-12-12 03:09:32
70356185,1,,,0,175,"<p><em><strong>TL;DR:</strong></em> I want to perform paged queries in Azure Cosmos DB using continuation token and, regardless of the page I'm requesting, get the total number of records that the query would return if it wasn't paged.</p>&#xA;<p>I have an API GraphQL with HotChocolate that fetch data from a Azure Cosmos DB. Now I'm trying to implement pagination in this API using continuation token to get the next pages. Everything worked fine until I tried to get the total count of my container. Here's the code:</p>&#xA;<pre><code>public async Task&lt;PagingResultDto&lt;EntityFromDatabase&gt;&gt; GetDataAsync(int itemsToTake, string continuationToken)&#xA;{&#xA;    var container = new CosmosClient(_connectionString).GetDatabase(_databaseId).GetContainer(_containerId);&#xA;&#xA;    var requestOptions = new QueryRequestOptions()&#xA;    {&#xA;        PartitionKey = _partitionKey,&#xA;        MaxItemCount = itemsToTake&#xA;    };&#xA;&#xA;    var baseQuery = container.GetItemLinqQueryable&lt;EntityFromDatabase&gt;(requestOptions: requestOptions, continuationToken: continuationToken);&#xA;&#xA;    var iterator = baseQuery.ToFeedIterator();&#xA;&#xA;    var currentResultSet = await iterator.ReadNextAsync();&#xA;    var queryResults = new List&lt;EntityFromDatabase&gt;();&#xA;    queryResults.AddRange(currentResultSet);&#xA;&#xA;    return new PagingResultDto&lt;EntityFromDatabase&gt;&#xA;    {&#xA;        HasNextPage = iterator.HasMoreResults,&#xA;        HasPreviousPage = !string.IsNullOrWhiteSpace(continuationToken),&#xA;        ContinuationToken = currentResultSet.ContinuationToken,&#xA;        Data = queryResults,&#xA;        TotalCount = await baseQuery.CountAsync()&#xA;    };&#xA;}&#xA;</code></pre>&#xA;<p>On the first run of my query, requesting 2 items and no continuation token provided, I get this return:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;entitiesFromDb&quot;: {&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;endCursor&quot;: &quot;{\&quot;V\&quot;:0,\&quot;Rid\&quot;:\&quot;\&quot;,\&quot;Continuation\&quot;:[{\&quot;token\&quot;:\&quot;\\\&quot;+RID:~NVwcAObfHW0CAAAAAAAAAA==#RT:1#TRC:2#ISV:2#IEO:65567#QCF:4#FPC:AgEAAAAKAAHA/P/RQAcA2IA=\\\&quot;\&quot;,\&quot;range\&quot;:{\&quot;min\&quot;:\&quot;\&quot;,\&quot;max\&quot;:\&quot;FF\&quot;}}],\&quot;PK\&quot;:\&quot;[\\\&quot;D248E16E8CAC5276F41601BCAD91BC42\\\&quot;]\&quot;}&quot;,&#xA;        &quot;hasPreviousPage&quot;: false,&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;startCursor&quot;: null&#xA;      },&#xA;      &quot;totalCount&quot;: 227,&#xA;      &quot;nodes&quot;: [&#xA;        {&#xA;          &quot;id&quot;: &quot;184&quot;&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;183&quot;&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>On the second run of my query, requesting 2 items and providing the continuation token returned in the first query, I get this exception:</p>&#xA;<blockquote>&#xA;<p>Invalid format for continuation token {&quot;V&quot;:0,&quot;Rid&quot;:&quot;&quot;,&quot;Continuation&quot;:[{&quot;token&quot;:&quot;&quot;+RID:~NVwcAObfHW0CAAAAAAAAAA==#RT:1#TRC:2#ISV:2#IEO:65567#QCF:4#FPC:AgEAAAAKAAHA/P/RQAcA2IA=&quot;&quot;,&quot;range&quot;:{&quot;min&quot;:&quot;&quot;,&quot;max&quot;:&quot;FF&quot;}}],&quot;PK&quot;:&quot;[&quot;D248E16E8CAC5276F41601BCAD91BC42&quot;]&quot;} for ParallelCrossPartitionQueryPipelineStage</p>&#xA;</blockquote>&#xA;<p>An important information: If I remove the <code>await baseQuery.CountAsync()</code> command, any query works regardless of whether I provide the continuation token or not.</p>&#xA;<p>If I create a new <code>baseQuery</code> without the continuationToken, just for running <code>CountAsync</code>, it works fine, but I would like to avoid this option as I will have more complex queries and want to avoid code duplication. Any thoughts?</p>&#xA;",17677759,,,,2021-12-14 22:17:04,CountAsync of Azure Cosmos DB SDK throwing Invalid format for continuation token,<c#><graphql><azure-cosmosdb><hotchocolate>,0,0,0,2021-12-14 22:17:04
70377662,1,,,1,581,"<p>with a simple schema like this:</p>&#xA;<pre><code>type Ticket @model{&#xA;  id: ID! @primaryKey&#xA;  title: String!&#xA;  description: String!&#xA;  state: State @default(value: &quot;new&quot;)&#xA;  priority: Priority&#xA;}&#xA;enum Priority {&#xA;  low&#xA;  medium&#xA;  high&#xA;  emergency&#xA;}&#xA;enum State {&#xA;  new&#xA;  pending&#xA;  closed&#xA;  waiting&#xA;  suspended&#xA;}&#xA;</code></pre>&#xA;<p>How can I filter my query in order to get the tickets that have <strong>priority</strong> equal &quot;low&quot; OR &quot;high&quot; and also <strong>state</strong> equal &quot;new&quot; OR &quot;waiting&quot; for example?</p>&#xA;<p>In the <a href=""https://docs.amplify.aws/cli/graphql/search-and-result-aggregations/#nested-search-conditions-and-or-not"" rel=""nofollow noreferrer"">documentation</a> there is an example for a condition with AND and OR together, but not for multiple OR.</p>&#xA;<p>Filters are provided through a JS Object, I can't use multiple <strong>OR</strong> keys in this way for example:</p>&#xA;<pre><code>let graphQLObject = {&#xA;  query: queries.listTickets,&#xA;  variables: {&#xA;    filter: {&#xA;      or: [&#xA;        { priority: {eq: &quot;low&quot;} },&#xA;        { priority: {eq: &quot;high&quot;} }&#xA;      ],&#xA;      or: [&#xA;        { state: {eq: &quot;new&quot;} },&#xA;        { state: {eq: &quot;waiting&quot;} }&#xA;      ]&#xA;    }&#xA;  }&#xA;};&#xA;await API.graphql(graphQLObject);&#xA;</code></pre>&#xA;",16592093,,,,2021-12-16 10:45:49,Multiple OR/AND filter in AWS Amplify GraphQL,<amazon-web-services><graphql><aws-amplify>,0,0,0,2021-12-16 10:45:49
70428248,1,,,2,182,"<p>I’ve got a cursor base paginated relay connection which is ordered by a startDatetime timestamp. The query looks like this;</p>&#xA;<pre><code>query UnassignedShiftsQuery($first: Int, $cursor: String) {&#xA;user {&#xA;    id&#xA;    unassignedShifts(first: $first, after: $cursor) {&#xA;      edges {&#xA;        __typename&#xA;        cursor&#xA;        node {&#xA;          ...OpenShiftFragment&#xA;        }&#xA;      }&#xA;      pageInfo {&#xA;        ...PageInfoFragment&#xA;      }&#xA;      __typename&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;${OPEN_SHIFT_FRAGMENT}&#xA;${PAGE_INFO_FRAGMENT}&#xA;</code></pre>&#xA;<p>And the relevant schema in Absinthe:</p>&#xA;<pre><code>connection(node_type: :open_shift, non_null_edges: true, non_null_edge: true) do&#xA;  edge do&#xA;    field :node, non_null(:open_shift)&#xA;  end&#xA;end&#xA;&#xA;object :user do&#xA;  field :id, non_null(:string)&#xA;  connection field :unassigned_shifts, node_type: :open_shift, non_null_connection: true do           resolve(&amp;Resolvers.Shifts.list_shifts/3)&#xA;  end&#xA;end&#xA;&#xA;object :open_shift do&#xA;  field :id, non_null(:string)&#xA;  field :start_datetime, non_null(:datetime)&#xA;end&#xA;</code></pre>&#xA;<p>And the Shifts resolver;</p>&#xA;<pre><code>def list_shifts(_parent, args, %{context: %{current_user: user}}) do&#xA;  Absinthe.Relay.Connection.from_query(&#xA;    Shifts.unassigned_shifts(user),&#xA;    &amp;get_preloaded_shifts/1,&#xA;    args&#xA;  )&#xA;end&#xA;&#xA;defp get_preloaded_shifts(query) do&#xA;  query&#xA;  |&gt; Repo.all()&#xA;  |&gt; Repo.preload([:shift_type])&#xA;end&#xA;</code></pre>&#xA;<p>Where, for the sake of brevity Shifts.unassigned_shifts could be assumed to be;</p>&#xA;<pre><code>def unassigned_shifts(user) do&#xA;  from shifts in Backend.Shifts.Shift,&#xA;    order_by: shifts.start_datetime,&#xA;    where: shifts.user_id == ^user.id&#xA;end&#xA;</code></pre>&#xA;<p>After the the initial query is rendered, the user can select an arbitrary date that they would like to jump to whist remaining in the paginated list. This thing is huge, so they may want to jump to a date and then scroll back and forth from there.</p>&#xA;<p>In subsequent queries I can pass that date in the fetchMore query, but how to I apply that in the Absinthe.Relay.Connection.from_query call in the resolver. Simplistically I’m thinking I need to take the date, turn that into a cursor and pass that cursor into the args that from_query takes, but I’m not sure if I’m on the right track or how to go about it.</p>&#xA;<p>I’m reasonably new to Elixir so haven’t been able to work this out from reading the Absinthe source so any pointers would be really helpful.</p>&#xA;<p>Thanks!</p>&#xA;",84330,,84330,2021-12-21 01:38:45,2021-12-21 01:38:45,How to jump to a specific date in a cursor based relay pagination?,<graphql><apollo><apollo-client><relay><absinthe>,0,4,0,2021-12-20 21:27:38
70439997,1,,,0,149,"<p>I'm having a problem with my implementation of the relay style pagination. I'm using MongoDB/mongoose, NestJS.</p>&#xA;<p>I implement cursor using mongodb <code>_id</code> field, so I just run a base64 encoding on the value of that document's <code>_id</code> to generate a cursor for that document in the graphql edge.</p>&#xA;<p>When the data is paginated using either <code>after</code> or <code>before</code>, I query documents that has their <code>_id</code> greater than <code>after</code> or less than <code>before</code>. <code>after</code> being the <code>endCursor</code> for the previous data in forward pagination and before being the <code>endCursor</code> for the previous data in backward pagination</p>&#xA;<p>This works fine when the query is sorted by <code>_id</code> but when it's being sorted by other fields then there's a bug which I'll explain as follows:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// documents&#xA;[&#xA;  {&#xA;    _id: 1,&#xA;    name: &quot;foo&quot;,&#xA;    age: 7&#xA;  },&#xA;  {&#xA;    _id: 2,&#xA;    name: &quot;bar&quot;,&#xA;    age: 3&#xA;  },&#xA;  {&#xA;    _id: 3,&#xA;    name: &quot;baz&quot;,&#xA;    age: 9&#xA;  },&#xA;  {&#xA;    _id: 4,&#xA;    name: &quot;raz&quot;,&#xA;    age: 6&#xA;  },&#xA;  {&#xA;    _id: 5,&#xA;    name: &quot;roo&quot;,&#xA;    age: 10&#xA;  },&#xA;]&#xA;</code></pre>&#xA;<p>Now say I have a query</p>&#xA;<pre class=""lang-js prettyprint-override""><code>async find(page: Pagination, filter?: JobFilterInput, sort?: JobSortInput) {&#xA;  const { limit, cursorQuery, isForward } = getPage(page)&#xA;  const data = await this.collection&#xA;    .find({ ...cursorQuery, ...(filter as any) })&#xA;    .limit(limit)&#xA;    .sort({ ...(sort || getSortBy(isForward)) })&#xA;    .lean()&#xA;&#xA;  return data&#xA;}&#xA;</code></pre>&#xA;<p>Now whenever I find a number of documents after a specific <code>_id</code> (or end cursor) with the <code>$gt</code> operator, since the documents are sorted by <code>_id: 'asc'</code> for forward pagination it works fine, but whenever they are sorted by other fields than <code>_id</code> the <code>$gt</code> breaks because the documents is haphazardly ordered with respect to <code>_id</code>. And this affects whatever result I get as edges and the pageInfo itself.</p>&#xA;<p>I think mongodb does find before sort so on first request say we pick first 2 sorted by age <code>desc</code>, we get:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>// initial result (first: 2, sort: { age: DESC })&#xA;[&#xA;  {&#xA;    _id: 5,&#xA;    name: &quot;roo&quot;,&#xA;    age: 10&#xA;  },&#xA;  {&#xA;    _id: 3,&#xA;    name: &quot;baz&quot;,&#xA;    age: 9&#xA;  },&#xA;]&#xA;</code></pre>&#xA;<p>This gives us an endCursor of <code>3</code> in base64 encoding. Now on next request to fetch more, we look for where <code>_id</code> greater than <code>3</code> using <code>$gt</code>, then the bug sets in because where <code>_id</code> greater than <code>3</code> starts from after <code>age: 9</code>, returning to us documents with <code>_id</code> <code>4</code> and <code>5</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>// fetch more actual result:  (first: 2, after: 3, sort: { age: DESC })&#xA;[&#xA;  {&#xA;    _id: 5,&#xA;    name: &quot;roo&quot;,&#xA;    age: 10&#xA;  },&#xA;  {&#xA;    _id: 4,&#xA;    name: &quot;raz&quot;,&#xA;    age: 6&#xA;  },&#xA;]&#xA;&#xA;// fetch more expected result:  (first: 2, after: 3, sort: { age: DESC })&#xA;[&#xA;  {&#xA;    _id: 1,&#xA;    name: &quot;foo&quot;,&#xA;    age: 7&#xA;  },&#xA;  {&#xA;    _id: 4,&#xA;    name: &quot;raz&quot;,&#xA;    age: 6&#xA;  }&#xA;]&#xA;</code></pre>&#xA;<p>Utility functions:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export const CURSOR_KEY = '_id'&#xA;&#xA;export const getSortBy = (isForward: boolean, cursorKey = CURSOR_KEY) =&gt; ({ [cursorKey]: isForward ? Sort.ASC : Sort.DESC })&#xA;&#xA;export const isForwardPage = (page: Pagination) =&gt; {&#xA;  return Boolean(page.after) || Boolean(page.first) || !(Boolean(page.before) || Boolean(page.last))&#xA;}&#xA;&#xA;export function getPage(page: Pagination, cursorKey = CURSOR_KEY): Page {&#xA;  const isForward = isForwardPage(page)&#xA;  const limit = (isForward ? page.first : page.last) ?? 20&#xA;&#xA;  if (page.first &amp;&amp; page.first &lt; 0) {&#xA;    throw new BadRequestException('Check the query `first` input. Negative value detected.')&#xA;  }&#xA;&#xA;  if (page.last &amp;&amp; page.last &lt; 0) {&#xA;    throw new BadRequestException('Check the query `last` input. Negative value detected.')&#xA;  }&#xA;&#xA;  if (typeof page.after === 'string' &amp;&amp; Boolean(page.after)) {&#xA;    const cursorQuery = createCursorQuery(page.after, isForward, cursorKey)&#xA;    return { isForward, limit, cursorQuery }&#xA;  } else if (typeof page.before === 'string' &amp;&amp; Boolean(page.before)) {&#xA;    const cursorQuery = createCursorQuery(page.before, isForward, cursorKey)&#xA;    return { isForward, limit, cursorQuery }&#xA;  }&#xA;&#xA;  return { isForward, limit }&#xA;}&#xA;&#xA;export function createCursorQuery(cursor: string, isForward: boolean, cursorKey = CURSOR_KEY) {&#xA;  if (isForward) {&#xA;    return { [cursorKey]: { $gt: new Types.ObjectId(deopacify(cursor)) as any } }&#xA;  }&#xA;&#xA;  return { [cursorKey]: { $lt: new Types.ObjectId(deopacify(cursor)) as any } }&#xA;}&#xA;&#xA;export const opacify = (value: any) =&gt; Buffer.from(value).toString('base64')&#xA;&#xA;export const deopacify = (value: any) =&gt; Buffer.from(value, 'base64').toString('utf8')&#xA;</code></pre>&#xA;",8124214,,8124214,2021-12-21 19:07:43,2021-12-21 19:07:43,Implementing the Relay style GraphQL cursor pagination with MongoDB and MongoDB _id,<javascript><mongodb><pagination><graphql>,0,0,0,2021-12-21 18:22:03
70440382,2,,70439948,1,,"<p>Data: <code>{findUser: {id: USER-14161234567}}</code></p>&#xA;<p>The <code>id</code> is not at the top level of the map, you should first get the ['findUser'] key and then the ['id'] as this is nested.</p>&#xA;<pre><code>    print(data);&#xA;    print(data['findUser']['id']);&#xA;</code></pre>&#xA;",11086844,,,,2021-12-21 18:59:16,"",,0,1,0,2021-12-21 18:59:16
70453389,1,,,4,537,"<p>I am trying to sort a Graphql Query in Directus v9 by a subfield.</p>&#xA;<p>There is a small description how to do this... but not for subfields:</p>&#xA;<p><a href=""https://docs.directus.io/reference/query/#sort"" rel=""nofollow noreferrer"">https://docs.directus.io/reference/query/#sort</a></p>&#xA;<p>my query looks like this:</p>&#xA;<pre><code>query {&#xA;  invoices(sort: [&quot;customer__name&quot;] ) {&#xA;    id&#xA;    status&#xA;    customer {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I have tried multiple forms like <code>customer:name</code>, ```customer_name``.</p>&#xA;<p>if i sort by field &quot;status&quot; in ascending order the query looks like this and it works:</p>&#xA;<pre><code>query {&#xA;  invoices(sort: [&quot;status&quot;] ) {&#xA;    id&#xA;    status&#xA;    customer {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>if i sort by field &quot;status&quot; in descending order the query looks like this and it works:</p>&#xA;<pre><code>query {&#xA;  invoices(sort: [&quot;-status&quot;] ) {&#xA;    id&#xA;    status&#xA;    customer {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>has anyone tried this?</p>&#xA;",17742850,,,,2022-05-27 14:37:33,Is it able to sort by subfields in directus v9 Graphql Query,<graphql><directus>,1,2,0,2021-12-22 18:08:41
70486558,1,,,0,144,"<p>I have the following GraphQL query which returns me the information from Cloudflare's analytics dashboard like cachedBytes, cachedRequests.</p>&#xA;<pre><code>query {&#xA;  viewer {&#xA;    zones(filter: {zoneTag: &quot;%s&quot;}) {&#xA;      httpRequests1dGroups(orderBy: [date_ASC], limit: 100, filter: {date_geq: &quot;2021-11-24&quot;, date_lt: &quot;2021-12-24&quot;}) {&#xA;        dimensions {&#xA;          date&#xA;        }&#xA;        sum {&#xA;          bytes&#xA;          cachedBytes&#xA;          cachedRequests&#xA;          contentTypeMap {&#xA;            bytes&#xA;            requests&#xA;            edgeResponseContentTypeName&#xA;          }&#xA;          requests&#xA;&#xA;        }&#xA;        uniq {&#xA;          uniques&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Does anybody know how to retrieve DNS query information from a Cloudflare zone?</p>&#xA;",17755924,,,,2021-12-27 09:33:27,Retrieve DNS query information from a Cloudflare zone using GraphQL,<python><graphql><cloudflare>,1,0,0,2021-12-26 12:46:53
70490899,1,70494778,,0,206,"<p>In .NET C#, we used Odata to filter, page, sort the database results from SQL database. Odata in .NET would actually go into the database, and query WHERE, ORDER By Filters to database, instead of extracting all the database results, and applying filtering on the api memory.</p>&#xA;<p>I am curious if GraphQL, queries the database internally or applies filtering on the API memory set.</p>&#xA;<p><strong>Resource:</strong></p>&#xA;<p><a href=""https://graphql.org/"" rel=""nofollow noreferrer"">https://graphql.org/</a></p>&#xA;",15435022,,,,2021-12-27 11:19:27,Does Graphql query the database itself?,<java><spring-boot><graphql><odata>,1,1,0,2021-12-27 01:09:36
70501642,1,70510289,,0,90,"<p>I'm wrote and tested a query to retrieve the documents and it works just fine it gets exactly what I asked for and when I take out each of the filters it retrieves the corrent documents. Now instead of manually commenting each filter I want to base it on the index as it goes down, so at <code>index = 4</code> it should use all filters and at <code>index = 3</code> it should use one less filter until at <code>index = 0</code> where it should just get the documents.</p>&#xA;<p>The code that works just fine:</p>&#xA;<pre><code>    users = await User.find({&#xA;      $and: ignoreUsers.map((id) =&gt; {&#xA;        return { _id: { $ne: new ObjectId(id) } };&#xA;      }),&#xA;      objectives: { $in: objectives },&#xA;      ranking: ranking,&#xA;      expLevel: { $gte: expLevel - 1, $lte: expLevel + 1 },&#xA;      industries: { $in: industries },&#xA;      &quot;skills.self&quot;: { $in: skills },&#xA;      interests: { $in: interests },&#xA;    });&#xA;</code></pre>&#xA;<p>This produces 1 document which is correct, however when I add the if conditions it produces 5 documents which is not corrent. The <code>ranking.&lt;variable&gt;</code> are numbers 1-4 so if the <code>index = 4</code> then all the if conditions should be true right? but none of them are being executed. only the objectives and ranking filters work, the whole <code>$expr</code> conditions are being ignored</p>&#xA;<pre><code>        let index = 4;&#xA;&#xA;        // supposed to be in while loop but testing just once does not produce just the 1 document it's supposed to&#xA;&#xA;        const fetchCondUsers = await User.find({&#xA;          $and: ignoreUsers.map((id) =&gt; {&#xA;            return { _id: { $ne: new ObjectId(id) } };&#xA;          }),&#xA;          objectives: { $in: objectives },&#xA;          &#xA;          $expr: {&#xA;            $cond: {&#xA;              if: { $gte: [index, 0] },&#xA;              then: {&#xA;                ranking: ranking,&#xA;              },&#xA;              else: &quot;$$REMOVE&quot;,&#xA;            },&#xA;            $cond: {&#xA;              if: { $gte: [index, ranking.expLevel] },&#xA;              then: {&#xA;                $and: [&#xA;                  { $gte: [&quot;$expLevel&quot;, expLevel - 1] },&#xA;                  { $lte: [&quot;$expLevel&quot;, expLevel + 1] },&#xA;                ],&#xA;              },&#xA;              else: &quot;$$REMOVE&quot;,&#xA;            },&#xA;            $cond: {&#xA;              if: { $gte: [index, ranking.industry] },&#xA;              then: {&#xA;                industries: { $in: [&quot;$industries&quot;, industries] },&#xA;              },&#xA;              else: &quot;$$REMOVE&quot;,&#xA;            },&#xA;            $cond: {&#xA;              if: { $gte: [index, ranking.skills] },&#xA;              then: {&#xA;                skills: { $in: [&quot;$skills&quot;, skills] },&#xA;              },&#xA;              else: &quot;$$REMOVE&quot;,&#xA;            },&#xA;            $cond: {&#xA;              if: { $gte: [index, ranking.interests] },&#xA;              then: {&#xA;                interests: { $in: [&quot;$interests&quot;, interests] },&#xA;              },&#xA;              else: &quot;$$REMOVE&quot;,&#xA;            },&#xA;          },&#xA;        }).limit(limit);&#xA;</code></pre>&#xA;<p>Ideally this is what I'm trying to do</p>&#xA;<pre><code>      users = await User.find({&#xA;        $and: ignoreUsers.map((id) =&gt; {&#xA;          return { _id: { $ne: new ObjectId(id) } };&#xA;        }),&#xA;        objectives: { $in: objectives },&#xA;        if (index === 0) ranking: ranking,&#xA;        if (index === 1) expLevel: { $gte: expLevel - 1, $lte: expLevel + 1 },&#xA;        if (index === 2) industries: { $in: industries },&#xA;        if (index === 3) &quot;skills.self&quot;: { $in: skills },&#xA;        if (index === 4) interests: { $in: interests },&#xA;      });&#xA;</code></pre>&#xA;",7675202,,7675202,2021-12-28 16:19:48,2021-12-28 17:09:01,MongoDB - find() with 5 filters and conditions gives different results than no conditions,<mongodb><mongoose><graphql><apollo>,1,0,0,2021-12-28 00:20:04
70521100,1,70521367,,1,33,"<blockquote>&#xA;<p>Here's the some code i try what I did</p>&#xA;</blockquote>&#xA;<pre><code>  deleteajobewith_events(event){&#xA;&#xA;     const data =event.store.readQuery({&#xA;        query: ClientJobesList,&#xA;        variables: {id:1} &#xA;      });&#xA;    data.client.jobes.filter(jobee=&gt;jobee.id != 101);&#xA;&#xA;    console.log(data);&#xA;    event.store.writeQuery({ query: ClientJobesList, data});&#xA; }&#xA;</code></pre>&#xA;<blockquote>&#xA;<p>If I console log the 'data', it shows the same data without filtering</p>&#xA;</blockquote>&#xA;<p><strong>this is a hint about the 'data' object</strong></p>&#xA;<pre><code> {&#xA; &quot;data&quot;: {&#xA;&quot;client&quot;: {&#xA;  &quot;id&quot;: &quot;1&quot;,&#xA;  &quot;client_name&quot;: &quot;Marouane&quot;,&#xA;  &quot;jobes&quot;: [&#xA;    {&#xA;      &quot;id&quot;: &quot;101&quot;,&#xA;      &quot;title&quot;: &quot;cbkvjk&quot;,&#xA;      &quot;order&quot;: 88,&#xA;      &quot;client_id&quot;: &quot;1&quot;&#xA;    },&#xA;  .........&#xA;    ]&#xA;  }&#xA;}&#xA;}&#xA;</code></pre>&#xA;",13110384,,11989189,2022-04-18 18:40:43,2022-04-18 18:40:43,vue filtering method how it works,<javascript><vue.js><graphql><apollo>,2,0,0,2021-12-29 14:57:38
70524028,1,71672490,,5,4638,"<p>I get the error below when I add <strong>'graphene_django'</strong> inside <em><strong>INSTALLED_APPS</strong></em> in the settings.py.</p>&#xA;<p>After running</p>&#xA;<pre><code>python3 manage.py runserver&#xA;</code></pre>&#xA;<p>graphene_django is installed successfully using</p>&#xA;<pre><code>pip install django graphene_django&#xA;</code></pre>&#xA;<p>This is full error that I get:</p>&#xA;<pre><code>Watching for file changes with StatReloader&#xA;Exception in thread django-main-thread:&#xA;Traceback (most recent call last):&#xA;  File &quot;/usr/local/Cellar/python@3.9/3.9.9/Frameworks/Python.framework/Versions/3.9/lib/python3.9/threading.py&quot;, line 973, in _bootstrap_inner&#xA;    self.run()&#xA;  File &quot;/usr/local/Cellar/python@3.9/3.9.9/Frameworks/Python.framework/Versions/3.9/lib/python3.9/threading.py&quot;, line 910, in run&#xA;    self._target(*self._args, **self._kwargs)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/autoreload.py&quot;, line 64, in wrapper&#xA;    fn(*args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/core/management/commands/runserver.py&quot;, line 115, in inner_run&#xA;    autoreload.raise_last_exception()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/autoreload.py&quot;, line 87, in raise_last_exception&#xA;    raise _exception[1]&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py&quot;, line 381, in execute&#xA;    autoreload.check_errors(django.setup)()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/autoreload.py&quot;, line 64, in wrapper&#xA;    fn(*args, **kwargs)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/__init__.py&quot;, line 24, in setup&#xA;    apps.populate(settings.INSTALLED_APPS)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/apps/registry.py&quot;, line 91, in populate&#xA;    app_config = AppConfig.create(entry)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/apps/config.py&quot;, line 223, in create&#xA;    import_module(entry)&#xA;  File &quot;/usr/local/Cellar/python@3.9/3.9.9/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py&quot;, line 127, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1030, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1007, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 680, in _load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 850, in exec_module&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 228, in _call_with_frames_removed&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene_django/__init__.py&quot;, line 1, in &lt;module&gt;&#xA;    from .fields import DjangoConnectionField, DjangoListField&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene_django/fields.py&quot;, line 18, in &lt;module&gt;&#xA;    from .utils import maybe_queryset&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene_django/utils/__init__.py&quot;, line 2, in &lt;module&gt;&#xA;    from .utils import (&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene_django/utils/utils.py&quot;, line 6, in &lt;module&gt;&#xA;    from django.utils.encoding import force_text&#xA;ImportError: cannot import name 'force_text' from 'django.utils.encoding' (/usr/local/lib/python3.9/site-packages/django/utils/encoding.py)&#xA;</code></pre>&#xA;<p>Any idea on what's going wrong here?</p>&#xA;",7444273,,8172439,2022-02-25 08:24:23,2022-04-09 12:58:21,ImportError: cannot import name 'force_text' from 'django.utils.encoding' (/usr/local/lib/python3.9/site-packages/django/utils/encoding.py),<python><python-3.x><django><graphql><graphene-django>,4,3,0,2021-12-29 19:20:06
70534052,2,,70533244,1,,"<p>Min &amp; Max prices are within the retailPriceRange object, unded Product &gt; Prices &gt; retailPriceRange! You can see this from the <a href=""https://developer.bigcommerce.com/graphql-explorer"" rel=""nofollow noreferrer"">GraphQL Explorer</a> :)&#xA;Something like this ...</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>{&#xA;...&#xA;prices {&#xA;        price {&#xA;           value&#xA;           currencyCode&#xA;        }&#xA;        priceRange {&#xA;          min {&#xA;            value&#xA;            currencyCode&#xA;          }&#xA;          max {&#xA;            value&#xA;            currencyCode&#xA;          }&#xA;        }&#xA;...&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p><a href=""https://i.stack.imgur.com/InjJU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/InjJU.png"" alt=""enter image description here"" /></a></p>&#xA;",14810188,,14810188,2021-12-30 17:00:30,2021-12-30 17:00:30,"",,0,1,0,2021-12-30 16:12:32
70538891,1,,,0,101,<p>Quick Question. I am implementing multiple files upload using ReactJs. Is there anyway to zip the files programmatically in to one before uploading and storing in backend ? In my use case I need the files to be stored as zip.</p>&#xA;<p>I don't know where to start. So no code to add here :(</p>&#xA;<p>Help would be much appreciated.</p>&#xA;,3160351,,,,2021-12-31 04:04:16,React: Zip multiple files before upload using Graphql,<node.js><reactjs><react-native><graphql><apollo-client>,0,1,0,2021-12-31 04:04:16
70558611,1,,,0,319,"<p>I am trying to set up a search page with multiple inputs users can filter/order by. Is there a standard way to programmatically combine the user's selections? For example, I have one query that can query for items with a <code>timestamp</code> property greater than a variable argument, and I have another query that fetches all items and sorts them by another field. In the UI, users have the ability to turn these filters on or off, or select different options to filter by. Right now I am combining them by using string interpolation, to make a big string based on various react state values, and also making a variables object based on the same state values, but I am wondering if there is a cleaner way to do this, as it is quickly becoming a bit of a mess.</p>&#xA;<p>For clarification, on its own, one query looks like this:</p>&#xA;<pre><code>export const ITEMS_WITH_TIMESTAMP_GT = gql`&#xA;    query getItemsWithTimestampGreaterThan($x: Int!) {&#xA;        items(where: { timestamp_gt: $x }) {&#xA;            id&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>and another which, on its own, looks like this:</p>&#xA;<pre><code>export const ITEMS_BY_AMOUNT = gql`&#xA;    query getItemsByAmount {&#xA;        items(orderBy: amount, orderDirection: desc) {&#xA;            id&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>Currently my attempt to combine them together looks like this (selectByTimestamp and orderByAmount are react state values, booleans turned on or off in the ui)</p>&#xA;<pre><code>const queryString = gql`&#xA;    combinedQuery${selectByTimestamp ? &quot;($timestamp: Int!)&quot; : &quot;&quot;} {&#xA;        items(${selectByTimestamp ? &quot;where: {timestamp_gt: $timestamp}&quot; : &quot;&quot;}${orderByAmount ? &quot;, orderBy: amount&quot; : &quot;&quot;}) {&#xA;            id&#xA;        }&#xA;    }&#xA;`&#xA;</code></pre>&#xA;<p>With just these two queries its already getting pretty messy. There are also other search filters, and since users can select to use them or not use them, I can't just merge them into one big hardcoded query. Will I need to make a query string for every possible combination of them?</p>&#xA;",11204012,,,,2022-01-02 18:22:32,How to programmatically combine multiple graphql queries,<reactjs><graphql><apollo><gql>,0,2,0,2022-01-02 18:22:32
70585823,1,70587724,,2,1909,"<p>Basically, I have a table with two indexes that I'm trying to query and filter.&#xA;The querying part works for the Table and the index but the problem happens when I try to filter:</p>&#xA;<pre><code>ValidationException: Can not use both expression and non-expression parameters in the same request: Non-expression parameters: {QueryFilter} Expression parameters: {KeyConditionExpression}&#xA;</code></pre>&#xA;<p>Here are the params passed to docClient.query():</p>&#xA;<pre><code>{&#xA;  TableName: 'MyTable',&#xA;  Limit: 15,&#xA;  ScanIndexForward: false,&#xA;  IndexName: 'user-date-index',&#xA;  KeyConditionExpression: '#user = :yyyy',&#xA;  ExpressionAttributeNames: { '#user': 'user' },&#xA;  ExpressionAttributeValues: { ':yyyy': 'the_user_id' },&#xA;  QueryFilter: { status: { AttributeValueList: [Array], ComparisonOperator: 'EQ' } }&#xA;}&#xA;</code></pre>&#xA;<p>When I call the query with the same params but without the QueryFilter, I get correct results, but I still need to filter (by status in this case, and I have about 5 other options to filter with).</p>&#xA;<p>I've spent a few hours trying different things and the AWS docs are not clear enough and no examples are presented, I've spent a whole day to even get to that point.</p>&#xA;",3812411,,,,2022-01-05 04:13:34,Can not use both expression and non-expression parameters in the same request,<amazon-web-services><graphql><dynamodb-queries>,1,0,0,2022-01-04 22:34:22
70593759,1,70593801,,2,943,"<p>I am new in graphql query . I am getting this error <strong>unknown type error i</strong></p>&#xA;<p>I am hitting this API</p>&#xA;<p>My query is</p>&#xA;<pre><code>query getCallLogsForLawyer(&#xA;  $endDate: end_date!&#xA;  $limit: limit!&#xA;  $page: page!&#xA;  $startDate: start_date!&#xA;  $userId: user_id!&#xA;) {&#xA;  getCallLogsForLawyer(&#xA;    end_date: $endDate&#xA;    limit: $limit&#xA;    page: $page&#xA;    start_date: $startDate&#xA;    user_id: $userId&#xA;  ) {&#xA;    _id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>my variable is this</p>&#xA;<pre><code>{&#xA;   &quot;endDate&quot;:&quot;Mon Jan 10 2022&quot;,&#xA;   &quot;limit&quot;:100101010,&#xA;   &quot;page&quot;:1,&#xA;   &quot;startDate&quot;:&quot;Tue Nov 02 2021&quot;,&#xA;   &quot;userId&quot;:&quot;614eb5ef2a89b6fd69fc5ab7&quot;&#xA;}&#xA;</code></pre>&#xA;<p>My api Schema is this&#xA;<a href=""https://i.stack.imgur.com/wiW7q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wiW7q.png"" alt=""enter image description here"" /></a></p>&#xA;",5711656,,,,2022-01-05 13:37:07,unknown type error in graphql query while fetching content?,<javascript><reactjs><graphql><graphql-js>,1,0,0,2022-01-05 13:34:01
70593801,2,,70593759,2,,"<p>Your types are wrong, according to your schema, it should be -</p>&#xA;<pre><code>query getCallLogsForLawyer(&#xA;  $endDate: String!&#xA;  $limit: Float!&#xA;  $page: String!&#xA;  $startDate: Float!&#xA;  $userId: Float!&#xA;) {&#xA;  getCallLogsForLawyer(&#xA;    end_date: $endDate&#xA;    limit: $limit&#xA;    page: $page&#xA;    start_date: $startDate&#xA;    user_id: $userId&#xA;  ) {&#xA;    _id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1849358,,,,2022-01-05 13:37:07,"",,0,0,0,2022-01-05 13:37:07
70609203,2,,70608748,0,,"<p>Well, you need to add <code>.flat()</code> after the <code>.map(...)</code>.</p>&#xA;<p>Or you can use <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"" rel=""nofollow noreferrer"">reduce</a> method to accumulate the result.</p>&#xA;",8416201,,,,2022-01-06 15:08:48,"",,0,0,0,2022-01-06 15:08:48
70622716,2,,55151128,0,,"<p>If you're trying to query or mutate based on conditions you need to use some condition clauses seen <a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#filtering-queries"" rel=""nofollow noreferrer"">here</a>. For example, your code should look something like this:</p>&#xA;<pre><code>        await client.mutate({&#xA;            mutation: query,&#xA;            variables: {&#xA;                   input: {&#xA;                       RekognitionId: {eq: inputObj.RekognitionId},&#xA;                       Emotion: {eq: []}&#xA;                   }&#xA;            },&#xA;            fetchPolicy: 'no-cache'&#xA;        }).then(function logData(data) {&#xA;            console.log('LAMBDA results of query: ', data);&#xA;            callback(data);&#xA;        })&#xA;        .catch((error)=&gt;{&#xA;            console.log('LAMBDA ERROR:', error);&#xA;            callback(error);&#xA;        });&#xA;</code></pre>&#xA;<p>The 'Map' error is kind of dumb in my opinion, it doesn't give you much to work with. This error may refer to other issues as well, but it seems that most of these issues are with the conditions.</p>&#xA;",11255886,,1839439,2022-01-07 14:35:23,2022-01-07 14:35:23,"",,0,0,0,2022-01-07 14:30:19
70625115,1,,,0,28,"<p>Consider following documents:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>[&#xA;  {&#xA;    &quot;Book&quot;: &quot;Book A&quot;,&#xA;    &quot;Authors&quot;: [{&quot;Name&quot;: &quot;Author A&quot;, &quot;Age&quot;: 25} , {&quot;Name&quot;: &quot;Author B&quot;, &quot;Age&quot;: 27}]&#xA;  },&#xA;  {&#xA;    &quot;Book&quot;: &quot;Book B&quot;,&#xA;    &quot;Authors&quot;: [{&quot;Name&quot;: &quot;Author C&quot;, &quot;Age&quot;: 22} , {&quot;Name&quot;: &quot;Author D&quot;, &quot;Age&quot;: 66}]&#xA;  },&#xA;  {&#xA;    &quot;Book&quot;: &quot;Book C&quot;,&#xA;    &quot;Authors&quot;: [{&quot;Name&quot;: &quot;Author A&quot;, &quot;Age&quot;: 25} , {&quot;Name&quot;: &quot;Author E&quot;, &quot;Age&quot;: 46}, {&quot;Name&quot;: &quot;Author F&quot;, &quot;Age&quot;: 88}]&#xA;  }&#xA;]&#xA;</code></pre>&#xA;<p>Now I want to query all books that has author name <code>Author A</code> or <code>Author D</code>. This is how I would create a query in mongodb flawor:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>db.collection(&quot;Books&quot;)&#xA;  .find({ &quot;Authors&quot;: { &quot;$elemMatch&quot;: { &quot;Name&quot; { &quot;$in&quot; : [&quot;Author A&quot;, &quot;Author D&quot;] } } } })&#xA;</code></pre>&#xA;<p>Array where <code>$in</code> applies may be large enough (up to 100 entities) so ORing all varians isn't really feasible.</p>&#xA;<p>Is there any way this can be translated into graph query language?</p>&#xA;<pre class=""lang-json prettyprint-override""><code>query {&#xA;  books(filter: ??? ) {&#xA;    name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Important part is I do not own GQL server side and I'm only consuming an existing one</p>&#xA;",2559709,,2559709,2022-01-07 18:13:10,2022-01-07 18:13:10,Filter documents by nested entities in GraphQL,<graphql>,1,1,0,2022-01-07 17:37:57
70628426,1,,,0,335,"<p>A returned data object looks like the following:</p>&#xA;<pre><code>{&#xA;  data: {&#xA;    posts: {&#xA;      edges: [&#xA;        {&#xA;          post: {&#xA;            id: &quot;1&quot;,&#xA;            title: &quot;Foo&quot;&#xA;          }&#xA;        },&#xA;        {&#xA;          post: {&#xA;            id: &quot;2&quot;,&#xA;            title: &quot;Bar&quot;&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is based on the following query:</p>&#xA;<pre><code>    query MyQuery {&#xA;      posts {&#xA;        edges {&#xA;          post: node {&#xA;            id&#xA;            title&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>This works and I can use it, but I’m having to create nested interfaces, unfortunately.</p>&#xA;<p>Question: <strong>Can I either simplify the returned results OR transform them with JavaScript <code>map()</code>?</strong></p>&#xA;<p>Ideally, I’d like for the GQL response (or resulting object) to be like:</p>&#xA;<pre><code>{&#xA;  data: {&#xA;    posts: [&#xA;      {&#xA;        id: &quot;1&quot;,&#xA;        title: &quot;Foo&quot;&#xA;      },&#xA;      {&#xA;        id: &quot;2&quot;,&#xA;        title: &quot;Bar&quot;&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Note:</strong> I do not have the ability to update the server-side GraphQL schema. The solution must be client/consumer side.</p>&#xA;<p>Thanks!</p>&#xA;<h2>EDIT</h2>&#xA;<p>Adding my Angular/TS code that calls and processes the GraphQL...</p>&#xA;<h3>post.service.ts</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';&#xA;import { Apollo, gql } from 'apollo-angular';&#xA;import { map, Observable } from 'rxjs';&#xA;import { GraphQLResponse } from 'src/app/core/types/graphQLResponse';&#xA;import { Post } from '../models/post';&#xA;&#xA;export interface PostResponse {&#xA;  edges: Post[]&#xA;  pageInfo: {&#xA;    startCursor: string&#xA;    hasPreviousPage: boolean&#xA;    hasNextPage: boolean&#xA;    endCursor: string&#xA;  }&#xA;}&#xA;&#xA;export const getPostsQuery = gql`&#xA;  query getPostsQuery {&#xA;    posts {&#xA;      edges {&#xA;        post: node {&#xA;          id&#xA;          title&#xA;          date&#xA;          uri&#xA;          categories {&#xA;            edges {&#xA;              category: node {&#xA;                id&#xA;                name&#xA;                uri&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;        cursor&#xA;      }&#xA;      pageInfo {&#xA;        startCursor&#xA;        hasPreviousPage&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;@Injectable({&#xA;  providedIn: 'root'&#xA;})&#xA;export class PostService {&#xA;&#xA;  constructor(private apollo: Apollo) { }&#xA;&#xA;  public getPosts(): Observable&lt;PostResponse&gt; {&#xA;   &#xA;    return this.apollo.query&lt;GraphQLResponse&lt;'posts', PostResponse&gt;&gt;({&#xA;      query: getPostsQuery&#xA;    }).pipe(map(resp =&gt; resp.data.posts));&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<h3>model/post.ts</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>interface CategoryNode {&#xA;    id: string;&#xA;    name: string;&#xA;    uri: string;&#xA;}&#xA;&#xA;interface Category {&#xA;    category: CategoryNode;&#xA;}&#xA;&#xA;interface CategoryEdges{&#xA;    edges: Category[];&#xA;}&#xA;&#xA;interface PostNode {&#xA;    id: string;&#xA;    title: string;&#xA;    date: string;&#xA;    uri: string;&#xA;    categories: CategoryEdges;&#xA;}&#xA;&#xA;export interface Post {&#xA;    article: PostNode;&#xA;    cursor: string;&#xA;}&#xA;</code></pre>&#xA;<p>As you can see, way too many nested interfaces.</p>&#xA;<h3>Actual sample response (used for unit testing)</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>      {&#xA;        data: {&#xA;          posts: {&#xA;            edges : [&#xA;              {&#xA;                post: {&#xA;                  id: &quot;cG9zdDoxMjc=&quot;,&#xA;                  title: &quot;Lorem Ipsum&quot;,&#xA;                  date: &quot;2022-01-06T22:00:53&quot;,&#xA;                  uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;                  categories: {&#xA;                    edges: [&#xA;                      {&#xA;                        category: {&#xA;                          id: &quot;dGVybToy&quot;,&#xA;                          name: &quot;General&quot;,&#xA;                          uri: &quot;\/category\/general\/&quot;&#xA;                        }&#xA;                      }&#xA;                    ]&#xA;                  }&#xA;                },&#xA;                cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;              },&#xA;              {&#xA;                post: {&#xA;                  id: &quot;cG9zdDoxMjc=&quot;,&#xA;                  title: &quot;Lorem Ipsum&quot;,&#xA;                  date: &quot;2022-01-06T22:00:53&quot;,&#xA;                  uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;                  categories: {&#xA;                    edges: [&#xA;                      {&#xA;                        category: {&#xA;                          id: &quot;dGVybToy&quot;,&#xA;                          name: &quot;General&quot;,&#xA;                          uri: &quot;\/category\/general\/&quot;&#xA;                        }&#xA;                      },&#xA;                      {&#xA;                        category: {&#xA;                          id: &quot;dGVybToy&quot;,&#xA;                          name: &quot;General&quot;,&#xA;                          uri: &quot;\/category\/general\/&quot;&#xA;                        }&#xA;                      }&#xA;                    ]&#xA;                  }&#xA;                },&#xA;                cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;              },&#xA;            ],&#xA;            pageInfo: {&#xA;              startCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;,&#xA;              hasPreviousPage: false,&#xA;              hasNextPage: false,&#xA;              endCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;            }       &#xA;          }&#xA;        }&#xA;      }; &#xA;</code></pre>&#xA;<pre><code></code></pre>&#xA;",916995,,916995,2022-01-08 03:33:38,2022-01-08 05:32:36,Need help transforming GraphQL results,<javascript><angular><typescript><graphql><apollo>,2,8,0,2022-01-07 23:52:02
70629861,2,,70628426,0,,"<p>I ended up using nested <code>map()</code>'ing to transform the GraphQL response to a &quot;cleaner&quot; object.</p>&#xA;<p>Below is my final code, if anyone has the same question/issue.</p>&#xA;<p><strong>NOTE:</strong> In the code below I'm using &quot;articles&quot; instead of &quot;posts,&quot; but it's the same concept.</p>&#xA;<h3>models/article-gql.ts</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>interface GqlCategoryNode {&#xA;    category: {&#xA;        id: string;&#xA;        name: string;&#xA;        uri: string;&#xA;    };&#xA;}&#xA;&#xA;interface GqlArticleNode {&#xA;    article: {&#xA;        id: string;&#xA;        title: string;&#xA;        date: string;&#xA;        uri: string;&#xA;        categories: {&#xA;            edges: GqlCategoryNode[]&#xA;        };&#xA;    };&#xA;    cursor: string;&#xA;}&#xA;&#xA;export interface GqlArticleResponse {&#xA;    edges: GqlArticleNode[]&#xA;    pageInfo: {&#xA;        startCursor: string&#xA;        hasPreviousPage: boolean&#xA;        hasNextPage: boolean&#xA;        endCursor: string&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<h3>models/article.ts</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>interface Category {&#xA;    id: string;&#xA;    name: string;&#xA;    uri: string;&#xA;}&#xA;&#xA;export interface Article {&#xA;    id: string;&#xA;    title: string;&#xA;    date: string;&#xA;    uri: string;&#xA;    categories: Category[];&#xA;    cursor: string;&#xA;}&#xA;&#xA;export interface PageInfo {&#xA;    startCursor: string;&#xA;    hasPreviousPage: boolean;&#xA;    hasNextPage: boolean;&#xA;    endCursor: string;&#xA;}&#xA;</code></pre>&#xA;<h3>article.service.ts</h3>&#xA;<pre class=""lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';&#xA;import { Apollo, gql } from 'apollo-angular';&#xA;import { map, Observable } from 'rxjs';&#xA;import { GraphQLResponse } from 'src/app/core/types/graphQLResponse';&#xA;import { Article, PageInfo } from '../models/article';&#xA;import { GqlArticleResponse } from '../models/article-gql';&#xA;&#xA;export const getArticlesQuery = gql`&#xA;  query getArticlesQuery {&#xA;    articles: posts {&#xA;      edges {&#xA;        article: node {&#xA;          id&#xA;          title&#xA;          date&#xA;          uri&#xA;          categories {&#xA;            edges {&#xA;              category: node {&#xA;                id&#xA;                name&#xA;                uri&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;        cursor&#xA;      }&#xA;      pageInfo {&#xA;        startCursor&#xA;        hasPreviousPage&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;@Injectable({&#xA;  providedIn: 'root'&#xA;})&#xA;export class ArticleService {&#xA;&#xA;  constructor(private apollo: Apollo) { }&#xA;&#xA;  public getArticles(): Observable&lt;[PageInfo, Article[]]&gt; {&#xA;    return this.apollo.query&lt;GraphQLResponse&lt;'articles', GqlArticleResponse&gt;&gt;({&#xA;      query: getArticlesQuery&#xA;    }).pipe(map(resp =&gt; {&#xA;      return [&#xA;        resp.data.articles.pageInfo as PageInfo,&#xA;        resp.data.articles.edges.map((articleNode) =&gt; {&#xA;        return {&#xA;          id: articleNode.article.id,&#xA;          title: articleNode.article.title,&#xA;          date: articleNode.article.date,&#xA;          uri: articleNode.article.uri,&#xA;          cursor: articleNode.cursor,&#xA;          categories: articleNode.article.categories.edges.map((categoryNode) =&gt; {&#xA;            return {&#xA;              id: categoryNode.category.id,&#xA;              name: categoryNode.category.name,&#xA;              uri: categoryNode.category.uri&#xA;            }&#xA;          })&#xA;        }&#xA;      })]&#xA;    })) as Observable&lt;[PageInfo, Article[]]&gt;;&#xA;  }&#xA;&#xA;}&#xA;</code></pre>&#xA;<h3>article.service.spec.ts</h3>&#xA;<p>Below you will notice that I'm transforming the <em>server</em> response within the service and testing the response from the service to ensure it was transformed as expected.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>import { TestBed } from '@angular/core/testing';&#xA;import { Apollo } from 'apollo-angular';&#xA;import { ApolloTestingController, ApolloTestingModule } from 'apollo-angular/testing';&#xA;import { Article, PageInfo } from '../models/article';&#xA;import { GqlArticleResponse } from '../models/article-gql';&#xA;import { ArticleService, getArticlesQuery } from './article.service';&#xA;&#xA;&#xA;describe('ArticleService', () =&gt; {&#xA;  let service: ArticleService;&#xA;  let controller: ApolloTestingController;&#xA;&#xA;  beforeEach(() =&gt; {&#xA;    TestBed.configureTestingModule({&#xA;      imports: [&#xA;        ApolloTestingModule,&#xA;      ],&#xA;      providers: [&#xA;        ArticleService&#xA;      ]&#xA;    });&#xA;    service = TestBed.inject(ArticleService);&#xA;    controller = TestBed.inject(ApolloTestingController);&#xA;  });&#xA;&#xA;  afterEach(async () =&gt; {&#xA;    const apolloClient = TestBed.inject(Apollo).client;&#xA;    await apolloClient.clearStore();&#xA;  })&#xA;&#xA;  it('should be created', () =&gt; {&#xA;    expect(service).toBeTruthy();&#xA;  });&#xA;&#xA;  it('should return a list of articles', (done) =&gt; {&#xA;    const mockArticlesServerResponse: GqlArticleResponse = {&#xA;      edges: [&#xA;        {&#xA;          article: {&#xA;            id: &quot;cG9zdDoxMjc=&quot;,&#xA;            title: &quot;Lorem Ipsum&quot;,&#xA;            date: &quot;2022-01-06T22:00:53&quot;,&#xA;            uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;            categories: {&#xA;              edges: [&#xA;                {&#xA;                  category: {&#xA;                    id: &quot;dGVybToy&quot;,&#xA;                    name: &quot;General&quot;,&#xA;                    uri: &quot;\/category\/general\/&quot;&#xA;                  }&#xA;                }&#xA;              ]&#xA;            }&#xA;          },&#xA;          cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;        },&#xA;        {&#xA;          article: {&#xA;            id: &quot;cG9zdDoxMjc=&quot;,&#xA;            title: &quot;Lorem Ipsum&quot;,&#xA;            date: &quot;2022-01-06T22:00:53&quot;,&#xA;            uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;            categories: {&#xA;              edges: [&#xA;                {&#xA;                  category: {&#xA;                    id: &quot;dGVybToy&quot;,&#xA;                    name: &quot;General&quot;,&#xA;                    uri: &quot;\/category\/general\/&quot;&#xA;                  }&#xA;                },&#xA;                {&#xA;                  category: {&#xA;                    id: &quot;dGVybToy&quot;,&#xA;                    name: &quot;Something&quot;,&#xA;                    uri: &quot;\/category\/general\/&quot;&#xA;                  }&#xA;                }&#xA;              ]&#xA;            }&#xA;          },&#xA;          cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;        }&#xA;      ],&#xA;      pageInfo: {&#xA;        startCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;,&#xA;        hasPreviousPage: false,&#xA;        hasNextPage: false,&#xA;        endCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;      }&#xA;    };&#xA;&#xA;    const mockArticlesServiceResponse: [PageInfo, Article[]] = [&#xA;      {&#xA;        startCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;,&#xA;        hasPreviousPage: false,&#xA;        hasNextPage: false,&#xA;        endCursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;      },&#xA;      [&#xA;        {&#xA;          id: &quot;cG9zdDoxMjc=&quot;,&#xA;          title: &quot;Lorem Ipsum&quot;,&#xA;          date: &quot;2022-01-06T22:00:53&quot;,&#xA;          uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;          categories: [&#xA;            {&#xA;              id: &quot;dGVybToy&quot;,&#xA;              name: &quot;General&quot;,&#xA;              uri: &quot;\/category\/general\/&quot;&#xA;            }&#xA;          ],&#xA;          cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;        },&#xA;        {&#xA;          id: &quot;cG9zdDoxMjc=&quot;,&#xA;          title: &quot;Lorem Ipsum&quot;,&#xA;          date: &quot;2022-01-06T22:00:53&quot;,&#xA;          uri: &quot;\/2022\/01\/06\/lorem-ipsum\/&quot;,&#xA;          categories: [&#xA;            {&#xA;              id: &quot;dGVybToy&quot;,&#xA;              name: &quot;General&quot;,&#xA;              uri: &quot;\/category\/general\/&quot;&#xA;            },&#xA;            {&#xA;              id: &quot;dGVybToy&quot;,&#xA;              name: &quot;Something&quot;,&#xA;              uri: &quot;\/category\/general\/&quot;&#xA;            }&#xA;          ],&#xA;          cursor: &quot;YXJyYXljb25uZWN0aW9uOjEyNw==&quot;&#xA;        }&#xA;      ]&#xA;    ];&#xA;&#xA;    service.getArticles().subscribe(resp =&gt; {&#xA;      expect(resp).toEqual(mockArticlesServiceResponse);&#xA;      done();&#xA;    });&#xA;&#xA;    const req = controller.expectOne(getArticlesQuery);&#xA;    expect(req.operation.operationName).toBe('getArticlesQuery');&#xA;    req.flush({ data: { articles: mockArticlesServerResponse } });&#xA;    controller.verify();&#xA;&#xA;  });&#xA;});&#xA;&#xA;</code></pre>&#xA;<p>Thanks everyone for your input and assistance!</p>&#xA;",916995,,,,2022-01-08 05:32:36,"",,0,0,0,2022-01-08 05:32:36
70632090,1,,,2,150,"<p>I am trying to solve the following problem with the Apollo graphql client in React:&#xA;I have a graphql server that allows queries for a list of results, for example search results. The total list is in-feasibly long so the result indices can be limited with a parameter:</p>&#xA;<pre><code>query getResults($offset:Int!,$limit: Int!){&#xA;   getResults(offset:offset, limit: limit){ title, content}&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>When the user scrolls through the result list, I want to increase the limit parameter so that additional results are loaded. However doing this naively would force the server to resend all the results which were already loaded previously. Is there a way to solve the issue elegantly?</p>&#xA;",12368967,,,,2022-01-08 11:56:24,Apollo graphql client query for list of results with dynamic size efficiently,<reactjs><graphql><apollo-client>,0,0,0,2022-01-08 11:56:24
70653603,1,,,0,93,"<p>I'm new to Apollo Client and I'm trying to implement pagination like this:&#xA;<a href=""https://i.stack.imgur.com/2U3Yz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2U3Yz.png"" alt=""enter image description here"" /></a></p>&#xA;<p>in PageInfo I have the following properties</p>&#xA;<pre><code>PageInfo {&#xA;  endCursor&#xA;  hasNextPage&#xA;  startCursor&#xA;}&#xA;</code></pre>&#xA;<p>And in variables I can pass <strong>first</strong> and <strong>after</strong> fields. Is this data enough to implement all logic of pagination? Can you recommend me which of the methods is the most suitable?</p>&#xA;",9791993,,9791993,2022-01-10 14:13:35,2022-01-10 14:13:35,Pagination in React with Apollo client,<reactjs><graphql><apollo-client>,0,0,0,2022-01-10 14:01:45
70655989,2,,68312713,0,,"<p>in case someone still needs this, to get the persons you actually need to use the people type:</p>&#xA;<pre><code>{&#xA;  allPeople( first: 10 ) {&#xA;      totalCount&#xA;      people {&#xA;          name&#xA;          height&#xA;      }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Here's a <a href=""https://graphql.org/swapi-graphql/?query=%7B%20allPeople(%20first%3A10%20%20)%20%7B%0A%09totalCount%0A%20%20pageInfo%7B%0A%20%20%20%20hasNextPage%0A%20%20%20%20hasPreviousPage%0A%20%20%20%20startCursor%0A%20%20%20%20endCursor%0A%20%20%7D%0A%20%20edges%7B%0A%20%20%20%20cursor%0A%20%20%7D%0A%20%20people%7B%0A%20%20%20%20name%0A%20%20%20%20id%0A%20%20%20%20filmConnection%7B%0A%20%20%20%20%20%20films%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%7D%0A%0A%0A%0A"" rel=""nofollow noreferrer"">link</a> to this request</p>&#xA;",8435402,,8435402,2022-01-11 08:09:31,2022-01-11 08:09:31,"",,0,0,0,2022-01-10 16:48:07
70664087,1,,,0,393,"<p>I need to duplicate some information between two stores ( one being the source store and the other the destination store ) .. can I open access to both stores, do a fetch data query on the source store and then mutate to the destination store, rather than having to use an intermediate storage file or memory, as the data size is large.</p>&#xA;",17900808,,,,2022-01-11 14:02:32,"In Shopify, using REST API's or GraphQL, can I simultaneously open and work with two stores",<rest><graphql><shopify>,1,0,0,2022-01-11 09:03:45
70665899,2,,70662311,-1,,"<p>OK, I made a stupid mistake by not specifying <code>gatsby-source-filesystem</code> in <code>gatsby-config.js</code>. After that, the <code>publicURL</code> field shows up.</p>&#xA;",10579013,,,,2022-01-11 11:20:34,"",,0,0,0,2022-01-11 11:20:34
70674856,1,70678906,,-1,697,"<p>I am writing a graphql api endpoint where I have customer details as below.</p>&#xA;<pre><code>{&#xA;customer_name:&#xA;customer_address:&#xA;    [ &#xA;        {&#xA;        address_1:&#xA;        },&#xA;        {&#xA;        address_2:&#xA;        },&#xA;    ]&#xA;}&#xA; &#xA;</code></pre>&#xA;<p>I need to apply pagination on customer_address which is a list.</p>&#xA;<p>Is this possible? Or I can do it only at top level record? Please let me know what would be the best way to do it?</p>&#xA;",4981459,,,,2022-01-12 09:11:05,How to add graphql pagination on nested object,<graphql>,1,0,0,2022-01-12 00:04:41
70675436,2,,70675281,4,,"<p>OK this turned out to be a configuration issue. To allow filtering by product type, it needs to be turned on in the admin for your store. If you navigate to:&#xA;Online Store &gt; Navigation</p>&#xA;<p>... and scroll to the bottom, you will see where you can add allowed filters:&#xA;<a href=""https://i.stack.imgur.com/CD8mP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CD8mP.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Even if it says your theme doesn't support filters, it will still change the way the API behaves.</p>&#xA;",545537,,,,2022-01-12 01:45:41,"",,0,1,0,2022-01-12 01:45:41
70691507,1,70694307,,1,353,"<p>im new in graphql, and what i want to achieve is simplify this schema:</p>&#xA;<pre><code>input UserQueryFilter {&#xA;   email: String&#xA;}&#xA;input UserQueryInput {&#xA;    filter: UserQueryFilter&#xA;    anotherArgs: String&#xA;}&#xA;&#xA;type User {&#xA;   email: String!&#xA;}&#xA;&#xA;Query { &#xA;    User (input: UserQueryInput) : [User]&#xA;}&#xA;</code></pre>&#xA;<p>into this:</p>&#xA;<pre><code>&#xA;input UserQueryFilter {&#xA;   email: String&#xA;}&#xA;&#xA;type User {&#xA;   email: String!&#xA;}&#xA;&#xA;Query { &#xA;    User (input: { filter: UserQueryFilter }, anotherArgs: String ) : [User]&#xA;}&#xA;</code></pre>&#xA;<p>but i got :</p>&#xA;<pre><code>Syntax Error: Expected Name, found &quot;{&quot;.&quot;,&quot;locations&quot;:[{&quot;line&quot;:183,&quot;column&quot;:20}] ...&#xA;</code></pre>&#xA;<p>when it comes to more complex application, it will become easier to code on the second one.&#xA;is there anything can do about it?</p>&#xA;<p>Thanks for your help!</p>&#xA;",16360035,,,,2022-01-13 09:39:03,GraphQL use simple object instead create specific type on schema,<typescript><graphql><apollo><express-graphql><typegraphql>,1,1,0,2022-01-13 04:41:14
70693654,2,,70677989,0,,"<p>It seems that your schema is pretty much unclear and wrong. I will give you my connection example that shows how you can create connection between collections.</p>&#xA;<pre><code>type User @model&#xA;{&#xA;  id: ID!&#xA;  username: String!&#xA;  name: String!&#xA;  surname: String!&#xA;  email: String&#xA;  departments: [UserDepartment] @connection(keyName: &quot;departmentsByUser&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type Department @model {&#xA;  id: ID!&#xA;  name: String!&#xA;}&#xA;&#xA;type UserDepartment @model &#xA;@key(name: &quot;departmentsByUser&quot;, fields: [&quot;userID&quot;])&#xA;{&#xA;  id: ID!&#xA;  userID: ID!&#xA;  departmentID: ID!&#xA;  user: User @connection(fields: [&quot;userID&quot;])&#xA;  department: Department @connection(fields: [&quot;departmentID&quot;])&#xA;}&#xA;</code></pre>&#xA;",12550913,,1839439,2022-01-13 08:49:39,2022-01-13 08:49:39,"",,0,2,0,2022-01-13 08:44:38
70696948,2,,70673086,1,,"<p>Can you create middle table between location and staff table and fetch via that table.&#xA;Example:</p>&#xA;<pre><code>type Staff&#xA;  @model {&#xA;  id: ID!&#xA;  name: String&#xA;  locations: [StaffLocation] @connection(keyName: &quot;staffLocationByStaffId&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;type Location&#xA;  @model {&#xA;  id: ID!&#xA;  name: String&#xA;  staffs: [StaffLocation] @connection(keyName: &quot;staffLocationByLocationId&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;type StaffLocation&#xA;  @key(name: &quot;staffLocationByStaffId&quot;, fields: [&quot;staffId&quot;])&#xA;  @key(name: &quot;staffLocationByLocationId&quot;, fields: [&quot;locationId&quot;])&#xA;  @model {&#xA;  id: ID!&#xA;  staffId: ID!&#xA;  locationId: ID!&#xA;  staff: Staff @connection(fields: [&quot;staffId&quot;])&#xA;  location: Location @connection(fields: [&quot;locationId&quot;])&#xA;}&#xA;</code></pre>&#xA;",12550913,,,,2022-01-13 12:53:25,"",,0,1,0,2022-01-13 12:53:25
70698942,1,,,0,67,"<pre><code>payload = &quot;&quot;&quot; query GetOrders($num_els: Int, $created_at: String, $cursor: String) {&#xA;              orders(first: $num_els, query: $created_at, after: $cursor) {&#xA;                edges {&#xA;                  node{&#xA;                    email&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&quot;&quot;&quot;&#xA;</code></pre>&#xA;<p>I try to send a simple query. The <code>$cursor</code> field can be empty.</p>&#xA;<pre><code>variables = {'num_els': num_elements, 'created_at': f'created_at:&gt;2022-01-10', 'cursor': None}&#xA;r = requests.post(constants['SHOPIFY_URL'], headers=headers,&#xA;                          json={'query': payload, 'variables': variables}).json()&#xA;</code></pre>&#xA;<p>However this gives me the</p>&#xA;<pre><code>[{'message': 'Parse error on &quot;query&quot; (STRING) at [1, 2]', 'locations': [{'line': 1, 'column': 2}]}]&#xA;</code></pre>&#xA;<p>Even if I discard the a bit complicated part with <code>$created_at</code>, the problem continues. Do you have any suggestions?</p>&#xA;",2980481,,,,2022-01-13 15:25:55,Graphql query constructing in python,<python><graphql><shopify>,1,0,0,2022-01-13 15:18:30
70707226,1,,,0,81,"<p>I want to get this type of data in return from a query by sending start_year and end_year.</p>&#xA;<pre><code>{&#xA;    &quot;data&quot;: {&#xA;              &quot;year&quot;: ['2018','2019','2020'],&#xA;               &quot;gasoline&quot;: ['67','21','9'],&#xA;               &quot;gasoline&quot;: ['80','10','10'],&#xA;              }&#xA;}&#xA;</code></pre>&#xA;<p>I need to know what will be the query, schema and resolver to return this format of data.</p>&#xA;",4064038,,,,2022-01-14 07:22:22,"Returning custom fields from nodejs graphql, how to write query, schema and resolver in graphql",<node.js><express><graphql><apollo-server>,0,0,0,2022-01-14 07:22:22
70717803,1,70745138,,0,489,"<p>I'm trying to define generic type definitions for building connections and edges in GraphQL. I'm keeping with the Relay spec, except that I'm also including the conventional <code>nodes</code> connection property for convenience. The <a href=""https://typegraphql.com/docs/1.1.1/generic-types.html"" rel=""nofollow noreferrer"">TypeGraphQL docs</a> show how to do something very similar, but I'm getting the following error when I try to run the server:</p>&#xA;<blockquote>&#xA;<p>Cannot determine GraphQL output type for 'nodes' of 'Connection' class. Is the value, that is used as its TS type or explicit type, decorated with a proper decorator or is it a proper output value?</p>&#xA;</blockquote>&#xA;<p>Typically, this shows up when the <code>@ObjectType</code> decorator is missing from a class definition which is then used as a field type somewhere else; however, I've confirmed that the types I'm passing have definitely been defined with this decorator, and I've also tried with a few different types from my schema. The docs demonstrate using a generic as a field definition, so that doesn't seem to be the issue either.</p>&#xA;<p>My type definitions are as follows:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>interface RawEdge&lt;NodeType&gt; {&#xA;  node: NodeType&#xA;}&#xA;&#xA;interface Edge&lt;NodeType&gt; extends RawEdge&lt;NodeType&gt; {&#xA;  cursor: string&#xA;}&#xA;&#xA;function Edge&lt;NodeType&gt;(NodeClass: ClassType&lt;NodeType&gt;) {&#xA;  @ObjectType({ isAbstract: true })&#xA;  abstract class Edge {&#xA;    constructor(identifier: string, node: NodeType) {&#xA;      this.cursor = Buffer.from(identifier).toString('base64')&#xA;      this.node = node&#xA;    }&#xA;&#xA;    @Field()&#xA;    cursor: string&#xA;&#xA;    @Field(type =&gt; NodeClass)&#xA;    node: NodeType&#xA;  }&#xA;&#xA;  return Edge&#xA;}&#xA;&#xA;&#xA;interface Connection&lt;NodeType, EdgeType extends Edge&lt;NodeType&gt;&gt; {&#xA;  totalCount: number&#xA;  edges: EdgeType[]&#xA;  nodes: NodeType[]&#xA;  pageInfo: PageInfo&#xA;}&#xA;&#xA;function Connection&lt;NodeType, EdgeType extends Edge&lt;NodeType&gt;&gt;(&#xA;  NodeClass: ClassType&lt;NodeType&gt;,&#xA;  EdgeClass: ClassType&lt;Edge&lt;NodeType&gt;&gt;&#xA;) {&#xA;  @ObjectType({ isAbstract: true })&#xA;  abstract class Connection {&#xA;    constructor(edges: EdgeType[], page: PageQuery) {&#xA;      this.totalCount = edges.length&#xA;      this.edges = edgesToReturn&lt;EdgeType&gt;(edges, page)&#xA;      this.nodes = this.edges.map(edge =&gt; edge.node)&#xA;      this.pageInfo = pageInfo(this, edges)&#xA;    }&#xA;&#xA;    @Field(type =&gt; Int)&#xA;    totalCount: number&#xA;&#xA;    @Field(type =&gt; [EdgeClass])&#xA;    edges: EdgeType[]&#xA;&#xA;    @Field(type =&gt; [NodeClass])&#xA;    nodes: NodeType[]&#xA;&#xA;    @Field()&#xA;    pageInfo: PageInfo&#xA;  }&#xA;&#xA;  return Connection&#xA;}&#xA;</code></pre>&#xA;<p>EDIT: The following workaround resolves the type issue, which proves that the types being passed in have the proper decorators in their definition. However, this is extremely clunky, so I would like to avoid having to use it if possible.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>function Edge&lt;NodeType&gt;(NodeClass: ClassType&lt;NodeType&gt;) {&#xA;  @ObjectType({ isAbstract: true })&#xA;  abstract class Edge {&#xA;    constructor(identifier: string, node: NodeType) {&#xA;      this.cursor = Buffer.from(identifier).toString('base64')&#xA;      this.node = node&#xA;    }&#xA;&#xA;    @Field()&#xA;    cursor: string&#xA;&#xA;    // @Field decorator removed&#xA;    node: NodeType&#xA;  }&#xA;&#xA;  return Edge&#xA;}&#xA;&#xA;function Connection&lt;NodeType, EdgeType extends Edge&lt;NodeType&gt;&gt;(&#xA;  NodeClass: ClassType&lt;NodeType&gt;,&#xA;  EdgeClass: ClassType&lt;Edge&lt;NodeType&gt;&gt;&#xA;) {&#xA;  @ObjectType({ isAbstract: true })&#xA;  abstract class Connection {&#xA;    constructor(edges: EdgeType[], page: PageQuery) {&#xA;      this.totalCount = edges.length&#xA;      this.edges = edgesToReturn&lt;EdgeType&gt;(edges, page)&#xA;      this.nodes = this.edges.map(edge =&gt; edge.node)&#xA;      this.pageInfo = pageInfo(this, edges)&#xA;    }&#xA;&#xA;    @Field(type =&gt; Int)&#xA;    totalCount: number&#xA;&#xA;    @Field(type =&gt; [EdgeClass])&#xA;    edges: EdgeType[]&#xA;&#xA;    // @Field decorator removed&#xA;    nodes: NodeType[]&#xA;&#xA;    @Field()&#xA;    pageInfo: PageInfo&#xA;  }&#xA;&#xA;  return Connection&#xA;}&#xA;&#xA;type RawDepartmentProductEdge = RawEdge&lt;Product&gt;&#xA;&#xA;@ObjectType()&#xA;class DepartmentProductEdge extends Edge(Product) {&#xA;  // Define the field type here instead of in the generic&#xA;  @Field(type =&gt; Product)&#xA;  node: Product&#xA;}&#xA;&#xA;@ObjectType()&#xA;class DepartmentProductConnection extends Connection(Product, DepartmentProductEdge) {&#xA;  // Define the field type here instead of in the generic&#xA;  @Field(type =&gt; [Product])&#xA;  nodes: Product[]&#xA;}&#xA;</code></pre>&#xA;<hr />&#xA;<p><strong>Context, for anyone who's curious:</strong></p>&#xA;<p>The purpose of all this is to generate connections using something like this...</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type RawDepartmentProductEdge = RawEdge&lt;Product&gt;&#xA;&#xA;@ObjectType()&#xA;class DepartmentProductEdge extends Edge(Product) {}&#xA;&#xA;@ObjectType()&#xA;class DepartmentProductConnection extends Connection(Product, DepartmentProductEdge) {}&#xA;</code></pre>&#xA;<p>...and then populate them like this...</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const products = [] // Retrieve the products here&#xA;const edges = products.map(node =&gt; new DepartmentProductEdge(node.id, node)&#xA;const connection = new DepartmentProductConnection(edges, pagination)&#xA;</code></pre>&#xA;<p>...so that everything is as DRY as possible, but I can still add meta to the edges as needed.</p>&#xA;",10768928,,10768928,2022-01-15 02:39:29,2022-01-17 17:16:28,Why can't TypeGraphQL determine the type of a generic?,<typescript><graphql><typegraphql>,1,0,0,2022-01-15 00:04:10
70722828,1,70725085,,3,493,"<p>I need your help in order to sort a GraphQL data by the field createdAt in descending order. When queering by ID, the API, doesn't allow you to sort the array of the given ID.&#xA;If i remove the sort key, the query runs ok, but the data is in ascending order (older to new) and I need to retrieve all the new values.</p>&#xA;<p>Do you know how can I sort the array?&#xA;Thank you in advance!</p>&#xA;<pre><code>  query GetCategory{&#xA;    category(id: 4, sort: &quot;createdAt:desc&quot;) {&#xA;      data&#xA;        {&#xA;          id&#xA;          attributes&#xA;          {&#xA;            name&#xA;            reviews{&#xA;              data&#xA;              {&#xA;                id&#xA;                attributes&#xA;                {&#xA;                  title&#xA;                  body&#xA;                  rating&#xA;                  createdAt&#xA;                  categories{&#xA;                    data&#xA;                    {&#xA;                      id&#xA;                      attributes{&#xA;                        name&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;    }&#xA;  }&#xA;&#xA;</code></pre>&#xA;",0,user17901809,,,2022-01-15 20:22:18,"GraphQL - sort error - Unknown argument ""sort""",<reactjs><graphql><strapi>,1,1,0,2022-01-15 15:29:56
70730234,1,,,0,42,"<p>I am working on a requirement where I need to submit a date value from my Next JS Front end to the backend via a GraphQL mutation. When the end-user clicks on <code>Enrol Now</code>  button I need to insert a row, where one of the field end_date should contain the value as today + 60 days. Below is my code</p>&#xA;<p><a href=""https://i.stack.imgur.com/UNhl0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UNhl0.png"" alt=""enter image description here"" /></a></p>&#xA;<p>and this is how the Mutation looks like</p>&#xA;<p><a href=""https://i.stack.imgur.com/uuErv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uuErv.png"" alt=""enter image description here"" /></a></p>&#xA;<p>and getting the below error</p>&#xA;<p><a href=""https://i.stack.imgur.com/zOeiC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zOeiC.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Any thoughts or ideas on this error and how to skip it?&#xA;I am Hasura on the backend and the data type of field is <code>date</code> only</p>&#xA;<p><a href=""https://i.stack.imgur.com/aH0lv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aH0lv.png"" alt=""enter image description here"" /></a></p>&#xA;",8109657,,,,2022-01-16 12:56:16,GraphQL Mutation error - Unable to submit a date value from my front end,<date><graphql><next.js>,0,0,0,2022-01-16 12:56:16
70737421,2,,54425838,0,,"<p>This is also possible:</p>&#xA;<pre><code>const fileData = await prismaClient.fileCuratedData.findFirst({&#xA;  where: {&#xA;    fileId: fileId,&#xA;    createdAt: {&#xA;      gte: fromdate}&#xA;  },&#xA;}); &#xA;</code></pre>&#xA;",11199752,,,,2022-01-17 06:41:20,"",,0,0,0,2022-01-17 06:41:20
70744855,2,,70744571,0,,"<p><code>metadata</code> in Gatsby's example is a GraphQL node valid in their data structure, if yours hasn't it simply don't use it or it will break the code since it's not a valid custom type.</p>&#xA;<p>The problem in your query, besides using an invalid field (<code>metadata</code>) is that you are using an <code>elemMatch</code> filter, comparing<code>contentful_id</code> (number) to <code>boxon</code> (string), so it will never work in your scenario (it works in Gatsbys' because it's the same type). In your case, you may want to use <code>in</code> (for arrays) or <code>eq</code> (for single values). Check the available list at: <a href=""https://www.gatsbyjs.com/docs/graphql-reference/#filter"" rel=""nofollow noreferrer"">https://www.gatsbyjs.com/docs/graphql-reference/#filter</a></p>&#xA;<p>As far as I understand your question, it seems that you want to split your <code>diaporama</code> data in two different nodes, the ones that contain <code>boxon</code> and the ones that contain <code>attaqueGenetique</code>. If so, you will need to create different nodes by aliasing them:</p>&#xA;<pre><code>query FilterByTagsQuery {&#xA;  boxon: allContentfulDiaporama(&#xA;    sort: { fields: contentful_id }&#xA;    filter: {&#xA;        metadata: { tags: { in: [&quot;boxon&quot;]  } }&#xA;      }&#xA;  ) {&#xA;    nodes {&#xA;      #your data/fields here&#xA;    }&#xA;  }&#xA;  attaqueGenetique: allContentfulDiaporama(&#xA;    sort: { fields: contentful_id }&#xA;    filter: {&#xA;        metadata: { tags: { in: [&quot;attaqueGenetique&quot;]  } }&#xA;      }&#xA;  ) {&#xA;    nodes {&#xA;      #your data/fields here&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Test the query in the GraphiQL playground, available at <code>localhost:8000/___graphql</code> where it will be much more intuitive for you to add or remove filters and see the available nodes.</p>&#xA;<p>The snippet above will generate two different data structures based on the tags aliased. With this: <code>boxon: allContentfulDiaporama</code>, you are aliasing the result of <code>allContentfulDiaporama</code> in <code>boxon</code> so in your page, you will be able to access directly <code>props.data.boxon</code> and <code>props.data.attaqueGenetique</code> respectively.</p>&#xA;<p>Keep in mind that the <code>sort</code> filtering method only works on dates or numeric values, in the case of strings, it will sort them alphabetically. So I'm assuming that your data has a <code>contentful_id</code> (I'm not sure how it will be helpful sorting by <code>contentful_id</code>).</p>&#xA;<p>According to this <a href=""https://github.com/gatsbyjs/gatsby/pull/34480"" rel=""nofollow noreferrer"">pull-request</a> the <code>enableTags</code> feature was fixed in the cutting-edge release(5 days ago) so try to upgrade your plugin dependency.</p>&#xA;<p>It seems to be fixed in, according to this <a href=""https://github.com/gatsbyjs/gatsby/issues/34556"" rel=""nofollow noreferrer"">GitHub thread</a>:</p>&#xA;<pre><code>gatsby-source-contentful@7.5.0-next.0&#xA;</code></pre>&#xA;<p>Or in the next release.</p>&#xA;",5585371,,5585371,2022-01-25 08:58:14,2022-01-25 08:58:14,"",,0,8,0,2022-01-17 16:53:15
70775493,2,,47590134,-1,,"<p>I know this answer is 4 years late but I just came across this problem.</p>&#xA;<p>This seemed to work for me:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>    const flattenGqlEdges = (edges) =&gt; edges.map((edge) =&gt; edge.node);&#xA;    flattenedData = flattenGqlEdges(data.allContentfulDocuments.edges)&#xA;</code></pre>&#xA;<p>For anyone that needs this in future :)</p>&#xA;",6716421,,,,2022-01-19 17:53:42,"",,0,0,0,2022-01-19 17:53:42
70857478,1,,,0,45,"<p>I am trying to query from this GraphQL, which currently has over 86k entries (as you can see by the total it returns)</p>&#xA;<p><code>https://axieinfinity.com/graphql-server-v2/graphql?query={axies(from:1,size:1,sort:IdAsc,owner:%220x27263b825bab7ef905718185342905fbd248d1ed%22){total,results{id}}}</code></p>&#xA;<p>However, whenever I try to ask a &quot;from&quot; past 9999, it gives an empty list.</p>&#xA;<p>The same happens when I ask &quot;from:9999&quot; and &quot;size:2&quot;</p>&#xA;<p>Compare these results:</p>&#xA;<p><code>https://axieinfinity.com/graphql-server-v2/graphql?query={axies(from:9999,size:1,sort:IdAsc,owner:%220x27263b825bab7ef905718185342905fbd248d1ed%22){total,results{id}}}</code></p>&#xA;<p><code>https://axieinfinity.com/graphql-server-v2/graphql?query={axies(from:9999,size:2,sort:IdAsc,owner:%220x27263b825bab7ef905718185342905fbd248d1ed%22){total,results{id}}}</code></p>&#xA;<p><code>https://axieinfinity.com/graphql-server-v2/graphql?query={axies(from:10000,size:1,sort:IdAsc,owner:%220x27263b825bab7ef905718185342905fbd248d1ed%22){total,results{id}}}</code></p>&#xA;<p>Is there something I can do, or is this some kind of protection in the GraphQL itself?</p>&#xA;",7639202,,,,2022-01-26 00:45:26,Why is it not possible to get results past 10k in a graph that has over 80k entries?,<graphql>,0,1,0,2022-01-26 00:45:26
70859230,1,,,3,112,"<p>i'm somewhat new to graphql, i want to know if it possible to implement either offset or cursor pagination for nested graphql object,</p>&#xA;<p>let take an example :</p>&#xA;<pre><code>query Query($poolId: Int!) {&#xA;  pool(id: $poolId) {&#xA;    id&#xA;    title&#xA;    questions {&#xA;      id&#xA;      description&#xA;      choices {&#xA;        description&#xA;        id&#xA;        &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>what is the best way to paginate pool questions and choices?</p>&#xA;<p>Thanks</p>&#xA;",3210059,,,,2022-01-26 06:12:44,Nested pagination graphql query,<node.js><typescript><graphql><nestjs>,0,0,0,2022-01-26 06:12:44
70871371,1,,,0,71,"<p>For example, i have this query in my schema:</p>&#xA;<pre><code>extend type Query {&#xA;  order (code: String! @eq): Order @find&#xA;&#xA;  orders(&#xA;    orderBy: _ @orderBy(columns: [&quot;created_at&quot;, &quot;delivery_date&quot;, &quot;production_date&quot;])&#xA;    where: String @whereConditions(columns: [&quot;code&quot;, &quot;closed_at&quot;, &quot;delivery_date&quot;])&#xA;    hasCity: String @whereConditions(columns: [&quot;name&quot;])&#xA;    hasStatus: Int @whereConditions(columns: [&quot;id&quot;])&#xA;  ): [Order!] @paginate&#xA;}&#xA;</code></pre>&#xA;<p>As you can see, there is a lot  of fields (<code>orderBy</code>, <code>where</code>, <code>hasCity</code>, <code>hasStatus</code>), each one setted as i want to provide for client-side.</p>&#xA;<p>So i wonder if there is any way to make these fields reusable in any other queries i want every time i want to.</p>&#xA;",14671559,,,,2022-01-26 23:07:36,Is there any way to reuse query fields in schemas?,<graphql>,0,1,0,2022-01-26 23:07:36
70871508,2,,66891672,1,,"<p><code>addSchemaLevelResolver</code> has been <a href=""https://github.com/ardatan/graphql-tools/releases/tag/%40graphql-tools%2Fschema%408.0.0"" rel=""nofollow noreferrer"">removed</a> in favor of <a href=""https://www.graphql-tools.com/docs/resolvers-composition"" rel=""nofollow noreferrer"">Resolvers Composition</a>.&#xA;I believe <code>addSchemaLevelResolver</code> and the new <code>Resolvers Composition</code> would literally traverse the schema and add resolve function to each Type and Field.</p>&#xA;",1643850,,,,2022-01-26 23:26:06,"",,0,0,0,2022-01-26 23:26:06
70872584,2,,70872333,0,,<p>I figured out the answer. You need to set the updatedAt field to required. So it should look like: updatedAt: AWSDATETIME!</p>&#xA;,17834286,,,,2022-01-27 02:25:44,"",,0,0,0,2022-01-27 02:25:44
70877269,1,,,0,296,<p>I am new in Bigcommerce and I need to get or fetch 100000 record from GraphQL or Bigcommerce API of Bigcommerce.</p>&#xA;<p>Is this possible or any other way to get data.</p>&#xA;,1547438,,,,2022-01-27 13:27:37,How get or fetch 100000 record from GraphQL or API of bigcommerce,<graphql><bigcommerce>,1,0,0,2022-01-27 10:49:30
70906149,1,70916267,,1,393,"<p>Let's say we query the server with this request, we only want to get the following user's Email, My current implementation requests the whole User object from the MongoDB, which I can imagine is extremely inefficient.</p>&#xA;<pre><code>GQL&#xA;{&#xA;  user(id:&quot;34567345637456&quot;) {&#xA;    email&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>How would you go about creating a MongoDB filter that would only return those Specified Fields? E.g,</p>&#xA;<pre><code>JS object&#xA;{&#xA;   &quot;email&quot;: 1&#xA;}&#xA;</code></pre>&#xA;<p>My current server is running Node.js, Fastify and Mercurius</p>&#xA;",17996051,,,,2022-01-30 15:46:44,Construct MongoDB query from GraphQL request,<javascript><node.js><typescript><graphql><fastify>,2,2,0,2022-01-29 13:57:08
70912797,2,,70906149,2,,"<blockquote>&#xA;<p>which I can imagine is extremely inefficient.</p>&#xA;</blockquote>&#xA;<p>Doing this task is an advanced feature with many pitfalls. I would suggest starting building a simple extraction that read all the fields. This solution works and does not return any additional field to the client.</p>&#xA;<p>The pitfalls are:</p>&#xA;<ul>&#xA;<li>nested queries</li>&#xA;<li>complex object composition</li>&#xA;<li>aliasing</li>&#xA;<li>multiple queries into one request</li>&#xA;</ul>&#xA;<p>Here an example that does what you are looking for.&#xA;It manages aliasing and multiple queries.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const Fastify = require('fastify')&#xA;const mercurius = require('mercurius')&#xA;&#xA;const app = Fastify({ logger: true })&#xA;&#xA;const schema = `&#xA;  type Query {&#xA;    select: Foo&#xA;  }&#xA;&#xA;  type Foo {&#xA;    a: String&#xA;    b: String&#xA;  }&#xA;`&#xA;&#xA;const resolvers = {&#xA;  Query: {&#xA;    select: async (parent, args, context, info) =&gt; {&#xA;      const currentQueryName = info.path.key&#xA;&#xA;      // search the input query AST node&#xA;      const selection = info.operation.selectionSet.selections.find(&#xA;        (selection) =&gt; {&#xA;          return (&#xA;            selection.name.value === currentQueryName ||&#xA;            selection.alias.value === currentQueryName&#xA;          )&#xA;        }&#xA;      )&#xA;      &#xA;      // grab the fields requested by the user&#xA;      const project = selection.selectionSet.selections.map((selection) =&gt; {&#xA;        return selection.name.value&#xA;      })&#xA;&#xA;      // do the query using the projection&#xA;      const result = {}&#xA;      project.forEach((fieldName) =&gt; {&#xA;        result[fieldName] = fieldName&#xA;      })&#xA;&#xA;      return result&#xA;    },&#xA;  },&#xA;}&#xA;&#xA;app.register(mercurius, {&#xA;  schema,&#xA;  resolvers,&#xA;  graphiql: true,&#xA;})&#xA;&#xA;app.listen(3000)&#xA;</code></pre>&#xA;<p>Call it using:</p>&#xA;<pre><code>query {&#xA;  one: select {&#xA;    a&#xA;  }&#xA;  two: select {&#xA;    a&#xA;    aliasMe:b&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Returns</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;one&quot;: {&#xA;      &quot;a&quot;: &quot;a&quot;&#xA;    },&#xA;    &quot;two&quot;: {&#xA;      &quot;a&quot;: &quot;a&quot;,&#xA;      &quot;aliasMe&quot;: &quot;b&quot;&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3309466,,,,2022-01-30 07:42:56,"",,0,0,0,2022-01-30 07:42:56
70919750,2,,70919656,0,,"<p>Problem should be in this line</p>&#xA;<pre><code>this.state.isToggleOn &amp;&amp; this.state.selectedCategory &amp;&amp; row.id  == edge.node.frontmatter.id&#xA;</code></pre>&#xA;<p>You are checking id in wrong way, you should check like</p>&#xA;<pre><code>this.state.isToggleOn &amp;&amp; this.state.selectedCategory == row.id&#xA;</code></pre>&#xA;<p>Because in your approach if <code>selectedCategory</code> exist you let to open all childrens not just the one with <code>id</code> match</p>&#xA;",13544849,,,,2022-01-30 23:07:35,"",,0,0,0,2022-01-30 23:07:35
70923136,1,,,2,517,"<p>I have a union on two concrete types <strong>Prodotto</strong> and <strong>ProdottoVariante</strong> both implements a interface of type <strong>Articolo</strong>.</p>&#xA;<pre><code>union Articoli = Prodotto | ProdottoVariante&#xA;&#xA;extend type Query {&#xA;  articoli: [Articoli!]!&#xA;}&#xA;</code></pre>&#xA;<p>I want to query all Prodotto and all ProdottoVariante by typing <strong>articoli</strong> but I don't know how to resolve <strong>Articoli</strong></p>&#xA;<p>I'm trying in this way:</p>&#xA;<pre><code>func (r *queryResolver) Articoli(ctx context.Context) ([]model.Articoli, error) {&#xA;    var articoli []model.Articoli&#xA;&#xA;    r.DB.Model(&amp;model.Prodotto{}).Select(&quot;nome&quot;).Find(&amp;articoli)&#xA;    r.DB.Model(&amp;model.ProdottoVariante{}).Select(&quot;nome&quot;).Find(&amp;articoli)&#xA;&#xA;    return articoli, nil&#xA;}&#xA;</code></pre>&#xA;<p>and I'm querying in this way:</p>&#xA;<pre><code>query {&#xA;  articoli {&#xA;    __typename&#xA;    ...on Prodotto {&#xA;      nome&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>but I get this error:</p>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;must not be null&quot;,&#xA;      &quot;path&quot;: [&#xA;        &quot;articoli&quot;,&#xA;        0&#xA;      ]&#xA;    }&#xA;  ],&#xA;  &quot;data&quot;: null&#xA;}&#xA;</code></pre>&#xA;<pre><code>sql: Scan error on column index 0, name &quot;nome&quot;: unsupported Scan, storing driver.Value type string into type *model.Articoli&#xA;</code></pre>&#xA;<p>How to correctly resolve Unions with gorm?</p>&#xA;",3348195,,,,2022-02-07 20:15:50,How to resolve a Graphql Union with Gorm?,<go><graphql><go-gorm><gqlgen>,1,0,0,2022-01-31 08:38:59
70928105,2,,55830930,14,,"<p>Since Prisma 2.4 this should be basically possible by using array in orderBy:</p>&#xA;<pre><code>const users = await prisma.user.findMany({&#xA;   select: {&#xA;      email: true,&#xA;      role: true,&#xA;   },&#xA;   orderBy: [&#xA;      {&#xA;         email: 'desc',&#xA;      },&#xA;      {&#xA;         role: 'desc',&#xA;      }&#xA;   ],&#xA;})&#xA;</code></pre>&#xA;<p>Find more in docs: <a href=""https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#sort-user-by-multiple-fields---email-and-role"" rel=""noreferrer"">https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#sort-user-by-multiple-fields---email-and-role</a></p>&#xA;",8736198,,,,2022-01-31 15:01:32,"",,0,3,0,2022-01-31 15:01:32
70938147,2,,70864299,2,,"<p>GraphQL trivially supports &quot;circular&quot; nested parent-child queries to arbitrary depth. GraphQL resolves fields recursively, <a href=""https://spec.graphql.org/October2021/#sec-Executing-Fields"" rel=""nofollow noreferrer"">stopping when all field values resolve to scalars</a>.</p>&#xA;<p>In your example, the query would terminate if you removed <code>options {....}</code>, because <code>code</code> is a scalar.  The right place to stop depends on your use case.</p>&#xA;<p>Here's a <a href=""https://graphql.org/swapi-graphql/?query=query%20AllFilms(%24f%3AInt)%20%7B%0A%20%20allFilms(first%3A%24f)%20%7B%0A%20%20%20%20films%20%7B%0A%20%20%20%20%20%20title%0A%20%20%20%20%20%20characterConnection(first%3A%20%24f)%20%7B%0A%20%20%20%20%20%20%20%20characters%20%7B%0A%20%20%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20%20%20filmConnection%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20films%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20characterConnection%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20characters%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20filmConnection%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20films%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=AllFilms&amp;variables=%7B%0A%20%20%22f%22%3A%202%0A%7D"" rel=""nofollow noreferrer"">runnable example</a> using the &quot;circular&quot; character-film relation in the Star Wars API.  The query terminates when there are no more <a href=""https://graphql.org/learn/schema/#object-types-and-fields"" rel=""nofollow noreferrer"">Object Type</a> fields to resolve.  This silly example is overly nested: the results quickly become repetitive. Repetitive nesting has its uses, though.  It can reshape the result set, for instance inverting a <code>parents &gt; children</code> structure  to <code>children &gt; parents</code>.</p>&#xA;<pre><code>query AllFilms($f:Int) {&#xA;  allFilms(first:$f) {&#xA;    films {&#xA;      title&#xA;      characterConnection(first: $f) {&#xA;        characters {&#xA;          name&#xA;          filmConnection {&#xA;            films {&#xA;              title&#xA;              characterConnection {&#xA;                characters {&#xA;                  name&#xA;                  filmConnection {&#xA;                    films {&#xA;                      title&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1103511,,,,2022-02-01 09:26:08,"",,0,0,0,2022-02-01 09:26:08
70940548,2,,57580224,0,,"<p>I'm by no means an expert, but i would agree with JudgeFudge.&#xA;Though i'll like to add, that you have the option to set the property type to &quot;string&quot; like that:</p>&#xA;<pre><code>@Column({ type: &quot;date&quot; })&#xA;date_of_birth: string;&#xA;</code></pre>&#xA;<p>Then you'll get the (in my opinion) better understandable error message:</p>&#xA;<pre><code>&quot;Datum/Zeit-Feldwert ist außerhalb des gültigen Bereichs: »1986-20-25«&quot; &#xA;(&quot;Date/Time field value is not in valid range&quot;)&#xA;</code></pre>&#xA;<p>instead of:</p>&#xA;<pre><code>&quot;ungültige Eingabesyntax für Typ date: »NaN-NaN-NaN«&quot; &#xA;(&quot;invalid input syntax for type date&quot;)&#xA;</code></pre>&#xA;<p>And if you input: <code>&quot;1986-02-30&quot;</code> with property type of <code>&quot;string&quot;</code> you'll get an error like above, while with property type of <code>&quot;Date&quot;</code> it will convert it to <code>&quot;1986-03-02&quot;</code> due to the javascript Date constructor.</p>&#xA;<p>But you can loose some &quot;schema transparency&quot;, since you're asking for a value of type &quot;string&quot; rather than &quot;Date&quot;, when for example working with TypeGraphQl like i do&#xA;and implementing entity-partials in the Args/Input-Types.</p>&#xA;<p>Coming to an end, if your requests contain a stringfied (to JSON) instance of an DateObject, an invalid date would be caught when trying to initialize this instance with the DateObject constructor, thus you can work with &quot;Date&quot; instead of &quot;string&quot;, when using this (last) approach.</p>&#xA;",16441971,,,,2022-02-01 12:26:35,"",,0,0,0,2022-02-01 12:26:35
70942071,1,70943155,,1,771,"<p>I do have simple groupBy query in my prisma which looks like this:</p>&#xA;<pre><code>const groupBy = await prisma.referral.groupBy({&#xA;  by: ['recommenderId'],&#xA;  _sum: {&#xA;     points: true,&#xA;  },&#xA;});&#xA;</code></pre>&#xA;<p>What I am looking for is the way to sort by this _sum value.</p>&#xA;<p>The current response is:</p>&#xA;<pre><code>{&#xA;    &quot;groupBy&quot;: [&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 20000&#xA;            },&#xA;            &quot;recommenderId&quot;: 3&#xA;        },&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 19000&#xA;            },&#xA;            &quot;recommenderId&quot;: 2&#xA;        },&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 34000&#xA;            },&#xA;            &quot;recommenderId&quot;: 1&#xA;        }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;<p>What I need is to get is:</p>&#xA;<pre><code>{&#xA;    &quot;groupBy&quot;: [&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 34000&#xA;            },&#xA;            &quot;recommenderId&quot;: 1&#xA;        },&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 20000&#xA;            },&#xA;            &quot;recommenderId&quot;: 3&#xA;        },&#xA;        {&#xA;            &quot;_sum&quot;: {&#xA;                &quot;points&quot;: 19000&#xA;            },&#xA;            &quot;recommenderId&quot;: 2&#xA;        },&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;<p>Based on documentation (<a href=""https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting#sorting"" rel=""nofollow noreferrer"">https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting#sorting</a>) I tried something like this:</p>&#xA;<pre><code>const groupBy = await prisma.referral.groupBy({&#xA;      by: ['recommenderId'],&#xA;      _sum: {&#xA;        points: true,&#xA;      },&#xA;      orderBy: [&#xA;        {&#xA;          _sum: 'desc',&#xA;        },&#xA;      ],&#xA;    });&#xA;</code></pre>&#xA;<p>But with code I'm getting error:</p>&#xA;<blockquote>&#xA;<p>Argument _sum: Got invalid value 'desc' on prisma.groupByReferral.&#xA;Provided String, expected ReferralSumOrderByAggregateInput</p>&#xA;</blockquote>&#xA;",2584910,,,,2022-02-01 16:04:50,Prisma - Sort by _sum,<postgresql><prisma><prisma-graphql>,1,0,0,2022-02-01 14:15:34
70943155,2,,70942071,3,,"<p>You can use <code>_sum</code> on different fields at the same time, so you also need to provide field name that you want to sort on:</p>&#xA;<pre><code>const groupBy = await prisma.referral.groupBy({&#xA;      by: ['recommenderId'],&#xA;      _sum: {&#xA;        points: true,&#xA;      },&#xA;      orderBy: [&#xA;        {&#xA;          _sum: {&#xA;            // Add `points` key here&#xA;            points: 'desc'&#xA;          }&#xA;        },&#xA;      ],&#xA;    });&#xA;</code></pre>&#xA;",5650447,,5650447,2022-02-01 16:04:50,2022-02-01 16:04:50,"",,0,3,0,2022-02-01 15:29:03
70955000,1,,,0,74,"<p>I am working with apollo, react-native and GraphQL. User is passing quiz, and in the end, all his responses should be passed to DB. Some questions has several options{key:value} for example: For men there are Top size cloth, Bottom size cloth and boots. So they should be passed to DB like: question 3: Men clothing:[{Top Size: XS}, {Bottom Size: XS}, {Boots: 7}]. So on playground I have written mutation that is working properly:</p>&#xA;<p>mutation {</p>&#xA;<p>createQuizResponse(&#xA;input: {&#xA;data:&#xA;{user: &quot;8&quot;, quizItem: &quot;3&quot;, options :[{key: &quot;TopSize&quot;, value: &quot;XS&quot;}, {key:&quot;BottomSize&quot;, value:&quot;XS&quot;}, {key:&quot;Boots&quot;, value:&quot;7&quot;}]}})&#xA;{</p>&#xA;<pre><code>quizResponse{&#xA;  user{&#xA;    id&#xA;  }&#xA;  quizItem{&#xA;    order&#xA;  }&#xA;  options{&#xA;    key&#xA;    value&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>}&#xA;}</p>&#xA;<p>And now the question is, how to write mutation using apollo client in react-native?</p>&#xA;",18099400,,,,2022-02-02 11:43:24,"Apollo, GraphQL, how to mutate and array of {key, value}",<react-native><graphql><apollo>,0,0,0,2022-02-02 11:43:24
70957831,1,70958697,,1,238,"<p><a href=""https://i.stack.imgur.com/zST4v.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zST4v.jpg"" alt=""enter image description here"" /></a></p>&#xA;<p><strong>Description</strong>:&#xA;I have a seeProfile resolver, which gives back a profile of a particular user.&#xA;This user has a photos array and I want to paginate these photos and I can't figure out how. I have a workaround but I'd like to know a way - shall it exist - to paginate a field of this one user.</p>&#xA;<p><strong>Workaround</strong>:&#xA;I can simply make a resolver for fetching pictures for a particular user with <strong>.findMany()</strong> and paginate them with take: and skip: . But then I make two queries instead of one. So, if anyone knows a way to paginate the photos inside findUnique query, please let me know, thanks!</p>&#xA;",16264008,,,,2022-02-02 15:52:05,Prisma 2: How to paginate fields of a .findUnique() query?,<graphql><prisma>,1,0,0,2022-02-02 14:55:56
70974619,2,,70972777,0,,"<p>Normally this would be handled on the GraphQL server to accept a filter.&#xA;So, for example, you can pass a variable to <code>surfCondition</code> such as</p>&#xA;<pre><code>surfCondition(filter: 2)&#xA;</code></pre>&#xA;<p>…which would then return automatically the filtered data.</p>&#xA;",6687135,,3025856,2022-02-05 00:28:35,2022-02-05 00:28:35,"",,0,1,0,2022-02-03 16:10:34
70979334,1,,,0,243,"<p>I am trying to develop a React-native app with an AWS AppSync backend however struggle when trying to create API endpoints that filters the returned results.</p>&#xA;<p>My Schema looks as the following:</p>&#xA;<pre><code>input CreatePostInput {&#xA;    id: ID&#xA;    images: [String!]&#xA;    category: String!&#xA;    title: String!&#xA;    description: String!&#xA;    price: Float!&#xA;    dimensions: DimensionInput!&#xA;    weight: Float!&#xA;    deliveryBy: AWSDate&#xA;    goingTo: LocationInput!&#xA;    goingFrom: LocationInput!&#xA;}&#xA;&#xA;input DeletePostInput {&#xA;    id: ID!&#xA;}&#xA;&#xA;type Dimension {&#xA;    length: Float!&#xA;    width: Float!&#xA;    height: Float!&#xA;}&#xA;&#xA;input DimensionInput {&#xA;    length: ModelFloatInput!&#xA;    width: ModelFloatInput!&#xA;    height: ModelFloatInput!&#xA;}&#xA;&#xA;type Location @model {&#xA;    city: String!&#xA;    country: String!&#xA;    latitude: Float!&#xA;    longitude: Float!&#xA;}&#xA;&#xA;input LocationInput {&#xA;    city: ModelStringInput&#xA;    country: ModelStringInput&#xA;    latitude: ModelFloatInput!&#xA;    longitude: ModelFloatInput!&#xA;}&#xA;&#xA;enum ModelAttributeTypes {&#xA;    binary&#xA;    binarySet&#xA;    bool&#xA;    list&#xA;    map&#xA;    number&#xA;    numberSet&#xA;    string&#xA;    stringSet&#xA;    _null&#xA;}&#xA;&#xA;input ModelBooleanInput {&#xA;    ne: Boolean&#xA;    eq: Boolean&#xA;    attributeExists: Boolean&#xA;    attributeType: ModelAttributeTypes&#xA;}&#xA;&#xA;input ModelFloatInput {&#xA;    ne: Float&#xA;    eq: Float&#xA;    le: Float&#xA;    lt: Float&#xA;    ge: Float&#xA;    gt: Float&#xA;    between: [Float]&#xA;    attributeExists: Boolean&#xA;    attributeType: ModelAttributeTypes&#xA;}&#xA;&#xA;input ModelIDInput {&#xA;    ne: ID&#xA;    eq: ID&#xA;    le: ID&#xA;    lt: ID&#xA;    ge: ID&#xA;    gt: ID&#xA;    contains: ID&#xA;    notContains: ID&#xA;    between: [ID]&#xA;    beginsWith: ID&#xA;    attributeExists: Boolean&#xA;    attributeType: ModelAttributeTypes&#xA;    size: ModelSizeInput&#xA;}&#xA;&#xA;input ModelIntInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    between: [Int]&#xA;    attributeExists: Boolean&#xA;    attributeType: ModelAttributeTypes&#xA;}&#xA;&#xA;input ModelPostConditionInput {&#xA;    images: ModelStringInput&#xA;    category: ModelStringInput&#xA;    title: ModelStringInput&#xA;    goingTo: LocationInput&#xA;    goingFrom: LocationInput&#xA;    description: ModelStringInput&#xA;    price: ModelFloatInput&#xA;    weight: ModelFloatInput&#xA;    dimensions: DimensionInput&#xA;    deliveryBy: ModelStringInput&#xA;    and: [ModelPostConditionInput]&#xA;    or: [ModelPostConditionInput]&#xA;    not: ModelPostConditionInput&#xA;}&#xA;&#xA;type ModelPostConnection {&#xA;    items: [Post]!&#xA;    nextToken: String&#xA;}&#xA;&#xA;input ModelPostFilterInput {&#xA;    id: ModelIDInput&#xA;    images: ModelStringInput&#xA;    category: ModelStringInput&#xA;    goingTo: LocationInput&#xA;    goingFrom: LocationInput&#xA;    title: ModelStringInput&#xA;    description: ModelStringInput&#xA;    price: ModelFloatInput&#xA;    weight: ModelFloatInput&#xA;    dimensions: DimensionInput&#xA;    deliveryBy: ModelStringInput&#xA;    and: [ModelPostFilterInput]&#xA;    or: [ModelPostFilterInput]&#xA;    not: ModelPostFilterInput&#xA;}&#xA;&#xA;input ModelSizeInput {&#xA;    ne: Int&#xA;    eq: Int&#xA;    le: Int&#xA;    lt: Int&#xA;    ge: Int&#xA;    gt: Int&#xA;    between: [Int]&#xA;}&#xA;&#xA;enum ModelSortDirection {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;&#xA;input ModelStringInput {&#xA;    ne: String&#xA;    eq: String&#xA;    le: String&#xA;    lt: String&#xA;    ge: String&#xA;    gt: String&#xA;    contains: String&#xA;    notContains: String&#xA;    between: [String]&#xA;    beginsWith: String&#xA;    attributeExists: Boolean&#xA;    attributeType: ModelAttributeTypes&#xA;    size: ModelSizeInput&#xA;}&#xA;&#xA;type Mutation {&#xA;    createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post&#xA;    updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post&#xA;    deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post&#xA;}&#xA;&#xA;type Post @model {&#xA;    id: ID!&#xA;    images: [String!]&#xA;    category: String!&#xA;    title: String!&#xA;    description: String!&#xA;    price: Float!&#xA;    dimensions: Dimension!&#xA;    weight: Float!&#xA;    deliveryBy: AWSDate&#xA;    goingTo: Location!&#xA;        @connection&#xA;    goingFrom: Location!&#xA;        @connection&#xA;    createdAt: AWSDateTime!&#xA;    updatedAt: AWSDateTime!&#xA;}&#xA;&#xA;type Query {&#xA;    getPost(id: ID!): Post&#xA;    listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection&#xA;}&#xA;&#xA;type Subscription {&#xA;    onCreatePost: Post&#xA;        @aws_subscribe(mutations: [&quot;createPost&quot;])&#xA;    onUpdatePost: Post&#xA;        @aws_subscribe(mutations: [&quot;updatePost&quot;])&#xA;    onDeletePost: Post&#xA;        @aws_subscribe(mutations: [&quot;deletePost&quot;])&#xA;}&#xA;&#xA;input UpdatePostInput {&#xA;    id: ID!&#xA;    images: [String!]&#xA;    category: String&#xA;    title: String&#xA;    description: String&#xA;    price: Float&#xA;    dimensions: DimensionInput&#xA;    weight: Float&#xA;    deliveryBy: AWSDate&#xA;    goingTo: LocationInput&#xA;    goingFrom: LocationInput&#xA;}&#xA;</code></pre>&#xA;<p>When trying to filter based on the location with the following query:</p>&#xA;<pre><code>query MyQuery {&#xA;  listPosts(filter: {&#xA;    and: {&#xA;      goingTo: {&#xA;        latitude: {&#xA;          between: [50.509865, 52.509865]&#xA;        },&#xA;        longitude: {&#xA;          between: [-1.118092, 1.118092]&#xA;        }&#xA;      }&#xA;    }&#xA;  }) {&#xA;    nextToken&#xA;    items {&#xA;      category&#xA;      createdAt&#xA;      deliveryBy&#xA;      description&#xA;      id&#xA;      images&#xA;      price&#xA;      title&#xA;      updatedAt&#xA;      weight&#xA;      goingTo {&#xA;        city&#xA;        country&#xA;        latitude&#xA;        longitude&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>It simply returns all the records in the database. It completely ignores the latitude and longitude filter as seen by the returned results:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;listPosts&quot;: {&#xA;      &quot;nextToken&quot;: null,&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;category&quot;: &quot;Gardening&quot;,&#xA;          &quot;createdAt&quot;: &quot;2022-01-27T16:09:35.702Z&quot;,&#xA;          &quot;deliveryBy&quot;: &quot;2022-06-17&quot;,&#xA;          &quot;description&quot;: &quot;Flower pot passed ...&quot;,&#xA;          &quot;id&quot;: &quot;8b50553c-....,&#xA;          &quot;images&quot;: [&#xA;            &quot;https://media.ist...&#xA;          ],&#xA;          &quot;price&quot;: 50,&#xA;          &quot;title&quot;: &quot;Flowerpot&quot;,&#xA;          &quot;updatedAt&quot;: &quot;2022-01-27T16:09:35.702Z&quot;,&#xA;          &quot;weight&quot;: 1.1,&#xA;          &quot;goingTo&quot;: {&#xA;            &quot;city&quot;: &quot;Los Angeles&quot;,&#xA;            &quot;country&quot;: &quot;USA&quot;,&#xA;            &quot;latitude&quot;: 34.052235,&#xA;            &quot;longitude&quot;: -118.243683&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;category&quot;: &quot;Electronics&quot;,&#xA;          &quot;createdAt&quot;: &quot;2022-01-27T16:20:35.040Z&quot;,&#xA;          &quot;deliveryBy&quot;: &quot;2022-01-31&quot;,&#xA;          &quot;description&quot;: &quot;The very Raspberry pi ...&quot;,&#xA;          &quot;id&quot;: &quot;c7fdf32d-d27...&quot;,&#xA;          &quot;images&quot;: [&#xA;            &quot;https://images.pri...&#xA;          ],&#xA;          &quot;price&quot;: 5,&#xA;          &quot;title&quot;: &quot;Raspberry Pi Zero&quot;,&#xA;          &quot;updatedAt&quot;: &quot;2022-01-27T16:20:35.040Z&quot;,&#xA;          &quot;weight&quot;: 0.1,&#xA;          &quot;goingTo&quot;: {&#xA;            &quot;city&quot;: &quot;Copenhagen&quot;,&#xA;            &quot;country&quot;: &quot;Denmark&quot;,&#xA;            &quot;latitude&quot;: 55.676098,&#xA;            &quot;longitude&quot;: 12.568337&#xA;          }&#xA;        } ....&#xA;</code></pre>&#xA;<p>Why is the filter being ignored? I tried my way with custom resolvers, but to no avail...</p>&#xA;",15634470,,,,2022-02-03 22:44:12,Incorrect filtering resolver in AWS AppSync,<amazon-web-services><graphql><aws-appsync><amplify>,0,0,0,2022-02-03 22:44:12
70984332,2,,60040092,1,,<p>I had the same issue and finally found a solution after trying many options.<br />&#xA;Query <code>X</code> and <code>Y</code> can be run sequentially on <strong>server-side</strong> by using parent and child Vue components.</p>&#xA;<ol>&#xA;<li>Run query <code>X</code> in the parent component.</li>&#xA;<li>Pass the result of <code>X</code> to the child component via props.</li>&#xA;<li>Run query <code>Y</code> in the child component with variables from props.</li>&#xA;</ol>&#xA;,4889634,,,,2022-02-04 09:51:01,"",,0,1,0,2022-02-04 09:51:01
70994489,1,70997172,,0,108,"<p>If I execute the following cypher in Neo4j browser returns the expected values</p>&#xA;<pre><code>MATCH (n:Document)&#xA;RETURN { &#xA;    year: n.year ,&#xA;    countdocs : COUNT(n) &#xA;}&#xA;</code></pre>&#xA;<p>Result:</p>&#xA;<pre><code>{&quot;countdocs&quot;:3,&quot;year&quot;:&quot;2018&quot;}    &#xA;</code></pre>&#xA;<p>But If I execute the same cypher in neo4j-graphql</p>&#xA;<pre><code>type Query {&#xA;    totalActivityOverTime: [JSONObject] @cypher(statement: &quot;&quot;&quot;&#xA;       MATCH (n:Document)&#xA;        RETURN { &#xA;         year: n.year ,&#xA;         countdocs : COUNT(n) &#xA;       }&#xA;    &quot;&quot;&quot;) &#xA;}&#xA;</code></pre>&#xA;<p>returns :</p>&#xA;<pre><code>  {&#xA;    &quot;countdocs&quot;: {&#xA;      &quot;low&quot;: 3,&#xA;      &quot;high&quot;: 0&#xA;    },&#xA;    &quot;year&quot;: &quot;2018&quot;&#xA;  },&#xA;</code></pre>&#xA;<p>What means the values ​​low and high?</p>&#xA;<p>Thanks!</p>&#xA;",3407798,,,,2022-02-05 23:15:15,Why using the count function in neo4j with graphql returns two values ​called low and high?,<javascript><neo4j><graphql><neo4j-graphql-js>,2,1,0,2022-02-05 00:59:32
70996452,1,,,0,212,"<p>I am Using Graphql to fetch data from api with some Where condition. In that, i need to check whether a field is not null and if so then i need to check for some key is present in that object and write the where query.</p>&#xA;<p>My Graphql query is as follows:</p>&#xA;<pre><code>query Orders{&#xA;  orders(limit:500 where:&quot;(store(key in (\&quot;store1\&quot;,\&quot;store2\&quot;))) and (state(key in (\&quot;state1\&quot;,\&quot;state2\&quot;)))&quot;){&#xA;      total&#xA;      count&#xA;      results {&#xA;        id&#xA;        origin&#xA;        store{&#xA;          key&#xA;        }&#xA;        state{&#xA;          key &#xA;          id&#xA;        }&#xA;      }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>if i run the above query i am getting error as below</p>&#xA;<pre><code>&quot;message&quot;: &quot;Malformed parameter: where: The field 'key' does not exist.&quot;,&#xA;      &quot;path&quot;: [&#xA;        &quot;orders&quot;&#xA;      ],&#xA;</code></pre>&#xA;<p>This is because the object state is null in some of the results and so , i need to check for the key if the state object is not null.</p>&#xA;<p>I tried <code>state!=null</code> but this doesn't work.&#xA;Any ideas or suggestions?</p>&#xA;",11143458,,2805067,2022-02-05 11:02:45,2022-02-05 11:02:45,Graphql conditional where Query,<javascript><reactjs><graphql>,0,1,0,2022-02-05 08:43:25
71002945,2,,70994489,0,,"<p>Thanks to @Sbunzini and @stdob-- I found the solution:</p>&#xA;<p>Schema:</p>&#xA;<pre><code>type Activity{&#xA;  year: String&#xA;  countdocs: Int&#xA;}&#xA;&#xA;type Query {&#xA;    totalActivityOverTime: [Activity] @cypher(statement: &quot;&quot;&quot;&#xA;       MATCH (n:Document)&#xA;        RETURN { &#xA;         year: n.year ,&#xA;         countdocs : COUNT(n) &#xA;       }&#xA;    &quot;&quot;&quot;) &#xA;}&#xA;</code></pre>&#xA;<p>GraphQL:</p>&#xA;<pre><code>{&#xA;  totalActivityOverTime{&#xA;    year&#xA;    countdocs &#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Thanks!</p>&#xA;",3407798,,,,2022-02-05 23:15:15,"",,0,0,0,2022-02-05 23:15:15
71009805,1,,,0,239,"<p>Angular 13 with Apollo-Angular @^3.0.0v2</p>&#xA;<p>Retrieving data from a graph and the Paginator updates but the table does not load.</p>&#xA;<p><strong>DataSource.ts</strong></p>&#xA;<pre class=""lang-typescript prettyprint-override""><code>export class ShipTableDataSource extends DataSource&lt;OrderShipInfo&gt; {&#xA;  data: OrderShipInfo[] = [];&#xA;  isLoading = true;&#xA;  paginator: MatPaginator | undefined;&#xA;  sort: MatSort | undefined;&#xA;&#xA;  constructor(private allOrdersGQL: GetAllOrdersGQL) {&#xA;    super();&#xA;    this.allOrdersGQL.watch().valueChanges.subscribe(result =&gt; {&#xA;      this.isLoading = false;&#xA;      //@ts-ignore&#xA;      this.data = result.data.orders?.orders&#xA;    });    &#xA;    &#xA;  }&#xA;&#xA;  /**&#xA;   * Connect this data source to the table. The table will only update when&#xA;   * the returned stream emits new items.&#xA;   * @returns A stream of the items to be rendered.&#xA;   */&#xA;  connect(): Observable&lt;OrderShipInfo[]&gt; {&#xA;</code></pre>&#xA;<p>Component.ts</p>&#xA;<pre class=""lang-typescript prettyprint-override""><code>export class ShipTableComponent implements OnInit, AfterViewInit {&#xA;&#xA;  @ViewChild(MatPaginator) paginator!: MatPaginator;&#xA;  @ViewChild(MatSort) sort!: MatSort;&#xA;  @ViewChild(MatTable) table!: MatTable&lt;OrderShipInfo&gt;;&#xA;  dataSource!: ShipTableDataSource;&#xA;&#xA;  /** Columns displayed in the table. Columns IDs can be added, removed, or reordered. */&#xA;  displayedColumns = ['poNumber', 'orderNumber', 'trackingNumber', 'vendorName'];&#xA;&#xA;&#xA;  constructor(private allOrdersGQL: GetAllOrdersGQL) { &#xA;    &#xA;  }&#xA;&#xA;  ngOnInit(): void {&#xA;    this.dataSource = new ShipTableDataSource(this.allOrdersGQL);&#xA;    }&#xA;&#xA;  ngAfterViewInit(): void {&#xA;    this.dataSource.sort = this.sort;&#xA;    this.dataSource.paginator = this.paginator;&#xA;    this.table.dataSource = this.dataSource;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Table after the data is loaded with no results</p>&#xA;<p><a href=""https://i.stack.imgur.com/jL9hc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jL9hc.png"" alt=""enter image description here"" /></a></p>&#xA;",10524951,,6463558,2022-02-17 04:28:50,2022-02-17 04:28:50,Material Table ->Datasource (Connect()) - Data Arrives Late and does not populate table,<angular><typescript><graphql><angular-material><apollo-client>,0,0,0,2022-02-06 17:30:59
71016512,1,,,1,160,"<p>I'm trying to save a new item to a graphql model, and then get the newly created item id and then use it to save to another table.</p>&#xA;<p>Here is the code I'm using for creating the new item</p>&#xA;<pre><code>import { DataStore } from &quot;@aws-amplify/datastore&quot;;&#xA;import { Tenants } from &quot;./models&quot;;&#xA;&#xA;DataStore.save(&#xA;      new Tenants({&#xA;        agency_name: &quot;Lorem ipsum dolor sit amet&quot;,&#xA;      })&#xA;    );&#xA;&#xA;//Now, Here I will do my stuff with the newly created tenant Id.&#xA;&#xA;</code></pre>&#xA;<p>Thanks a lot</p>&#xA;",11016348,,,,2022-02-07 09:52:29,AWS Appsync Graphql Get the Newly created item Id,<graphql><aws-amplify><aws-appsync>,0,0,0,2022-02-07 09:52:29
71035259,2,,71033128,1,,"<p>Unfortunately, at the moment there is no <code>MAX_BY</code> aggregate function, but as a workaround you can use something like this:</p>&#xA;<pre><code>FOR d IN docs&#xA;  COLLECT key = d.custom_key AGGREGATE v = MAX([d.value, d])&#xA;  RETURN { custom_key: key, doc: v[1] }&#xA;</code></pre>&#xA;",12747833,,12747833,2022-02-12 15:42:51,2022-02-12 15:42:51,"",,0,2,0,2022-02-08 14:05:43
71050120,1,,,1,574,"<p>Working with graphql java. I have schema like :</p>&#xA;<pre><code>type Deal {&#xA;  id: Int!,&#xA;  type: Type,&#xA;  instruments: [Instrument]&#xA;  #.. other fields&#xA;}&#xA;&#xA;type Instrument {&#xA;  id: Int!,&#xA;  name: String,&#xA;  legs: [Leg],&#xA;  #.. other fields&#xA;&#xA;}&#xA;type Leg {&#xA;  id: Int!&#xA;  payments: [Payment],&#xA;  #.. other fields&#xA;}&#xA;&#xA;type Payment {&#xA;  id: Int!,&#xA;  amount: Boolean!,&#xA;  account: Int!&#xA;  #.. other fields&#xA;}&#xA;</code></pre>&#xA;<p>The requirement is to fetch deal related payments with given filter criteria. the criteria contains fields from parents as well as child objects. The query looks like</p>&#xA;<pre><code>type Query {&#xA;  dealPayments(filter: Filter):[Deal]&#xA;}&#xA;&#xA;input Filter {&#xA;  type: Type, //field on Deal&#xA;  amountGreaterThan: Integer //field on Payment&#xA;  account: Integer //field on Payment&#xA;  # other conditions&#xA;}&#xA;</code></pre>&#xA;<p>I want to implement my resolvers in a way that enables me to retrieve all Deals which have payment account as given account.</p>&#xA;<pre><code>query AllDealsforAccount($filter : {&quot;account&quot; = 123}) {&#xA;   Deal {&#xA;     id &#xA;     instruments  {&#xA;       id&#xA;       legs {&#xA;         id&#xA;         payments (account: 123){&#xA;           id&#xA;           account&#xA;         }&#xA;       }&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>Now applying the corresponding criteria in child resolvers - the child object(payment) becomes null, but deal is still in the response. ** How to filter the parent deals based on child resolver? **</p>&#xA;<p>Any help would be appreciated. TIA</p>&#xA;",18161262,,,,2022-02-09 13:04:38,java GraphQL filtering parent data in child resolver,<java><graphql><parent-child><graphql-java><resolver>,0,1,0,2022-02-09 13:04:38
71056541,1,,,0,116,"<p>I have a peculiar situation where I need to resolve a type based on another type's value. For instance:</p>&#xA;<pre><code>type Car {&#xA;  year: Int!&#xA;  make: String!&#xA;  tireTypesSupported: [TireType]!,&#xA;  tireTypeInstalled: Tires!&#xA;}&#xA;&#xA;type TireType {&#xA;  id: ID!&#xA;}&#xA;&#xA;interface Tires {&#xA;  typeId: ID!&#xA;}&#xA;&#xA;type MudTires implements Tires {&#xA;  typeId: ID!&#xA;  width: Float!&#xA;  ratio: Float!&#xA;}&#xA;&#xA;type RaceTires implements Tires {&#xA;  typeId: ID!&#xA;  maxSpeed: Int!&#xA;  width: Float&#xA;}&#xA;</code></pre>&#xA;<p>Based on the fact that Apollo resolves the types Top-Bottom, in my Tires <code>resolveType</code>, Can I access the values of tireTypesSupported and match the <code>id</code> with the <code>typeId</code> to return the correct type? I know this problem could be solved by perhaps doing some design tweaks to the schema, or also checking the keys in the structure response, however in the real life scenario those are no solutions.</p>&#xA;",10200258,,,,2022-02-09 23:45:13,How do I access top-level field values from resolveType?,<graphql><apollo-client><apollo-server>,0,1,0,2022-02-09 20:50:45
71063570,1,,,3,997,"<p>Use this function to flatten the response returned from strapi on version 4. Helps you get rid of data and attributes properties</p>&#xA;<p>This will give you the same response structure as version 3 of strapi. This would help you migrate to version 4 from version 3 easily.</p>&#xA;<p>How to use it?</p>&#xA;<ol>&#xA;<li>import the file.</li>&#xA;<li>const flattnedData = flattenObj({...data})</li>&#xA;</ol>&#xA;<p>NOTE: The data here is the response returned from strapi version 4.</p>&#xA;<pre><code>export const flattenObj = (data) =&gt; {&#xA;const isObject = (data) =&gt;&#xA;    Object.prototype.toString.call(data) === &quot;[object Object]&quot;;&#xA;const isArray = (data) =&gt;&#xA;    Object.prototype.toString.call(data) === &quot;[object Array]&quot;;&#xA;&#xA;const flatten = (data) =&gt; {&#xA;    if (!data.attributes) return data;&#xA;&#xA;    return {&#xA;    id: data.id,&#xA;    ...data.attributes,&#xA;    };&#xA;};&#xA;&#xA;if (isArray(data)) {&#xA;    return data.map((item) =&gt; flattenObj(item));&#xA;}&#xA;&#xA;if (isObject(data)) {&#xA;    if (isArray(data.data)) {&#xA;    data = [...data.data];&#xA;    } else if (isObject(data.data)) {&#xA;    data = flatten({ ...data.data });&#xA;    } else if (data.data === null) {&#xA;    data = null;&#xA;    } else {&#xA;    data = flatten(data);&#xA;    }&#xA;&#xA;    for (const key in data) {&#xA;       data[key] = flattenObj(data[key]);&#xA;    }&#xA;&#xA;    return data;&#xA;}&#xA;&#xA;return data;&#xA;};&#xA;</code></pre>&#xA;",14154849,,14154849,2022-06-25 04:22:30,2022-06-25 04:22:30,strapi version 4 flatten complex response structure,<json><graphql><response><apollo-client><strapi>,0,4,0,2022-02-10 10:35:23
71064148,1,,,3,994,"<p>I'm rewriting strapi v3 queries to v4 (GraphQL), and with new fields 'data' and 'attributes', I have a problem going too much deep into nested objects, an example of how data looks:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>user {&#xA;  data {&#xA;    id&#xA;    attributes {&#xA;      company {&#xA;        data {&#xA;          id&#xA;          attributes {&#xA;            location {&#xA;              data {&#xA;                id&#xA;                ...&#xA;              }&#xA;          }&#xA;      }&#xA;    &#xA;    }&#xA;  }&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>Am I missing something in the documentation, is there a way to avoid this much nesting, should I restructure data in Model, or?</p>&#xA;",14133683,,,,2022-06-23 03:55:05,Strapi v4 too much nested data,<graphql><strapi>,2,0,0,2022-02-10 11:17:26
71070241,1,,,0,18,"<p>I'm using Apollo for react queries and can't seem to make a succession of requests. I'm trying to make one request for each day of the month. I have a query like</p>&#xA;<pre><code>const [getDate, {data}] = useGetDateLazyQuery();&#xA;</code></pre>&#xA;<p>Then prepare one query for each day of the month and try to run it like</p>&#xA;<pre><code>const params = getDateQueryParams(month); // returns an array of 28 variable objects&#xA;params.map(variables =&gt; getDate({variables})&#xA;</code></pre>&#xA;<p>But Apollo is being too crafty and only runs the very last call to <code>getDate</code></p>&#xA;<p>How can I tell Apollo to just do what I asked it?</p>&#xA;<p>Also I would rather even do</p>&#xA;<pre><code>const data = await getDateQuery({variables})&#xA;</code></pre>&#xA;<p>Because I'm 100% sure my next problem is the <code>data</code> state is not going to even update properly even if I do make those 28 queries. It will probably also be the last result.</p>&#xA;",17694534,,,,2022-02-10 18:13:25,Make series of requests with Apollo,<reactjs><apollo>,0,0,0,2022-02-10 18:13:25
71078922,1,,,0,18,"<p>I need to find a reservation in db which have have values in between <code>check_in</code> and <code>check_out</code> dates</p>&#xA;<p>Based on the following values I should get the object in return because <code>check_in</code> date is in between reservation's check in and out dates, but instead is not received anything.</p>&#xA;<p>Any idea how shall I fix this?</p>&#xA;<pre><code>const Reservations = [{&#xA;    _id: new ObjectId(&quot;62063d32778aab0f709a2c4d&quot;),&#xA;    check_in: 'Thu Feb 17 2022 00:00:00 GMT+0000 (Greenwich Mean Time)',&#xA;    check_out: 'Sun Feb 20 2022 00:00:00 GMT+0000 (Greenwich Mean Time)',&#xA;    guest: new ObjectId(&quot;62052c3c6b6e5fa8934175ec&quot;),&#xA;    room: new ObjectId(&quot;6202e7a2515dbbadfa04ad6e&quot;),&#xA;    createdAt: 2022-02-11T10:40:50.227Z,&#xA;    updatedAt: 2022-02-11T10:40:50.227Z,&#xA;    __v: 0&#xA;  }&#xA;]&#xA;&#xA;const checkIn = `Fri Feb 18 2022 00:00:00 GMT+0000 (Greenwich Mean Time)`&#xA;const checkOut = `Mon Feb 28 2022 00:00:00 GMT+0000 (Greenwich Mean Time)`&#xA;&#xA;let reservations = await Reservation.find({&#xA;    $and: [&#xA;      {&#xA;        check_in: {&#xA;          $gte: checkIn.toString(),&#xA;        },&#xA;      },&#xA;      {&#xA;        check_out: {&#xA;          $lte: checkOut.toString(),&#xA;        },&#xA;      },&#xA;    ],&#xA;  });&#xA;</code></pre>&#xA;",5019495,,5019495,2022-02-11 11:04:16,2022-02-11 11:04:16,How to find items in mongodb table in the range between two values?,<mongodb><graphql>,0,1,0,2022-02-11 10:54:34
71085607,2,,71084942,0,,"<p>I changed my mutation to this and now it works. I still don't fully understand why the other format didn't work.</p>&#xA;<pre><code>mutation AddJob($title: String!, $company: String!, $description: String!) &#xA;{&#xA;    addJob(title: $title, company: $company, description: $description)&#xA;}&#xA;</code></pre>&#xA;",16932160,,,,2022-02-11 19:28:48,"",,0,2,0,2022-02-11 19:28:48
71088361,1,,,1,186,"<p>I am Using AWS AppSync for my react native application and can't seem to figure out how to get sort inside of a query (nested queries/sorting?). Not sure what the proper terminology would be but here are my <code>graphQL</code> models, each month can contain many <code>monthsPhotos</code>:</p>&#xA;<pre><code>type Month&#xA;  @model&#xA;  @auth(rules: [{ allow: owner, operations: [read, create, delete, update] }]) {&#xA;  id: ID!&#xA;  name: String!&#xA;  owner: String!&#xA;  monthsphotos: [MonthPhoto] @hasMany&#xA;  createdAt: AWSDateTime!&#xA;  updatedAt: AWSDateTime!&#xA;  sorttype: String!&#xA;    @index(&#xA;      name: &quot;monthsByDateTime&quot;&#xA;      queryField: &quot;monthsByDateTime&quot;&#xA;      sortKeyFields: [&quot;createdAt&quot;]&#xA;    )&#xA;}&#xA;&#xA;type MonthPhoto&#xA;  @model&#xA;  @auth(rules: [{ allow: owner, operations: [read, create, delete, update] }]) {&#xA;  id: ID!&#xA;  month: Month @belongsTo&#xA;  thumbnail: String&#xA;  owner: String!&#xA;  caption: String&#xA;  location: String&#xA;  date: String&#xA;  createdAt: AWSDateTime!&#xA;  updatedAt: AWSDateTime!&#xA;  monthMonthsphotosId: ID!&#xA;    @index(&#xA;      name: &quot;monthPhotosByDateTime&quot;&#xA;      queryField: &quot;monthPhotosByDateTime&quot;&#xA;      sortKeyFields: [&quot;createdAt&quot;]&#xA;    )&#xA;  file: S3Object&#xA;}&#xA;</code></pre>&#xA;<p>my query for my months looks like this:</p>&#xA;<pre><code>export const monthsByDateTime = /* GraphQL */ `&#xA;  query MonthsByDateTime(&#xA;    $sorttype: String!&#xA;    $createdAt: ModelStringKeyConditionInput&#xA;    $sortDirection: ModelSortDirection&#xA;    $filter: ModelMonthFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    monthsByDateTime(&#xA;      sorttype: $sorttype&#xA;      createdAt: $createdAt&#xA;      sortDirection: $sortDirection&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        monthsphotos {&#xA;          items {&#xA;            file {&#xA;              bucket&#xA;              region&#xA;              key&#xA;            }&#xA;            createdAt&#xA;            caption&#xA;            date&#xA;            location&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>This lets me sort my months data by the date and time is was created. Ultimately I want a query that sorts all the months, and also sorts all the <code>monthsPhotos</code> within those months in 1 query. How would I go about doing this? Below is another query I made to sort <code>monthsPhotos</code> alone, I have not figured out how to connect these two into one:</p>&#xA;<pre><code>export const monthPhotosByDateTime = /* GraphQL */ `&#xA;  query MonthPhotosByDateTime(&#xA;    $monthMonthsphotosId: ID!&#xA;    $createdAt: ModelStringKeyConditionInput&#xA;    $sortDirection: ModelSortDirection&#xA;    $filter: ModelMonthPhotoFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    monthPhotosByDateTime(&#xA;      monthMonthsphotosId: $monthMonthsphotosId&#xA;      createdAt: $createdAt&#xA;      sortDirection: $sortDirection&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        file {&#xA;              bucket&#xA;              region&#xA;              key&#xA;            }&#xA;        caption&#xA;        location&#xA;        date&#xA;        createdAt&#xA;        monthMonthsphotosId&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",17734794,,7206922,2022-02-12 07:21:35,2022-02-12 07:21:35,Sorting AWS AppSync 'GraphQL' connected queries (nesting sorting?),<graphql><aws-appsync>,0,0,0,2022-02-12 01:54:30
71120023,1,,,0,152,"<p>The documentation for GraphQl-Ruby states that top level errors are added to <code>errors</code> when <a href=""https://graphql-ruby.org/errors/execution_errors"" rel=""nofollow noreferrer"">raising an exception</a> like this:</p>&#xA;<pre class=""lang-rb prettyprint-override""><code>raise GraphQL::ExecutionError, &quot;Can't continue with this query&quot;&#xA;</code></pre>&#xA;<p>Which produces:</p>&#xA;<pre class=""lang-rb prettyprint-override""><code>{&#xA;  &quot;errors&quot; =&gt; [&#xA;    {&#xA;      &quot;message&quot; =&gt; &quot;Can't continue with this query&quot;,&#xA;      &quot;locations&quot; =&gt; [&#xA;        {&#xA;          &quot;line&quot; =&gt; 2,&#xA;          &quot;column&quot; =&gt; 10,&#xA;        }&#xA;      ],&#xA;      &quot;path&quot; =&gt; [&quot;user&quot;, &quot;login&quot;],&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>But I want to continue and add more than one error to the errors array. How do I do this (cleanly without a hack)</p>&#xA;",63810,,,,2022-02-15 23:54:38,How do I add more than one error to the errors array in graphql-ruby?,<ruby><graphql><graphql-ruby>,1,0,0,2022-02-15 00:59:59
71139783,1,,,0,608,"<p>I have a Query that takes an argument with child type which also takes an argument. I would like to pass arguments on both the query and the query child type. I need help on how to implement this logic.</p>&#xA;<p>When I hard code the &quot;after&quot; variable the app works fine. How do I implement the resolver to get the after variable from the front-end and then pass is to playerInFoAPI in the dataSources?</p>&#xA;<p><strong>SCHEMA</strong></p>&#xA;<pre><code>const { gql } = require(&quot;apollo-server-express&quot;);&#xA;&#xA;const typeDefs = gql`&#xA;  scalar Date&#xA;&#xA;  type Query {&#xA;    text: String!&#xA;    club(slug: String!): Club!&#xA;  }&#xA;&#xA;  type Club {&#xA;    id: ID!&#xA;    name: String!&#xA;    pictureSecondaryUrl: String&#xA;    domesticLeague: DomesticLeague&#xA;    players(first: Int, after: String): PlayerConnection!&#xA;  }&#xA;&#xA;  type PlayerConnection {&#xA;    edges: [playerEdge!]!&#xA;    nodes: [Player!]!&#xA;    pageInfo: PageInfo!&#xA;  }&#xA;&#xA;  type PageInfo {&#xA;    endCursor: String&#xA;    hasNextPage: Boolean!&#xA;    hasPreviousPage: Boolean!&#xA;    startCursor: String&#xA;  }&#xA;&#xA;  type Player {&#xA;    id: ID!&#xA;    displayName: String!&#xA;    slug: String!&#xA;    age: Int!&#xA;    birthDate: Date&#xA;    position: String!&#xA;    country: Country!&#xA;    subscriptionsCount: Int!&#xA;    pictureUrl: String&#xA;    shirtNumber: Int&#xA;    status: PlayerStatus!&#xA;    activeClub: Club&#xA;    allSo5Scores: So5ScoreConnection!&#xA;  }&#xA;&#xA;  type playerEdge {&#xA;    cursor: String!&#xA;    node: Player&#xA;  }&#xA;&#xA;  type Country {&#xA;    code: String!&#xA;  }&#xA;&#xA;  type PlayerStatus {&#xA;    id: ID!&#xA;    lastFifteenSo5Appearances: Int&#xA;    lastFifteenSo5AverageScore: Float&#xA;    lastFiveSo5Appearances: Int&#xA;    lastFiveSo5AverageScore: Float&#xA;    playingStatus: String&#xA;  }&#xA;&#xA;  type So5ScoreConnection {&#xA;    nodes: [So5Score!]!&#xA;  }&#xA;&#xA;  type So5Score {&#xA;    score: Float&#xA;  }&#xA;  type DomesticLeague {&#xA;    id: ID!&#xA;    displayName: String!&#xA;  }&#xA;`;&#xA;&#xA;module.exports = typeDefs;&#xA;</code></pre>&#xA;<p><strong>GRAPHQL DATA SOURCE WITH QUERY</strong></p>&#xA;<pre><code>const { GraphQLDataSource } = require(&quot;apollo-datasource-graphql&quot;);&#xA;const { gql } = require(&quot;apollo-server-express&quot;);&#xA;&#xA;const PLAYER_INFO = gql`&#xA;  query PLAYER_INFO($slug: String!, $after: String) {&#xA;    club(slug: $slug) {&#xA;      players(first: 2, after: $after) {&#xA;        pageInfo {&#xA;          endCursor&#xA;          hasNextPage&#xA;          hasPreviousPage&#xA;          startCursor&#xA;        }&#xA;        edges {&#xA;          # start node&#xA;          node {&#xA;            id&#xA;            displayName&#xA;            slug&#xA;            age&#xA;            birthDate&#xA;            position&#xA;            country {&#xA;              slug&#xA;              code&#xA;            }&#xA;            subscriptionsCount&#xA;            pictureUrl&#xA;            shirtNumber&#xA;            activeClub {&#xA;              id&#xA;              name&#xA;              pictureSecondaryUrl&#xA;              domesticLeague {&#xA;                id&#xA;                displayName&#xA;              }&#xA;            }&#xA;            status {&#xA;              id&#xA;              lastFifteenSo5Appearances&#xA;              lastFifteenSo5AverageScore&#xA;              lastFiveSo5Appearances&#xA;              lastFiveSo5AverageScore&#xA;              playingStatus&#xA;            }&#xA;            allSo5Scores {&#xA;              nodes {&#xA;                score&#xA;              }&#xA;            }&#xA;          } #end node&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;class PlayerInfoAPI extends GraphQLDataSource {&#xA;  constructor() {&#xA;    super();&#xA;    this.baseURL = &quot;https://api.sorare.com/graphql/&quot;;&#xA;  }&#xA;&#xA;  async getPlayerInfo(slug,after) {&#xA;    try {&#xA;      const response = await this.query(PLAYER_INFO, {&#xA;        variables: {&#xA;          slug,&#xA;          after&#xA;        },&#xA;      });&#xA;&#xA;      return this.playerInfoReducer(response.data.club.players);&#xA;    } catch (err) {&#xA;      console.log(err);&#xA;      throw new Error(err.message);&#xA;    }&#xA;  }&#xA;&#xA;  playerInfoReducer(data) {&#xA;    return {&#xA;      players: {&#xA;        pageInfo: {&#xA;          endCursor: data.pageInfo.endCursor,&#xA;          startCursor: data.pageInfo.startCursor,&#xA;          hasNextPage: data.pageInfo.hasNextPage,&#xA;          hasPreviousPage: data.pageInfo.hasPreviousPage,&#xA;        },&#xA;&#xA;        &#xA;      },&#xA;    };&#xA;  }&#xA;}&#xA;&#xA;module.exports = PlayerInfoAPI;&#xA;&#xA;</code></pre>&#xA;<p><strong>RESOLVER</strong></p>&#xA;<pre><code>const dateScalar = require(&quot;../Utils/CustomDate&quot;);&#xA;&#xA;const resolvers = {&#xA;  Date: dateScalar,&#xA;&#xA;  Query: {&#xA;    text: () =&gt; &quot;Hello There!&quot;,&#xA;&#xA;    club: (_, { slug }, { dataSources }) =&gt;&#xA;      dataSources.playerInfoAPI.getPlayerInfo(slug),&#xA;  },&#xA;  // Club: {&#xA;  //   players(_, { after }, { dataSources }) {&#xA;  //     return dataSources.playerInfoAPI.getPlayerInfo(after);&#xA;  //   },&#xA;  // },&#xA;};&#xA;&#xA;module.exports = resolvers;&#xA;</code></pre>&#xA;<p><strong>FRONT END WITH FETCHMORE FUNCTION</strong></p>&#xA;<pre><code>const SLUG = &quot;slug-example&quot;;&#xA;&#xA;const PlayerListTable = () =&gt; {&#xA;  const { data, loading, error, networkStatus, fetchMore } = useQuery(&#xA;    PLAYERS_INFO,&#xA;    {&#xA;      variables: { slug: SLUG, after: null },&#xA;      notifyOnNetworkStatusChange: true,&#xA;    }&#xA;  );&#xA;&#xA;  const onLoadMore = () =&gt; {&#xA;    //destructure end cursor&#xA;    const { endCursor } = data.club.players.pageInfo;&#xA;    console.log(endCursor);&#xA;&#xA;    fetchMore({&#xA;      variables: {&#xA;        after: endCursor,&#xA;      },&#xA;&#xA;      updateQuery: (prevResult, { fetchMoreResult }) =&gt; {&#xA;        console.log(fetchMoreResult);&#xA;      },&#xA;    });&#xA;  };&#xA;</code></pre>&#xA;",13139969,,,,2022-07-20 09:14:53,Apollo GraphQL resolvers how to pass arguments to query child type,<node.js><graphql><apollo-server>,1,2,0,2022-02-16 10:07:44
71139900,1,,,0,25,"<p>I have a Query to filter my <code>Premises</code> by a query called <code>premiseBySelectedFlag</code> Like this.</p>&#xA;<pre><code> premiseBySelectedFlag(selected: Boolean!): [Premise!]!&#xA;    @resolver(name: &quot;listAllSelectedPremises&quot;, paginated: true)&#xA;</code></pre>&#xA;<p>How do I create a function for this?</p>&#xA;<p>Currently, I have a basic function I use for my queries, like this</p>&#xA;<pre><code>Query(&#xA;  Lambda(&#xA;    [&quot;size&quot;, &quot;after&quot;, &quot;before&quot;],&#xA;    Let(&#xA;      {&#xA;        match: Match(Index(&quot;latestSelectedPremises&quot;)),&#xA;        page: If(&#xA;          Equals(Var(&quot;before&quot;), null),&#xA;          If(&#xA;            Equals(Var(&quot;after&quot;), null),&#xA;            Paginate(Var(&quot;match&quot;), { size: Var(&quot;size&quot;) }),&#xA;            Paginate(Var(&quot;match&quot;), { after: Var(&quot;after&quot;), size: Var(&quot;size&quot;) })&#xA;          ),&#xA;          Paginate(Var(&quot;match&quot;), { before: Var(&quot;before&quot;), size: Var(&quot;size&quot;) })&#xA;        )&#xA;      },&#xA;      Map(Var(&quot;page&quot;), Lambda([&quot;_&quot;, &quot;ref&quot;], Get(Var(&quot;ref&quot;))))&#xA;    )&#xA;  )&#xA;)&#xA;</code></pre>&#xA;<p>But When i do this in my GraphQL playground</p>&#xA;<pre><code>query{&#xA;  premiseBySelectedFlag(selected: true){&#xA;    data{&#xA;      _id&#xA;      content&#xA;      selected&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I get this error in my GraphQL</p>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;Lambda expects an array with 3 elements. Array contains 4.\n&quot;,&#xA;      &quot;extensions&quot;: {&#xA;        &quot;code&quot;: &quot;invalid argument&quot;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>What is the correct way to create this function?</p>&#xA;<p>PS. I created the index <code>latestSelectedPremises</code></p>&#xA;<p><a href=""https://i.stack.imgur.com/rjZIk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rjZIk.png"" alt=""enter image description here"" /></a>&#xA;Is this correct?</p>&#xA;<p>Thank you</p>&#xA;",2735762,,,,2022-02-16 10:15:43,How do I create a lambda function for basic GraphQL filtering on FaunaDB?,<javascript><filter><lambda><graphql><faunadb>,0,0,0,2022-02-16 10:15:43
71166140,1,,,0,349,"<p>I have a current Query type defined like this:</p>&#xA;<pre><code>type BoxItems {&#xA;  total: Number,&#xA;  boxItems: [BoxItem]&#xA;}&#xA;type Box {&#xA;     boxItemUuid: UUID!&#xA;     boxItems:(page: Number, pageSize: Number): BoxItems&#xA;}&#xA;extend Query {&#xA;   boxes(input: SomeInputType): [Box]&#xA;   boxItems(boxItemUuid: UUID!, page: Number, pageSize: Number): BoxItems&#xA;}&#xA;</code></pre>&#xA;<p>Which is then called by client like:</p>&#xA;<pre><code>query BoxesQuery($input: SomeInputType){&#xA;  boxes(input:$input){&#xA;   boxItems:(pageSize:1){&#xA;     total&#xA;  }&#xA; }&#xA;}&#xA;</code></pre>&#xA;<p>In this case a boxItems resolver function is still able to access boxItemUuid in the args object. My question is what if I decide to create input types for my boxItems Query type. For instance, lets say boxItemUuid was now defined in FilterInfo type</p>&#xA;<pre><code> boxItems(pageInfo: PageInfo, filter: FilterInfo): BoxItems&#xA;</code></pre>&#xA;<p>How would I go about defining the query client BoxesQuery, to pass boxItemUuid as a field on the FilterInfo type? Is this even possible? Is it bad practice for query types to include non scalar type parameters?</p>&#xA;",2394409,,2394409,2022-02-17 22:39:46,2022-02-18 17:33:15,GraphQL query with nested query passing parameters to non scalar type arguments,<graphql><apollo-client><apollo-server>,1,0,0,2022-02-17 22:24:45
71183489,1,,,0,252,"<p>I'm wondering what's the best method to get file uplaod/download working in Apollo Graphql</p>&#xA;<pre><code>type Query {&#xA;  getFile: File # &lt;-- Errors out, File isn't recognized as a type&#xA;}&#xA;&#xA;type Mutation {&#xA;  uploadFile(File): Int&#xA;}&#xA;</code></pre>&#xA;",2167582,,,,2022-02-22 07:12:48,How to define a file upload/download endpoint in Apollo / Graphql?,<file-upload><download><graphql><apollo>,0,1,0,2022-02-19 08:55:49
71216563,2,,71214798,0,,"<p>By default the <code>sort</code> GraphQL option sorts alphabetically. In your case, if you want the default order just remove the following line:</p>&#xA;<pre><code>  sort: {fields: frontmatter___order, order: ASC}&#xA;</code></pre>&#xA;<p>Leaving your query as:</p>&#xA;<pre><code>categoryA: allMdx(&#xA;  filter: {frontmatter: {section: {eq: &quot;categoryA&quot;}}}&#xA;  ) {&#xA;    distinct(field: frontmatter___category)&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        frontmatter {&#xA;          category&#xA;          path&#xA;          title&#xA;        }&#xA;      }&#xA;    }&#xA;   }&#xA;</code></pre>&#xA;<p>This should return the categories in the fetched order.</p>&#xA;<p>Another option is using the JavaScript <a href=""https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"" rel=""nofollow noreferrer""><code>sort()</code></a> method before printing the categories somewhere. Something like:</p>&#xA;<pre><code>let sortedData = props.data.categoryA.edges.node.sort((a, b) =&gt; a.frontmatter.order - b.frontmatter.order);&#xA;</code></pre>&#xA;<p>Applying your code. The idea relies on not using GraphQL sorting but JavaScript's.</p>&#xA;<pre><code>let sortedData= data[section]['distinct'].sort((a, b) =&gt; a.frontmatter.order - b.frontmatter.order));&#xA;</code></pre>&#xA;<p>Then just loop through your <code>sortedData</code> in the same way.:</p>&#xA;<pre><code>  {sortedData[section]['distinct'].map((category) =&gt;(&#xA;    &lt;SubMenu &#xA;      key={category} &#xA;      title={category.replace('-', ' ')}&#xA;      style={{&#xA;        fontWeight: 700,&#xA;        maxWidth: 250,&#xA;      }}&#xA;    &gt;&#xA;      {checkCategory(category)} //get the MD files that belongs to this category&#xA;    &lt;/SubMenu&gt;&#xA;  ))}&#xA;</code></pre>&#xA;",5585371,,5585371,2022-03-08 05:06:35,2022-03-08 05:06:35,"",,0,2,0,2022-02-22 06:02:38
71253957,2,,70382084,10,,"<p><strong>&quot;force_text&quot;</strong> is removed from <strong>Django 4.0</strong>:</p>&#xA;<p><a href=""https://docs.djangoproject.com/en/4.0/releases/4.0/#features-removed-in-4-0"" rel=""noreferrer"">Features removed in 4.0</a></p>&#xA;<p>But <strong>graphene_django</strong> still uses <strong>&quot;force_text&quot;</strong> in <strong>utils.py</strong>.</p>&#xA;<p><strong>utils.py:</strong></p>&#xA;<pre class=""lang-py prettyprint-override""><code>from django.utils.encoding import force_text # Line 6&#xA;&#xA;s = force_text(s) # Line 29&#xA;</code></pre>&#xA;<p>So you need to replace <strong>&quot;force_text&quot;</strong> with <strong>&quot;force_str&quot;</strong> as shown below:</p>&#xA;<p><strong>utils.py:</strong></p>&#xA;<pre class=""lang-py prettyprint-override""><code>from django.utils.encoding import force_str# Line 6&#xA;&#xA;s = force_str(s) # Line 29&#xA;</code></pre>&#xA;<p>These are the paths to <strong>utils.py</strong> for <strong>Linux</strong> and <strong>Windows</strong>:</p>&#xA;<p><strong>Linux:</strong></p>&#xA;<p>&lt;your_venv&gt;/lib/&lt;python_version&gt;/site-packages/graphene_django/utils/utils.py</p>&#xA;<p><strong>Windows:</strong></p>&#xA;<p>&lt;your_venv&gt;/lib/site-packages/graphene_django/utils/utils.py</p>&#xA;",8172439,,8172439,2022-02-24 15:10:52,2022-02-24 15:10:52,"",,0,0,0,2022-02-24 14:59:22
71291089,1,,,0,30,"<p>I'm using neo4j's graphql library and it uses enums for SortDirections, like this:</p>&#xA;<pre><code>enum SortDirection {&#xA;    ASC&#xA;    DESC&#xA;}&#xA;</code></pre>&#xA;<p>And I would like to be able to dynamically set this from my React Native application, but I'm not sure how I would go about it because I can't just reference <code>DESC</code> - the closest I have come up with is making it a string, which doesn't work <code>&quot;DESC&quot;</code>.</p>&#xA;<pre><code>let options = { sort: { originalValue: sortDirection }, limit: 10 }&#xA;&#xA;</code></pre>&#xA;<p>Since it's an enum and not a string, <code>&quot;DESC&quot;</code> doesn't work. But I'm not able to just write <code>DESC</code> because it's not a defined variable in my javascript application, any idea what to do? Thank you in advance.</p>&#xA;",1604072,,3065924,2022-02-28 09:27:34,2022-02-28 09:27:34,How can I dynamically set a SortDirection for Neo4j Graphql in javascript?,<reactjs><react-native><neo4j><graphql>,1,0,0,2022-02-28 05:55:41
71293575,1,,,0,79,"<p>I using scout with meilisearch but search directive not working with orderBy</p>&#xA;<pre><code>input OrderByClause {&#xA;column: String!&#xA;order: DESC&#xA;}&#xA;type Query {&#xA;users(search: String @search orderBy: [OrderByClause!] @orderby): [User!]! @paginate&#xA;&#xA;Query&#xA;users(first:10, search: &quot;test&quot;, orderBy: [ {column: &quot;id&quot;, order: DESC}])&#xA;</code></pre>&#xA;<p>but working in controller&#xA;<code>$users = User::search('test')-&gt;orderBy('id','desc')-&gt;paginate()</code></p>&#xA;",13762180,,,,2022-02-28 10:27:11,How to use @search directive with orderby,<laravel><graphql><laravel-lighthouse>,0,1,0,2022-02-28 10:27:11
71307108,2,,71305535,0,,"<p>I found it. The link is provided via <code>connect</code> keyword.</p>&#xA;<pre><code>mutation createUser {&#xA;  createUser(data: {&#xA;    name: &quot;some_name&quot;, settings: {&#xA;      connect: {&#xA;        settings_uid: &quot;settings_uid&quot;&#xA;      }&#xA;    }&#xA;  }) {&#xA;    user_uid&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",11503139,,,,2022-03-01 10:34:54,"",,0,0,0,2022-03-01 10:34:54
71315918,1,71315972,,0,259,"<p>I need to set fragment to my gql. It is working code:</p>&#xA;<pre><code>const findEntity = gql`&#xA;  query findEntity($pagination: Pagination, $sort: Sort) {&#xA;    organizationList(pagination: $pagination, sort: $sort) {&#xA;      data {&#xA;        _id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>This code doesn't work:</p>&#xA;<pre><code>const TEST_FRAGMENT = gql`&#xA;  fragment organizationList on OrganizationsPage {&#xA;    data {&#xA;      _id&#xA;      name&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;const findEntity = gql`&#xA;  query findEntity($pagination: Pagination, $sort: Sort) {&#xA;    organizationList(pagination: $pagination, sort: $sort) {&#xA;      ${TEST_FRAGMENT}&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;</code></pre>&#xA;<p>errors: [{message: &quot;Cannot query field &quot;fragment&quot; on type &quot;OrganizationsPage&quot;.&quot;,…},…]</p>&#xA;<p>What I do wrong? I think I repeated documentation sample...</p>&#xA;",11025362,,,,2022-03-01 23:59:38,How to fetch graphQl fragment?,<javascript><graphql><apollo-client>,1,1,0,2022-03-01 23:50:41
71315972,2,,71315918,1,,"<p>Fragments use pseudo-spread syntax and you need to include them in the query. I also used caps for the fragment name for convention compliance.</p>&#xA;<pre><code>const findEntity = gql`&#xA;  ${TEST_FRAGMENT}&#xA;  query findEntity($pagination: Pagination, $sort: Sort) {&#xA;    organizationList(pagination: $pagination, sort: $sort) {&#xA;      ...OrganizationListFields&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",1231844,,,,2022-03-01 23:59:38,"",,0,2,0,2022-03-01 23:59:38
71333327,2,,70933025,3,,"<p>I think this is related to this change: <a href=""https://github.com/graphql-java/graphql-java/pull/2549"" rel=""nofollow noreferrer"">https://github.com/graphql-java/graphql-java/pull/2549</a></p>&#xA;<p>New limits have been introduced to GraphQL.</p>&#xA;<p>You can use <code>graphql.parser.ParserOptions;</code> to set a higher maxTokens value.</p>&#xA;",18361503,,2963422,2022-03-07 08:04:10,2022-03-07 08:04:10,"",,0,0,0,2022-03-03 07:12:59
71335387,1,,,1,295,"<p>I think there is something I don't understand here... First time working with cursor-based pagination in GraphQL.</p>&#xA;<p>I am using the Apollo iOS client in my swift project.</p>&#xA;<p>What I can't seems to grasp is that I have a query that looks like this:</p>&#xA;<pre><code>query BalloonsList {&#xA;  balloons {&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      hasPreviousPage&#xA;      startCursor&#xA;      endCursor&#xA;    }&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        name&#xA;        description&#xA;        imageUrl&#xA;        variant&#xA;        color&#xA;        price&#xA;        availableSince&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>It works perfectly, the server always responds with 5 objects and I receive the end-cursor for the next request. I can pass in the cursor by implementing a variable in the query like so:</p>&#xA;<pre><code>query BalloonsList($cursor:String) {&#xA;  balloons(after:$cursor) {&#xA;</code></pre>&#xA;<p>However, when I have this variable in my query and I don't have a cursor for the very first request it fails of cause. So, an option could be to create two different queries one with the variable and one without for the first request, but it just seems wrong.</p>&#xA;<p>I feel like there is something fundamental I don't understand here? How do I implement the <code>after:</code> parameter in my query only after my first fetch?</p>&#xA;<p>Hope it makes sense </p>&#xA;",12764203,,,,2022-03-09 21:50:21,Pagination: First request without a cursor in GraphQL?,<swift><graphql><pagination><apollo-client>,1,1,0,2022-03-03 10:13:19
71351977,1,,,0,150,"<p>I'm trying to simplify my query to graphql and I ended up duplicating code in the query</p>&#xA;<p>here are what similar to what I have.</p>&#xA;<pre><code>fragment VehicleFragment on Vehicle {&#xA;    id&#xA;    name&#xA;    type&#xA;    brand&#xA;    childs{&#xA;      id&#xA;      name&#xA;      type&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>1- can I use the VehicleFragment again inside my fragment?</p>&#xA;<p>secon thing I'm trying to achieve somehting like this</p>&#xA;<pre><code>query FetchVehicles($filter: ProductFilterInput!) {&#xA;    vehicles() {&#xA;        ... VehicleFragment&#xA;        childs{&#xA;         ... VehicleFragment&#xA;        }   &#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>when I'm using the second query with Apollo client for Android it generate only a model with the <code>VehicleFragment</code> without the childs object  like this</p>&#xA;<pre><code> data class Vehicle(&#xA;    val __typename: String = &quot;Vehicle&quot;,&#xA;    val fragments: Fragments&#xA;  )&#xA;&#xA; data class Fragments(&#xA;      val vehicleFragment: VehicleFragment&#xA;    )&#xA;</code></pre>&#xA;<p>2- what is the best way to achieve this ?</p>&#xA;",3553843,,,,2022-03-04 13:13:27,How to send qraphql query with fragment inside a fragment? Apollo Android,<android><graphql><apollo-client>,0,0,0,2022-03-04 13:13:27
71357395,2,,71357329,0,,"<p>You need to create a wrapper type that allows for other fields related to pagination because graphql only allows the returning of known/defined fields</p>&#xA;<p>Here's an example from a project I worked on prior:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>gql`&#xA;  type UserQueryResult {&#xA;    page: PositiveInt!&#xA;    total: PositiveInt!&#xA;    numPages: PositiveInt!&#xA;    resultsPerPage: PositiveInt!&#xA;    hasNextPage: Boolean!&#xA;    hasPreviousPage: Boolean!&#xA;    results: [User!]!&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>That way in your <code>Query</code> definition you can return the new paginated type.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>gql`&#xA;type Query {&#xA;&#xA;  &quot;&quot;&quot;&#xA;  Returns users that match the given query&#xA;  &quot;&quot;&quot;&#xA;  searchUsers(&#xA;    &quot;&quot;&quot;&#xA;    A string used to filter users&#xA;    &quot;&quot;&quot;&#xA;    query: String! = &quot;&quot;&#xA;&#xA;    &quot;&quot;&quot;&#xA;    The page requested, if the query has more than one page of results.&#xA;    &quot;&quot;&quot;&#xA;    page: PositiveInt! = 1&#xA;&#xA;    &quot;&quot;&quot;&#xA;    Number of results on each page. Must be between 1 and 50. Default is 9&#xA;    &quot;&quot;&quot;&#xA;    resultsPerPage: PositiveInt! = 9&#xA;  ): UserQueryResult!&#xA;}&#xA;&#xA;`&#xA;</code></pre>&#xA;<p>And from your client when you're querying you can do:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const USER_QUERY = gql`&#xA;  query ($page: PositiveInt!, $query: String!) {&#xA;    searchUsers(page: $page, query: $query) {&#xA;      numPages&#xA;      page&#xA;      total&#xA;      results {&#xA;        id&#xA;        name&#xA;        email&#xA;        adminPrivileges&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;",10237430,,,,2022-03-04 21:29:57,"",,0,1,0,2022-03-04 21:29:57
71401201,2,,50373038,1,,<p>I also faced a similar issue.</p>&#xA;<p>For months we have had the following in our schema</p>&#xA;<p>type WindData {&#xA;N: windData!&#xA;NE: windData!&#xA;E: windData!&#xA;SE: windData!&#xA;S: windData!&#xA;SW: windData!&#xA;W: windData!&#xA;NW: windData!&#xA;}</p>&#xA;<p>type windData {&#xA;isAlarm: Boolean!&#xA;value: Float!&#xA;}</p>&#xA;<p>A few days ago the schema build start failing with</p>&#xA;<pre><code>Schema has the following errors: - Schema contains duplicate type names.&#xA;</code></pre>&#xA;<p>Appears that case is no longer adhered to so we had to go look for any types that mixed case and make the names unique</p>&#xA;<p>A change in behaviour from AWS Appsync....</p>&#xA;,10125208,,,,2022-03-08 20:42:14,"",,0,0,0,2022-03-08 20:42:14
71402156,1,,,0,477,"<p>I've been trying to fix this 400 issue but no luck so far. When running a total count query with pagination, it works just fine but as soon as I expand my query to add edges, cursor and node, it breaks.</p>&#xA;<p>My hunch says, there is some discrepancy between resolver and Schema, could be wrong. Please do not suggest to modify the Schema, my only option is to update the resolver to make it work. Please help!</p>&#xA;<p>The query with count and pagination (Works just fine)-</p>&#xA;<pre><code>query MyQuery {&#xA;  orders(orderId: &quot;3y8&quot;) {&#xA;    totalCount&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      endCursor&#xA;      hasPreviousPage&#xA;      startCursor&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;Response -&#xA;{&#xA;  &quot;data&quot;: {&#xA;    &quot;orders&quot;: {&#xA;      &quot;totalCount&quot;: 7,&#xA;      &quot;pageInfo&quot;: {&#xA;        &quot;hasNextPage&quot;: true,&#xA;        &quot;endCursor&quot;: &quot;eyJ==&quot;,&#xA;        &quot;hasPreviousPage&quot;: false,&#xA;        &quot;startCursor&quot;: null&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I have added Schema, query and resolver which is VTL based. Also CloudWatch logs, which clearly shows the response i am getting - Edges : [{Node, Cursor}]</p>&#xA;<pre><code>type Query {&#xA;        orders(&#xA;        orderId: String,&#xA;        last: Int,&#xA;        before: String,&#xA;        first: Int,&#xA;        after: String&#xA;    ): Connection&#xA;}&#xA;&#xA;type Connection {&#xA;    edges: [Edge!]!&#xA;    pageInfo: PageInfo!&#xA;    totalCount: Int!&#xA;}&#xA;&#xA;interface Edge {&#xA;    node: Node!&#xA;    cursor: String!&#xA;}&#xA;&#xA;interface Node {&#xA;    id: String!&#xA;}&#xA;&#xA;</code></pre>&#xA;<pre><code>  orders(orderId: &quot;3y8&quot;, first: 1) {&#xA;    totalCount&#xA;    edges {&#xA;      cursor&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Resolver-&gt;</p>&#xA;<pre><code>#set($edges = [])&#xA;#set( $nextTokenCursor = &quot;&quot; )&#xA;#if($context.result.nextToken) &#xA;    #set($nextTokenCursor = $context.result.nextToken)&#xA;#end&#xA;&#xA;#foreach($item in $context.result.items)&#xA;    $util.quiet($edges.add({&quot;node&quot;: $item, &quot;cursor&quot;: $nextTokenCursor}))&#xA;#end&#xA;{&#xA;          &quot;edges&quot;: $util.toJson($edges),&#xA;          &quot;totalCount&quot;: $util.toJson($ctx.result.items.size()),&#xA;          &quot;pageInfo&quot;: {&#xA;            &quot;hasPreviousPage&quot;: false,&#xA;            &quot;hasNextPage&quot;: #if($context.result.nextToken) true #else false #end,&#xA;            &quot;endCursor&quot;: $util.toJson($nextTokenCursor)&#xA;          }&#xA;}&#xA;</code></pre>&#xA;<p>CloudWatch Logs -&gt;</p>&#xA;<p>&quot;transformedTemplate&quot;: &quot;{edges=[{node={summary={<strong>Records</strong>}, customer={}}, cursor=eyJ==}], totalCount=1, pageInfo={hasPreviousPage=false, hasNextPage=true, endCursor=eyJ== }}&quot;</p>&#xA;",18412520,,,,2022-03-08 22:20:58,AWS AppSync GraphQL query failing with Status Code 400,<graphql><aws-appsync>,0,0,0,2022-03-08 22:20:58
71416388,2,,71335387,0,,<p>@Herku was right. This:</p>&#xA;<pre><code>query BalloonsList($cursor:String) {&#xA;  balloons(after:$cursor) {&#xA;</code></pre>&#xA;<p>This worked since it's optional. What caused the problem was that Apollo had created another type for me called ID instead of String.</p>&#xA;,12764203,,,,2022-03-09 21:50:21,"",,0,0,0,2022-03-09 21:50:21
71424540,1,,,1,346,"<p>I am building a django graphql api with graphene for photography events. Each event has a location, photographer and event date. I want to be able to filter all events by year, month or day, e.g. return all events happening in April 2022 or all events that happen on Thursdays. I would also like to filter for future events only.  The model:</p>&#xA;<pre class=""lang-py prettyprint-override""><code># models.py&#xA;&#xA;class Event(models.Model):&#xA;    STATUS = (&#xA;        (&quot;Scheduled&quot;, &quot;Scheduled&quot;),&#xA;        (&quot;Cancelled&quot;, &quot;Cancelled&quot;),&#xA;        (&quot;Available&quot;, &quot;Available&quot;),&#xA;        (&quot;Complete&quot;, &quot;Complete&quot;),&#xA;    )&#xA;    location = models.ForeignKey(&#xA;        Location, on_delete=models.SET_NULL, null=True, related_name=&quot;location_events&quot;&#xA;    )&#xA;    photographer = models.ForeignKey(&#xA;        Photographer,&#xA;        on_delete=models.SET_NULL,&#xA;        null=True,&#xA;        related_name=&quot;photographer_events&quot;,&#xA;    )&#xA;    event_date = models.DateField()&#xA;    status = models.CharField(max_length=50, choices=STATUS, default=&quot;Scheduled&quot;)&#xA;    created = models.DateTimeField(auto_now_add=True)&#xA;&#xA;    class Meta:&#xA;        constraints = [&#xA;            models.UniqueConstraint(&#xA;                name=&quot;location_event&quot;, fields=(&quot;location&quot;, &quot;event_date&quot;)&#xA;            )&#xA;        ]&#xA;&#xA;    def __str__(self):&#xA;        return f&quot;Event {self.location}, {self.event_date}, {self.status}&quot;&#xA;</code></pre>&#xA;<pre class=""lang-py prettyprint-override""><code># schema.py&#xA;&#xA;from graphene_django import DjangoObjectType&#xA;from graphene import relay, ObjectType&#xA;from graphene_django.filter import DjangoFilterConnectionField&#xA;&#xA;from events.models import Event&#xA;&#xA;&#xA;&#xA;class EventNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Event&#xA;        filter_fields = {&#xA;            &quot;event_date&quot;: [&quot;exact&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;],&#xA;            &quot;status&quot;: [&quot;exact&quot;],&#xA;        }&#xA;        interfaces = (relay.Node,)&#xA;&#xA;class EventsQuery(ObjectType):&#xA;    event = relay.Node.Field(EventNode)&#xA;    all_events = DjangoFilterConnectionField(EventNode)&#xA;&#xA;</code></pre>&#xA;<p>Using this set up, when I try to run this query on graphiql browser interface:</p>&#xA;<pre><code>query filterEvents{&#xA;  allEvents(eventDate:&quot;2022-02-14&quot;){&#xA;    edges{&#xA;      node{&#xA;        id&#xA;        eventDate&#xA;        photographer{&#xA;          firstName&#xA;          lastName&#xA;        }&#xA;        location{&#xA;          id&#xA;          name&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>It works and gives me the events for that specific date.</p>&#xA;<p>But when I try to fetch for a month, day or year I get the following errors:</p>&#xA;<pre><code>allEvents(eventDate_Year:&quot;2022&quot;)&#xA;&gt; &quot;message&quot;: &quot;['{\&quot;event_date__year\&quot;: [{\&quot;message\&quot;: \&quot;Enter a number.\&quot;, \&quot;code\&quot;: \&quot;invalid\&quot;}]}']&quot;,&#xA;&#xA;allEvents(eventDate_Year:2022)&#xA;&gt; &quot;message&quot;: &quot;Argument \&quot;eventDate_Year\&quot; has invalid value 2022.\nExpected type \&quot;Date\&quot;, found 2022.&quot;,&#xA;&#xA;allEvents(eventDate_Year:&quot;2022-02-14&quot;)&#xA;&gt; &quot;message&quot;: &quot;['{\&quot;event_date__year\&quot;: [{\&quot;message\&quot;: \&quot;Enter a number.\&quot;, \&quot;code\&quot;: \&quot;invalid\&quot;}]}']&quot;,&#xA;&#xA;</code></pre>&#xA;<p>I tried using <code>django_filters</code> like so:</p>&#xA;<pre class=""lang-py prettyprint-override""><code># schema.py&#xA;...&#xA;from django_filters import FilterSet&#xA;&#xA;class EventFilter(FilterSet):&#xA;    class Meta:&#xA;        model = Event&#xA;        fields = &quot;__all__&quot;&#xA;        filter_fields = {&#xA;            &quot;event_date&quot;: [&#xA;                &quot;exact&quot;,&#xA;                &quot;year&quot;,&#xA;                &quot;month&quot;,&#xA;                &quot;day&quot;,&#xA;            ],&#xA;            &quot;status&quot;: [&quot;exact&quot;],&#xA;        }&#xA;&#xA;class EventNode(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Event&#xA;        filterset_class = EventFilter&#xA;        interfaces = (relay.Node,)&#xA;</code></pre>&#xA;<p>This method doesn't give me the <code>eventDate_Year</code>, <code>eventDate_Month</code> and <code>eventDate_Day</code> augments as the previous method.<br />&#xA;How can I achieve this?</p>&#xA;",13242245,,,,2022-03-10 12:59:07,"How to filter by year, month, or day in django graphene query",<python><django><graphql><graphene-django>,0,0,0,2022-03-10 12:59:07
71436355,2,,66656789,1,,"<p>Not sure when this was implemented, but you can now query the complexity and limit, as described in the docs and reference <a href=""https://docs.gitlab.com/ee/api/graphql/reference/#queryquerycomplexity"" rel=""nofollow noreferrer"">https://docs.gitlab.com/ee/api/graphql/reference/#queryquerycomplexity</a></p>&#xA;<p>Example query:</p>&#xA;<pre><code>{&#xA;  queryComplexity {&#xA;    limit&#xA;    score&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Example response:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;queryComplexity&quot;: {&#xA;      &quot;limit&quot;: 300,&#xA;      &quot;score&quot;: 3&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1848241,,,,2022-03-11 09:29:28,"",,0,0,0,2022-03-11 09:29:28
71449345,1,,,5,242,"<pre><code>query {&#xA;    comp(func: eq(dgraph.type,&quot;ServiceTemplate&quot;)) {&#xA;    topologytemplate{&#xA;        nodetemplates { &#xA;             name&#xA;             namespace @filter (eq(url,&quot;a_url&quot;)){&#xA;                    url&#xA;            }&#xA;         }&#xA;      }   &#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>Using the above query I am want to filter data that nodetemplate objects have matching URL that we are passing in query and we get a list of all nodetemplates but I am getting result as follows:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;comp&quot;: [&#xA;      {&#xA;        &quot;topologytemplate&quot;: {&#xA;          &quot;nodetemplates&quot;: [&#xA;            {&#xA;              &quot;name&quot;: &quot;a&quot;,&#xA;              &quot;namespace&quot;: {&#xA;                &quot;url&quot;: &quot;a_url&quot;&#xA;              }&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;b&quot;&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;c&quot;&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;d&quot;&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;e&quot;&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;f&quot;,&#xA;              &quot;namespace&quot;: {&#xA;                &quot;url&quot;: &quot;b_url&quot;&#xA;              }&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;g&quot;&#xA;            }&#xA;          ]&#xA;        }&#xA;      }&#xA;    ]&#xA;  },&#xA;}&#xA;</code></pre>&#xA;<p>But I want only those nodetemplates that have URLs that we are going to filter using graphQL.&#xA;Any idea how to filter it.</p>&#xA;",18212681,,,,2022-03-12 11:31:06,How to filter data with nested object in GraphQL,<database><graph><graphql><dql><dgraph>,0,1,0,2022-03-12 11:31:06
71463334,1,,,0,188,"<p>I have a following graphQL query.</p>&#xA;<pre><code>export const GET_CARDS = gql`&#xA;    query GetContentCards($filter: { $limit: Int, $keywords: &quot;&quot;, $types: [PODCAST]}) {&#xA;        contentCards(filter: { limit: $limit, keywords: $keywords, types: $types }) {&#xA;            edges {&#xA;                ...on Podcast {&#xA;                    name&#xA;                    image {&#xA;                        ...Image&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        fragment Image on Image {&#xA;            uri&#xA;        }&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;<p>When I run this I get below error in google dev console.</p>&#xA;<pre><code>syntaxError.mjs:8 Uncaught GraphQLError: Syntax Error: Expected Name, found &quot;{&quot;.&#xA;</code></pre>&#xA;<p>Any idea what am I doing wrong?</p>&#xA;",1136062,,,,2022-03-14 06:10:30,GraphQL filter search query returns below error,<reactjs><graphql><apollo><react-apollo>,1,0,0,2022-03-14 05:29:49
71463577,2,,71463334,0,,"<pre><code>query GetContentCards($limit: Int, $types: [PODCAST]) {&#xA;        contentCards(filter: { limit: $limit, keywords: &quot;&quot;, types: $types }) {&#xA;            edges {&#xA;                ...on Podcast {&#xA;                    name&#xA;                    image {&#xA;                        ...Image&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        fragment Image on Image {&#xA;            uri&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<ol>&#xA;<li>I never define a variable as an object like <code>$filter: {...}</code>.</li>&#xA;<li>remove the <code>$keywords: &quot;&quot;</code> from the variables, you can assign it directly</li>&#xA;</ol>&#xA;",17488015,,17488015,2022-03-14 06:10:30,2022-03-14 06:10:30,"",,0,0,0,2022-03-14 06:07:08
71466008,1,,,0,81,"<p>Below is my sample data which store in Dgraph</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;comp&quot;: [&#xA;      {&#xA;        &quot;topologytemplate&quot;: {&#xA;          &quot;namespace&quot;: &quot;a&quot;,&#xA;          &quot;nodetemplates&quot;: [&#xA;            {&#xA;              &quot;name&quot;: &quot;a&quot;,&#xA;             &#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;b&quot;,&#xA;            }&#xA;          ]&#xA;        }&#xA;      },&#xA;      {&#xA;        &quot;topologytemplate&quot;: {&#xA;          &quot;namespace&quot;: &quot;c&quot;,&#xA;          &quot;nodetemplates&quot;: [&#xA;            {&#xA;              &quot;name&quot;: &quot;a&quot;,&#xA;            },&#xA;            {&#xA;              &quot;name&quot;: &quot;b&quot;,&#xA;              &quot;directives&quot;: [&#xA;                &quot;a&quot;&#xA;              ]&#xA;            },&#xA;          ]&#xA;        }&#xA;      }, &#xA;    ]&#xA;  },&#xA;}&#xA;</code></pre>&#xA;<p>I want to filter data so that as a result we get data that does not contain &quot;directives&quot; filed. I am want to filter data using GraphQL query?</p>&#xA;<p>Currently, I am trying to filter data as follows:</p>&#xA;<pre><code>query {&#xA;        comp(func: eq(dgraph.type,&quot;QQQ&quot;)){&#xA;            name&#xA;       topologytemplate{&#xA;             nodetemplates @filter (eq(nodetypename,&quot;a&quot;)){&#xA;               name&#xA;              directives&#xA;      }&#xA;    }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Query to check that directives filed are present or not in nodetemplate?</p>&#xA;",18212681,,,,2022-03-14 10:09:56,How to filter any data on any filed is present or not in object in GraphQL,<filter><graph><graphql><dql><dgraph>,0,0,0,2022-03-14 10:09:56
71469073,2,,69130080,0,,"<p>I'm in the same situation currently, and I'm afraid there aren't any good solution to this.</p>&#xA;<p>If <strong>the frontend is aware of the sorting criteria</strong> I guess you could use that to compare your new item to the first and last in the current list. If the sorting criteria is <code>name/asc</code> and your first item has <code>name: Adam</code>, the last item <code>name: Celine</code> and your new item <code>name: Billie</code>, then you know you can push it into the list, then sort alphabetically again.</p>&#xA;<p>If <strong>the frontend is NOT aware of the sorting criteria</strong>, or it simply is too much of a hassle finding out whether it fits in the list or not: Maybe consider <strong>solving it with UI</strong>, adding a new section altogether above the list that says <em>Recently added items</em> or similar. This does not solve the problem of updating the cache however...</p>&#xA;",13340762,,,,2022-03-14 14:07:41,"",,0,0,0,2022-03-14 14:07:41
71474724,2,,71444603,0,,"<p>So after insane trial and error, I came up with some sort of solution only to find out our Laravel relationship isn't quite returning what it is. However, for anyone who wants an example on how to query on a nested relationship, here's a good example that works on a different column:</p>&#xA;<pre><code>extend type Query {&#xA;  entries(first: Int!, &#xA;    page: Int, &#xA;    type: String @eq, &#xA;    site_id: ID @eq,&#xA;    hasContent: _ @whereHasConditions(relation: &quot;content&quot;, columns: [&quot;title&quot;])&#xA;   ): [Entry!]! @paginate&#xA;}&#xA;&#xA;&#xA;export const ALL_SITE_ENTRIES = gql`&#xA;  query Entries($first: Int!, $page: Int, $type: String, $site_id: ID, $title: Mixed) {&#xA;    entries(&#xA;        first: $first, &#xA;        page: $page, &#xA;        type: $type, &#xA;        site_id: $site_id, &#xA;        hasContent: {column: TITLE, operator: LIKE, value: $title}&#xA;      ) {&#xA;      data {&#xA;        ...EntryDetails&#xA;        content{&#xA;          id&#xA;          title&#xA;          status&#xA;        }&#xA;      }&#xA;      paginatorInfo {&#xA;        currentPage&#xA;        lastPage&#xA;        total&#xA;      }&#xA;    }&#xA;  }&#xA;  ${EntryDetailsFragment}&#xA;`&#xA;</code></pre>&#xA;<p>Note: to get the full LIKE experience, make sure to add %% around your text that you're searching.</p>&#xA;<p>Hope this helps someone. I really needed more examples to go off of. :)</p>&#xA;",1729405,,,,2022-03-14 22:02:14,"",,0,0,0,2022-03-14 22:02:14
71532480,1,,,0,145,"<p>I would like to ask you kindly if you could advise on how can I run a subcategory count query on GraphQL.</p>&#xA;<p>Currently I am running 4 queries in order to get the total and the count for each site. Do you know if this query can be aggregated into only one query returning in array of values?</p>&#xA;<p>I am looking for a way to make only one query and retrieve the data I want in an aggreagate way like subtotal for each category&#xA;I need to make some math in my app so I need all those total values for each category.&#xA;If the total is 100, and subtotal for nist is 30, for mitre 40 and cisa 30, then I need these values to be retrieved for each of these 3 categories.&#xA;<a href=""https://i.stack.imgur.com/sRDrt.png"" rel=""nofollow noreferrer"">total</a></p>&#xA;<p>What I need:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;webs&quot;: {&#xA;      &quot;meta&quot;: {&#xA;        &quot;pagination&quot;: {&#xA;    &quot;cisa&quot;: {&#xA;          &quot;total&quot;: 498},&#xA;    &quot;nist&quot;: :{&#xA;      &quot;total&quot;: 3198},&#xA;        },&#xA;    &quot;mitre&quot;: :{&#xA;      &quot;total&quot;: 998},&#xA;        },&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Now I am using 4 different queries which is not ok.</p>&#xA;<pre><code>  query  total{&#xA;    webs{&#xA;      meta{&#xA;        pagination{&#xA;          total&#xA;        }&#xA;      }&#xA;        }&#xA;      }&#xA;&#xA;query nist{&#xA;  webs(&#xA;    filters: { site :{eq: &quot;nist&quot;}}&#xA;) {&#xA;        meta{&#xA;            pagination{&#xA;                total&#xA;       }&#xA;     }&#xA;   }&#xA; }&#xA;&#xA;query cisa{&#xA;  webs(&#xA;    filters: { site :{eq: &quot;cisa&quot;}}&#xA;) {&#xA;        meta{&#xA;            pagination{&#xA;                total&#xA;       }&#xA;     }&#xA;   }&#xA; }&#xA;&#xA;query mitre{&#xA;  webs(&#xA;    filters: { site :{eq: &quot;mitre&quot;}}&#xA;) {&#xA;        meta{&#xA;            pagination{&#xA;                total&#xA;       }&#xA;     }&#xA;   }&#xA; }&#xA;&#xA;</code></pre>&#xA;",18506022,,18506022,2022-03-19 20:55:11,2022-03-19 20:55:11,GraphQL Subcategory Count Aggregated Query,<reactjs><graphql><strapi>,0,0,0,2022-03-18 19:49:24
71535242,1,,,0,54,"<p>*I am Japanese. My English is not good, so I translate with Deepl.</p>&#xA;<p>I made my blog with Gridsome.&#xA;I am trying to create a monthly archive page on that blog, but the filter between does not work in PlayGround.</p>&#xA;<p>The actual code is as follows (I am trying to get the articles posted in July 2021)</p>&#xA;<p><strong>Query</strong></p>&#xA;<pre><code>query PostsByDate($periodStartDate: Date, $periodEndDate: Date) {&#xA;  years: allPost(filter: {date: {between: [$periodStartDate, $periodEndDate]} }) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        title&#xA;        path&#xA;        date(format: &quot;YYYY/MM/DD&quot;)&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Variables</strong></p>&#xA;<pre><code>{&#xA;  &quot;periodStartDate&quot;: &quot;2021-07-01T00:00:00.000Z&quot;,&#xA;  &quot;periodEndDate&quot;: &quot;2021-07-31T23:59:59.999Z&quot;&#xA;}&#xA;</code></pre>&#xA;<p><strong>Result</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;years&quot;: {&#xA;      &quot;edges&quot;: []&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>An article submitted in July 2021 exists but does not appear in the results.&#xA;Is there anywhere I am wrong?</p>&#xA;<p><a href=""https://i.stack.imgur.com/5LtY6.png"" rel=""nofollow noreferrer"">PlayGround Image</a></p>&#xA;",18509486,,,,2022-03-19 03:57:09,Gridsome's GraphQL Between filter does not work,<graphql><gridsome>,0,0,0,2022-03-19 03:57:09
71547291,2,,71538706,0,,"<p>You can use prisma <a href=""https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#or"" rel=""nofollow noreferrer""><code>OR</code></a> and <a href=""https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#gt"" rel=""nofollow noreferrer""><code>gt</code></a> to filter artist who have at least one song track.</p>&#xA;<p>OR accept an arrary of conditions that must return true, while gt means value must be greater than x.</p>&#xA;",16648127,,,,2022-03-20 13:42:22,"",,0,0,0,2022-03-20 13:42:22
71548539,1,71550322,,0,347,"<p>I tried to query track records which either title or lyric contain &quot;cat&quot;. But only record return if both title and lyric have cat. May I know how to query by OR operator.</p>&#xA;<p>Query</p>&#xA;<pre><code>query Tracks($where: TrackWhereInput) {&#xA;  tracks(where: $where) {&#xA;    id&#xA;    title&#xA;    lyric&#xA;    youtube_url&#xA;    mp3_url&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Variables</p>&#xA;<pre><code>{&#xA;  &quot;where&quot;: {&#xA;    &quot;OR&quot;: [&#xA;      {&#xA;        &quot;title&quot;: {&#xA;          &quot;contains&quot;: &quot;cat&quot;&#xA;        },&#xA;        &quot;lyric&quot;: {&#xA;          &quot;contains&quot;: &quot;cat&quot;&#xA;        }&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1559116,,,,2022-03-20 20:17:20,Graphql Prisma OR operator not working for two columns,<apollo-server><prisma-graphql><typegraphql>,1,0,0,2022-03-20 16:28:39
71549677,1,,,0,390,"<p>I have this graphql query - I had to reverse it as I had to match/filter on a linkedForm</p>&#xA;<pre><code>query LocalState3 {&#xA;  localStatePageCollection(where: { seoName: &quot;ca&quot;}, limit:1) {&#xA;    items {&#xA;      name&#xA;      seoName&#xA;      url&#xA;      linkedFrom {&#xA;        entryCollection{&#xA;          items {&#xA;            ... on LocalCity {&#xA;              seoName&#xA;              name&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I will get a bunch of &quot;cities&quot; here - BUT I want to get a specific city UNDER the &quot;ca&quot; state. I know I can filter on the front end, BUT I'd rather do this in graphql if possible?</p>&#xA;<p>I thought this might work, but didn't</p>&#xA;<pre><code> entryCollection(where: { seoName: &quot;culver-city&quot;}, limit: 1)&#xA; entryCollection(filter: { seoName: { eq:&quot;culver-city&quot;}}, limit:1)&#xA;</code></pre>&#xA;<p>any way to filter on items or entryCollection or ?</p>&#xA;",1054992,,,,2022-04-06 15:27:27,"Contentful, is there a way to filter on entryCollection?",<graphql><contentful>,1,0,0,2022-03-20 18:48:48
71549882,2,,71533335,0,,"<p>I managed to solve my issue, by making a new column that stores all subtotals from my DB, and therefore I can do a one query that retrieves all my data in order to plot the plotly graph.</p>&#xA;",18506022,,,,2022-03-20 19:15:10,"",,0,0,0,2022-03-20 19:15:10
71550322,2,,71548539,1,,"<p>You must pass conditions to <code>OR</code> operator in different objects. You've passed an object array but both conditions are in same object. Conditions in same object use <code>AND</code> operator.</p>&#xA;<p>Your fixed code would be:</p>&#xA;<pre><code>{&#xA;  &quot;where&quot;: {&#xA;    &quot;OR&quot;: [&#xA;      {&#xA;        &quot;title&quot;: {&#xA;          &quot;contains&quot;: &quot;cat&quot;&#xA;        },&#xA;      },&#xA;      {&#xA;        &quot;lyric&quot;: {&#xA;          &quot;contains&quot;: &quot;cat&quot;&#xA;        }&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",11552383,,,,2022-03-20 20:17:20,"",,0,0,0,2022-03-20 20:17:20
71554597,1,,,0,87,"<p>I am trying to integrate GeoLocation aware searching via AWS OpenSearch in Amplify dynamoDB graphQL.&#xA;OpenSearch Instance that created using amplify cli i followed these steps to achieve geolocation wise items list from dynamoDB</p>&#xA;<p>Failed to receive data accroding to geolocation.</p>&#xA;<p><strong>Schema.graphql</strong></p>&#xA;<pre><code>type User&#xA;  @model&#xA;  @searchable {&#xA;  id: ID!&#xA;  full_name: String&#xA;  email: String&#xA;  phoneNumber: String&#xA;  location: Location&#xA;}&#xA;&#xA;type Query {&#xA;  nearbyUsers(&#xA;    location: LocationInput!, &#xA;    m: Int #Radius | Distance criteria to get users under perimeter&#xA; ): NearbyUserConnection&#xA;}&#xA;&#xA;type NearbyUserConnection {&#xA; items: [User]&#xA; total: Int&#xA; nextToken: String&#xA;}&#xA;&#xA;type Location {&#xA;  lat: Float&#xA;  lon: Float&#xA;}&#xA;</code></pre>&#xA;<p><strong>Query.nearbyusers.req.vtl</strong></p>&#xA;<pre><code>## Query.nearbyUsers.req.vtl&#xA;## Objects of type User will be stored in the /bikepoint index&#xA;&#xA;#set( $indexPath = &quot;/user/doc/_search&quot; )&#xA;#set( $distance = $util.defaultIfNull($ctx.args.m, 500) )&#xA;#set( $limit = $util.defaultIfNull($ctx.args.limit, 10) )&#xA;{&#xA;  &quot;version&quot;: &quot;2017-02-28&quot;,&#xA;  &quot;operation&quot;: &quot;GET&quot;,&#xA;  &quot;path&quot;: &quot;$indexPath.toLowerCase()&quot;,&#xA;  &quot;params&quot;: {&#xA;    &quot;body&quot;: {&#xA;      &quot;from&quot; : 0, &#xA;      &quot;size&quot; : ${limit},&#xA;      &quot;query&quot;: {&#xA;        &quot;bool&quot; : {&#xA;          &quot;must&quot; : {&#xA;            &quot;match_all&quot; : {}&#xA;          },&#xA;          &quot;filter&quot; : {&#xA;            &quot;geo_distance&quot; : {&#xA;              &quot;distance&quot; : &quot;${distance}m&quot;,&#xA;              &quot;pin.location&quot; : $util.toJson($ctx.args.location)&#xA;            }&#xA;          }&#xA;        }&#xA;      },&#xA;      &quot;sort&quot;: [{&#xA;        &quot;_geo_distance&quot;: {&#xA;          &quot;location&quot;: $util.toJson($ctx.args.location),&#xA;          &quot;order&quot;: &quot;asc&quot;,&#xA;          &quot;unit&quot;: &quot;m&quot;,&#xA;          &quot;distance_type&quot;: &quot;arc&quot;&#xA;        }&#xA;      }]&#xA;    }&#xA;  }&#xA;}```&#xA;&#xA;**opensearch Error Logs**&#xA;&#xA;&gt; [**,958][DEBUG][o.e.a.s.TransportSearchAction] [****] [****][user][0]:&#xA;&gt; Failed to execute [SearchRequest{searchType=QUERY_THEN_FETCH,&#xA;&gt; indices=[user],&#xA;&gt; indicesOptions=IndicesOptions[ignore_unavailable=false,&#xA;&gt; allow_no_indices=true, expand_wildcards_open=true,&#xA;&gt; expand_wildcards_closed=false, expand_wildcards_hidden=false,&#xA;&gt; allow_aliases_to_multiple_indices=true, forbid_closed_indices=true,&#xA;&gt; ignore_aliases=false, ignore_throttled=true], types=[doc],&#xA;&gt; routing='null', preference='null', requestCache=null, scroll=null,&#xA;&gt; maxConcurrentShardRequests=0, batchedReduceSize=512,&#xA;&gt; preFilterShardSize=null, allowPartialSearchResults=true,&#xA;&gt; localClusterAlias=null, getOrCreateAbsoluteStartMillis=-1,&#xA;&gt; ccsMinimizeRoundtrips=true,&#xA;&gt; source={&quot;size&quot;:10,&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match_all&quot;:{&quot;boost&quot;:1.0}}],&quot;filter&quot;:[{&quot;geo_distance&quot;:{&quot;location&quot;:[**],&quot;distance&quot;:10.0,&quot;distance_type&quot;:&quot;arc&quot;,&quot;validation_method&quot;:&quot;STRICT&quot;,&quot;ignore_unmapped&quot;:false,&quot;boost&quot;:1.0}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}}},&#xA;&gt; cancelAfterTimeInterval=null}] lastShard [true]&#xA;&gt; RemoteTransportException[[****][__IP__][__PATH__[__PATH__]]]; nested:&#xA;&gt; QueryShardException[failed to find geo_point field [location]];&#xA;&#xA;</code></pre>&#xA;",8320871,,,,2022-03-21 08:20:59,Amplify Geolocation aware search not working,<graphql><amazon-dynamodb><dynamodb-queries><amplify><opensearch>,0,0,0,2022-03-21 08:20:59
71564238,2,,64947130,2,,"<p>Your almost there, the query <code>sort</code> attribute looks to be off.&#xA;playing with it in the grapqhl playground i was able to sort using <code>base</code></p>&#xA;<pre><code>{&#xA;  allFile(sort: { fields: [base] }) {&#xA;    edges {&#xA;      node {&#xA;        base&#xA;        childImageSharp {&#xA;          fluid {&#xA;            src&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12149334,,,,2022-03-21 21:18:12,"",,0,0,0,2022-03-21 21:18:12
71568720,1,,,0,112,"<p>The below code excerpt comes from the <code>React-Relay</code> docs on <a href=""https://relay.dev/docs/guided-tour/list-data/rendering-connections/"" rel=""nofollow noreferrer"">Rendering Connections</a>. I am wondering if someone could provide me with an example of what the underlying schema definition (using `type-graphql for annotations/decorations) would look like.</p>&#xA;<pre><code>const {graphql} = require('RelayModern');&#xA;&#xA;const userFragment = graphql`&#xA;  fragment UserFragment on User {&#xA;    name&#xA;    friends(after: $cursor, first: $count)&#xA;      @connection(key: &quot;UserFragment_friends&quot;) {&#xA;      edges {&#xA;        node {&#xA;          ...FriendComponent&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>Would it look something like the following? With attention paid to the <code>UserType</code> type definition, and especial attention to the <code>friends</code> field. I am also hoping if anyone could turn my attention to a more elaborated upon example/boilerplate to help me understand what is compliant with the Relay specification. Some examples I am after:</p>&#xA;<ul>&#xA;<li>How to type the return type of a Query if I intend one of the Query's resolved fields to be a Connection type? And what would this look when written as a fragment.</li>&#xA;<li>How to type the same scenario as above, except now the return type is an iterable of the original return type?</li>&#xA;</ul>&#xA;<pre><code>@ObjectType({ implements: [Node] })&#xA;export class UserType extends Node {&#xA;  @Field()&#xA;  name: string&#xA;&#xA;  @Field()&#xA;  friends: UserConnection&#xA;}&#xA;&#xA;const User = createUnionType({&#xA;  name: 'User',&#xA;  types: () =&gt; [UserType] as const,&#xA;  resolveType: value =&gt; {&#xA;    // if ('code' in value) {&#xA;    //   return Error&#xA;    // }&#xA;    return UserType&#xA;  }&#xA;})&#xA;&#xA;@ObjectType()&#xA;export class UserEdge extends EdgeType('report', User) {}&#xA;&#xA;@ObjectType()&#xA;export class UserConnection extends ConnectionType&lt;UserEdge&gt;(&#xA;  'user',&#xA;  UserEdge&#xA;) {&#xA;}&#xA;</code></pre>&#xA;",9588400,,,,2022-03-22 08:09:27,Understanding React-Relay Connections in the Context of Type-GraphQL,<graphql><typegraphql><react-relay>,0,0,0,2022-03-22 08:09:27
71572043,1,,,0,352,"<p>I see many examples online in ORMs and more elaborate graphql queried systems like:</p>&#xA;<pre><code>{&#xA;  things(filter: {age: {gt: 18}, name: {eq: &quot;Jane&quot;}}) {&#xA;    id, age, name&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And I found several tutorials how to implement fairly trivial resolvers, however, I cannot find how to implement something like the above in graphql.js from first principles.</p>&#xA;<p>How do you define such a 'dynamic' input? You are only allowed to use 'input' schemas as input for Query resolvers, but interfaces cannot be input schemas. So how do you define this filter object as input schema and how do you make it dynamic (so you don't have to specify it for all gt,lt,lte,gte,eq,ne inside the schema if that's even possible?</p>&#xA;<p>It is ok for me to have the syntax different than above, for instance, I could imagine it being easier to have the filters implemented as [Filter] instead, but even that I cannot get close to working.</p>&#xA;<p>I ultimately want to do what they say here <a href=""https://www.apollographql.com/blog/graphql/filtering/how-to-search-and-filter-results-with-graphql/"" rel=""nofollow noreferrer"">https://www.apollographql.com/blog/graphql/filtering/how-to-search-and-filter-results-with-graphql/</a> in the bottom of the article but leaves it as a little exercise for the reader:</p>&#xA;<pre><code>{&#xA; things(filter: { or: [ { age: { gt: 18 } }, {age: { lt: 5 } } ], name: { eq: &quot;Jane&quot; } }) { &#xA;  id, age, name&#xA; } &#xA;}&#xA;</code></pre>&#xA;<p>Again, not married to the syntax and not asking for full examples, but I cannot even get this at all going. I can write the resolvers; that's no problem, I just have no clue how to create a schema that parses without errors that accepts this.</p>&#xA;",145360,,,,2022-03-22 12:25:41,Writing a Query schema with graphql.js with a complex filter,<graphql><graphql-js>,0,0,0,2022-03-22 12:25:41
71588006,1,71588007,,0,272,"<p>GitHub's graphql cursors are intentionally opaque, so they shouldn't ever be decode by a client. However I'd like to know their approach towards pagination, especially when combined with sorting.</p>&#xA;",2643330,,,,2022-03-23 13:22:21,How does GitHub encode their graphQL cursors?,<graphql><pagination><reverse-engineering>,1,0,0,2022-03-23 13:22:21
71588007,2,,71588006,1,,"<p>There are multiple layers of encoding for the encoding used for pagination cursors used by GitHub. I will list them in order from the perspective of a decoder:</p>&#xA;<ol>&#xA;<li>The cursor string is encoded using <a href=""https://datatracker.ietf.org/doc/html/rfc4648#section-5"" rel=""nofollow noreferrer"">URL safe base64</a> meaning it uses <code>-</code> and <code>_</code> instead of <code>+</code> and <code>/</code>. This might be to have consistency with their REST based API.</li>&#xA;<li>Decoding the base64 string gives us another string in the format of <code>cursor:v2:[something]</code> so the next step is decoding the something.</li>&#xA;<li>The 'something' is a binary encoded piece of data containing the actual cursor properties. The first byte defines the cursor type:&#xA;<ul>&#xA;<li><code>0x91</code> =&gt; We don't use any sorting, the cursor contains the length of the id field and the id itself. <code>0xcd</code> seems to indicate a two-byte id, <code>0xce</code> a four-byte id. This is followed by the id itself, which can be verified by decoding the base64 <code>id</code> graphql field.</li>&#xA;<li><code>0x92</code> =&gt; A composite cursor containing the sorted property and the id. This is either a length-prefixed ordinal number or two bytes plus a string or ISO date string followed by the length-prefixed id.</li>&#xA;</ul>&#xA;</li>&#xA;</ol>&#xA;",2643330,,,,2022-03-23 13:22:21,"",,0,0,0,2022-03-23 13:22:21
71588700,1,71588764,,0,568,"<p>I have an object with the below structure:</p>&#xA;<pre><code>  Order: [&#xA;    {&#xA;      id: '001',&#xA;      type: '',&#xA;      status: '',&#xA;      users: [&#xA;        {&#xA;          OrderId:'001', &#xA;          userId: 'String',&#xA;          user: {&#xA;            email: 'string',&#xA;            givenName: 'Name',&#xA;            lastName: 'LastName',&#xA;            phone: 'string',&#xA;          },&#xA;        },&#xA;      ],&#xA;  &#xA;    },&#xA;</code></pre>&#xA;<p>the order is of type Order[] and users of type UserData[]</p>&#xA;<pre><code>  type Order&#xA;  @model&#xA;  @key(fields: [&quot;organizationId&quot;, &quot;id&quot;])&#xA;  @auth(&#xA;    rules: []&#xA;  ) {&#xA;  id: ID!&#xA;  type: OrderType&#xA;  status: OrderStatus&#xA;&#xA;  userConnections: [UserOrderConnection] @connection(keyName: &quot;byOrder&quot;, fields: [&quot;id&quot;])&#xA;&#xA;  organizationId: ID!&#xA;}&#xA;&#xA;type UserOrderConnection&#xA;  @model&#xA;  @key(fields: [&quot;organizationId&quot;, &quot;id&quot;])&#xA;  @key(name: &quot;Order&quot;, fields: [&quot;OrderId&quot;], queryField: &quot;userOrderByOrder&quot;)&#xA;  @auth(&#xA;    rules: []&#xA;  ) {&#xA;  id: ID!&#xA;  accepted: Boolean&#xA;  OrderId: ID!&#xA;  Order: Order @connection(fields: [&quot;organizationId&quot;, &quot;id&quot;])&#xA;  userId: ID!&#xA;  user: UserData&#xA;}&#xA;</code></pre>&#xA;<p>Whenever I try to get the list of users per order :</p>&#xA;<p><code>let users = this.Order.users</code></p>&#xA;<p>it says that: users don't exist on type Order[], can anyone explain for me why.</p>&#xA;",8845321,,,,2022-03-23 14:15:49,Get an array of items from an object- typescript,<javascript><angular><typescript><lambda><graphql>,2,0,0,2022-03-23 14:11:54
71593267,1,71594318,,1,638,"<p>Let's say we have a user table with sequential <code>id</code> and want to use cursor based pagination(not sql cursor) while ordering by not unique <code>updated_at</code> column.</p>&#xA;<p>We do a query:</p>&#xA;<pre><code>SELECT * FROM user&#xA;LIMIT 3&#xA;ORDER BY updated_at asc;&#xA;</code></pre>&#xA;<p>For table (ordered by <code>updated_at</code> asc, <code>id</code> asc):</p>&#xA;<div class=""s-table-container"">&#xA;<table class=""s-table"">&#xA;<thead>&#xA;<tr>&#xA;<th>id</th>&#xA;<th>updated_at</th>&#xA;</tr>&#xA;</thead>&#xA;<tbody>&#xA;<tr>&#xA;<td>2</td>&#xA;<td>14:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>3</td>&#xA;<td>14:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>5</td>&#xA;<td>14:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>6</td>&#xA;<td>14:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>4</td>&#xA;<td>19:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>1</td>&#xA;<td>21:00</td>&#xA;</tr>&#xA;<tr>&#xA;<td>7</td>&#xA;<td>22:00</td>&#xA;</tr>&#xA;</tbody>&#xA;</table>&#xA;</div>&#xA;<p>And get first 3 rows (2,3,5), our cursor is last row <code>5 | 14:00</code>, now we need to get (6,4,1).</p>&#xA;<p>Is it correct to say that the best option is sort by&#xA;unique combination of <code>updated_at</code> and <code>id</code>&#xA;and use where like in example?</p>&#xA;<pre><code>SELECT * FROM user&#xA;WHERE updated_at &gt; cursor.updated_at(14:00) &#xA;      OR (updated_at = cursor.updated_at(14:00) AND id &gt; cursor.id(5))&#xA;LIMIT 3&#xA;ORDER BY updated_at asc, id asc;&#xA;</code></pre>&#xA;<p>If this query is correct, what to do with indexes? Should I always create two indexes <code>updated_at asc, id asc</code> and <code>updated_at desc, id asc</code> or single <code>updated_at</code> is enough?</p>&#xA;<p>And what do with cursor in graphql? It should be a <code>String</code> type, so should I stringify it as <code>${id}_${updated_at}</code> to pass around (parsing it for sql query back to <code>id</code> and <code>updated_at</code>) or should I save only <code>id</code> and prefetch <code>updated_at</code> for this <code>id</code> to use in query?</p>&#xA;",10188661,,10188661,2022-03-23 20:26:43,2022-03-23 21:35:08,SQL(graphql) cursor based pagination with order by not unique column,<sql><postgresql><graphql><pagination>,1,0,0,2022-03-23 19:54:40
71594318,2,,71593267,2,,"<p>Your query is correct other than the placement of the LIMIT and the use of an unquoted reserved word as a table name, but it could be written better with a tuple comparison.</p>&#xA;<pre><code>SELECT * FROM &quot;user&quot;&#xA;WHERE (updated_at,id) &gt; (cursor.updated_at, cursor.id)&#xA;ORDER BY updated_at asc, id asc&#xA;LIMIT 3;&#xA;</code></pre>&#xA;<p>Not only is that cleaner, it will efficiently use an index on <code>(updated_at asc, id asc)</code>.  A quirk of the tuple comparison though is that there is no way to describe the ordering in discordant directions, but you don't seem to need that anyway.  (If &quot;id&quot; is an int, you could just negate it to achieve that)</p>&#xA;<p>I can't answer the graphql-specific part of your question.</p>&#xA;",1721239,,,,2022-03-23 21:35:08,"",,0,0,0,2022-03-23 21:35:08
71602542,1,,,1,1153,"<p>I just started to learn graphql and HotChocolate.Data in .net core.&#xA;I usind attribute [UseFiltering]&#xA;How do I use nested objects` fields to filter rows from a table and also filter the nested objects as well?</p>&#xA;<pre><code>query GetData(&#xA;  $search: String&#xA;) {&#xA;  documents(&#xA;    where: {&#xA;       name: { contains: $search }&#xA;    }&#xA;  ) {&#xA;    total: totalCount&#xA;    items {&#xA;      id&#xA;      name&#xA;      requirements(&#xA;        where: {&#xA;          name: { contains: $search }&#xA;        }&#xA;      ) &#xA;      {&#xA;        id&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Filtering by documents works fine, but if I try to connect the filtering by requirements I get errors&#xA;Error during generation:  Unknown argument &quot;where&quot; on field &quot;Document.requirements&quot;.</p>&#xA;",18352117,,18352117,2022-03-24 13:53:15,2022-03-24 13:53:15,GraphQL query use nested objects` fields to filter,<graphql><hotchocolate>,0,1,0,2022-03-24 12:26:46
71603397,1,,,0,39,"<p>I have a problem. I do not want a &quot;break&quot; down in my GraphQL output. I have a GraphQL schema with a person. That person can have one or more interests. But unfortunately I only get a breakdown</p>&#xA;<p>What I mean by breakdown is the second curly brackets.</p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA; ...&#xA; {&#xA;  ...&#xA; }&#xA;}&#xA;</code></pre>&#xA;<p>Is there an option to get the id of the person plus the id of the interests and the status without the second curly bracket?</p>&#xA;<p>GraphQL schema</p>&#xA;<pre><code>Person&#xA;└── Interest&#xA;</code></pre>&#xA;<p>Query</p>&#xA;<pre><code>query {&#xA;  model {&#xA;    allPersons{&#xA;      id&#xA;      name&#xA;        interest {&#xA;        id&#xA;        status&#xA;        }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>[OUT]</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;model&quot;: {&#xA;      &quot;allPersons&quot;: [&#xA;        {&#xA;          &quot;id&quot;: &quot;01&quot;,&#xA;          &quot;name&quot;: &quot;Max&quot;,&#xA;          &quot;interest &quot;: {&#xA;            &quot;id&quot;: 4488448&#xA;            &quot;status&quot;: &quot;active&quot;&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;02&quot;,&#xA;          &quot;name&quot;: &quot;Sophie&quot;,&#xA;          &quot;interest &quot;: {&#xA;            &quot;id&quot;: 15445&#xA;            &quot;status&quot;: &quot;deactivated&quot;&#xA;          }&#xA;        },&#xA;</code></pre>&#xA;<p>What I want</p>&#xA;<pre><code>{&#xA;        {&#xA;          &quot;id&quot;: &quot;01&quot;,&#xA;           &quot;id-interest&quot;: 4488448&#xA;           &quot;status&quot;: &quot;active&quot;&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;02&quot;,&#xA;          &quot;name&quot;: &quot;Sophie&quot;,&#xA;          &quot;id-interest&quot;: 15445&#xA;          &quot;status&quot;: &quot;deactivated&quot;&#xA;        },&#xA;}&#xA;</code></pre>&#xA;<p>What I tried but that deliver me the same result</p>&#xA;<pre><code>fragment InterestTask on Interest {&#xA; id&#xA; status&#xA;}&#xA;&#xA;query {&#xA;  model {&#xA;    allPersons{&#xA;      id&#xA;      interest {&#xA;        ...InterestTask &#xA;      }&#xA;        &#xA;    }&#xA;    &#xA;  }&#xA;}&#xA;</code></pre>&#xA;",18528165,,18528165,2022-03-24 13:39:40,2022-03-24 16:21:31,Get GraphQL output without second curly bracket,<graphql>,0,0,0,2022-03-24 13:28:38
71604876,1,,,0,152,"<p>I have graphql prisma api. Currently there is lyric field in Track table.</p>&#xA;<p>&quot;Let it [Am]be, let it [C/G]be, let it [F]be, let it [C]be&quot;</p>&#xA;<p>if I search using contain in graphql like example &quot;Let it be&quot;, this record is not come out because of the chord. Is there a way to replace the chord in lyric field before searching with contain.</p>&#xA;<p>I even tried to use prisma, but I don't find a way to replace string.</p>&#xA;<p>Regards,&#xA;Alex</p>&#xA;",1559116,,1559116,2022-03-24 15:53:03,2022-03-24 15:53:03,Graphql prisma string replace,<graphql><prisma-graphql><typegraphql>,0,5,0,2022-03-24 15:04:24
71613565,2,,69143733,0,,<p>Another workaround I've used is to skip any child resolver and just load additional entities conditionally in the base resolver.</p>&#xA;<pre><code>@DgsQuery&#xA;public User getUserById(@InputArgument UUID id) {&#xA;    var user = userService.findById(id);&#xA;    if (dfe.getSelectionSet().contains(&quot;articles&quot;) {&#xA;        Hibernate.initialize(user.getArticles());&#xA;    }&#xA;    return user;&#xA;}&#xA;</code></pre>&#xA;,3252391,,,,2022-03-25 07:44:39,"",,0,0,0,2022-03-25 07:44:39
71616913,1,,,4,620,"<p>I am learning react-relay (v13) and have a problem specifying a pagination fragment with @refetchable. It is a very basic structure and everything works if @refetchable is not used (ie I can query grapql server, obtain data, useFragment to render same query/fragment without pagination)</p>&#xA;<p>When I introduce @refetchable in the ProjectsFragment_user the react-relay compiler gives error:</p>&#xA;<pre><code>[ERROR] ✖︎ Invalid use of @refetchable on fragment 'ProjectsFragment_user', only supported are fragments on:&#xA; - the Viewer type&#xA; - the Query type&#xA; - the Node interface or types implementing the Node interface&#xA; - @fetchable type&#xA;</code></pre>&#xA;<p>Now this is confusing as ProjectsFragment_user is on a query that looks like this:</p>&#xA;<pre><code>// Dashboard.js&#xA;export const dashboardQuery = graphql`&#xA;query DashboardQuery ($id: ID) {&#xA;  user (id: $id){&#xA;    id &#xA;    name&#xA;    ...ProjectsFragment_user&#xA;  }&#xA;}&#xA;`;&#xA;// then &#xA;const  data = useLazyLoadQuery(dashboardQuery, {}, {},);&#xA;&#xA;</code></pre>&#xA;<pre><code>//Projects.js defines fragment&#xA;&#xA;const {data, loadNext} = usePaginationFragment(graphql`&#xA;    fragment ProjectsFragment_user on User &#xA;    @argumentDefinitions(&#xA;        first: {type: &quot;Int&quot;, defaultValue: 10}&#xA;        after: {type: &quot;String&quot;}&#xA;        before: {type: &quot;String&quot;}&#xA;      )&#xA;    @refetchable(queryName: &quot;ProjectsListPaginationQuery&quot;)&#xA;    {&#xA;            projects (first: $first, after: $after, before: $before)&#xA;            @connection(key: &quot;ProjectsList_projects&quot;) {&#xA;                total&#xA;                edges {&#xA;                  node {&#xA;                   id&#xA;                   name&#xA;          &#xA;                    members {&#xA;                     total&#xA;                     edges {&#xA;                     node {&#xA;                        member_id&#xA;                        member {&#xA;                        name&#xA;                        }&#xA;                        role&#xA;                      }&#xA;                     }&#xA;                   }&#xA;                  }&#xA;              }&#xA;            }&#xA;        }&#xA;    `,&#xA;    props?.projects);&#xA;&#xA;</code></pre>&#xA;<p>Note, if just useFragment on ProjectsFragment_user and remove @refetchable I can fetch and render data.</p>&#xA;<p>Does anyone have any clues why @refetchable is not allowed here??</p>&#xA;",9128309,,,,2022-03-25 13:21:10,react-relay Invalid use of @refetchable on fragment,<reactjs><graphql-js><relaymodern><react-relay>,1,0,0,2022-03-25 12:21:10
71632855,1,71655334,,0,1174,<p>Hi Im trying to save time and date to Mongo DB but it seems to be changing the date to another format and even when I try in that format it removes the timezone and changes the time</p>&#xA;<p>2022-03-30T09:00:46-07:00</p>&#xA;<p>becomes</p>&#xA;<p>2022-03-30T16:00:46.000+00:00</p>&#xA;<p>*My issue is when I send emails to tell clients the time it sends the wrong time completely causing confusion.&#xA;How can I ensure the timezone get saved in Mongo.</p>&#xA;<p>Im using graphql as an api lang if needed.</p>&#xA;,7644474,,7644474,2022-03-27 01:06:59,2022-03-29 01:06:56,How to save DateTime to MongoDB with Timezone intact?,<node.js><mongodb><express><mongoose><apollo>,2,2,0,2022-03-27 00:33:20
71655334,2,,71632855,0,,<p>There was no way to do it. It's best to store timezone separate and convert</p>&#xA;,7644474,,,,2022-03-29 01:06:56,"",,0,0,0,2022-03-29 01:06:56
71688320,1,,,0,90,"<p>So, I want to get the filtered data to my client,&#xA;I coded:</p>&#xA;<pre><code>  async function getData() {&#xA;    const exampleData= await API.graphql(graphqlOperation(listExample,{&#xA;      variables: { limit: 1000 },&#xA;      filter: {     &#xA;        order_number: {&#xA;           regexp: `.*TEST.*` &#xA;          }&#xA;      }&#xA;    }));&#xA;    dispatch({ type: QUERY, example: exampleData.data.listExample.items });&#xA;  }&#xA;</code></pre>&#xA;<p>But I couldn't receive any data,</p>&#xA;<p>Accroding to this document&#xA;<a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#filtering-queries"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#filtering-queries</a></p>&#xA;<p>I tried eq, ne, etc. They all work fine and get filtered data.</p>&#xA;",14574562,,14574562,2022-03-31 07:26:14,2022-03-31 07:26:14,How should I use Regex in AWS Amplify GraphQL,<reactjs><database><graphql><aws-amplify>,0,2,0,2022-03-31 07:12:21
71691438,2,,66830662,0,,"<p>For the first page your <code>nextToken</code> must be <code>null</code> as described <a href=""https://docs.amplify.aws/guides/api-graphql/graphql-pagination/q/platform/js/"" rel=""nofollow noreferrer"">here</a>.</p>&#xA;<p>There's nothing else wrong, try this:</p>&#xA;<pre><code>const [nextToken, setNextToken] = useState(&quot;&quot;);&#xA;&#xA;const fetchData = async (nToken = nextToken, size = perPage) =&gt; {&#xA;    try {&#xA;        const pictureData = await API.graphql(graphqlOperation(listPictures,&#xA;            {&#xA;                limit: size,&#xA;                nextToken: nToken ? nToken : null&#xA;            }));&#xA;        setNextToken(pictureData.data.listPictures.nextToken);&#xA;...&#xA;</code></pre>&#xA;",4458531,,4458531,2022-03-31 14:21:57,2022-03-31 14:21:57,"",,0,0,0,2022-03-31 11:08:03
71697718,2,,71696312,0,,"<p>I don't have your data structure and can't test. Does something like this work?</p>&#xA;<pre><code>query MyQuery {&#xA;  allWpCategory(&#xA;        filter: {&#xA;            posts: {&#xA;                elemMatch: {&#xA;                    id: {&#xA;                        ne: &quot;something&quot;&#xA;                    }&#xA;                }&#xA;            }, {&#xA;                id: {&#xA;                    in: [&quot;dGVybTo0Mg==&quot;]&#xA;                }&#xA;            }&#xA;        })&#xA;    {&#xA;        nodes {&#xA;            posts { // cannot filter here &#xA;                nodes {&#xA;                    title&#xA;                    id&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",2828026,,,,2022-03-31 18:50:25,"",,0,3,0,2022-03-31 18:50:25
71702236,2,,48331103,2,,"<p>In NestJS framework, this error happened to me because I defiled GraphQL field in my schema.graphql file as:</p>&#xA;<pre><code>  lastUpdated(): Date&#xA;</code></pre>&#xA;<p>Instead it should be just</p>&#xA;<pre><code>  lastUpdated: Date&#xA;</code></pre>&#xA;<p>(it doesn't take any argument)</p>&#xA;",8230784,,,,2022-04-01 05:34:26,"",,0,1,0,2022-04-01 05:34:26
71725244,2,,71725205,0,,"<p>Use</p>&#xA;<pre class=""lang-html prettyprint-override""><code>&lt;p v-for=&quot;edge in result.posts.edges.node&quot; :key=&quot;edge.id&quot;&gt;{{ edge.title }}&lt;/p&gt;&#xA;</code></pre>&#xA;",12570655,,12570655,2022-04-03 11:02:59,2022-04-03 11:02:59,"",,0,0,0,2022-04-03 10:57:56
71732349,1,71741437,,0,151,"<p>I am in deep water.<br />&#xA;I am trying to get all rows from a PostgreSQL database through a GraphQL api.<br />&#xA;I am using the <a href=""https://package.elm-lang.org/packages/dillonkearns/elm-graphql/latest/"" rel=""nofollow noreferrer""><code>dillonkearns/elm-graphql</code></a> elm package.<br />&#xA;This is my query (image for context):</p>&#xA;<pre><code>query getAllTheDATA {&#xA;  allEvents1S {&#xA;    nodes {&#xA;      name&#xA;      stopTime&#xA;      stopDate&#xA;      startTime&#xA;      startDate&#xA;      responsible&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/icdKP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/icdKP.png"" alt=""enter image description here"" /></a></p>&#xA;<h2>Current code:</h2>&#xA;<p>This code is just to make the query with the selectors.</p>&#xA;<pre><code>module Test exposing (..)&#xA;import Json.Decode as JD exposing (Decoder)&#xA;    &#xA;import Graphql.Operation exposing (RootQuery)&#xA;import Graphql.SelectionSet as SelectionSet exposing (SelectionSet,with)&#xA;import Calendar.Object exposing (Events1(..))&#xA;import Calendar.Object.Events1 as Events1&#xA;import Calendar.Object.Events1SConnection as EConn&#xA;import Calendar.Query as Query&#xA;import Calendar.Scalar exposing (Id(..))&#xA;import Calendar.Interface&#xA;import Calendar.Interface&#xA;    &#xA;type alias Activity2 =&#xA;   { name : Maybe String          -- The name of each activity&#xA;   , start_date : Maybe String    -- The start date for an activity&#xA;   , start_time: Maybe String     -- The start time for an activity&#xA;   , stop_date : Maybe String     -- The end date for an activity&#xA;   , stop_time: Maybe String      -- The end time for an activity&#xA;   , responsible : Maybe String   -- who is responsible&#xA;   }&#xA;    &#xA;eventsListSelection : SelectionSet (List Activity2) Calendar.Object.Events1SConnection&#xA;eventsListSelection =&#xA;    EConn.nodes &lt;----- this is where the problem lies&#xA;    &#xA;fetchEventsQuery : SelectionSet (Maybe (List Activity2)) RootQuery&#xA;fetchEventsQuery =&#xA;    Query.allEvents1S (List Activity2) eventsListSelection&#xA;</code></pre>&#xA;<h1>Questions:</h1>&#xA;<p>How would I, in elm using the elm-graphql package, collect this data and store it in a list?</p>&#xA;",7063897,,7063897,2022-04-05 18:30:44,2022-04-05 18:30:44,elm-graphq: Get list of all objects from connection query,<postgresql><graphql><elm>,1,3,0,2022-04-04 05:18:40
71751733,1,71752572,,0,123,"<p>I was able via Google Dev Tools - Networking to paste the graphql query into Insomnia (copy url bash) to make a working python request. Now something has been changed on the part of the provider. Now I can not even run the curl in insomnia. I only get response 400.&#xA;On my previous code I get error message, which I can not solve myself.&#xA;I would be very happy for a working solution.</p>&#xA;<p>My coder that worked so far is:</p>&#xA;<pre><code>import requests&#xA;import json&#xA;&#xA;def scrape_digitec():&#xA;    url = &quot;https://www.digitec.ch/api/graphql&quot;&#xA;    headers = {&#xA;        &quot;authority&quot;: &quot;www.digitec.ch&quot;,&#xA;        &quot;accept&quot;: &quot;application/json&quot;,&#xA;        &quot;accept-language&quot;: &quot;de-CH&quot;,&#xA;        &quot;cache-control&quot;: &quot;no-cache&quot;,&#xA;        &quot;content-type&quot;: &quot;application/json&quot;,&#xA;        &quot;origin&quot;: &quot;https://www.digitec.ch&quot;,&#xA;        &quot;pragma&quot;: &quot;no-cache&quot;,&#xA;        &quot;referer&quot;: &quot;https://www.digitec.ch/search?q=bang%20olufsen&quot;,&#xA;        &quot;sec-ch-ua&quot;: '&quot;Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;100&quot;, &quot;Google Chrome&quot;;v=&quot;100&quot;',&#xA;        &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;,&#xA;        &quot;sec-ch-ua-platform&quot;: '&quot;Windows&quot;',&#xA;        &quot;sec-fetch-dest&quot;: &quot;empty&quot;,&#xA;        &quot;sec-fetch-mode&quot;: &quot;cors&quot;,&#xA;        &quot;sec-fetch-site&quot;: &quot;same-origin&quot;,&#xA;        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36&quot;,&#xA;        &quot;x-dg-country&quot;: &quot;ch&quot;,&#xA;        &quot;x-dg-mandator&quot;: &quot;406802&quot;,&#xA;        &quot;x-dg-portal&quot;: &quot;25&quot;,&#xA;        &quot;x-dg-testgroup&quot;: &quot;Default&quot;&#xA;    }&#xA;&#xA;    search = 'lg'&#xA;    offset = '0'&#xA;    payload = '{&quot;query&quot;:&quot;query ENTER_SEARCH(\\t$query: String!\\t$sortOrder: ProductSort\\t$limit: Int = 9\\t$offset: Int = 0\\t$filters: [SearchFilter]\\t$include: [String!]\\t$exclude: [String!]\\t$searchQueryId: String\\t$siteId: String) {\\tsearch(\\t\\tquery: $query\\t\\tfilters: $filters\\t\\tsearchQueryId: $searchQueryId\\t\\tsiteId: $siteId\\t) {\\t\\tproducts(limit: $limit, offset: $offset, sortOrder: $sortOrder) {\\t\\t\\ttotal\\t\\t\\thasMore\\t\\t\\tnextOffset\\t\\t\\tresults {\\t\\t\\t\\t...ProductSearchResult\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\tfilters(include: $include, exclude: $exclude) {\\t\\t\\tproduct {\\t\\t\\t\\tidentifier\\t\\t\\t\\tname\\t\\t\\t\\tfilterType\\t\\t\\t\\tscore\\t\\t\\t\\ttooltip {\\t\\t\\t\\t\\t...FilterTooltipResult\\t\\t\\t\\t\\t__typename\\t\\t\\t\\t}\\t\\t\\t\\t...CheckboxSearchFilterResult\\t\\t\\t\\t...RangeSearchFilterResult\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\tmagazinePages(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\t__typename\\t\\t}\\t\\tauthors(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\t__typename\\t\\t}\\t\\tdiscussions(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\t__typename\\t\\t}\\t\\tquestions(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\t__typename\\t\\t}\\t\\tratings(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\t__typename\\t\\t}\\t\\tproductTypes(limit: 24) {\\t\\t\\ttotal\\t\\t\\tresults {\\t\\t\\t\\tid\\t\\t\\t\\tname\\t\\t\\t\\tprimarySynonyms\\t\\t\\t\\tisVisible\\t\\t\\t\\tdescription\\t\\t\\t\\tmetaDescription\\t\\t\\t\\timageUrl\\t\\t\\t\\tsearchScore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\tbrands(limit: 24) {\\t\\t\\ttotal\\t\\t\\tresults {\\t\\t\\t\\tid\\t\\t\\t\\ttitle\\t\\t\\t\\tsearchScore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\thelp(limit: 3) {\\t\\t\\tids {\\t\\t\\t\\tid\\t\\t\\t\\tscore\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\ttotal\\t\\t\\thasMore\\t\\t\\tresults {\\t\\t\\t\\tsearchScore\\t\\t\\t\\ttitle\\t\\t\\t\\tid\\t\\t\\t\\turl\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\t_meta {\\t\\t\\tqueryInfo {\\t\\t\\t\\tcorrectedQuery\\t\\t\\t\\tdidYouMeanQuery\\t\\t\\t\\tlastProductSearchPass\\t\\t\\t\\texecutedSearchTerm\\t\\t\\t\\ttestGroup\\t\\t\\t\\tisManagedQuery\\t\\t\\t\\tisRerankedQuery\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\tredirectionUrl\\t\\t\\tportalReferral {\\t\\t\\t\\tproductCount\\t\\t\\t\\tportalName\\t\\t\\t\\turl\\t\\t\\t\\tproductImageUrls\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}}fragment ProductSearchResult on ProductSearchResultItem {\\tsearchScore\\tmandatorSpecificData {\\t\\t...ProductMandatorSpecific\\t\\t__typename\\t}\\tproduct {\\t\\t...ProductMandatorIndependent\\t\\t__typename\\t}\\toffer {\\t\\t...ProductOffer\\t\\t__typename\\t}\\t__typename}fragment FilterTooltipResult on FilterTooltip {\\ttext\\tmoreInformationLink\\t__typename}fragment CheckboxSearchFilterResult on CheckboxSearchFilter {\\toptions {\\t\\tidentifier\\t\\tname\\t\\tproductCount\\t\\tscore\\t\\treferenceValue {\\t\\t\\tvalue\\t\\t\\tunit {\\t\\t\\t\\tabbreviation\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\tpreferredValue {\\t\\t\\tvalue\\t\\t\\tunit {\\t\\t\\t\\tabbreviation\\t\\t\\t\\t__typename\\t\\t\\t}\\t\\t\\t__typename\\t\\t}\\t\\ttooltip {\\t\\t\\t...FilterTooltipResult\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\t__typename}fragment RangeSearchFilterResult on RangeSearchFilter {\\treferenceMin\\tpreferredMin\\treferenceMax\\tpreferredMax\\treferenceStepSize\\tpreferredStepSize\\trangeMergeInfo {\\t\\tisBottomMerged\\t\\tisTopMerged\\t\\t__typename\\t}\\treferenceUnit {\\t\\tabbreviation\\t\\t__typename\\t}\\tpreferredUnit {\\t\\tabbreviation\\t\\t__typename\\t}\\trangeFilterDataPoint {\\t\\t...RangeFilterDataPointResult\\t\\t__typename\\t}\\t__typename}fragment ProductMandatorSpecific on MandatorSpecificData {\\tisBestseller\\tisDeleted\\tshowroomSites\\tsectorIds\\t__typename}fragment ProductMandatorIndependent on ProductV2 {\\tid\\tproductId\\tname\\tnameProperties\\tproductTypeId\\tproductTypeName\\tbrandId\\tbrandName\\taverageRating\\ttotalRatings\\ttotalQuestions\\tisProductSet\\timages {\\t\\turl\\t\\theight\\t\\twidth\\t\\t__typename\\t}\\tenergyEfficiency {\\t\\tenergyEfficiencyColorType\\t\\tenergyEfficiencyLabelText\\t\\tenergyEfficiencyLabelSigns\\t\\tenergyEfficiencyImage {\\t\\t\\turl\\t\\t\\theight\\t\\t\\twidth\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\tseo {\\t\\tseoProductTypeName\\t\\tseoNameProperties\\t\\tproductGroups {\\t\\t\\tproductGroup1\\t\\t\\tproductGroup2\\t\\t\\tproductGroup3\\t\\t\\tproductGroup4\\t\\t\\t__typename\\t\\t}\\t\\tgtin\\t\\t__typename\\t}\\thasVariants\\tsmallDimensions\\tbasePrice {\\t\\tpriceFactor\\t\\tvalue\\t\\t__typename\\t}\\t__typename}fragment ProductOffer on OfferV2 {\\tid\\tproductId\\tofferId\\tshopOfferId\\tprice {\\t\\tamountIncl\\t\\tamountExcl\\t\\tcurrency\\t\\tfraction\\t\\t__typename\\t}\\tdeliveryOptions {\\t\\tmail {\\t\\t\\tclassification\\t\\t\\tfutureReleaseDate\\t\\t\\t__typename\\t\\t}\\t\\tpickup {\\t\\t\\tsiteId\\t\\t\\tclassification\\t\\t\\tfutureReleaseDate\\t\\t\\t__typename\\t\\t}\\t\\tdetailsProvider {\\t\\t\\tproductId\\t\\t\\tofferId\\t\\t\\tquantity\\t\\t\\ttype\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\tlabel\\ttype\\tvolumeDiscountPrices {\\t\\tminAmount\\t\\tprice {\\t\\t\\tamountIncl\\t\\t\\tamountExcl\\t\\t\\tcurrency\\t\\t\\t__typename\\t\\t}\\t\\tisDefault\\t\\t__typename\\t}\\tsalesInformation {\\t\\tnumberOfItems\\t\\tnumberOfItemsSold\\t\\tisEndingSoon\\t\\tvalidFrom\\t\\t__typename\\t}\\tincentiveText\\tisIncentiveCashback\\tisNew\\tisSalesPromotion\\thideInProductDiscovery\\tcanAddToBasket\\thidePrice\\tinsteadOfPrice {\\t\\ttype\\t\\tprice {\\t\\t\\tamountIncl\\t\\t\\tamountExcl\\t\\t\\tcurrency\\t\\t\\tfraction\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\tminOrderQuantity\\t__typename}fragment RangeFilterDataPointResult on RangeFilterDataPoint {\\tcount\\treferenceValue {\\t\\tvalue\\t\\tunit {\\t\\t\\tabbreviation\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\tpreferredValue {\\t\\tvalue\\t\\tunit {\\t\\t\\tabbreviation\\t\\t\\t__typename\\t\\t}\\t\\t__typename\\t}\\t__typename}\&quot;,\&quot;variables\&quot;:{\&quot;limit\&quot;:100,\&quot;offset\&quot;:'+offset+',\&quot;query\&quot;:\&quot;'+search+'\&quot;,\&quot;filters\&quot;:[],\&quot;sortOrder\&quot;:null,\&quot;include\&quot;:[\&quot;bra\&quot;,\&quot;pt\&quot;,\&quot;pr\&quot;],\&quot;exclude\&quot;:[\&quot;off\&quot;],\&quot;searchQueryId\&quot;:\&quot;4ce81461-09e2-4f7a-bb9a-8f6f8503fdc4\&quot;,\&quot;siteId\&quot;:null},\&quot;operationName\&quot;:\&quot;ENTER_SEARCH\&quot;}'&#xA;&#xA;    response = requests.request(&quot;POST&quot;, url, data=payload, headers=headers)&#xA;    print(response)&#xA;    data = response.json()&#xA;    print(json.dumps(data, indent=2))&#xA;    print(json.dumps(data))&#xA;&#xA;if __name__ == '__main__':&#xA;    scrape_digitec()&#xA;</code></pre>&#xA;",16960828,,,,2022-04-05 13:23:54,I need help to fix scraping graphql API,<web-scraping><python-requests><graphql>,1,0,0,2022-04-05 12:25:01
71774854,1,,,0,60,"<p>If I have a query as below:</p>&#xA;<pre><code>query {&#xA;      queryState(filter: {code: {in : [&quot;WA&quot;, &quot;VA&quot;]}}){&#xA;        code&#xA;        name&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>What is the max number of values that I can provide in the array used for the <code>IN</code> clause? I tried looking up the documentation but did not find relevant information on this?</p>&#xA;",3469521,,62576,2022-04-07 00:03:01,2022-04-07 00:03:01,Max limit of values in IN clause,<graphql>,0,0,0,2022-04-07 00:01:38
71783481,1,,,0,206,"<p>How can I filter a query based on the input from a user. I have seen a few different methods but I am getting no results. Can I add a filter after the setRentals or do I need a complete new query. I have a search bar that gives {location} when a user adds it. I want to pass that location to the query thus listing all the rentals by the String type.</p>&#xA;<pre><code> useEffect(() =&gt; {&#xA;    fetchPosts();&#xA;  }, []);&#xA;  async function fetchPosts() {&#xA;    const postData = await API.graphql({&#xA;      query: listRentals,&#xA;    });&#xA;    setRentals(postData.data.listRentals.items);&#xA;  }&#xA;</code></pre>&#xA;",15215008,,,,2022-04-07 13:54:31,Filtering queries from graphql with dynamic location from search bar?,<graphql><next.js><aws-amplify>,0,0,0,2022-04-07 13:54:31
71789287,1,,,0,237,"<p>How can I query fetched data using graphql. I have a search input that I want a user to be able to type for example &quot;England&quot; and then fetch all the properties listed in England, or filter depending on which way would work. I have tried numerous things that I have found online and nothing makes it clear. The method below is the closest I have got but I get an AST error.</p>&#xA;<p>This is this the schema</p>&#xA;<pre><code>export const listRentals = /* GraphQL */ `&#xA;  query ListRentals(&#xA;    $filter: ModelRentalFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listRentals(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        title&#xA;        description&#xA;        MaxNumberOfGuest&#xA;        MaxNumberOfAdults&#xA;        MaxNumberOfChildren&#xA;        NumberOfBedrooms&#xA;        NumberOfBaths&#xA;        PricePerNight&#xA;        AdditionalCosts&#xA;        FeaturedImage&#xA;        username&#xA;        StreetName&#xA;        Area&#xA;        ZipCode&#xA;        Island&#xA;        lat&#xA;        lon&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>The {location} is pulled from the what the user types in. I am using AWS Amplify if that makes a difference to anything and the frontEnd is NextJs. I have seen a few articles that mention Apollo, but they seem to be dated posts and I believe AWS has had a lot of changes from then.</p>&#xA;<pre><code>function Search() {&#xA;  const [rentals, setRentals] = useState([]);&#xA;  useEffect(() =&gt; {&#xA;    fetchPosts();&#xA;  }, []);&#xA;  async function fetchPosts() {&#xA;    const postData = await API.graphql(&#xA;      graphqlOperation(&#xA;        (listRentals,&#xA;        {&#xA;          filter: {&#xA;            Island: {&#xA;              eq: {location},&#xA;            },&#xA;          },&#xA;        })&#xA;      )&#xA;    );&#xA;    setRentals(postData.data.listRentals.items);&#xA;  }&#xA;&#xA;  graphqlOperation;&#xA;  const router = useRouter();&#xA;  const { location, startDate, endDate, noOfGuests } = router.query;&#xA;  const formattedStartDate = format(new Date(startDate), &quot;dd MMMM yy&quot;);&#xA;  const formattedEndDate = format(new Date(endDate), &quot;dd MMMM yy&quot;);&#xA;  const range = `${formattedStartDate} - ${formattedEndDate}`;&#xA;  return (&#xA;    &lt;div&gt;&#xA;      &lt;SearchBar&#xA;        rentals={rentals}&#xA;        placeholder={`${location}  | ${range} | ${noOfGuests}`}&#xA;      /&gt;&#xA;&#xA;      &lt;main className=&quot;flex&quot;&gt;&#xA;        &lt;section className=&quot;flex-grow pt-14 px-6&quot;&gt;&#xA;        &#xA;          &lt;div className=&quot;flex flex-col&quot;&gt;&#xA;            {rentals.map((rental, id) =&gt; (&#xA;              &lt;Link key={id} href={`/rentals/${rental.id}`}&gt;&#xA;                &lt;a&gt;&#xA;                  &lt;RentalCard rental={rental} /&gt;&#xA;                &lt;/a&gt;&#xA;              &lt;/Link&gt;&#xA;            ))}&#xA;          &lt;/div&gt;&#xA;        &lt;/section&gt;&#xA;      &lt;/main&gt;&#xA;    &lt;/div&gt;&#xA;  );&#xA;}&#xA;&#xA;export default Search;&#xA;</code></pre>&#xA;",15215008,,,,2022-04-07 21:45:56,how do I filter a graphql query,<graphql><next.js><aws-amplify>,0,2,0,2022-04-07 21:45:56
71822423,2,,71594949,1,,"<p>ID types in GraphQL are handled as String.<br />&#xA;Probably, you are using number as the ID of the todo, so the type does not match, resulting in an error.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const SpecifiedScalars = {&#xA;  ID: 'string',&#xA;  String: 'string',&#xA;  Float: 'number',&#xA;  Int: 'number',&#xA;  Boolean: 'boolean',&#xA;}&#xA;</code></pre>&#xA;<p>from <a href=""https://github.com/graphql-nexus/nexus/blob/11d028277e7fec241246237dbe31707c037407ee/src/typegenPrinter.ts#L44"" rel=""nofollow noreferrer"">https://github.com/graphql-nexus/nexus/blob/11d028277e7fec241246237dbe31707c037407ee/src/typegenPrinter.ts#L44</a></p>&#xA;",9359438,,,,2022-04-11 03:27:36,"",,0,0,0,2022-04-11 03:27:36
71833187,1,,,0,180,"<p>Im making a code to get data from pipefy API and the pagination isn't working out for me</p>&#xA;<pre><code>headers = {&#xA;    &quot;authorization&quot;: 'Bearer TOKEN',&#xA;    &quot;content-type&quot;: &quot;application/json&quot;&#xA;}&#xA;first_query = True&#xA;has_next_page = True&#xA;pipe_id = &quot;PIPE_ID_NUMBER&quot;&#xA;    if first_query:&#xA;        payload = &quot;{\&quot;query\&quot;:\&quot;{ allCards (pipeId:&quot;+pipe_id+&quot;, first:50){edges{node{id title fields {report_value updated_at}} cursor} pageInfo {endCursor hasNextPage}}}\&quot;}&quot;&#xA;        print(payload)&#xA;        first_query = False&#xA;    else:&#xA;        payload = &quot;{\&quot;query\&quot;:\&quot;{allCards(pipeId:&quot;+pipe_id+&quot;,after:\&quot;&quot;+end_cursor+&quot;\&quot;){edges{node{id title fields{report_value updated_at}}}pageInfo{endCursor hasNextPage}}}\&quot;}&quot;&#xA;        print(payload)&#xA;    response = requests.request(&quot;POST&quot;, url, data=payload, headers=headers)&#xA;    print(response)    &#xA;    json_data = json.loads(response.text)&#xA;    end_cursor = json_data[&quot;data&quot;][&quot;allCards&quot;][&quot;pageInfo&quot;][&quot;endCursor&quot;]&#xA;    has_next_page = json_data[&quot;data&quot;][&quot;allCards&quot;][&quot;pageInfo&quot;][&quot;hasNextPage&quot;]&#xA;    total_records_pg = len(json_data[&quot;data&quot;][&quot;allCards&quot;][&quot;edges&quot;])&#xA;</code></pre>&#xA;<p>and i got the return:</p>&#xA;<pre><code>{&quot;query&quot;:&quot;{ allCards (pipeId:PIPE_ID, first:50){edges{node{id title fields {report_value updated_at}} cursor} pageInfo {endCursor hasNextPage}}}&quot;}&#xA;&lt;Response [200]&gt;&#xA;{&quot;query&quot;:&quot;{allCards(pipeId:PIPE_ID,after:&quot;WyIyLjAiLCItNTcuMCIsNTA0NDMxMzg4XQ&quot;){edges{node{id title fields{report_value updated_at}}}pageInfo{endCursor hasNextPage}}}&quot;}&#xA;&lt;Response [400]&gt;&#xA;Traceback (most recent call last):&#xA;  File &quot;c:\Users\rafael.alves\Desktop\Novo PC\uknow\DigitalPE\import requests.py&quot;, line 32, in &lt;module&gt;&#xA;    json_data = json.loads(response.text)&#xA;  File &quot;C:\Users\rafael.alves\AppData\Local\Programs\Python\Python310\lib\json\__init__.py&quot;, line 346, in loads&#xA;    return _default_decoder.decode(s)&#xA;  File &quot;C:\Users\rafael.alves\AppData\Local\Programs\Python\Python310\lib\json\decoder.py&quot;, line 337, in decode&#xA;    obj, end = self.raw_decode(s, idx=_w(s, 0).end())&#xA;  File &quot;C:\Users\rafael.alves\AppData\Local\Programs\Python\Python310\lib\json\decoder.py&quot;, line 355, in raw_decode&#xA;    raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None&#xA;json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)&#xA;PS C:\Users\rafael.alves\Desktop\Novo PC\uknow&gt; &#xA;</code></pre>&#xA;<p>have looking everywhere where i got it wrong but no with no succes.&#xA;the &quot;&lt;Response [400]&gt;&quot; tells me that the payload just bring empty, and i supossed  that means the mistake is the &quot;after&quot; argument</p>&#xA;",18775336,,18775336,2022-04-11 19:24:09,2022-07-01 13:31:05,"Python - pagination ""after"" parameter doesnt work in query",<python><graphql><request><query-parameters>,1,0,0,2022-04-11 19:17:18
71833652,1,72588735,,3,566,"<p>Is there a way to implement graphql <a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">cursor based pagination</a> with nested pagination queries in a performant way?</p>&#xA;<p>Let's say we have 3 pseudo graphql types:</p>&#xA;<pre><code>type User {&#xA;  id: ID!&#xA;  books: [Book!]!&#xA;}&#xA;&#xA;type Book {&#xA;  isbn: ID!&#xA;  pages: [Page!]!&#xA;}&#xA;&#xA;type Page {&#xA;  num: ID!&#xA;}&#xA;</code></pre>&#xA;<p>For simplicity let's say user could read thousands of books and each book can have hundred of pages.</p>&#xA;<p><code>user</code> database table:</p>&#xA;<pre><code>id&#xA;1&#xA;2&#xA;3&#xA;...etc&#xA;</code></pre>&#xA;<p><code>book</code> database table:</p>&#xA;<pre><code>isbn&#xA;1&#xA;2&#xA;3&#xA;...etc&#xA;</code></pre>&#xA;<p><code>page</code> database table:</p>&#xA;<pre><code>num&#xA;1&#xA;2&#xA;3&#xA;...etc&#xA;</code></pre>&#xA;<p><code>user_book</code> database table:</p>&#xA;<pre><code>user_id | book_isbn&#xA;1       | 2&#xA;1       | 3&#xA;2       | 1&#xA;...etc&#xA;</code></pre>&#xA;<p><code>book_page</code> database table:</p>&#xA;<pre><code>book_isbn | page_num&#xA;1         | 1&#xA;1         | 2&#xA;2         | 3&#xA;...etc&#xA;</code></pre>&#xA;<p>We can't load million users, thousands of books they read and hundreds of pages, so we do a pagination. Let's say we want to load 100 users, first 50 books that each of them read and first 10 pages of each book:</p>&#xA;<pre><code>{&#xA;  users(first: 100, after: &quot;9&quot;) {&#xA;   edges { &#xA;     node {&#xA;       id&#xA;       books(first: 50) {&#xA;         edges {&#xA;           node {&#xA;             id&#xA;             pages(first: 10) {&#xA;               node {&#xA;                 id&#xA;               }&#xA;             }&#xA;           }&#xA;         }&#xA;       }&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>We can load users <code>10..110</code>, then for each user <code>books</code> resolver use parent user <code>id</code> to load 50 books and for each book <code>pages</code> resolver load 10 pages:</p>&#xA;<pre><code>// pseudo code&#xA;const resolvers = {&#xA;  // get users from 10 to 110&#xA;  users: (_, args) =&gt; `SELECT * FROM user WHERE id &gt; args.after LIMIT 100`,&#xA;  User: {&#xA;    books: (root) =&gt; `SELECT * FROM book JOIN user_book ub WHERE ub.user_id = root.id LIMIT 50`&#xA;  },&#xA;  Book: {&#xA;    pages: (root) =&gt; `SELECT * FROM page JOIN book_page bp WHERE bp.book_isbn = root.isbn LIMIT 10`&#xA;  }&#xA;};&#xA;</code></pre>&#xA;<h2>Problem 1 SQL</h2>&#xA;<p>We do 1 database request to get 100 users, then 100 requests to get books for each user and finally 500 requests to get pages for each book (100 users * 50 books). Total of <strong>601</strong> database request for one query :(</p>&#xA;<p>If we didn't have pagination we could use dataloader to batch user ids into array in books resolver and book ids in pages resolver to do only 3 database requests. But how can having array of user ids <code>10...100</code> can we query only 50 books for <strong>each</strong> user and the same for pages?</p>&#xA;<h2>Problem 2 Graphql</h2>&#xA;<p>We can't use cursor for nested paginated queries (books and pages) because we don't know them and even if we did we could not pass them separately for each group:</p>&#xA;<pre><code>{&#xA;  users(first: 100, after: &quot;9&quot;) {&#xA;   edges { &#xA;     node {&#xA;       id&#xA;       // this will not work because for each user books group we need it's own cursor&#xA;       books(first: 50, after: &quot;99&quot;) {&#xA;         edges {&#xA;           node {&#xA;             id&#xA;           }&#xA;         }&#xA;       }&#xA;     }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;<p>My only idea to solve this is to allow pagination only as top level query and never use it as field on type.</p>&#xA;",10188661,,10188661,2022-04-17 15:06:17,2022-06-15 16:13:38,"Graphql nested cursor based pagination, resolver and SQL query",<sql><postgresql><graphql><pagination><dataloader>,1,0,0,2022-04-11 20:00:32
71844246,1,,,0,21,"<p>For example, we have a subpage /test , this page contains 3 components, is it better to send the date in props, or one better way is to use the same query inside the component.I will just add that these components also have their children to whom they send data in props. What are the rules?</p>&#xA;",13072299,,13072299,2022-04-12 14:18:46,2022-04-12 14:18:46,"Sending apollo data in props, or writing new queries in children component - good practice",<reactjs><typescript><graphql><apollo>,0,0,0,2022-04-12 14:12:52
71848722,1,,,0,65,"<p>I was using Relay Modern and now I am using Apollo Client. I would like to write the equivalent of a fragment component.</p>&#xA;<p>In Relay Modern, the fragment data is only available in the component that requires it and it is only fetched when the component is mounted. Is it possible to have the same behaviour in Apollo Client?</p>&#xA;<p>In my example the Child's data is available in the parent and it is fetched before the component is mounted.</p>&#xA;<p>Question:</p>&#xA;<p><strong>can I set up apollo client the child fragment data is only fetched when the child mounts</strong></p>&#xA;",8896573,,,,2022-04-12 20:29:17,only render fragment data when component is mounted: Apollo Client,<graphql><apollo-client><relay>,1,0,0,2022-04-12 20:22:11
71854936,1,,,1,61,"<p>I'm trying to implement batching in redux-saga using graphql-request's <code>batchRequests()</code> function but not sure of the syntax.</p>&#xA;<p>Here's what I've tried</p>&#xA;<pre><code>    export default ({ gqlClient } = {}) =&gt; {&#xA;        function* getDashboardData() {&#xA;        while (true) {&#xA;            try {&#xA;                yield take(dashboardActions.getDashboardDataPending.type);&#xA;&#xA;                yield call([gqlClient, gqlClient.batchRequests],&#xA;                   { document: queries.home.getUserData, variables: { period: 'day', date: 'last30' } },&#xA;                   { document: queries.home.getRevenueData, variables: { period: 'day', date: 'last60' } }&#xA;                 );&#xA;                 &#xA;                 ...&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<pre><code>   export default ({ gqlClient } = {}) =&gt; {&#xA;            function* getDashboardData() {&#xA;            while (true) {&#xA;                try {&#xA;                    yield take(dashboardActions.getDashboardDataPending.type);&#xA;    &#xA;                    yield apply(gqlClient, gqlClient.batchRequests,&#xA;                     [&#xA;                       { document: queries.home.getUserData, variables: { period: 'day', date: 'last30' } },&#xA;                       { document: queries.home.getRevenueData, variables: { period: 'day', date: 'last60' } }&#xA;                     ]);&#xA;                     &#xA;                     ...&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;</code></pre>&#xA;<p>But this doesn't work.&#xA;<a href=""https://i.stack.imgur.com/09bEQ.png"" rel=""nofollow noreferrer"">Error screenshot</a>&#xA;Using graphql-request v3.7.0 &amp; redux-saga v1.1.3</p>&#xA;<p>Can someone tell the correct way to do it?&#xA;<a href=""https://github.com/prisma-labs/graphql-request#batching"" rel=""nofollow noreferrer"">graphql-request's docs</a></p>&#xA;",8285539,,8285539,2022-04-13 12:35:28,2022-04-14 04:43:18,How to use graphql-request's batching via the batchRequests() function in redux-saga?,<reactjs><graphql><redux-saga><prisma><prisma-graphql>,1,0,0,2022-04-13 09:17:11
71865886,2,,55211609,0,,"<p>The short answer is no.</p>&#xA;<p>Filtering users is the <code>user</code> query's responsibility, not the children's. You are trying to split a query that's actually a single query (filter users by address).</p>&#xA;<p>If you want to modify the result of the user query itself, you should add an <code>address</code> parameter to the <code>user</code> query itself so it can filter the users by address.</p>&#xA;<p>Something like this:</p>&#xA;<pre><code>Users($filter: String!) {&#xA;  user(filter: $filter, addressFilter: $addressFilter) { &#xA;    id, &#xA;    name, &#xA;    address { &#xA;       street, &#xA;       city, &#xA;       country&#xA;    } &#xA;  } &#xA;}&#xA;</code></pre>&#xA;<p>Then the resolver look like this:</p>&#xA;<pre><code>const resolverMap = {&#xA;  Query: {&#xA;    User(obj, args, context, info) {&#xA;      // query both API for User info (not including address)&#xA;      // and API for user addresses using $filter and $addressFilter&#xA;      // Then match results from both API and discard users with invalid&#xA;      // addresses&#xA;&#xA;      // For example if the filter is country: England, only &#xA;      // return users that live in England with their address&#xA;    },&#xA;  },&#xA;  Address: {&#xA;    address: (obj, args, context, info) {&#xA;      // you don't need this resolver unless you want to somehow&#xA;      // change or format the addresses previously returned&#xA;    },&#xA;  },&#xA;}&#xA;</code></pre>&#xA;<p>If you still want to make it work the way you initially intended, you may find a way to hack it and make it work. You may be able to access the entire query object from the <code>user</code> resolver parameters, maybe inject stuff in the context to make it available in the resolvers, but even if you manage to do it you are kind of breaking the GraphQL semantics.</p>&#xA;<p>The <code>user</code> query is the one responsible for returning the list of users. After it returns the children resolvers can't change the user list itself again, only the children objects.</p>&#xA;<p>The <code>address</code> resolver will be called once for each user after the <code>user</code> query has already completed but it has nothing to do with modifying the result of the <code>user</code> query. The address resolver should only change address itself, but not the parent. <code>address</code> is a not a list, so it doesn't make sense to use it for filtering it, but you could use the <code>address</code> resolver to format each address in a particular way.</p>&#xA;",925649,,,,2022-04-14 02:38:04,"",,0,0,0,2022-04-14 02:38:04
71866596,2,,71854936,0,,"<p>This worked for me</p>&#xA;<pre><code>export default ({ gqlClient } = {}) =&gt; {&#xA;    function* getDashboardData() {&#xA;    while (true) {&#xA;        try {&#xA;            yield take(dashboardActions.getDashboardDataPending.type);&#xA;&#xA;            yield call([gqlClient, gqlClient.batchRequests],&#xA;               [{ document: queries.home.getUserData, variables: { period: 'day', date: 'last30' } },&#xA;                { document: queries.home.getRevenueData, variables: { period: 'day', date: 'last60' } }]&#xA;             );&#xA;             &#xA;             ...&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",8285539,,,,2022-04-14 04:43:18,"",,0,1,0,2022-04-14 04:43:18
71868581,1,,,0,118,"<p>I'm trying to make a function requesting same query with different input values.<br>&#xA;As you can see below, I want to get info up to date (totally 14 days's result) one by one and render this data one by one. <br>&#xA;But the problem is that when I check the console.log(data), it's just printed one time with the result data of last query request.</p>&#xA;<p>I want</p>&#xA;<pre><code>data of 15th of April&#xA;data of 14th of April&#xA;data of 13th of April&#xA;data of 12th of April&#xA;data of 11th of April&#xA;...&#xA;data of 1th of April&#xA;</code></pre>&#xA;<p>one by one.</p>&#xA;<p>Is there anyone could give me solution or any clues?&#xA;Below is my code.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const [getSomething, { data, error, loading, client, variables }] =&#xA;    useGetSomethingLazyQuery();&#xA;&#xA;const makeSomething = async () =&gt; {&#xA;    const today = new Date();&#xA;    const dates = [];&#xA;&#xA;    for (let i = 0; i &lt; 15; i++) {&#xA;      let date = subDays(today, i);&#xA;      dates.push(date);&#xA;    }&#xA;&#xA;    await dates.map(async (date) =&gt; {&#xA;      const result = await getSomething({&#xA;        variables: {&#xA;          logisticId,&#xA;          sellerId,&#xA;          currentEndDate: new Date(date),&#xA;          period: 1, // days&#xA;        },&#xA;      });&#xA;      console.log(result) //result is always same as last query result &#xA;      return result; &#xA;    });&#xA;&#xA;    await client.refetchQueries({&#xA;      include: [namedOperations.Query.getSomethingQuery],&#xA;    });&#xA;  };&#xA;</code></pre>&#xA;",14510253,,205233,2022-04-14 08:30:20,2022-04-14 08:30:20,How to request same query many times using map method and use the data one by one,<graphql><apollo>,0,0,0,2022-04-14 08:22:25
71895726,1,71906114,,1,339,"<p>I am using the rebing graphql laravel library and it works very fine returning json data. Currently I am trying to build a paginated table via reactjs frontend so I need to get a paginated data just the way it works normally with blade. I have used the <code>paginate</code> method in place of the <code>get</code> method but it somehow still gives same data format. This is what I have in my resolve method currently:</p>&#xA;<pre><code>$models = YearModel&#xA;        ::with($with)&#xA;        -&gt;select($select)&#xA;        -&gt;where($where)&#xA;        -&gt;orderByDesc('year_id');&#xA;    if (isset($args['limit'])) {&#xA;        $models = $models-&gt;paginate($args['limit']);&#xA;    } else {&#xA;        $models = $models-&gt;get();&#xA;    }&#xA;    return $models;&#xA;</code></pre>&#xA;<p><code>paginate</code> and <code>get</code> returns same data to the frontend whereas I was expecting <code>paginate</code> to give some data which would include stuffs like currentPage, nextPage, previousPage as the <code>LengthAwarePaginator</code> class would normally do. So I believe the graphql library is somehow formating the paginated data as a normal data before returning it to the frontend. I am not sure why this is like this as I am new to graphql. Any idea or solution will be appreciated please. Thanks</p>&#xA;",10339262,,10339262,2022-04-16 18:28:23,2022-04-17 23:05:04,Return paginated data from rebing laravel graphql server,<laravel><graphql><pagination>,1,0,0,2022-04-16 16:43:16
71906114,2,,71895726,1,,"<p>I was able to get a paginated data response by changing my query return type from <code>Type::nonNull(Type::listOf(Type::nonNull(GraphQL::type('YearModel'))))</code> to <code>GraphQL::paginate('YearModel')</code> and modified my query this way:</p>&#xA;<pre><code>query {&#xA;        yearModels (limit: 10) {&#xA;            data {&#xA;                id&#xA;                year&#xA;            }&#xA;            total&#xA;            per_page&#xA;            current_page&#xA;            from&#xA;            to&#xA;            last_page&#xA;            has_more_pages&#xA;        }&#xA;    }`&#xA;</code></pre>&#xA;<p>data, total, per_page, current_page, from, to, last_page, has_more_pages are fields coming from <code>Rebing\GraphQL\Support\PaginationType</code> <code>getPaginationFields</code> method.</p>&#xA;",10339262,,,,2022-04-17 23:05:04,"",,0,0,0,2022-04-17 23:05:04
71924280,1,,,0,54,"<p>We have 3 remote graphQL servers (v11) and a gateway (v12) to facilitate a centralized stitching environment (sort of as in <a href=""https://github.com/ChilliCream/hotchocolate-examples/tree/master/misc/Stitching/centralized"" rel=""nofollow noreferrer"">this</a> example) such that we may make available combined data to the client.</p>&#xA;<p>However, we have a requirement to do calculations on some of the stitched data after everything has been retrieved from the remote graphQL servers.</p>&#xA;<p>For example, if server A provides inventory data, server B provides product data, and server C provides sales data ... and assume the query is as follows:</p>&#xA;<pre><code>query {&#xA;  fetchProducts {&#xA;    name&#xA;    barCode&#xA;    inventory {&#xA;      numberInStock&#xA;      reserved&#xA;      available&#xA;    }&#xA;    sales {&#xA;      unitPrice&#xA;      unitsSold&#xA;      dailyAvgCount&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Now, assuming this is for the current day, and I want to forecast total sales for the day using inventory and sales data for a given product, how could I do this at the gateway? If possible, can one intercept and modify the data before it is returned in the response?</p>&#xA;",637278,,,,2022-04-19 11:33:59,GraphQL (HotChocolate): Access all retrieved data at Gateway after stitching results returned,<c#><graphql><hotchocolate>,0,0,0,2022-04-19 11:33:59
71946123,1,,,1,318,"<p>I need help with syrup pool data fetching from pancakeswap subgraph api using GraphQL.&#xA;I tried to get smartchefs where the earnedToken in &quot;PancakeSwap Token&quot;, the same way it is on the website, however the query result does not seem to give me any data.&#xA;The filtering of getting SmartChefs is not working (or I don't know how to perform filtering).&#xA;I am interested in TvL and cake rewards APY for the Cake single stake pool specifically.</p>&#xA;<p>If someone managed to fetch this type of data, it would be very helpful!</p>&#xA;",18884395,,,,2022-04-20 20:57:41,Pancakeswap API (Subgraph),<graphql>,0,0,0,2022-04-20 20:57:41
71954121,1,71955352,,2,544,"<p>I have a <code>filterModel</code> which is a Map <code>Map&lt;String, ColumnFilter&gt; filterModel</code> in order to filter my Actor data. I get an filterModel Object from the client when I try to filter my data. How do I define this Java Map in my graphql Query?</p>&#xA;<p>filterModel Object from client:</p>&#xA;<pre><code>filterModel: {&#xA;               firstname: {filterType: 'text', type: 'contains', filter: 'Tom'}, ...&#xA;              }&#xA;</code></pre>&#xA;<p>schema:</p>&#xA;<pre><code>type Actor {&#xA;    actorId: ID!,&#xA;    firstName: String,&#xA;    lastName: String,&#xA;}&#xA;&#xA;type Query {&#xA;    rows(&#xA;        filterModel: [filterModel]&#xA;    ): [Actor]&#xA;}&#xA;&#xA;input filterModel {&#xA;    key: String,&#xA;    value: ColumnFilter&#xA;}&#xA;&#xA;input ColumnFilter {&#xA;    filterType: String,&#xA;    type: String,&#xA;    filter: String&#xA;}&#xA;</code></pre>&#xA;",18438174,,,,2022-04-21 13:29:15,How to define a Java Map in graphql?,<java><spring-boot><graphql><maps><graphql-java>,1,0,0,2022-04-21 12:01:39
72002566,1,,,1,46,"<p>I am trying to pass default variables to my gql query in React :</p>&#xA;<pre><code>query getQuery($id: UUID!, $current: Boolean = true) {&#xA;  myQuery(id: $id) {&#xA;    id&#xA;    name&#xA;    versions (current: $current) {&#xA;      id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre><code>useQuery(MY_QUERY, {&#xA;  fetchPolicy: 'network-only',&#xA;  notifyOnNetworkStatusChange: true,&#xA;  variables: {&#xA;    id: myId&#xA;  },&#xA;});&#xA;</code></pre>&#xA;<p>But i have an error <code>Error: Unexpected end of JSON input</code></p>&#xA;",18941484,,,,2022-06-28 08:10:14,"Using GQL from Apollo/client default variables results in ""Unexpected end of JSON input""",<reactjs><graphql><apollo-client>,1,0,0,2022-04-25 16:10:47
72010058,1,72010350,,2,152,"<p>I don't get it, I sent in the right input type here:</p>&#xA;<p><strong>Caller from JS code:</strong></p>&#xA;<pre><code>export interface FilterInput {&#xA;    limit?: number;&#xA;}&#xA;&#xA;const filter: FilterInput = { limit: 1 };&#xA;const query = {&#xA;    query: `query { &#xA;        companies(filter: ${filter}) {&#xA;            list {&#xA;                name&#xA;            }&#xA;        }&#xA;    }`,&#xA;};&#xA;const response = await sendQuery(query);&#xA;        &#xA;</code></pre>&#xA;<p><strong>GraphQL Schema:</strong></p>&#xA;<pre><code>companies(filter: FilterInput): Companies&#xA;&#xA;input FilterInput {&#xA;  limit: Int&#xA;}&#xA;</code></pre>&#xA;<p><strong>Error:</strong> <code>Expected value of type &quot;FilterInput&quot;, found [object, Object].</code></p>&#xA;<p>When I try this out in <strong>graphiql</strong> in the browser, it works fine:</p>&#xA;<pre><code>query {&#xA;    companies(filter: { limit: 6 }) {&#xA;        list {&#xA;            name&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",4694781,,,,2022-04-26 08:00:39,"Expected value found [object, Object] Query Params",<javascript><graphql>,1,0,0,2022-04-26 07:37:05
72010350,2,,72010058,1,,<p>Using a js object in a template string directly resolves to <code>[object Object]</code> i.e. <code>${filter}</code> resolves to precisely <code>[object Object]</code> hence the error.</p>&#xA;<p>To solve it you can use <code>JSON.stringify(filter)</code>. Here is the string in the same format as before but with the fix:</p>&#xA;<pre><code>`query { &#xA;    companies(filter: ${JSON.stringify(filter)}) {&#xA;        list {&#xA;            name&#xA;        }&#xA;    }&#xA;}`&#xA;</code></pre>&#xA;,13256628,,,,2022-04-26 08:00:39,"",,0,3,0,2022-04-26 08:00:39
72010517,1,,,0,40,"<p>The Query is to find all leads filtered by the userid which is stored in loadedby [String]</p>&#xA;<pre><code>query LeadMany($filter: FilterFindManyLeadInput) {&#xA;  leadMany(filter: $filter) {&#xA;    name&#xA;    loadedby&#xA;}&#xA;}&#xA;</code></pre>&#xA;<p>The Filter variables</p>&#xA;<pre><code>{&#xA;  &quot;filter&quot;: {&#xA;    &quot;loadedby&quot;: [&quot;123&quot;]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Which returns the data correctly</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;leadMany&quot;: [&#xA;      {&#xA;        &quot;name&quot;: &quot;A&quot;,&#xA;        &quot;loadedby&quot;: [&#xA;          &quot;123&quot;,&#xA;          &quot;789&quot;&#xA;        ],&#xA;</code></pre>&#xA;<p>But when I want to sort it by the second index in the loadedby array it doesn't return. So the filter is only checking with the first index</p>&#xA;<pre><code>{&#xA;  &quot;filter&quot;: {&#xA;    &quot;loadedby&quot;: [&quot;789&quot;]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;leadMany&quot;: []&#xA;}}&#xA;</code></pre>&#xA;<p>Using Graphql Compose with Mongoose plugin for schema definition.</p>&#xA;",18949922,,,,2022-04-26 08:12:54,GraphQL filter only checks with first index during query,<javascript><graphql><apollo-server><graphql-compose>,0,0,0,2022-04-26 08:12:54
72011183,1,,,1,363,"<p>I am trying to implement Relay-Style pagination on a postgres. I have gone through the relay specification, and it recommends having a globally unique cursor for each entity. The specification for pagination is that the client provides <code>first</code> and <code>after</code> for Forward pagination and <code>last</code> and <code>before</code> for Backward pagination.</p>&#xA;<p>Assume I have a table called Products, with an auto incrementing primary key integer ID. In the most basic case, pagination is very straight forward. For forward pagination it would be something like <code>SELECT * FROM products WHERE id &gt; cursor LIMIT 10</code> for forward pagination, and <code>SELECT * FROM products WHERE id &lt; cursor ORDER BY id DESC LIMIT 10</code></p>&#xA;<p>The problem arises when we have additional sorting requirements. Let us say, our product table has a name field on which we want to sort.</p>&#xA;<pre><code>Name    Id (cursor field)&#xA;Trendy  1&#xA;Autumn  2&#xA;Winter  3&#xA;Crazy   4&#xA;Antman  5&#xA;Marvel  6&#xA;</code></pre>&#xA;<p>And we want to paginate, with page size of 3, sorted on name ASC. The query would be:</p>&#xA;<p><code>SELECT * FROM products ORDER BY name ASC LIMIT 3</code>, And we would get the following output:</p>&#xA;<p><code>(Antman, 5), (Autumn 1), (Crazy 4)</code></p>&#xA;<p>But now, how will I get the next three? This query <code>SELECT * FROM products WHERE id &gt;= 4 ORDER BY name ASC LIMIT 3;</code> would not work, as Trendy has ID &lt; 1. Do I create a different cursor for Name and use that for paginating with Name? Okay, what if we wanted to sort on multiple fields together (let us say we have a price field, we want to sort from decreasing to increasing price, and then sort based on created time, and then on name. The price might not be unique and any other additional constraints), how would I create a cursor then?</p>&#xA;<p>What is the standard approach to solve this problem? I have tried to research as much as I can but I couldn't find any information on how to accomplish this in fastapi and sqlalchemy. Django has FilterableConnectionField, but I couldn't understand the implementation. Any help is very appreciated, thank you.</p>&#xA;<p>edit: I figured out how to do this. It is called queryset pagination, and sqlakeyset repo on github had a good implementation of this pattern. <a href=""https://github.com/djrobstep/sqlakeyset"" rel=""nofollow noreferrer"">https://github.com/djrobstep/sqlakeyset</a></p>&#xA;",6139011,,6139011,2022-04-27 10:50:22,2022-04-27 10:50:22,How to implement GraphQL Relay style cursor based pagination in postgres (with sqlalchemy and fastAPI),<postgresql><graphql><pagination><fastapi><relay>,0,0,0,2022-04-26 09:02:44
72011696,1,,,0,49,"<p>I have a query (based on JSON input) defined in Gatsbys GraphiQL IDE which looks this trying to return only those items which have a value of less than 10 in <em>playtime_forever</em>:</p>&#xA;<pre><code>  allContentJson(&#xA;    filter: {response: {games: {elemMatch: {playtime_forever: {lt: 10}}}}}&#xA;  ) {&#xA;    edges {&#xA;      node {&#xA;        response {&#xA;          games {&#xA;            playtime_forever&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>However running this query I also receive those which are greater than 10:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;allContentJson&quot;: {&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;response&quot;: {&#xA;              &quot;games&quot;: [&#xA;                {&#xA;                  &quot;playtime_forever&quot;: 0&#xA;                },&#xA;                {&#xA;                  &quot;playtime_forever&quot;: 93&#xA;                },&#xA;                {&#xA;                  &quot;playtime_forever&quot;: 5302&#xA;                }&#xA;              ]&#xA;            },&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  },&#xA;  &quot;extensions&quot;: {}&#xA;}&#xA;</code></pre>&#xA;<p>I have this feeling this is how <em>elemMatch</em> is supposed to work or is there any other approach (possibly by defining types?)</p>&#xA;",2558811,,,,2022-04-26 09:39:01,Gatsby graphql filter statement is not working as expected,<json><graphql><gatsby><graphiql>,0,0,0,2022-04-26 09:39:01
72012927,2,,72012723,0,,"<p><code>site</code> filters will find any site node that matches the filters. It isn't intended to filter the subfields of the node like you are trying to.</p>&#xA;<p>That said, you can filter your GraphQL <code>siteMetadata</code> results using JavaScript:</p>&#xA;<pre><code>const pages = data.site.siteMetadata.pages;&#xA;&#xA;pages.filter(pageItem =&gt; /* whatever filter you need */);&#xA;</code></pre>&#xA;<p>More details: <a href=""https://github.com/gatsbyjs/gatsby/issues/13989"" rel=""nofollow noreferrer"">https://github.com/gatsbyjs/gatsby/issues/13989</a></p>&#xA;<p>You can add this &quot;feature&quot; on your <a href=""https://github.com/gatsbyjs/gatsby/issues/10990#issuecomment-475720442"" rel=""nofollow noreferrer"">own using schema customization</a> APIs.</p>&#xA;",5585371,,5585371,2022-04-26 15:51:28,2022-04-26 15:51:28,"",,0,3,0,2022-04-26 11:11:53
72017648,1,,,0,73,"<p>I have an Enum like so:</p>&#xA;<pre><code>public Enum Status {&#xA;  Draft,&#xA;  Submitted,&#xA;  Accepted&#xA;}&#xA;</code></pre>&#xA;<p>Currently, when I sort by Status, it will come back in the order of the Enum, asc/desc. I'd like it to be able to be sorted alphabetically without having to reorder the Enum.</p>&#xA;<p>I've seen on the Hot Chocolate documentation that it allows for custom sorting configurations, but would like some help in how that actually works.</p>&#xA;",18955330,,,,2022-04-26 16:44:40,Sorting Enum values alphabetically with Hot Chocolate,<javascript><sorting><graphql><hotchocolate>,0,0,0,2022-04-26 16:44:40
72018353,2,,71833187,0,,"<p>I made it work</p>&#xA;<pre><code> if first_query:&#xA;        payload = &quot;{\&quot;query\&quot;:\&quot;{ allCards (pipeId:%d, first:50){edges{node{id title phases_history {phase{name}}fields {report_value   name updated_at}} cursor} pageInfo {endCursor hasNextPage}}}\&quot;}&quot; % (&#xA;            pipe_id)&#xA;        first_query = False&#xA;    else:&#xA;        payload = '{&quot;query&quot;: &quot;{allCards(pipeId: %d,after: \\&quot;%s\\&quot;){edges{node{id title phases_history {phase{name}} fields{report_value name updated_at}}}pageInfo{endCursor hasNextPage}}}&quot;}' % (&#xA;            pipe_id, end_cursor)&#xA;</code></pre>&#xA;",18775336,,,,2022-04-26 17:47:00,"",,0,1,0,2022-04-26 17:47:00
72043035,1,,,0,71,<p>I am exploring the Shopify StoreFront API . Could Somebody explain the difference between the filter and query options</p>&#xA;,3766933,,,,2022-04-28 11:40:37,Filters Vs Query in Shopify Storefront API,<graphql><shopify><shopify-app>,0,0,0,2022-04-28 11:40:37
72078458,2,,46513476,3,,"<p>It's usually a simple mistake. Caused by declaring in the schema a <strong><code>List</code></strong> instead of a <strong><code>Field</code></strong>. The reverse will happen if you interchange. An example from <code>Django-graphene</code>. Switch from this:</p>&#xA;<pre><code>my_query_name = graphene.List(MyModelType, id=graphene.Int())&#xA;</code></pre>&#xA;<p>to this:</p>&#xA;<pre><code>my_query_name = graphene.Field(MyModelType, id=graphene.Int())&#xA;</code></pre>&#xA;",1877184,,,,2022-05-01 16:18:01,"",,0,0,0,2022-05-01 16:18:01
72081641,1,,,1,715,"<p>I am very new to AWS Amplify's GraphQL, and am struggling to get the correct data returned to me when I execute the GraphQL query I created.</p>&#xA;<p>Starting at the top, I have 3 tables or models: UserTB, UserRoleTB, and RoleTB.</p>&#xA;<ul>&#xA;<li>UserTB holds a list of all created users. One to many relationship with UserRoleTB</li>&#xA;<li>UserRoleTB holds a list of all Users and their assigned Roles</li>&#xA;<li>RoleTB holds a list of all roles. One to Many relationship with UserRoleTB</li>&#xA;</ul>&#xA;<p>GraphQL Schemas:</p>&#xA;<pre><code>type UserRoleTB @model @auth(rules: [{allow: public}]) {&#xA;  id: ID!&#xA;  roletbID: ID! @index(name: &quot;byRoleTB&quot;)&#xA;  usertbID: ID! @index(name: &quot;byUserTB&quot;)&#xA;}&#xA;&#xA;type RoleTB @model @auth(rules: [{allow: public}]) {&#xA;  id: ID!&#xA;  roleName: String&#xA;  roleDescription: String&#xA;  UserRoleTBS: [UserRoleTB] @hasMany(indexName: &quot;byRoleTB&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type UserTB @model @auth(rules: [{allow: public}]) {&#xA;  id: ID!&#xA;  username: String&#xA;  name: String&#xA;  email: String&#xA;  password: String&#xA;  lastLogin: String&#xA;  UserRoleTBS: [UserRoleTB] @hasMany(indexName: &quot;byUserTB&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>I created two queries that will return all data from the UserRoleTB and the UserTB.</p>&#xA;<p>Queries:</p>&#xA;<pre><code>export const listUserTBS = /* GraphQL */ `&#xA;  query ListUserTBS(&#xA;    $filter: ModelUserTBFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listUserTBS(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        username&#xA;        name&#xA;        email&#xA;        password&#xA;        lastLogin&#xA;        createdAt&#xA;        updatedAt&#xA;        _version&#xA;        _deleted&#xA;        _lastChangedAt&#xA;      }&#xA;      nextToken&#xA;      startedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listUserRoleTBS = /* GraphQL */ `&#xA;  query ListUserRoleTBS(&#xA;    $filter: ModelUserRoleTBFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listUserRoleTBS(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        roletbID&#xA;        createdAt&#xA;        updatedAt&#xA;        _version&#xA;        _deleted&#xA;        _lastChangedAt&#xA;      }&#xA;      nextToken&#xA;      startedAt&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I need to apply a filter to these where if users have a specific role assigned to them, it returns that user. For example, I will run the listUserRoleTBS query and apply a filter that does just that:</p>&#xA;<pre><code>query Example {&#xA;  listUserRoleTBS(filter: {roletbID: {eq: &quot;0f16af1f-007d-4a46-b6c1-799539ac1a0f&quot;}}) {&#xA;    items {&#xA;      usertbID&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>which returns the following:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;listUserRoleTBS&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;usertbID&quot;: &quot;b0e294de-32cb-4fa4-8ca8-c42cb191d26f&quot;&#xA;        },&#xA;        {&#xA;          &quot;usertbID&quot;: &quot;22bda12a-8399-458d-9b15-0e83864125b5&quot;&#xA;        },&#xA;        {&#xA;          &quot;usertbID&quot;: &quot;89f9c1c4-fa5a-44da-b245-e5add7abd436&quot;&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>In addition to the displaying the usertbID, I also need to display the name field from the UserTB table. However, it doesn't seem possible since it does not belong to the UserRoleTB table. It appears I may only be able to use the PK of the UserTB table (usertbID) as an option for response. Having the name field in the response is important because that field will be used to populate a drop-down list on a front-end GUI</p>&#xA;<p><strong>Is there any way I can add the name field from UserTB to this query? If not, what are my options?</strong></p>&#xA;<p>Additionally, I tried a different approach where I run the listUserTBS query with the following filter:</p>&#xA;<pre><code>query Example {&#xA;  listUserTBS {&#xA;    items {&#xA;      name&#xA;      UserRoleTBS(filter: {roletbID: {eq: &quot;0f16af1f-007d-4a46-b6c1-799539ac1a0f&quot;}}) {&#xA;        items {&#xA;          roletbID&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>and it provided the following result:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;listUserTBS&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;name&quot;: &quot;Joe&quot;,&#xA;          &quot;UserRoleTBS&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;roletbID&quot;: &quot;0f16af1f-007d-4a46-b6c1-799539ac1a0f&quot;&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;brandon&quot;,&#xA;          &quot;UserRoleTBS&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;roletbID&quot;: &quot;0f16af1f-007d-4a46-b6c1-799539ac1a0f&quot;&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;glen&quot;,&#xA;          &quot;UserRoleTBS&quot;: {&#xA;            &quot;items&quot;: [&#xA;              {&#xA;                &quot;roletbID&quot;: &quot;0f16af1f-007d-4a46-b6c1-799539ac1a0f&quot;&#xA;              }&#xA;            ]&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;dave&quot;,&#xA;          &quot;UserRoleTBS&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;stewart&quot;,&#xA;          &quot;UserRoleTBS&quot;: {&#xA;            &quot;items&quot;: []&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>As you can see, it will give me every user within the system, and if a user has the specified role, it will display the role. However, the downside is it will fetch literally ever user even if they don't have the role. I don't need every user, just a subset.</p>&#xA;",19011203,,16995190,2022-05-03 01:38:44,2022-05-03 01:38:44,How to filter an AWS Amplify GraphQL query to pull data and fields from two tables?,<json><api><graphql><amazon-dynamodb><aws-amplify>,0,0,0,2022-05-02 01:45:47
72084239,1,72093836,,0,36,"<p>For example, When there are a lot of data like this:</p>&#xA;<pre><code>[&#xA;  {title:&quot;string&quot; , data:&quot;2022-05-01&quot;, amount:10},&#xA;  {title:&quot;string&quot; , data:&quot;2022-04-01&quot;, amount:10},&#xA;  {title:&quot;string&quot; , data:&quot;2022-03-03&quot;, amount:10},&#xA;  {title:&quot;string&quot; , data:&quot;2022-04-01&quot;, amount:10}&#xA;]&#xA;</code></pre>&#xA;<p>Is there a way to efficiently divide and manage the data every month?&#xA;I want to make a monthly list using a filter and manage it.&#xA;(sorry for my bad English)</p>&#xA;",18576560,,9676887,2022-05-02 13:26:32,2022-05-03 00:57:55,"Using graph QL and React, how can I divide API by month?",<reactjs><graphql><apollo>,1,6,0,2022-05-02 08:39:34
72091134,2,,71958705,1,,"<p>I'm not sure if this is recommended, so I appreciate feedback, but I found the following way to list all selected nodes:</p>&#xA;<ol>&#xA;<li>Inject <code>IResolverContext context</code> (using HotChocolate.Resolvers) as one of the parameters in the query.</li>&#xA;<li><code>context.Selection.SyntaxNode.SelectionSet.Selections</code> gives an <code>IEnumerable&lt;ISelectionNode&gt;</code>. That contains exactly the fields the user has selected.</li>&#xA;</ol>&#xA;",1367392,,,,2022-05-02 18:55:40,"",,0,0,0,2022-05-02 18:55:40
72093836,2,,72084239,0,,"<p>I give you an example for your reference:</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>let data = [{&#xA;    title: ""string"",&#xA;    data: ""2022-05-01"",&#xA;    amount: 10&#xA;  },&#xA;  {&#xA;    title: ""string"",&#xA;    data: ""2022-04-01"",&#xA;    amount: 10&#xA;  },&#xA;  {&#xA;    title: ""string"",&#xA;    data: ""2022-03-03"",&#xA;    amount: 10&#xA;  },&#xA;  {&#xA;    title: ""string"",&#xA;    data: ""2022-04-01"",&#xA;    amount: 10&#xA;  }&#xA;];&#xA;let monthly;&#xA;for (let i = 0; i &lt; 12; i++) {&#xA;  monthly=(data.filter(gg =&gt; {&#xA;    let d = new Date(gg.data);&#xA;    return (d.getMonth() == i)&#xA;  }));&#xA;  if (monthly.length&gt;0){&#xA;    console.log(monthly);&#xA;  }&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",2018278,,,,2022-05-03 00:57:55,"",,0,0,0,2022-05-03 00:57:55
72113903,1,,,0,69,"<p>I'm using the <a href=""https://gitlab.com/-/graphql-explorer"" rel=""nofollow noreferrer"">graphql explorer</a> for gitlab and I'm trying to get timelog entries for a given user (as below).</p>&#xA;<p>The response gives me a <code>projectId</code> which I assume I'd have to use in a subsequent query (I don't believe I can get it in the same query?), but the <code>project</code> object doesn't let me find the project by ID, only fullpath.</p>&#xA;<p>Am I correct in understanding that I would need to use the <code>projects</code> query and provide the id there?  In trying that (query below), I just get the error <code>12345678 is not a valid GitLab ID.</code> (obviously I'm using a real ID given previously).</p>&#xA;<p>So, two points/questions I guess:</p>&#xA;<ul>&#xA;<li>The timelog entry provides a projectId which I can't use in either the project or projects query to get the project name?</li>&#xA;<li>I can't just return the project name directly in the same query as the original user timelog one?</li>&#xA;</ul>&#xA;<p>Any thoughts greatly appreciated.</p>&#xA;<pre><code>{&#xA;  users(usernames: [&quot;user1&quot;]) {&#xA;    nodes {&#xA;      id&#xA;      username&#xA;      timelogs(startDate: &quot;2022-05-03T09:00:00&quot;) {&#xA;        nodes {&#xA;          issue {&#xA;            projectId&#xA;          }&#xA;          timeSpent&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre><code>{&#xA;  projects(ids:[12345678]) {&#xA;    nodes {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",695170,,,,2022-05-05 16:28:06,How can I get the project name for a timelog issue entry using the project ID from a Gitlab GraphQL query,<graphql><gitlab>,1,1,0,2022-05-04 13:36:50
72122113,2,,72114065,0,,<p>It was an issue that came out because the resolver file name was wrong.</p>&#xA;,18576560,,,,2022-05-05 04:58:36,"",,0,0,0,2022-05-05 04:58:36
72130608,2,,72113903,0,,"<p>I don't know if this helps, but I use:</p>&#xA;<pre><code>{&#xA;  group(fullPath: &quot;groupname&quot;) {&#xA;    name&#xA;    timelogs(startTime: &quot;2022-04-01&quot;, endTime: &quot;2022-04-30&quot;, username: &quot;roberto&quot;) {&#xA;      pageInfo {&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;      nodes {&#xA;        &#xA;        user {&#xA;          username&#xA;        }&#xA;        issue {&#xA;          iid&#xA;          webUrl&#xA;          state&#xA;          projectId&#xA;          title&#xA;        }&#xA;        spentAt&#xA;        timeSpent&#xA;        summary&#xA;        note {&#xA;          body&#xA;          url&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",19045145,,,,2022-05-05 16:28:06,"",,0,1,0,2022-05-05 16:28:06
72145078,2,,72144770,2,,<p>You can expand a fragment in a fragment definition to do this:</p>&#xA;<pre><code>fragment ParagraphText on paragraph__text {&#xA;  field_title&#xA;  field_body&#xA;  field_subtitle&#xA;  field_image&#xA;}&#xA;&#xA;fragment ParagraphTextWithButton on paragraph__text {&#xA;  ...ParagraphText&#xA;  field_button&#xA;}&#xA;</code></pre>&#xA;,203130,,,,2022-05-06 17:01:26,"",,0,0,0,2022-05-06 17:01:26
72150795,2,,72150011,1,,"<p>It's the default configuration when you're retrieving items, you need to have pagination implemented for more than 10 items as mentioned <a href=""https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/graphql-api.html#pagination-by-page"" rel=""nofollow noreferrer""><strong><code>here</code></strong></a>,</p>&#xA;<pre><code>documents(pagination: { start: 20, limit: 30 }) {&#xA;</code></pre>&#xA;",1749403,,,,2022-05-07 08:29:15,"",,0,0,0,2022-05-07 08:29:15
72163790,2,,65420524,0,,"<pre><code>clients(&#xA;  where: {&#xA;    and: [{ name: { contains: &quot;a&quot; } }, { endDate: { gte: &quot;2017-12-31&quot; } }]&#xA;  }&#xA;) {&#xA;    id&#xA;    name&#xA;    endDate&#xA;    reasonForEnding&#xA;  }&#xA;</code></pre>&#xA;<p>This is the answer</p>&#xA;",11507996,,10196369,2022-05-09 08:47:19,2022-05-09 08:47:19,"",,0,0,0,2022-05-08 17:57:42
72165797,2,,72165224,0,,"<p>The problem was that 'vars' was of type String, created that way in setVars()</p>&#xA;<p>Making an object fixed it. Like so:</p>&#xA;<pre><code>setVars({&#xA;                    customerId: parseInt(row.original.customerId, 10),&#xA;                    [column.id]: e.target.value&#xA;                })&#xA;</code></pre>&#xA;<p>I knew it had to be something simple. Leaving this post up in case it helps others.</p>&#xA;<p>Thank you for your time and attention.</p>&#xA;",16824901,,,,2022-05-08 23:41:23,"",,0,0,0,2022-05-08 23:41:23
72187536,2,,72175270,1,,"<p>You can use the allUsers insted of the UserById, and provide the list as a filter.</p>&#xA;<pre><code>query MyQuery {&#xA;  allUsers(filter: {id: {in: &quot;&quot;}}) {&#xA;    nodes {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>}</p>&#xA;",13237963,,,,2022-05-10 13:47:05,"",,0,1,0,2022-05-10 13:47:05
72197483,1,,,0,605,"<p>I am using Strapi headless CMS and I have a collection type called <code>Teacher Profiles</code>. And I am adding an extra field in the query response that I calculate on the fly. This field doesn't exist in the original content type. I am adding this using extension in file <code>.src/index.js</code>.</p>&#xA;<p>The field is being added successfully and I am able to receive it in the response.</p>&#xA;<p>But the problem is that I can't filter records based on this field.</p>&#xA;<p><code>./src/index.js</code></p>&#xA;<pre><code>&quot;use strict&quot;;&#xA;&#xA;const { NotFoundError } = require(&quot;@strapi/utils&quot;).errors;&#xA;&#xA;module.exports = {&#xA;  register: ({ strapi }) =&gt; {&#xA;    const { transformArgs, getContentTypeArgs } = strapi&#xA;      .plugin(&quot;graphql&quot;)&#xA;      .service(&quot;builders&quot;).utils;&#xA;    const extensionService = strapi.plugin(&quot;graphql&quot;).service(&quot;extension&quot;);&#xA;&#xA;    const extension = ({ nexus }) =&gt; ({&#xA;      types: [&#xA;        nexus.extendType({&#xA;          type: &quot;TeacherProfile&quot;,&#xA;          definition(t) {&#xA;            t.int(&quot;minimum_hourly_rate&quot;);&#xA;          },&#xA;        }),&#xA;        nexus.extendInputType({&#xA;          type: &quot;TeacherProfileFiltersInput&quot;,&#xA;          definition(t) {&#xA;            t.field(&quot;minimum_hourly_rate&quot;, {&#xA;              type: &quot;IntFilterInput&quot;,&#xA;            });&#xA;          },&#xA;        }),&#xA;        nexus.extendType({&#xA;          type: &quot;Query&quot;,&#xA;          definition(t) {&#xA;            t.field(&quot;teacherProfiles&quot;, {&#xA;              type: &quot;TeacherProfileEntityResponseCollection&quot;,&#xA;              args: getContentTypeArgs(&#xA;                strapi.contentTypes[&quot;api::teacher-profile.teacher-profile&quot;]&#xA;              ),&#xA;              async resolve(parent, args, ctx) {&#xA;                const transformedArgs = transformArgs(args, {&#xA;                  contentType:&#xA;                    strapi.contentTypes[&quot;api::teacher-profile.teacher-profile&quot;],&#xA;                  usePagination: true,&#xA;                });&#xA;&#xA;                const teacherProfiles = await strapi.entityService.findMany(&#xA;                  &quot;api::teacher-profile.teacher-profile&quot;,&#xA;                  transformedArgs&#xA;                );&#xA;&#xA;                const { toEntityResponseCollection } = strapi&#xA;                  .plugin(&quot;graphql&quot;)&#xA;                  .service(&quot;format&quot;).returnTypes;&#xA;&#xA;                const transformedTeacherProfiles = teacherProfiles.map(&#xA;                  (teacherProfile) =&gt; {&#xA;                    return {&#xA;                      ...teacherProfile,&#xA;                      minimum_hourly_rate:&#xA;                        Math.floor(Math.random() * (40 - 30 + 1)) + 30,&#xA;                      // Math.random won't be actually used - it is just to demonstrate that I'll do some calculation here and&#xA;                      // value can vary&#xA;                    };&#xA;                  }&#xA;                );&#xA;&#xA;                if (transformedTeacherProfiles) {&#xA;                  return toEntityResponseCollection(&#xA;                    transformedTeacherProfiles,&#xA;                    {&#xA;                      args: transformedArgs,&#xA;                      resourceUID: &quot;api::teacher-profile.teacher-profile&quot;,&#xA;                    }&#xA;                  );&#xA;                } else {&#xA;                  throw NotFoundError();&#xA;                }&#xA;              },&#xA;            });&#xA;          },&#xA;        }),&#xA;      ],&#xA;    });&#xA;&#xA;    extensionService.use(extension);&#xA;  },&#xA;};&#xA;</code></pre>&#xA;<p>When I send these filters with the query:</p>&#xA;<pre><code>{&#xA;  &quot;filters&quot;: { &quot;minimum_hourly_rate&quot;: { &quot;lte&quot;: 30}},&#xA;  &quot;pagination&quot;: { &quot;limit&quot;: 2}&#xA;}&#xA;</code></pre>&#xA;<p>And console log <code>args</code>, it gives:</p>&#xA;<pre><code>{&#xA;  filters: { minimum_hourly_rate: { lte: 30 } },&#xA;  pagination: { limit: 2 },&#xA;  sort: []&#xA;}&#xA;</code></pre>&#xA;<p>This is correct. But when I console log the <code>transformedArgs</code>, it gives:</p>&#xA;<pre><code>{ sort: [], start: 0, limit: 2, filters: {} }&#xA;</code></pre>&#xA;<p>When there is a field in the <code>filters</code> that is not present in the content type schema, it doesn't get transformed. Which is probably correct, as transform function compares given args to the content type schema.</p>&#xA;<p>If I mutate the <code>transformedArgs</code>, and manually add the <code>minimum_hourly_rate</code> value in it, then I give it to:</p>&#xA;<pre><code>strapi.entityService.findMany(&#xA;    &quot;api::teacher-profile.teacher-profile&quot;, mutatedTransformedArgs&#xA;);&#xA;&#xA;</code></pre>&#xA;<p>This also gives an error:</p>&#xA;<pre><code>Error: ER_BAD_FIELD_ERROR: Unknown column 't0.minimum_hourly_rate' in 'where clause'&#xA;</code></pre>&#xA;<p>Which is also correct as strapi entityService doesn't know about this field <code>minimum_hourly_rate</code>. (it doesn't exist on the original schema).</p>&#xA;<p>So, my question is basically how do I filter records based on this filter? For example, I want to retrieve 15 records where  minimum_hourly_rate &lt; 30</p>&#xA;",6618719,,,,2022-05-11 08:04:56,How do I make additional filter work on Strapi GraphQL query resolver extension,<node.js><graphql><strapi><headless-cms><nuxt-strapi>,0,0,0,2022-05-11 08:04:56
72201837,1,,,0,106,"<p>I'm not very familiar with graphql filtering and I will try to explain what I'm aiming to do. Here is the schema that I have:</p>&#xA;<pre><code>type Trial {&#xA;  id: ID!&#xA;  facilites(filter: {country: ['NZ']}): {&#xA;    country: String,&#xA;    prop1: String,&#xA;    prop2: String&#xA;  }  &#xA;}&#xA;&#xA;type Query {&#xA;  trials(filter: {country: ['AU', 'DN']}): [Trial]&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>The aim is to initially filter by countries provided in the&#xA;<code>trials(filter: {country: ['AU', 'DN']})</code>. I will do that with the e.g. leftJoin to combine it with facilites. As country is however a field of facilites I'm not sure this is a way to go.</p>&#xA;<p>A separate resolver will be written to support countries from the facilites filter. But this is considered to be optional for now.</p>&#xA;",7926415,,,,2022-05-11 13:22:19,Filter parent list based on a child field,<graphql><apollo>,0,0,0,2022-05-11 13:22:19
72202459,2,,72024820,0,,"<p>So after connecting on the <a href=""https://github.com/spring-projects/spring-graphql/issues/369"" rel=""nofollow noreferrer"">https://github.com/spring-projects/spring-graphql/issues/369</a></p>&#xA;<p>and adding <code>graphQlClient.stop().subscribe();</code> can resolve the problem.</p>&#xA;",3211830,,,,2022-05-11 14:02:44,"",,0,1,0,2022-05-11 14:02:44
72207621,2,,72200444,0,,"<p>Depending on how important is to perform this comparison you can inspect all the elements of <code>Document</code> to determine equality.</p>&#xA;<p>If this is to optimize and return the same result for the same input I would totally recommend just compare the strings and kept two entries (one for each string input).</p>&#xA;<p>If you <strong>really</strong> want to go for the deep compare route, you can check the <code>selectionSet</code> and compare each selection.</p>&#xA;<p>Take a look at the screenshot:</p>&#xA;<p><a href=""https://i.stack.imgur.com/kuWWG.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kuWWG.jpg"" alt=""Internal state of two objects"" /></a></p>&#xA;<p>You can also give <a href=""https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/builder/EqualsBuilder.html#reflectionEquals(java.lang.Object,%20java.lang.Object)"" rel=""nofollow noreferrer"">EqualsBuilder.html.reflectionEquals(Object,Object)</a> a try but it might inspect too deep (I tried and returned false)</p>&#xA;",20654,,,,2022-05-11 21:09:31,"",,0,0,0,2022-05-11 21:09:31
72214608,1,,,0,299,"<p>I have a graphql query like the following one. As you can see, I have a variable defined <code>activityCategory</code> which is of type array of strings. That filter is populated by a multiselect dropdown on the UI which will have options like <code>All</code>, <code>category1</code>, <code>category2</code> etc. So when <code>All</code> is selected we would send empty array <code>[]</code> to the filter which will return all the categories records. Or what ever were selected by the user for eg: <code>[category1, category2]</code>, which then will return only the selected category records only.</p>&#xA;<pre><code>gql`&#xA;  query searchActivities(&#xA;    $activityCategory: [String]&#xA;  ) {&#xA;    expert {&#xA;      engagement {&#xA;        getActivities(&#xA;          searchQuery: {&#xA;            activityCategory: $activityCategory&#xA;          }&#xA;        ) {&#xA;          activities {&#xA;            activityId&#xA;            activityCategory&#xA;            createdDate&#xA;            action&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>Now, we have added one more category to the categories enum let`s say <code>category3</code> which wouldn't be part of the UI multiselect filter. Also, the behaviour should be like if the option <code>All</code> is selected, it means give all categories records except this newly added <code>category3</code>. And if user selects few categories from the dropdown it'll behave in the same way it used to, an array of user selected values would be sent in the filter and only those will be received.</p>&#xA;<p>In short, for the variable <code>activityCategory</code> from the above query, the value would be either <code>activityCategory: {ne: &quot;category3&quot;}</code> or <code>activityCategory: [&quot;category1&quot;, &quot;category2&quot;]</code>. How does the above query change in this case? What <strong>type</strong> would I define for the query variable <code>activityCategory</code> instead of <code>[String]</code>?</p>&#xA;",2531954,,,,2022-05-12 11:21:00,"graphql query filter an attribute by ""array of values"" or ""all except one value""",<javascript><typescript><graphql><apollo-client><react-apollo>,0,0,0,2022-05-12 11:21:00
72248573,1,,,1,348,"<p>I am currently stuck on a problem with my prisma queries.</p>&#xA;<p>I have an asset which has a 1 to Many relationship to views. I am trying to perform a findMany() on assets which returns either;</p>&#xA;<ol>&#xA;<li>The asset with a list of views created within the last day</li>&#xA;<li>Or the asset with a count of views created in the last day</li>&#xA;</ol>&#xA;<p><strong>Finally I need to be able to orderBy this count or the count of views in my include statement.</strong> <em>(this is what I am stuck on)</em></p>&#xA;<pre><code>return await prisma.asset.findMany({&#xA;  take: parseInt(pageSize),&#xA;  skip: (pageSize * pageNumber),&#xA;  include: {&#xA;    _count: {&#xA;      select: {&#xA;        views: true&#xA;      },&#xA;    },&#xA;    views: {&#xA;      where: {&#xA;        createdAt: dateFilter&#xA;      },&#xA;    },&#xA;    likes: {&#xA;      where: {&#xA;        createdAt: dateFilter&#xA;      }&#xA;     },&#xA;    transactions: true,&#xA;  },&#xA;  orderBy: { views: { _count: 'desc' } }&#xA;</code></pre>&#xA;<p>My queries does correctly return only views in my date range but how do I go about ordering the assets based on the count of these views. I have been stuck for quite some time on this. My raw SQL is not strong enough to write it from scratch at the moment.</p>&#xA;<p>If anyone has any ideas, thanks.</p>&#xA;",19120986,,,,2022-05-16 06:25:42,Count or Include filtered relations prisma,<prisma><prisma-graphql><prisma2><plumatic-schema>,1,0,0,2022-05-15 13:11:50
72279308,2,,72276495,0,,"<p>You can write your own graphql statement to include the meetscores info.  Assuming your GraphQL schema is correct, you can do something like this:</p>&#xA;<pre><code>async _loadGymnastMeetSessions(&#xA;    filter: ModelGymnastMeetSessionsFilterInput,&#xA;    limit: number,&#xA;    nextToken: string&#xA;  ) {&#xA;    const statement = `query MyQuery {&#xA;  listGymnastMeetSessions(filter: {meetSessionID: {eq: &quot;4aea7082-60b8-4268-a816-00661e7a6e4d&quot;}}) {&#xA;    items {&#xA;      gymnastID&#xA;      meetSessionID&#xA;      gymnast {&#xA;        firstName&#xA;        lastName&#xA;        meetScores(filter: {meetSessionId: {eq: &quot;4aea7082-60b8-4268-a816-00661e7a6e4d&quot;}}) {&#xA;          items {&#xA;            balanceBeam&#xA;            floor&#xA;            unevenBars&#xA;            floor&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}`;&#xA;    const gqlAPIServiceArguments: any = {};&#xA;    if (filter) {&#xA;      gqlAPIServiceArguments.filter = filter;&#xA;    }&#xA;    if (limit) {&#xA;      gqlAPIServiceArguments.limit = limit;&#xA;    }&#xA;    if (nextToken) {&#xA;      gqlAPIServiceArguments.nextToken = nextToken;&#xA;    }&#xA;    const response = (await API.graphql(&#xA;      graphqlOperation(statement, gqlAPIServiceArguments)&#xA;    )) as any;&#xA;    return &lt;ListGymnastMeetSessionsQuery&gt;response.data.listGymnastMeetSessions;&#xA;}&#xA;</code></pre>&#xA;<p>Instead of explicitly adding the id to the query you can use your filter param that goes into the method, and $filter in your Graphql statement.</p>&#xA;",3745425,,,,2022-05-17 18:54:10,"",,0,5,0,2022-05-17 18:54:10
72285223,1,,,0,17,"<p>PS: my GraphQL skills are pretty basic so sorry for any incorrect use of words and terms</p>&#xA;<p>I want to achieve filtering on  the <strong>code</strong> field highlighted below</p>&#xA;<p>(transactions --&gt; edges --&gt; node --&gt; header --&gt; transactionSource --&gt; code = &quot;something&quot;</p>&#xA;<pre><code>    {&#xA;  transactions(last: 10) {&#xA;    edges {&#xA;      node {&#xA;        amount&#xA;        periodId&#xA;        header {&#xA;          owner {&#xA;            owner {&#xA;              code&#xA;              description&#xA;              dbId&#xA;              ownerDbId&#xA;              ownerCode&#xA;            }&#xA;          }&#xA;          transactionSource {&#xA;            code&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The client i'm working with have defined a list of filtering options, which I can successfully filter on, but when I try to filter on the <strong>code</strong> field I get the following result:</p>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;Argument 'filter' has invalid value. In field 'code': Unknown field.&quot;,&#xA;      &quot;locations&quot;: [&#xA;        {&#xA;          &quot;line&quot;: 2,&#xA;          &quot;column&quot;: 26&#xA;        }&#xA;      ],&#xA;      &quot;extensions&quot;: {&#xA;        &quot;code&quot;: &quot;ARGUMENTS_OF_CORRECT_TYPE&quot;,&#xA;        &quot;codes&quot;: [&#xA;          &quot;ARGUMENTS_OF_CORRECT_TYPE&quot;&#xA;        ],&#xA;        &quot;number&quot;: &quot;5.6.1&quot;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;<p>I presume this is because of me not knowing exactly how to set up the filter correctly.&#xA;Is there a way to filter on any field or do I need to talk to the guys maintaining the client and ask them nicely to make the <strong>code</strong> field available for filtering?</p>&#xA;<p>Thanks</p>&#xA;",19142885,,,,2022-05-18 07:55:43,"Filter Query by any field, not just defined available filters",<graphql>,0,0,0,2022-05-18 07:55:43
72304739,1,,,0,83,"<p>I'm trying to call a graph ql query where I want to filter the values based on a variable (MeetingID) value given by the user.</p>&#xA;<pre><code>    var MeetingID&#xA;    const handleUserInputChange = (e) =&gt; {&#xA;         MeetingID = e.target.name;&#xA;    &#xA;  };&#xA;    const querysort = Object.assign({},{&#xA;            sortDirection : 'ASC' ,type : 'datamodel', MeetingID: MeetingID&#xA;          })&#xA;    &#xA;    async function fetchTrans() {&#xA;            try {&#xA;              const transData = await API.graphql(graphqlOperation(datamodel,querysort, { filter: { MeetingID: MeetingID } }));&#xA;              console.log(transData);&#xA;              //const transData = await API.graphql(graphqlOperation(datamodelByDate,variables));&#xA;              const datamodels = transData.data.datamodel.items;&#xA;              setValue(datamodels)&#xA;              //console.log(transData.data.datamodelByDate.items)&#xA;            } catch (err) { console.log('error fetching transcription:', err) }&#xA;          }&#xA;</code></pre>&#xA;<p>And this my generated query by amplify codegen</p>&#xA;<pre><code>export const datamodel = /* GraphQL */ `&#xA;  query Datamodel(&#xA;    $type: String!&#xA;    $createdAt: ModelStringKeyConditionInput&#xA;    $sortDirection: ModelSortDirection&#xA;    $filter: ModelDatamodelFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    datamodel(&#xA;      type: $type&#xA;      createdAt: $createdAt&#xA;      sortDirection: $sortDirection&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        MeetingID&#xA;        Transcription&#xA;        createdAt&#xA;        type&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I'm getting all the transcriptions even though I have applied the query.</p>&#xA;",8112228,,,,2022-05-24 03:11:12,Filter queries from Graph QL based on a filter,<javascript><reactjs><amazon-web-services><graphql><aws-amplify>,1,2,0,2022-05-19 12:40:03
72305349,1,,,0,43,"<p><strong>Problem</strong></p>&#xA;<p>I am implementing cursor-based pagination in graphql in AWS appsync schema. I want to restrict the type depending on query. For example, <em>getBuildingsBySite</em> should not allow any type other than Building. Currently, it allows all types in the Union. How can this be achieved?</p>&#xA;<pre><code>    type Site {&#xA;      siteName: String&#xA;      address: String&#xA;      siteId: String!&#xA;      sitePicture: String&#xA;      siteImgUrl: String&#xA;    }&#xA;&#xA;    type Floor {&#xA;      floorName: String&#xA;      accessPointsCount: Int&#xA;      unitsCount: Int&#xA;      wingName: String&#xA;      floorId: String!&#xA;    }&#xA;&#xA;    type Building {&#xA;      buildingId: String!&#xA;      buildingName: String&#xA;      buildingAddress: String&#xA;      buildingImgUrl: String&#xA;      buildingImg: String&#xA;    }&#xA;&#xA;    type PageInfo {&#xA;      hasNextPage: Boolean&#xA;      endCursor: Boolean&#xA;    }&#xA;&#xA;    type Collection {&#xA;      edges: Edge&#xA;      pageInfo: PageInfo&#xA;    }&#xA;&#xA;    type Edge {&#xA;      node: [Node]&#xA;      cursor: String&#xA;    }&#xA;&#xA;    union Node = Site | Building | Floor&#xA;&#xA;    type Query {&#xA;        getSites(first: Int, cursor: String): Collection&#xA;        getBuildingsBySite(first: Int, cursor: String, siteId: String!): Collection&#xA;        getFloorsByBuilding(first: Int, cursor: String, siteId: String!, buildingId: String!): Collection&#xA;    }&#xA;</code></pre>&#xA;<p>Query</p>&#xA;<pre><code> {&#xA;      getBuildingsBySite(first: 10, cursor: &quot;xyz&quot;, siteId: &quot;S1&quot;) {&#xA;        edges {&#xA;          node {&#xA;            ... on Site {&#xA;              siteName&#xA;              address&#xA;              address&#xA;            }&#xA;&#xA;            ... on Building {&#xA;              buildingId&#xA;              buildingName&#xA;            }&#xA;&#xA;            ... on Floor {&#xA;              floorId&#xA;              floorName&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>If any better approach exists in AWS Appsync for pagination, please suggest it. Thanks</p>&#xA;",7808346,,7808346,2022-05-20 09:46:03,2022-05-20 09:46:03,How to restrict one type out of multiple types in graphql query?,<javascript><graphql><pagination><aws-appsync><unions>,0,0,0,2022-05-19 13:21:47
72315964,2,,72008321,0,,<p>If the  <code>[UseSorting]</code> annotation comes from <code>HotChocolate.Types</code> it's the old way of filtering (uses a different syntax). Then it should be <code>order_by</code> in your query.</p>&#xA;<p>Try <code>[HotChocolate.Data.UseSorting]</code> to match your query.</p>&#xA;,3181023,,6632744,2022-10-27 02:11:05,2022-10-27 02:11:05,"",,0,0,0,2022-05-20 08:40:35
72317787,1,72696923,,1,134,"<p>I have two tables that contain order data and product data in those orders.</p>&#xA;<p>I would like to return the data from the products table in alphabetical order.</p>&#xA;<p><strong>schema</strong></p>&#xA;<pre class=""lang-py prettyprint-override""><code># region Purchase Orders&#xA;class PurchasesProducts(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;&#xA;&#xA;class Purchases(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders&#xA;        interfaces = (relay.Node,)&#xA;        filter_fields = {}&#xA;        connection_class = ArtsyConnection&#xA;&#xA;&#xA;class PurchasesQuery(ObjectType):&#xA;    purchases = ArtsyConnectionField(Purchases)&#xA;&#xA;    @staticmethod&#xA;    def resolve_purchases(self, info, **kwargs):&#xA;        return purchase_orders.objects.filter(user_id=info.context.user.id).all().order_by(&quot;-date&quot;)&#xA;&#xA;&#xA;purchasesSchema = graphene.Schema(query=PurchasesQuery)&#xA;# endregion&#xA;</code></pre>&#xA;<p>The purchase order data that is returned is sorted correctly by date descending. However the data that is returned for the products in a order is not sorted by anything. I would like to sort the products by name alphabetically.</p>&#xA;<p><strong>response</strong></p>&#xA;<pre class=""lang-json prettyprint-override""><code>      ...&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;&quot;,&#xA;            &quot;cmOrderId&quot;: &quot;&quot;,&#xA;            &quot;username&quot;: &quot;&quot;,&#xA;            &quot;date&quot;: &quot;2022-04-28T20:16:05&quot;,&#xA;            &quot;articles&quot;: 10,&#xA;            &quot;merchandiseValue&quot;: &quot;&quot;,&#xA;            &quot;shippingValue&quot;: &quot;&quot;,&#xA;            &quot;trusteeValue&quot;: &quot;&quot;,&#xA;            &quot;totalValue&quot;: &quot;&quot;,&#xA;            &quot;PurchaseOrdersProductsOrderId&quot;: [&#xA;              {&#xA;                &quot;id&quot;: &quot;&quot;,&#xA;                &quot;productId&quot;: &quot;&quot;,&#xA;                &quot;productName&quot;: &quot;Yasharn, Implacable Earth&quot;,&#xA;                &quot;productNumber&quot;: &quot;148&quot;,&#xA;                &quot;quantity&quot;: 1,&#xA;                &quot;foil&quot;: false,&#xA;                &quot;condition&quot;: &quot;NM&quot;,&#xA;                &quot;language&quot;: &quot;ENG&quot;,&#xA;                &quot;cost&quot;: &quot;&quot;,&#xA;                &quot;status&quot;: &quot;INCOMING&quot;&#xA;              },&#xA;              {&#xA;                &quot;id&quot;: &quot;&quot;,&#xA;                &quot;productId&quot;: &quot;&quot;,&#xA;                &quot;productName&quot;: &quot;Magmatic Channeler&quot;,&#xA;                &quot;productNumber&quot;: &quot;240&quot;,&#xA;                &quot;quantity&quot;: 3,&#xA;                &quot;foil&quot;: false,&#xA;                &quot;condition&quot;: &quot;NM&quot;,&#xA;                &quot;language&quot;: &quot;ENG&quot;,&#xA;                &quot;cost&quot;: &quot;&quot;,&#xA;                &quot;status&quot;: &quot;INCOMING&quot;&#xA;              },&#xA;              ...&#xA;</code></pre>&#xA;",5429320,,178800,2022-05-27 03:35:58,2022-06-21 07:37:57,"Django Graphene, sort data returned in nested response",<python><django><graphql><graphene-python>,1,0,0,2022-05-20 10:57:33
72324031,2,,72321094,0,,"<p>For anyone interested, the solution was simple.&#xA;I had to modify the comment type in schema to:</p>&#xA;<pre><code>type Comment @aws_cognito_user_pool {        &#xA;    id: ID!&#xA;    sourceId: ID!&#xA;    body: String &#xA;    parent: String &#xA;    createdAt: String  &#xA;}   &#xA;&#xA;input CommentInput {        &#xA;    body: String &#xA;    parent: String &#xA;    createdAt: String  &#xA;} &#xA;</code></pre>&#xA;<p>then add the mutations and resolvers for create, update and delete of the Comment.</p>&#xA;<p>In the Foo comment field, a query resolver was needed.</p>&#xA;<p>This also meant a new table was needed for comments.</p>&#xA;<p>The table needed to have the <code>sourceId</code> as primary key and <code>ID</code> as sort key, with a global index setup on the sourceId&#xA;I swapped out the CRUD functions in my component with the appropriate Apollo mutations and done.</p>&#xA;",0,user15317112,,,2022-05-20 19:36:39,"",,0,0,0,2022-05-20 19:36:39
72347727,2,,72346471,0,,"<p>In your graphql directory auto-generated by aws-cli, create new file, <code>custom-queries.js</code> :</p>&#xA;<pre><code>- graphql/&#xA;  - mutations.js&#xA;  - subscriptions.js&#xA;  - queries.js&#xA;  - custom-queries.js &lt;&lt; Create this new file&#xA;</code></pre>&#xA;<p>define the following custom graphql query inside <code>custom-queries.js</code> :</p>&#xA;<pre><code> export const ListProductCategoriesByCategoryId = /* Graphql */ `&#xA;    query listProductCategories(&#xA;      $filter = ModelProductCategoryFilterInput&#xA;       ){&#xA;         listProductCategories( filter : $filter) {&#xA;           items {&#xA;              product {&#xA;                        price&#xA;                        image&#xA;                        id&#xA;                        title&#xA;                      }&#xA;                }&#xA;          }&#xA;        }&#xA;    `;&#xA;</code></pre>&#xA;<p>Now you should be able to import <code>ListProductCategoriesByCategoryId</code> in your code and call it like this :</p>&#xA;<pre><code>   import { API, graphqlOperation } from 'aws-amplify';&#xA;   import { ListProductCategoriesByCategoryId } from '../custom-queries.js';&#xA;.&#xA;.&#xA;.&#xA;   const fetchData = await API.graphql(&#xA;    graphqlOperation(&#xA;     ListProductCategoriesByCategoryId, &#xA;           { filter : { categoryID : { eq : &quot;1cb76.....&quot; }}&#xA;     )&#xA;   );&#xA;   console.log(fetchData);&#xA;</code></pre>&#xA;",7054619,,,,2022-05-23 11:24:47,"",,0,1,0,2022-05-23 11:24:47
72352963,1,,,0,148,"<p>With the recent changes to the Appsync Graphql transformer, I've been trying to migrate my code accordingly but seem to fail every time.</p>&#xA;<p>I'm following a straightforward tutorial on youtube that explains how to build a real-time chatting app.&#xA;The guy in the video develops his backend using the Appsync API with Graphql but is doing it with a V1 transformer.</p>&#xA;<p>I've tried to read the documentation and did change my code, but it doesn't seem to work the way I want it to.</p>&#xA;<p><strong>HIS CODE</strong></p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  imageUri: String&#xA;  status: String&#xA;  chatRoomUser: [ChatRoomUser] @connection(keyName: &quot;byUser&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type ChatRoomUser&#xA;@model&#xA;@key(name: &quot;byUser&quot;, fields: [&quot;userID&quot;, &quot;chatRoomID&quot;])&#xA;@key(name: &quot;byChatRoom&quot;, fields: [&quot;chatRoomID&quot;, &quot;userID&quot;]) {&#xA;  id: ID!&#xA;  userID: ID!&#xA;  chatRoomID: ID!&#xA;  user: User @connection(fields: [&quot;userID&quot;])&#xA;  chatRoom: ChatRoom @connection(fields: [&quot;chatRoomID&quot;])&#xA;}&#xA;&#xA;type ChatRoom @model {&#xA;  id: ID!&#xA;  chatRoomUsers: [ChatRoomUser] @connection(keyName: &quot;byChatRoom&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;</code></pre>&#xA;<p><strong>MY CODE</strong></p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  imageUri: String&#xA;  status: String&#xA;  chatRoomUser: [ChatRoomUser] @hasMany&#xA;}&#xA;&#xA;type ChatRoomUser @model {&#xA;  id: ID! @primaryKey&#xA;  userID: ID! @index(name: &quot;byUser&quot;, sortKeyFields: [&quot;chatRoomID&quot;])&#xA;  chatRoomID: ID! @index(name: &quot;byChatRoom&quot;, sortKeyFields: [&quot;userID&quot;])&#xA;  user: User @belongsTo(fields: [&quot;userID&quot;])&#xA;  chatRoom: ChatRoom @belongsTo(fields: [&quot;chatRoomID&quot;]&#xA;}&#xA;&#xA;type ChatRoom @model {&#xA;  id: ID!&#xA;  chatRoomUsers: [ChatRoomUser] @hasMany&#xA;}&#xA;</code></pre>&#xA;<p>These are his Query results with Aws</p>&#xA;<p><a href=""https://i.stack.imgur.com/aWNs3.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aWNs3.jpg"" alt=""His Query results look like this"" /></a></p>&#xA;<p>These are my Query results</p>&#xA;<p><a href=""https://i.stack.imgur.com/9Ryu0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9Ryu0.png"" alt=""My Query results"" /></a></p>&#xA;<p>This is my auto-generated queries.js file</p>&#xA;<pre><code>/* eslint-disable */&#xA;// this is an auto generated file. This will be overwritten&#xA;&#xA;export const getUser = /* GraphQL */ `&#xA;  query GetUser($id: ID!) {&#xA;    getUser(id: $id) {&#xA;      id&#xA;      name&#xA;      imageUri&#xA;      status&#xA;      chatRoomUser {&#xA;        items {&#xA;          id&#xA;          userID&#xA;          chatRoomID&#xA;          createdAt&#xA;          updatedAt&#xA;          userChatRoomUserId&#xA;          chatRoomChatRoomUsersId&#xA;        }&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listUsers = /* GraphQL */ `&#xA;  query ListUsers(&#xA;    $filter: ModelUserFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listUsers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        imageUri&#xA;        status&#xA;        chatRoomUser {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;export const getChatRoomUser = /* GraphQL */ `&#xA;  query GetChatRoomUser($id: ID!) {&#xA;    getChatRoomUser(id: $id) {&#xA;      id&#xA;      userID&#xA;      chatRoomID&#xA;      user {&#xA;        id&#xA;        name&#xA;        imageUri&#xA;        status&#xA;        chatRoomUser {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      chatRoom {&#xA;        id&#xA;        chatRoomUsers {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;      userChatRoomUserId&#xA;      chatRoomChatRoomUsersId&#xA;    }&#xA;  }&#xA;`;&#xA;export const listChatRoomUsers = /* GraphQL */ `&#xA;  query ListChatRoomUsers(&#xA;    $id: ID&#xA;    $filter: ModelChatRoomUserFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;    $sortDirection: ModelSortDirection&#xA;  ) {&#xA;    listChatRoomUsers(&#xA;      id: $id&#xA;      filter: $filter&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;      sortDirection: $sortDirection&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        userID&#xA;        chatRoomID&#xA;        user {&#xA;          id&#xA;          name&#xA;          imageUri&#xA;          status&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        chatRoom {&#xA;          id&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;        userChatRoomUserId&#xA;        chatRoomChatRoomUsersId&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;export const getChatRoom = /* GraphQL */ `&#xA;  query GetChatRoom($id: ID!) {&#xA;    getChatRoom(id: $id) {&#xA;      id&#xA;      chatRoomUsers {&#xA;        items {&#xA;          id&#xA;          userID&#xA;          chatRoomID&#xA;          createdAt&#xA;          updatedAt&#xA;          userChatRoomUserId&#xA;          chatRoomChatRoomUsersId&#xA;        }&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listChatRooms = /* GraphQL */ `&#xA;  query ListChatRooms(&#xA;    $filter: ModelChatRoomFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listChatRooms(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        chatRoomUsers {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>This is his auto-generated queries.js files</p>&#xA;<pre><code>/* tslint:disable */&#xA;/* eslint-disable */&#xA;// this is an auto generated file. This will be overwritten&#xA;&#xA;export const getUser = /* GraphQL */ `&#xA;  query GetUser($id: ID!) {&#xA;    getUser(id: $id) {&#xA;      id&#xA;      name&#xA;      imageUri&#xA;      status&#xA;      chatRoomUser {&#xA;        items {&#xA;          id&#xA;          userID&#xA;          chatRoomID&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listUsers = /* GraphQL */ `&#xA;  query ListUsers(&#xA;    $filter: ModelUserFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listUsers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        name&#xA;        imageUri&#xA;        status&#xA;        chatRoomUser {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;export const getChatRoomUser = /* GraphQL */ `&#xA;  query GetChatRoomUser($id: ID!) {&#xA;    getChatRoomUser(id: $id) {&#xA;      id&#xA;      userID&#xA;      chatRoomID&#xA;      user {&#xA;        id&#xA;        name&#xA;        imageUri&#xA;        status&#xA;        chatRoomUser {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      chatRoom {&#xA;        id&#xA;        chatRoomUsers {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listChatRoomUsers = /* GraphQL */ `&#xA;  query ListChatRoomUsers(&#xA;    $filter: ModelChatRoomUserFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listChatRoomUsers(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        userID&#xA;        chatRoomID&#xA;        user {&#xA;          id&#xA;          name&#xA;          imageUri&#xA;          status&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        chatRoom {&#xA;          id&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;export const getChatRoom = /* GraphQL */ `&#xA;  query GetChatRoom($id: ID!) {&#xA;    getChatRoom(id: $id) {&#xA;      id&#xA;      chatRoomUsers {&#xA;        items {&#xA;          id&#xA;          userID&#xA;          chatRoomID&#xA;          createdAt&#xA;          updatedAt&#xA;        }&#xA;        nextToken&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;export const listChatRooms = /* GraphQL */ `&#xA;  query ListChatRooms(&#xA;    $filter: ModelChatRoomFilterInput&#xA;    $limit: Int&#xA;    $nextToken: String&#xA;  ) {&#xA;    listChatRooms(filter: $filter, limit: $limit, nextToken: $nextToken) {&#xA;      items {&#xA;        id&#xA;        chatRoomUsers {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      nextToken&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I would love it if someone could try and look at the code and tell me if there are any wrong pieces of code because after I run queries on the console, it doesn't give me the same results it provides to him.</p>&#xA;<p>I appreciate any help anyone can provide,&#xA;Matti</p>&#xA;",19009375,,19009375,2022-05-27 15:51:08,2022-05-28 09:25:41,AWS Appsync Graphql,<amazon-web-services><react-native><graphql><aws-appsync><amplify>,1,3,0,2022-05-23 18:00:21
72353585,1,,,0,63,"<p>I have a GraphQL API connected to a Cassandra database.</p>&#xA;<p>Here's my mutation Query to retrieve acc and name fields from the table based on date:</p>&#xA;<pre><code>query($date: String) {&#xA;   getResources(date: $date ) {&#xA;    list {&#xA;        acc&#xA;        name&#xA;    }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Sample Query:</p>&#xA;<pre><code>query{getResourcesInput(getResources:{date:{eq:&quot;2020-06-28T16:48:37.000+0000&quot;}}){&#xA;list {&#xA;        acc&#xA;        name&#xA;    }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>What CQL data type should I set for the date field? It expects a json object.&#xA;Here's the error I get when set to String.</p>&#xA;<pre><code>{&quot;errors&quot;:[{&quot;error_code&quot;:&quot;400-901&quot;,&quot;description&quot;:&quot;Validation error of type FieldUndefined&quot;,&quot;field_name&quot;:&quot;getResources&quot;}]}&#xA;</code></pre>&#xA;",12713111,,,,2022-05-23 18:57:15,CQL Mutation Query Passing Json Parameter,<java><graphql><cql>,0,0,0,2022-05-23 18:57:15
72356807,2,,72304739,0,,"<p>You need to specify the operator</p>&#xA;<pre><code>var MeetingID;&#xA;&#xA;const querysort = Object.assign({},{&#xA;  sortDirection : 'ASC', &#xA;  type : 'datamodel', &#xA;  filter: { MeetingID: { eq: MeetingID } }&#xA;})&#xA;&#xA;await API.graphql(graphqlOperation(datamodel, querysort))&#xA;</code></pre>&#xA;",8763264,,,,2022-05-24 03:11:12,"",,0,0,0,2022-05-24 03:11:12
72366277,1,,,0,184,"<p>I am writing a resolver which performs a query with typeorm and should return an ordered result. Typeorm accepts a set of values for it's sorting parameter and I would like to be able to pass the same values to my resolver. When I try this however I get the error: <code>'FindOptionsOrderValue' only refers to a type, but is being used as a value here</code>.</p>&#xA;<pre><code>import { MyContext } from &quot;src/types&quot;;&#xA;import { Arg, Ctx, Query, Resolver } from &quot;type-graphql&quot;;&#xA;import { FindOptionsOrderValue } from &quot;typeorm&quot;;&#xA;import { MSCI_MarketData } from &quot;../entities&quot;;&#xA;&#xA;&#xA;@Resolver()&#xA;export class MarketDataResolver {&#xA;    @Query(() =&gt; [MSCI_MarketData])&#xA;&#xA;    marketData(&#xA;        @Arg(&quot;sort&quot;, () =&gt; FindOptionsOrderValue) sort: FindOptionsOrderValue,&#xA;        @Ctx() { em }: MyContext&#xA;    ): Promise&lt;MSCI_MarketData[]&gt; {&#xA;&#xA;        return em.find(MSCI_MarketData, { order: { Date: sort } });&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>When I change <code>Arg</code> line to <code>@Arg(&quot;sort&quot;, () =&gt; String) sort: FindOptionsOrderValue,</code> everything works just fine. However it accepts all string data and just converts it to &quot;ASC&quot; unless it's one of the accepted types in which case it works as expected.</p>&#xA;<p>How can I have my resolver throw an error when I pass in a type which typerom does not expect?</p>&#xA;",4923949,,,,2022-05-24 16:22:27,"Passing typeorm ordering parameter to type-graphql -- 'FindOptionsOrderValue' only refers to a type, but is being used as a value here",<typescript><typeorm><typegraphql>,0,1,0,2022-05-24 16:22:27
72406963,2,,70453389,0,,"<p>Unfortunately, sorting by related table's subfield it is not possible by now. See: <a href=""https://github.com/directus/directus/discussions/4502"" rel=""nofollow noreferrer"">https://github.com/directus/directus/discussions/4502</a></p>&#xA;<p>Edit: <a href=""https://github.com/directus/directus/pull/12084"" rel=""nofollow noreferrer"">https://github.com/directus/directus/pull/12084</a> they added support for sorting by nested M2O relation in <code>v9.10.0</code>.</p>&#xA;",1702731,,1702731,2022-05-27 14:37:33,2022-05-27 14:37:33,"",,0,0,0,2022-05-27 14:27:53
72410746,2,,68329273,0,,"<p>I never found the perfect solution, but here are the notes I took that describe a work-around I used:</p>&#xA;<p>So far this is the closest I have figured out (I have to look at the foreign key and not for the child object itself):</p>&#xA;<pre><code>{&#xA;GetAllAccounts(  where: {  accountManagerFid: {eq: null} }) {&#xA;    accountManagerFid,&#xA;      accountManager {&#xA;        userLastName &#xA;      }&#xA;  }&#xA;}&#xA; &#xA;</code></pre>&#xA;",7013906,,,,2022-05-27 20:26:27,"",,0,0,0,2022-05-27 20:26:27
72413584,1,,,0,43,"<p>I have a query to which i would like to insert a variable:</p>&#xA;<p>this is the query :</p>&#xA;<pre><code>query = gql`{getStuff{outputs(filter: [&quot;10_lorries&quot;, &quot;3_cars&quot;]){id, brand}}}`&#xA;const {data, error, loading} = useQuery(query)&#xA;</code></pre>&#xA;<p>which by itself works fine, but what if instead of explicitely passing the array I had it defined in a variable and want to pass it to the query?</p>&#xA;<pre><code>const vehicles= [&quot;10_lorries&quot;, &quot;3_cars&quot;]&#xA;</code></pre>&#xA;<p>when trying this data returns an undefined:</p>&#xA;<pre><code>query = gql`{getStuff{outputs(filter: vehicles){id, brand}}}`&#xA;</code></pre>&#xA;<p>I am struggling a bit to understand how to pass the variable into the gql query..</p>&#xA;",7836530,,7836530,2022-05-28 07:12:42,2022-05-28 08:04:47,how to use a predefined variable into gql query using apollo client,<graphql>,1,0,0,2022-05-28 07:02:26
72467259,1,72478601,,0,73,"<p>Let's say we have two entities.</p>&#xA;<ul>&#xA;<li><code>users</code> that has <code>uuid</code>, <code>name</code> and <code>age</code></li>&#xA;<li><code>users_books</code> that has <code>user_uuid</code>, <code>book_id</code> and <code>recommended_age</code>.</li>&#xA;</ul>&#xA;<p><code>user_uuid</code> was added as foreign key pointing to <code>uuid</code> in <code>Users</code></p>&#xA;<p>Using user name I want to get all the books that that user reads and have recommended age equal to users age.</p>&#xA;<p>Following query will get me all the books that user reads</p>&#xA;<pre><code>query getUserBooks($uuid: uuid!) {&#xA;  users_by_pk(uuid: $uuid) {&#xA;    uuid&#xA;    name&#xA;    age&#xA;    users_books() {&#xA;       book_id&#xA;       recommended_age&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And this is the query I am trying to create:</p>&#xA;<pre><code>query getUserBooksWithRestrictedAge($uuid: uuid!) {&#xA;  users_by_pk(uuid: $uuid) {&#xA;    uuid&#xA;    name&#xA;    age&#xA;    users_books(where:{recommended_age:{_eq: *WHAT_SHOULD_GO_HERE?*}}) {&#xA;       book_id&#xA;       recommended_age      &#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is this even possible?</p>&#xA;",2863227,,,,2022-06-02 15:28:54,How to use previously acquired data in the GraphQL query?,<graphql><hasura>,1,0,0,2022-06-01 19:41:49
72537672,1,,,0,11,"<p>I want to order events by &quot;beginningDate&quot;, but this is inside the table of components_date_hour witch is inside dateHour, and I can't find a way of referencing it in the line</p>&#xA;<pre><code>static queryEvents() {&#xA;    return gql`&#xA;      query Events($start:Int, $limit:Int) {&#xA;        events(where: {habilitaded: &quot;true&quot;}, sort: &quot;createdAt:desc&quot;, start:$start, limit:$limit) {   &#xA;...&#xA;</code></pre>&#xA;<p>I tried every variation possible, with <code>sort:&quot;dateHour[&quot;beginningDate&quot;]:desc&quot;</code>, or&quot;[]&quot;, &quot;.&quot;, etc...</p>&#xA;<p>To clarify a little bit, I have a &quot;event&quot; table, inside there is a &quot;dateHour&quot; witch have an id that reference to another table &quot;components_date_hour&quot;, and there it is the &quot;beginningDate&quot;</p>&#xA;",19293947,,,,2022-06-07 21:19:02,How do I order 'dataInicio' in my GraphQl query?,<graphql><graphql-js>,0,0,0,2022-06-07 21:19:02
72569886,1,,,0,70,"<h2>Document Structure</h2>&#xA;<h3>Data</h3>&#xA;<pre><code>class Data(EmbeddedDocument):&#xA;    v = FloatField()&#xA;    q = StringField()&#xA;    co2 = FloatField()&#xA;    price = FloatField()&#xA;    ts = DateTimeField()&#xA;</code></pre>&#xA;<h3>Meters Data</h3>&#xA;<pre><code>class MetersData(DynamicDocument):&#xA;    meta = {'collection': 'dk_heating'}&#xA;    _id = ObjectIdField()&#xA;    ident = StringField()&#xA;    meteringPointId = StringField()&#xA;    customer = StringField()&#xA;    cvr = StringField()&#xA;    type = StringField()&#xA;    unit = StringField()&#xA;    address = StringField()&#xA;    period = EmbeddedDocumentField(Period)&#xA;    hourly_data = ListField(EmbeddedDocumentField(Data), db_field='data')&#xA;    daily_data = ListField(EmbeddedDocumentField(Data))&#xA;    monthly_data = ListField(EmbeddedDocumentField(Data))&#xA;    # monthly_data = EmbeddedDocumentListField(Data)&#xA;    yearly_data = ListField(EmbeddedDocumentField(Data))&#xA;</code></pre>&#xA;<p>I am using this Query.</p>&#xA;<h2>Query</h2>&#xA;<pre><code>MetersData.objects.filter(address=address, customer=customer).fields(&#xA;                monthly_data={&quot;$elemMatch&quot;: {&quot;q&quot;: &quot;E&quot;}},&#xA;                address=1, customer=1, cvr=1, ident=1, meteringPointId=1, type=1, unit=1, period=1)&#xA;</code></pre>&#xA;<p>It returns me only the first matching element. I have read the documentation and it reads that $elemMatch is supposed to return only the first matching result. But in my case, I need all the matching results.</p>&#xA;<h2>Result of the Query</h2>&#xA;<p><a href=""https://i.stack.imgur.com/DYT8J.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DYT8J.png"" alt=""Query Result"" /></a></p>&#xA;<p>I have searched everywhere but I am unable to find a solution.</p>&#xA;",13317796,,,,2022-06-13 06:56:40,"Filter Embedded Documents that match a condition in MongoEngine, Django, GraphQl",<python-3.x><django><graphql><mongoengine>,1,0,0,2022-06-10 06:22:34
72577048,1,72577843,,0,71,"<p>How to implement pagination for graphQL Query? I keep receiving:  &quot;message&quot;: &quot;Unknown argument &quot;hasNextPage&quot; on field &quot;pageInfo&quot; of type &quot;Core_EventPeopleConnection&quot;.&quot;</p>&#xA;<pre><code>    query myquery($viewId: ID!,$hasNextPage: Boolean!, $endCursor: String!){&#xA;  Core_eventPeopleListView(viewId: $viewId){&#xA;    id&#xA;    people{&#xA;      pageInfo(hasNextPage: true,endCursor: $endCursor){&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;     nodes{&#xA;      firstName&#xA;      lastName&#xA;      jobTitle&#xA;      organization&#xA;      websiteUrl&#xA;    } &#xA;    }&#xA;    }    &#xA;    }&#xA;Variables:&#xA;        {&#xA;      &quot;viewId&quot;:&quot;RXZlbnRWaWV3XzMyMTY1Mw==&quot;,&#xA;      &quot;endCursor&quot;: &quot;WyJhZ2Fyd2FsIiwic2hydXRpIiwiUlhabGJuUlFaVzl3YkdWZk1UVXhPREkzTlRVPSJd&quot;,&#xA;      &quot;hasNextPage&quot;: true&#xA;    }&#xA;</code></pre>&#xA;",19086344,,,,2022-06-10 17:15:39,"Unknown argument \""hasNextPage\"" on field \""pageInfo\"" GraphQL",<api><variables><graphql><scrape>,1,0,0,2022-06-10 15:58:06
72577843,2,,72577048,1,,"<p>In Relay specification, <code>hasNextPage</code> is not an argument, but a field that is returned from the API to tell you if you can paginate further. Just remove the argument:</p>&#xA;<pre><code>query myquery($viewId: ID!,$hasNextPage: Boolean!, $endCursor: String!){&#xA;  Core_eventPeopleListView(viewId: $viewId){&#xA;    id&#xA;    people{&#xA;      pageInfo(endCursor: $endCursor){&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;      nodes{&#xA;        firstName&#xA;        lastName&#xA;        jobTitle&#xA;        organization&#xA;        websiteUrl&#xA;      } &#xA;    }&#xA;  }    &#xA;}&#xA;</code></pre>&#xA;",3849167,,,,2022-06-10 17:15:39,"",,0,0,0,2022-06-10 17:15:39
72587431,1,,,0,9,"<p>I'm trying to get the amount of new followers one has accumulated in a 24 hour period, my schema is setup with timestamps. I'm wondering if this is even possible without adding a special clause, or task to calculate it, itself.</p>&#xA;<p>Maybe fetch the record, and timeDiff it with updatedAt - date()&#xA;I'm very confused, any tips would be greatly appreciated.</p>&#xA;",15522126,,,,2022-06-11 19:46:36,Fetch the # change in a record within 24 hours,<mongodb><graphql><apollo>,0,0,0,2022-06-11 19:46:36
72588735,2,,71833652,1,,"<p>Your first problem mostly depends on your database and its available queries. You basically want something like <em>&quot;select the top n books for each user&quot;</em>. This can be done in SQL. See: <a href=""https://stackoverflow.com/questions/2129693/using-limit-within-group-by-to-get-n-results-per-group/30269273#30269273"">Using LIMIT within GROUP BY to get N results per group?</a></p>&#xA;<p>The second problem feels a bit contrived in my opinion: On your initial page load, you fetch and display 100 users, and for each user 50 books, and for each book 10 pages.</p>&#xA;<p>Now think in terms of the UI: There will be a button for each displyed user to fetch the next 50 books for that user. Though there's no need for nested pagination. You can simply use the <code>books</code> query endpoint for that.</p>&#xA;<p>I don't see a common real world scenario where you want to <em>&quot;fetch the next 50 books for every displayed user&quot;</em>.</p>&#xA;<p>The graphql schema would look something like this (I'll omit <code>pages</code>, because it is essentially the same as <code>books</code>):</p>&#xA;<pre><code>Query {&#xA;  users(first: Int, after: UserCursor): UserConnection&#xA;  books(first: Int, after: BookCursor): BookConnection&#xA;}&#xA;&#xA;type UserConnection {&#xA;  edges: [UserEdge]&#xA;}&#xA;&#xA;type UserEdge {&#xA;  cursor: UserCursor&#xA;  node: User&#xA;}&#xA;&#xA;type User {&#xA;  id: ID&#xA;  books(first: Int): BookConnection # no `after` argument here &#xA;}&#xA;&#xA;type BookConnection {&#xA;  edges: [BookEdge]&#xA;}&#xA;&#xA;type BookEdge {&#xA;  cursor: BookCursor # here comes the interesting part&#xA;  node: Book&#xA;}&#xA;&#xA;type Book {&#xA;  id: ID&#xA;}&#xA;</code></pre>&#xA;<p>The challenging part is: <em>&quot;What must <code>BookEdge.cursor</code> look like to make nested pagination work when you pass this cursor to <code>Query.books</code>?&quot;</em></p>&#xA;<p>Simple answer: The cursor must additionally include the <code>User.id</code>, because your server code must be able to <em>select the next 50 books <strong>for the given user id</strong> after the cursor</em>, e.g. (simplified) <code>SELECT * FROM book WHERE user = 42 LIMIT 50 OFFSET 50</code>.</p>&#xA;<p>As you can see, this GraphQL schema does not have any nested pagination. It just has nested cursors. And those cursors don't care if they originate from the top level of the schema (like <code>Query.users</code>) or from some nested level (like <code>Query.users.edges.node.books</code>).</p>&#xA;<p>The only important part is, that the cursor must include all necessary information for your server code to fetch the correct data. In this case it might be something like <code>cursor={Book.id, User.id}</code>. The <code>Book.id</code> is needed to be able to fetch <em>&quot;the next 50 books <strong>after</strong> this id&quot;</em> and the <code>User.id</code> is needed to fetch <em>&quot;books from only this particular user&quot;</em>.</p>&#xA;",1321564,,1321564,2022-06-15 16:13:38,2022-06-15 16:13:38,"",,0,0,0,2022-06-12 00:26:06
72596068,1,,,0,186,"<p>I have pretty good understanding of the GraphQl basics but I'm a beginner and as the complexity increases it exposes my lack of overall understanding. I'm trying to get a count of records returned from my resolver and would appreciate any help I can get.</p>&#xA;<p><strong>I have a directory structure like this</strong></p>&#xA;<pre><code>graphql&#xA;      |&#xA;      resolvers&#xA;              |&#xA;              index.js&#xA;              formsResolver.js&#xA;      type_defs&#xA;              |&#xA;              typeDefs.js&#xA;</code></pre>&#xA;<p><strong>The typeDefs.js file</strong></p>&#xA;<pre><code> type UnitSignInForm {&#xA;    id: ID!&#xA;    givenName: String!&#xA;    department: String!&#xA;    unit: String!&#xA;    isSignedIn: Boolean!&#xA;    signedInAt: String&#xA;    signedOutAt: String&#xA;  }&#xA;&#xA;  #My addition to attempt a separate type for count !!!!!!&#xA;  type AllForms {&#xA;    forms: [UnitSignInForm]&#xA;    count: Int!&#xA;  }      &#xA;&#xA;  type Query {&#xA;    #The working query to return forms !!!!!!!!!!!!!!!!!!!!!!&#xA;    getAllSignInForms(bySignedIn: Boolean, byUnit: String): [UnitSignInForm]&#xA; &#xA;    #My attempted implementation of getting count !!!!!!!!!!!!!&#xA;    getFormsAndCount(bySignedIn: Boolean, byUnit: String): [AllForms]&#xA;&#xA;  }&#xA;</code></pre>&#xA;<p><strong>The index.js from resolvers folder</strong></p>&#xA;<pre><code>     #My attempted modifier&#xA;     AllForms: {&#xA;       count: (parent) =&gt; parent.forms.length,&#xA;     },&#xA;      Query: {&#xA;        ...formsResolver.Query,&#xA;      },&#xA;</code></pre>&#xA;<p><strong>Utilizing the working query referenced in the typeDefs.js it returns</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;      {&#xA;        &quot;id&quot;: &quot;cl4bp1apf0004lkuxhhhxjlyt&quot;,&#xA;        &quot;givenName&quot;: &quot;persons name&quot;,&#xA;        &quot;department&quot;: &quot;MAINT&quot;,&#xA;        &quot;unit&quot;: &quot;some unit&quot;,&#xA;        &quot;isSignedIn&quot;: true,&#xA;        &quot;signedInAt&quot;: &quot;06/12/2022 12:22 PM&quot;&#xA;      },&#xA;      {&#xA;        &quot;id&quot;: &quot;fggfgfgv04lkuxhhhxjlyt&quot;,&#xA;        &quot;givenName&quot;: &quot;other persons name&quot;,&#xA;        &quot;department&quot;: &quot;MAINT&quot;,&#xA;        &quot;unit&quot;: &quot;some unit&quot;,&#xA;        &quot;isSignedIn&quot;: true,&#xA;        &quot;signedInAt&quot;: &quot;06/12/2022 12:22 PM&quot;&#xA;      }&#xA;}&#xA;</code></pre>&#xA;<p><strong>My attempt to implement a separate type and count fails but the desired return is</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;      {&#xA;        &quot;id&quot;: &quot;cl4bp1apf0004lkuxhhhxjlyt&quot;,&#xA;        &quot;givenName&quot;: &quot;persons name&quot;,&#xA;        &quot;department&quot;: &quot;MAINT&quot;,&#xA;        &quot;unit&quot;: &quot;some unit&quot;,&#xA;        &quot;isSignedIn&quot;: true,&#xA;        &quot;signedInAt&quot;: &quot;06/12/2022 12:22 PM&quot;&#xA;      },&#xA;      {&#xA;        &quot;id&quot;: &quot;fggfgfgv04lkuxhhhxjlyt&quot;,&#xA;        &quot;givenName&quot;: &quot;other persons name&quot;,&#xA;        &quot;department&quot;: &quot;MAINT&quot;,&#xA;        &quot;unit&quot;: &quot;some unit&quot;,&#xA;        &quot;isSignedIn&quot;: true,&#xA;        &quot;signedInAt&quot;: &quot;06/12/2022 12:22 PM&quot;&#xA;      },&#xA;      &quot;count&quot;: 2&#xA;}&#xA;</code></pre>&#xA;",11677614,,,,2022-06-12 21:39:17,Graphql records count,<javascript><graphql>,0,3,0,2022-06-12 21:39:17
72600489,1,,,0,44,"<p>We have an issue with my team where a <code>RESTDataSource</code> class has many methods and it makes the file 1500 lines long.</p>&#xA;<p>This class can be split into multiple <code>themes</code>, for instance a <code>Facebook</code> datasource has some methods about the <code>user</code>, some methods about the <code>article</code>...</p>&#xA;<p>Has anyone a method to split this class so that it becomes less messy?</p>&#xA;<p>For info this is the class I am talking about (but 1500 lines long) :</p>&#xA;<pre><code>const { RESTDataSource } = require('apollo-datasource-rest');&#xA;&#xA;class MoviesAPI extends RESTDataSource {&#xA;  constructor() {&#xA;    // Always call super()&#xA;    super();&#xA;    // Sets the base URL for the REST API&#xA;    this.baseURL = 'https://movies-api.example.com/';&#xA;  }&#xA;&#xA;  async getMovie(id) {&#xA;    // Send a GET request to the specified endpoint&#xA;    return this.get(`movies/${encodeURIComponent(id)}`);&#xA;  }&#xA;&#xA;  async getMostViewedMovies(limit = 10) {&#xA;    const data = await this.get('movies', {&#xA;      // Query parameters&#xA;      per_page: limit,&#xA;      order_by: 'most_viewed',&#xA;    });&#xA;    return data.results;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",9346979,,,,2022-06-13 09:23:23,How to split a RESTDataSource class into multiple files,<apollo><apollo-server><apollo-datasource-rest>,0,0,0,2022-06-13 09:23:23
72605361,2,,59341471,0,,"<p>Nested logic with the same and/or conjunction can be simplified into a single list.</p>&#xA;<p>For example, the following complex query:</p>&#xA;<pre><code>  or: [&#xA;    { or: [ { foo: { eq: &quot;A&quot; } }, { bar: { eq: &quot;B&quot; } } ] },&#xA;    { or: [ { baz: { eq: &quot;C&quot; } }, { quz: { eq: &quot;D&quot; } } ] }&#xA;  ]&#xA;} ) { ... }&#xA;&#xA;</code></pre>&#xA;<p>Moreover, can be simplified into the following simplified query syntax:</p>&#xA;<pre><code>queryPost(filter: {&#xA;  or: [&#xA;    { foo: { eq: &quot;A&quot; } }, &#xA;    { bar: { eq: &quot;B&quot; } },&#xA;    { baz: { eq: &quot;C&quot; } }, &#xA;    { quz: { eq: &quot;D&quot; } }&#xA;  ]&#xA;} ) { ... }&#xA;</code></pre>&#xA;",8648141,,,,2022-06-13 15:27:59,"",,0,0,0,2022-06-13 15:27:59
72615071,1,,,0,119,"<p>I have a query like this:</p>&#xA;<pre><code>export const myItemInfoQuery: DocumentNode = gql`&#xA;  query myItemInfoQuery(&#xA;      $filter: JSON&#xA;      $pagination: Pagination&#xA;    ) {&#xA;    myItemPages(&#xA;      filter: $filter &#xA;      pagination: $pagination&#xA;      ) {&#xA;      pageInfo {&#xA;        totalCount&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>and in my component, I need to call this query many times with different variables.</p>&#xA;<p>for eg:</p>&#xA;<pre><code>     const resA = useQuery(&#xA;            myItemInfoQuery, variablesA&#xA;        );&#xA;     const resB = useQuery(&#xA;            myItemInfoQuery, variablesB&#xA;        );&#xA;    const resC = useQuery(&#xA;            myItemInfoQuery, variablesC&#xA;        );&#xA;</code></pre>&#xA;<p>But all these three queries are being sent in separate payloads.&#xA;I want these three queries to be sent in a same payload..</p>&#xA;<p>how can I achieve this ?</p>&#xA;",4306696,,,,2022-06-14 10:03:41,how to send multiple queries in single payload React apollo,<reactjs><apollo><gql>,0,0,0,2022-06-14 10:03:41
72618219,1,,,2,92,"<p>I would like to query my organization deployments using GraphQL and use createdAt as a property (I am doing the same thing with a pull request query : <code>createdAt:&quot;2022-01-01..2022-01-31&quot;</code>).</p>&#xA;<p>For now, the only way I've found would be to iterate over my repositories, sort deployments by creation date, and stop the query if I reached my limit but I don't think that's efficient.</p>&#xA;<pre><code>{&#xA;  repository(owner: &quot;my_organization&quot;, name: &quot;my_repo&quot;) {&#xA;    deployments(orderBy: {field: CREATED_AT, direction: ASC}) {&#xA;      edges {&#xA;        node {&#xA;          state&#xA;          createdAt&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12319858,,,,2022-06-14 13:53:29,How to query GitHub deployments using GraphQL and use createdAt as a property?,<github><deployment><graphql><octokit-js>,0,0,0,2022-06-14 13:53:29
72633862,1,,,0,189,"<p>For background, we're using HotChocolate in C#, with Apollo Angular and graphql-codegen.</p>&#xA;<p>We want to fetch some data from a query, but twice within one named query with different criteria, for instance:</p>&#xA;<pre><code>&#xA;query getTeamMembers($organisationId: UUID!, $cursor: String) {&#xA;    teamMembers(organisationId: $organisationId, after: $cursor) {&#xA;        pageInfo {&#xA;            hasNextPage&#xA;            hasPreviousPage&#xA;            startCursor&#xA;            endCursor&#xA;        }&#xA;        edges {&#xA;            cursor&#xA;            node {&#xA;                ...teamMember&#xA;            }&#xA;        }&#xA;        totalCount&#xA;    }&#xA;    teamMembersWithSpecificCriteria: teamMembers(organisationId: $organisationId, after: $cursor, where: {...}&#xA;    ] }}) {&#xA;        totalCount&#xA;    }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>As you can see, this query (<code>getTeamMembers</code>) will fetch data from the same query resolver (<code>teamMembers</code>), but one is the entire dataset, the other is a subset of that data with a where clause.</p>&#xA;<p>(I've had to blur/change some names for reasons).</p>&#xA;<p>This seemingly <em>works</em> in the network request:</p>&#xA;<p><a href=""https://i.stack.imgur.com/KzNtr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KzNtr.png"" alt=""Network request"" /></a></p>&#xA;<p>but as you can see, both results have the same <code>__typename</code>, causing Apollo Angular to overwrite the data and set <code>23</code> for both:</p>&#xA;<p><a href=""https://i.stack.imgur.com/o2V80.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/o2V80.png"" alt=""enter image description here"" /></a></p>&#xA;<p>The code we have looks like this:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>&#xA;this.teamMembersQuery = this.apollo.watchQuery&lt;GetTeamMembersQuery,&#xA;          GetTeamMembersQueryVariables&gt;({&#xA;          query: GetTeamMembersDocument,&#xA;          fetchPolicy: &quot;cache-and-network&quot;,&#xA;          variables: {&#xA;            organisationId: currentOrganisation?.id&#xA;          }&#xA;        });&#xA;&#xA;        this.teamMembers$ = this.teamMembersQuery.valueChanges.pipe(&#xA;          map((result) =&gt; {&#xA;            this.cursor = result.data.teamMembers?.pageInfo.endCursor;&#xA;            this.hasNextPage = result.data.teamMembers?.pageInfo.hasNextPage;&#xA;            this.totalTeamMembersCount = result.data.teamMembers?.totalCount ?? 0;&#xA;            this.totalSpecificTeamMembersCount = result.data.teamMembersWithSpecificCriteria?.totalCount ?? 0;&#xA;            return result.data.teamMembers?.edges?.map((e) =&gt; e.node) ?? [];&#xA;          })&#xA;        );&#xA;&#xA;</code></pre>&#xA;<p>Is there a way around this without having to create another query resolver on the server? Isn't this the entire point of GraphQL to be able to query different data like this?</p>&#xA;<p>Any tips would be entirely helpful.</p>&#xA;",3655565,,,,2022-06-15 15:14:19,Fetching different data from the same query in GraphQL,<angular><typescript><graphql><apollo-client><apollo-angular>,0,0,0,2022-06-15 15:14:19
72636560,1,,,1,103,"<p>I am building a GraphQL query that has an interface and multiple types implementing that interface for different data endpoints.</p>&#xA;<pre><code>interface baseInterface {&#xA;  id: ID&#xA;  name: String&#xA;}&#xA;type type1 implements baseInterface {&#xA;  id: ID&#xA;  name: String&#xA;  location: string&#xA;}&#xA;type type2 implements baseInterface {&#xA;  id: ID&#xA;  name: String&#xA;  createdBy: string&#xA;}&#xA;</code></pre>&#xA;<p><code>type1</code> gets the data from <code>service1</code> and <code>type2</code> gets data from <code>service2</code>. The data is large from both the services so I can't pull all of the data in memory in one call. How does the Relay pagination work here? The two things I am trying to solve is:</p>&#xA;<ul>&#xA;<li>how do GraphQL interfaces work with Relay pagination. When the client has this query,</li>&#xA;</ul>&#xA;<pre><code>query findTypes(first:10, after: $opaqueCursor ) { &#xA; id,&#xA; name&#xA;}&#xA;</code></pre>&#xA;<p>how does it render paginated data from both the sources? Would it build two paginated sets and use different cursors? And will it return 10 from each?</p>&#xA;<ul>&#xA;<li>how does Relay pagination work with large data sets?</li>&#xA;</ul>&#xA;",837610,,,,2022-06-15 18:57:20,Relay pagination with GraphQL interfaces,<graphql><pagination><relay>,0,0,0,2022-06-15 18:57:20
72654103,1,,,0,20,"<p>I am trying to sort the list from graphql according to the start time and I tried to pass sort with start_time, but graphql showing &quot;GraphQLDocumentError: Unknown argument &quot;sort&quot; on field &quot;list.start_time&quot;.&quot;</p>&#xA;<pre><code>query GetListById($ListID: ID!) {&#xA;  list_by_id(id: $ListID, sort: &quot;start_time:desc&quot;) {&#xA;    id&#xA;    title&#xA;    start_time&#xA;    end_time&#xA;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Can anyone show me how can I sort the list into the front? Thanks</p>&#xA;",9824388,,,,2022-06-17 03:45:08,Sorting the list according to start time from GraphQL,<react-native><sorting><graphql>,0,2,0,2022-06-17 03:45:08
72658037,1,,,0,48,"<p>i've this in my laravel app to save articles:</p>&#xA;<pre><code>public function store()&#xA;    {&#xA;        $request =request();&#xA;        $res['result'] = Article::create([&#xA;            'ref' =&gt; Article::whereYear($request-&gt;year)-&gt;max('ref') + 1,//calculated based on last (highest value for this year) + 1. every year its reinitialized to 0&#xA;            'year' =&gt; $request-&gt;year,&#xA;            'stat' =&gt; $request-&gt;stat,&#xA;            'date_avis_red' =&gt; $request-&gt;date_avis_red,&#xA;        ]);&#xA;        &#xA;        return $res;&#xA;    }&#xA;</code></pre>&#xA;<p>is there a way to do the same thing with graphql whene execution the mutation of saving articles?&#xA;here is the mutation type:</p>&#xA;<pre><code>saveArt(&#xA;    id: ID&#xA;    year: Int!,&#xA;    ref:  Int, // i want this to be calculated based on the max ref for this year + 1 (sequential)&#xA;    stat: String,&#xA;    date_avis_red: Date,&#xA;): Article! @upsert&#xA;</code></pre>&#xA;<p>can someone give me the idea? thanks for all!</p>&#xA;",12155046,,,,2022-06-17 10:37:46,laravel lighthouse : how to auto calculate field base on its max value,<laravel><graphql><lighthouse>,0,0,0,2022-06-17 10:37:46
72659876,1,72661903,,0,97,"<p>I did not find anything about it in the Docs, but for me it seems to be a very common task, so is there a possibility/syntax or a workaround to achieve the following?</p>&#xA;<p>My GraphQL query looks something like this:</p>&#xA;<pre><code>query customerPersons(&#xA;  $pagination: PaginationInput!&#xA;  $filter: FilterPersonInput&#xA;) {&#xA;  persons(pagination: $pagination, filter: $filter) {&#xA;    totalCount&#xA;    data {&#xA;      ...PersonsData&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>With apollo and its codegen I get some helper React Hook function calls, which I can use like this:</p>&#xA;<pre><code>const { data } = useCustomerPersonsQuery({&#xA;  variables: {&#xA;    pagination: {&#xA;      skip: 0,&#xA;      take: 20,&#xA;    },&#xA;    filter: {&#xA;      query: 'peterchen',&#xA;      userType: 'Customer'&#xA;    }&#xA;  });&#xA;</code></pre>&#xA;<p>Is it possible <strong>to move the <code>userType: 'Customer'</code> part</strong> into the static part of my query? If it would be JavaScript I would say it is <code>assign</code> or <code>merge</code> two objects with the spread operator.&#xA;Something like:</p>&#xA;<pre><code>query customerPersons(&#xA;  $pagination: PaginationInput!&#xA;  $filter: FilterPersonInput&#xA;) {&#xA;  persons(pagination: $pagination, filter: { ...$filter, userType: &quot;Customer&quot; }) {&#xA;    totalCount&#xA;    data {&#xA;      ...PersonsData&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3344613,,,,2022-06-17 15:51:53,Does GQL support spreading / composing objects (eg. input args)?,<javascript><graphql><react-apollo><graphql-codegen>,1,2,0,2022-06-17 13:06:54
72683741,1,,,1,38,"<p>I need to perform a query on a MongoDB database using mongoose to select documents based on the value of properties contained in subdocuments.&#xA;These are my schemas:</p>&#xA;<pre><code>type Map{&#xA;    id: ID&#xA;    date: String!&#xA;    parcels: [Parcel!]!&#xA;  }&#xA;type Parcel {&#xA;    id: Int&#xA;    name: String!&#xA;    x: Int!&#xA;    y: Int!    &#xA;  }&#xA;</code></pre>&#xA;<p>I'd like to find a parcel by coordinates at a given date, so I tried these queries but I always get null:</p>&#xA;<pre><code>Map.find({date: &quot;2022-06-15&quot;, parcels:{x: 10, y:20}})&#xA;Map.find({date: &quot;2022-06-15&quot;, &quot;parcels.x&quot;: 10, &quot;parcels.y&quot;:20})&#xA;</code></pre>&#xA;<p>Is there any way to avoid retrieving all parcels and then selecting the one I'm looking for?</p>&#xA;",1305539,,,,2022-06-20 07:49:32,Mongoose find query on subdocuments property,<mongodb><mongoose><graphql>,0,0,0,2022-06-20 07:43:50
72700805,1,72701360,,0,54,"<p>I got product page with option to filter by size\model\price and sort.</p>&#xA;<p>I did succeed make this work but with like 5-6 useEffect and it looks very massy.</p>&#xA;<p>I need some hints on how to make it work without 5-6 useEffects because I tried really hard and didnt make it.</p>&#xA;<p>I am using redux toolkit .</p>&#xA;<p>So filters values are coming from redux-store</p>&#xA;<pre><code>  const { size, brand, price, sort } = useSelector((state) =&gt; state.filter);&#xA;</code></pre>&#xA;<p>products data coming from my backend</p>&#xA;<pre><code>  const { loading, error, data } = useQuery(GET_PRODUCTS);&#xA;</code></pre>&#xA;<p>and this is how I did it with so many use effects...</p>&#xA;<pre><code> useEffect(() =&gt; {&#xA;    if (sort.length &gt; 0) {&#xA;      if (sort.includes('price-highest')) {&#xA;        setFilteredProducts((filteredList) =&gt;&#xA;          filteredList.slice().sort((a, b) =&gt; b.price - a.price)&#xA;        );&#xA;      } else {&#xA;        setFilteredProducts((filteredList) =&gt;&#xA;          filteredList.slice().sort((a, b) =&gt; a.price - b.price)&#xA;        );&#xA;      }&#xA;    }&#xA;  }, [data?.getProducts, sort, size, brand, price]);&#xA;&#xA;  useEffect(() =&gt; {&#xA;    if (size.length &gt; 0) {&#xA;      setFilteredProducts((list) =&gt;&#xA;        list.filter((product) =&gt; {&#xA;          return product.size.includes(Number(...size));&#xA;        })&#xA;      );&#xA;    }&#xA;  }, [data?.getProducts, data, size, brand, price]);&#xA;&#xA;  useEffect(() =&gt; {&#xA;    if (brand.length &gt; 0) {&#xA;      setFilteredProducts((list) =&gt;&#xA;        list.filter((product) =&gt; {&#xA;          return product.brand.includes(...brand);&#xA;        })&#xA;      );&#xA;    }&#xA;  }, [data?.getProducts, brand, size, price]);&#xA;&#xA;  useEffect(() =&gt; {&#xA;    if (price.length &gt; 0) {&#xA;      setFilteredProducts((list) =&gt;&#xA;        list.filter((product) =&gt; {&#xA;          return product.price &gt; price[0][0] &amp;&amp; product.price &lt; price[0][1];&#xA;        })&#xA;      );&#xA;    }&#xA;  }, [data?.getProducts, price, brand, size]);&#xA;</code></pre>&#xA;<p>redux filters:&#xA;<a href=""https://i.stack.imgur.com/8R9sQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8R9sQ.png"" alt=""enter image description here"" /></a></p>&#xA;",13574542,,13574542,2022-06-21 12:39:09,2022-06-21 13:12:13,Filtering products depends user choice,<javascript><reactjs><graphql><apollo-client>,1,0,0,2022-06-21 12:29:11
72725166,1,72756722,,0,262,"<p>I have a GraphQL query that will return purchase orders and the products that go with those purchase orders. I have set up two filters, the first being on the username that is associated with a purchase order, and another filter on the product name for products for the purchase orders.</p>&#xA;<p>If a user were to search for a particular product, I would like to only return orders that contain that product. At the moment, it still returns all purchase orders, but removes the product data that doesn't match the search criteria.</p>&#xA;<p>The database structure is a table that contains the purchase orders called <code>purchase_orders</code> and a purchase order products tables called <code>purchase_orders_products</code> that has a FK called <code>order_id</code> to the purchase order id field.</p>&#xA;<p>For example, in the response below, if <code>purchaseOrdersProductsOrderId.edges</code> is empty, I don't need to return the order data for <code>ThisIsUsername</code>.</p>&#xA;<p><strong>Schema</strong></p>&#xA;<pre class=""lang-py prettyprint-override""><code># region Integration Purchase Orders&#xA;class PurchasesProducts(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;        interfaces = (relay.Node,)&#xA;        filter_fields = {'product_name': ['icontains']}&#xA;&#xA;&#xA;class Purchases(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;    products = ArtsyConnectionField(PurchasesProducts)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders&#xA;        interfaces = (relay.Node,)&#xA;        filter_fields = {'date': ['gt', 'lt', 'isnull'], 'username': ['icontains'],}&#xA;        connection_class = ArtsyConnection&#xA;&#xA;    @staticmethod&#xA;    def resolve_products(self, info, **kwargs):&#xA;        return purchase_orders_products.objects.filter(order_id=self.id).order_by('product_name').all()&#xA;&#xA;class PurchasesQuery(ObjectType):&#xA;    purchases = ArtsyConnectionField(Purchases)&#xA;    date_filter_list = graphene.List(graphene.List(graphene.String))&#xA;&#xA;    @staticmethod&#xA;    def resolve_date_filter_list(self, info, **kwargs):&#xA;        years = purchase_orders.objects.filter(user_id=info.context.user.id).annotate(year=ExtractYear('date'), month=ExtractMonth('date'),).order_by().values_list('year', 'month').order_by('-year', '-month').distinct()&#xA;        return years&#xA;&#xA;    @staticmethod&#xA;    def resolve_purchases(self, info, date_filter=None, **kwargs):&#xA;        return purchase_orders.objects.filter(user_id=info.context.user.id).all().order_by(&quot;-date&quot;)&#xA;&#xA;&#xA;purchasesSchema = graphene.Schema(query=PurchasesQuery)&#xA;# endregion&#xA;</code></pre>&#xA;<p><strong>Query</strong></p>&#xA;<pre><code>{&#xA;  dateFilterList&#xA;  purchases(first: 15, after: &quot;&quot;) {&#xA;    pageCursors {&#xA;      ...&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        ...&#xA;        products(productName_Icontains: &quot;access&quot;) {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              productId&#xA;              productName&#xA;              productNumber&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Response</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;dateFilterList&quot;: [&#xA;      ...&#xA;    ],&#xA;    &quot;purchases&quot;: {&#xA;      &quot;pageCursors&quot;: {&#xA;        ...&#xA;      },&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;ab0d9542-480a-4a99-8f49-3474e820beb0&quot;,&#xA;            &quot;username&quot;: &quot;ThisIsUsername&quot;,&#xA;            ...&#xA;            &quot;products&quot;: {&#xA;              &quot;edges&quot;: []&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;03e937b2-5b67-4161-90de-cdeda8dcd065&quot;,&#xA;            &quot;username&quot;: &quot;barry1234&quot;,&#xA;            ...&#xA;            &quot;products&quot;: {&#xA;              &quot;edges&quot;: [&#xA;                {&#xA;                  &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;f9945e45-59ef-42e9-9b06-988f24d1c8ed&quot;,&#xA;                    &quot;productId&quot;: &quot;84fae6ca-8a16-45ee-b36f-31a0ba134866&quot;,&#xA;                    &quot;productName&quot;: &quot;Access Denied&quot;,&#xA;                    &quot;productNumber&quot;: &quot;47&quot;&#xA;                  }&#xA;                }&#xA;              ]&#xA;            }&#xA;          }&#xA;        },&#xA;        ...&#xA;</code></pre>&#xA;",5429320,,5429320,2022-06-24 08:41:50,2022-06-25 19:40:59,"Django Graphene when filtering on nested value, don't show parent record if no data is returned",<python><python-3.x><django><graphql><graphene-python>,1,0,0,2022-06-23 05:54:09
72745659,1,,,0,13,"<p>Using schema stitching documentation it is not possible to achieve result for subschemas using namespaced types&#xA;<a href=""https://www.graphql-tools.com/docs/schema-stitching/stitch-combining-schemas"" rel=""nofollow noreferrer"">https://www.graphql-tools.com/docs/schema-stitching/stitch-combining-schemas</a></p>&#xA;<p>How should merge options be configured to get the desired result?</p>&#xA;<pre><code>#first schema&#xA;&#xA;type Post @key(selectionSet: &quot;{ id }&quot;) {&#xA;  id: String!&#xA;  comments: [Comment!]!&#xA;}&#xA;&#xA;type PostPayload {&#xA;  item: Post&#xA;}&#xA;&#xA;type PostsPayload {&#xA;  items: [Post!]&#xA;  pageInfo: PaginationInfo&#xA;}&#xA;&#xA;type PostQuery {&#xA;  getOne(where: PostWhereUniqueInput!): PostPayload!&#xA;  getList(filter: PostFilter = {} sort: [PostSort! ] = [{id: asc}] page: Int = 1 perPage: Int = 100): PostsPayload!&#xA;  getMany(ids: [ID!]!): PostsPayload! @merge(keyField: &quot;id&quot;)&#xA;}&#xA;&#xA;type Query {&#xA;  Post: PostQuery&#xA;}&#xA;...&#xA;&#xA;</code></pre>&#xA;<pre><code>###seciond schema&#xA;type Post @key(selectionSet: &quot;{ id }&quot;) {&#xA;  id: String!&#xA;  name: String!&#xA;}&#xA;&#xA;type PostPayload {&#xA;  item: Post&#xA;}&#xA;&#xA;type PostsPayload {&#xA;  items: [Post!]&#xA;  pageInfo: PaginationInfo&#xA;}&#xA;&#xA;type PostQuery {&#xA;  getOne(where: PostWhereUniqueInput!): PostPayload!&#xA;  getList(filter: PostFilter = {} sort: [PostSort! ] = [{id: asc}] page: Int = 1 perPage: Int = 100): PostsPayload!&#xA;  getMany(ids: [ID!]!): PostsPayload!  @merge(keyField: &quot;id&quot;)&#xA;}&#xA;&#xA;type Query {&#xA;  Post: PostQuery&#xA;}&#xA;...&#xA;</code></pre>&#xA;",11309453,,,,2022-06-24 14:35:09,Graphql-tools. Schema Stiching of namespaced types,<graphql><schema><graphql-tools>,0,0,0,2022-06-24 14:35:09
72756722,2,,72725166,1,,"<p>You should define filter for <code>product_name</code> at <code>Purchases</code> instead of <code>PurchaseProducts</code>. The most straightforward way to do it is defining <code>filterset_class</code>.&#xA;In my example, I have simplified a little bit queries and used <code>DjangoFilterConnectionField</code> because I dont know what is <code>ArtsyConnectionField</code>.</p>&#xA;<pre class=""lang-py prettyprint-override""><code>from django_filters import CharFilter, FilterSet&#xA;&#xA;class PurchaseOrderFilter(FilterSet):&#xA;    class Meta:&#xA;        model = purchase_orders&#xA;        fields = {'date': ['gt', 'lt', 'isnull'], 'username': ['icontains'],}&#xA;&#xA;    products__product_name = CharFilter(lookup_expr=&quot;icontains&quot;,)&#xA;&#xA;class PurchaseOrderProductFilter(FilterSet):&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;        fields = {&quot;name&quot;: [&quot;icontains&quot;]}&#xA;&#xA;class PurchasesProducts(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;        interfaces = (graphene.relay.Node,)&#xA;        filterset_class = PurchaseOrderProductFilter&#xA;&#xA;&#xA;class Purchases(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;    products = DjangoFilterConnectionField(PurchasesOrderProduct)&#xA;&#xA;    class Meta:&#xA;        model = purchases_orders&#xA;        interfaces = (graphene.relay.Node,)&#xA;        filterset_class = PurchaseOrderFilter&#xA;&#xA;    @staticmethod&#xA;    def resolve_products(self, info, **kwargs):&#xA;        return PurchaseOrderProduct.objects.filter(order_id=self.id).order_by('product_name').all()&#xA;</code></pre>&#xA;<p>Now your query would look like:</p>&#xA;<pre><code>query {&#xA;    purchases(first: 15, after: &quot;&quot;, products_ProductName: &quot;access&quot;) {&#xA;        edges {&#xA;            node {&#xA;                products {&#xA;                    edges {&#xA;                        node {&#xA;                            productName&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>And the response:</p>&#xA;<pre><code>{&#xA;    &quot;data&quot;: {&#xA;        &quot;purchases&quot;: {&#xA;            &quot;edges&quot;: [&#xA;                {&#xA;                    &quot;node&quot;: {&quot;products&quot;: {&quot;edges&quot;: [{&quot;node&quot;: {&quot;productName&quot;: &quot;access1&quot;}}]}}&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",7938435,,7938435,2022-06-25 19:40:59,2022-06-25 19:40:59,"",,0,0,0,2022-06-25 19:17:20
72779808,2,,72778279,0,,"<p>The answer was: strawberry.LazyType[&quot;Department&quot;, &quot;app.api.v1.definitions.department&quot;]</p>&#xA;",1314147,,,,2022-06-28 01:29:23,"",,0,0,0,2022-06-28 01:29:23
72782885,2,,72002566,0,,"<p>looks like everything are ok with your default value.&#xA;It's work&#xA;I think you should search for an error in another place&#xA;<a href=""https://i.stack.imgur.com/VTNtg.png"" rel=""nofollow noreferrer"">request payload</a></p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {gql} from '@apollo/client';&#xA;&#xA;export const getQuery = gql`&#xA;    query getQuery($id: UUID!, $current: Boolean = true) {&#xA;        myQuery(id: $id) {&#xA;            id&#xA;            name&#xA;            versions (current: $current) {&#xA;                id&#xA;            }&#xA;        }&#xA;    }`;</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",6898091,,,,2022-06-28 08:10:14,"",,0,0,0,2022-06-28 08:10:14
72802504,2,,72787729,0,,<p>Converting the fragment back to a string and then wrapping in gql works.</p>&#xA;<pre><code>import * as graphql from 'graphql';&#xA;&#xA;fragment = gql`${graphql.print(MMovieConnectionFragmentDoc)}`;&#xA;&#xA;gql`query myQuery {&#xA;        myQuery {&#xA;            ...myFragmentName&#xA;        }&#xA;    }&#xA;    ${fragment}&#xA;`;&#xA;</code></pre>&#xA;,464435,,,,2022-06-29 13:46:27,"",,0,0,0,2022-06-29 13:46:27
72804177,2,,72804058,0,,"<p>I found the issue. It was not a matter of the order in which things were wrapped but rather <strong>that I had the declaration for the sendErrorEmail mutation OUTSIDE of a component that was wrapped with the Apollo Provider.</strong> I had it out floating in App.js, but when I moved the line to under <code>ErrorPrompt = () =&gt; {</code> the error was removed</p>&#xA;",18899735,,,,2022-06-29 15:35:34,"",,0,0,0,2022-06-29 15:35:34
72811747,1,,,0,47,"<p>I am using amplify cli having dynamo database along with GraphQL API. I have a sales model which keep sales record i.e sale amount along with the date. I want to aggregate the sales amount for each month in a year to show the sales statistics on a graph which show total sales made in each month over the year. Currently I am using GraphQL queries to query/search data from the backend.</p>&#xA;<p>Here is the model that I am using.</p>&#xA;<pre><code>type Sales @model @searchable @auth(rules: [{ allow: private }]) {&#xA;id: ID!   &#xA;userID: String! @index(name: &quot;byAdded&quot;, sortKeyFields: [&quot;createdAt&quot;])   &#xA;createdAt: AWSDateTime!   &#xA;saleAmount: Float&#xA;}&#xA;</code></pre>&#xA;<p>Here is the example usage of graphQL query that I am currently using to get a aggregated amount for the whole year.</p>&#xA;<pre><code>await API.graphql(&#xA;        graphqlOperation(searchSales, {&#xA;          filter: {&#xA;            and: [&#xA;              { userID: { eq: userId } },&#xA;              { createdAt: { range:[&quot;2022-01-01&quot;, &quot;2022-12-31&quot;] } },&#xA;            ],&#xA;          },&#xA;          aggregates: {&#xA;            type: 'sum',&#xA;            field: 'saleAmount',&#xA;            name: 'totalSales',&#xA;          },&#xA;        }),&#xA;      );&#xA;</code></pre>&#xA;<p>Currenty Query result:</p>&#xA;<pre><code>{&quot;aggregateItems&quot;: [{&quot;name&quot;: &quot;totalSales&quot;, &quot;result&quot;: {&quot;value&quot;: 4608} }], &quot;nextToken&quot;: &quot;WyIwZTUyNmY2JkMjUiXQ==&quot;, &quot;total&quot;: 7}&#xA;</code></pre>&#xA;<p>I want to have a result like following:</p>&#xA;<pre><code>aggregations : { jan: 234, feb: 343, march: 3465, ...... } &#xA;</code></pre>&#xA;",5738449,,5738449,2022-06-30 07:32:55,2022-06-30 07:32:55,Is there any way to aggregate a model based on date range (i.e monthly aggregation) on dynamo db with graphql?,<javascript><amazon-ec2><graphql><amazon-dynamodb><aws-amplify>,0,0,0,2022-06-30 07:19:33
72818948,2,,72805691,0,,"<p>The prisma <a href=""https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting#sorting"" rel=""nofollow noreferrer"">docs</a> don't mention the ability for using <code>CASE</code> in the <code>orderBy</code> clause.</p>&#xA;<p>I have found some issues which seem to discuss this functionality or workaround.</p>&#xA;<ol>&#xA;<li>This issue seems to be what you're searching for however it's not so clear from the title. <a href=""https://github.com/prisma/prisma/issues/10335"" rel=""nofollow noreferrer"">https://github.com/prisma/prisma/issues/10335</a></li>&#xA;<li>This is in the archived prisma repo with a more precise title <a href=""https://github.com/prisma/specs/issues/128"" rel=""nofollow noreferrer"">https://github.com/prisma/specs/issues/128</a></li>&#xA;<li>Computed fields may be able to solve this. It's not possible yet but it looks like it's on the top of the Prisma Client Extension epic <a href=""https://github.com/prisma/client-planning/issues/25"" rel=""nofollow noreferrer"">https://github.com/prisma/client-planning/issues/25</a>. You would then be able to add this computed field- which would pull in the <code>happeningAt</code> date or if not yet scheduled then the <code>creationAt</code>- and sort on it. <a href=""https://github.com/prisma/prisma/issues/3394"" rel=""nofollow noreferrer"">https://github.com/prisma/prisma/issues/3394</a></li>&#xA;<li>I guess using a prisma raw query would be another option <a href=""https://github.com/prisma/client-planning/issues/25"" rel=""nofollow noreferrer"">https://github.com/prisma/client-planning/issues/25</a>.</li>&#xA;<li>If you're not paginating you can sort with javascript after pulling the records from the database.</li>&#xA;<li>Even with paginating you can get all the records and follow option 5, but this may add a lot to your execution time (the reason you may be doing paginating to begin with)</li>&#xA;</ol>&#xA;",9530790,,9530790,2022-07-11 14:03:40,2022-07-11 14:03:40,"",,0,0,0,2022-06-30 16:11:11
72821579,1,,,0,266,"<p>I would like to retrieve data from an API, the problem is that it only returns 49 data each time.&#xA;I got the startCursor, hasNextPage and endCursor but I don't know how to tell the script to loop until hasNextPage=False based on the endCursor and thus have all the data for my request.&#xA;Here is the code:</p>&#xA;<pre><code>import requests&#xA;import json&#xA;&#xA;query = &quot;&quot;&quot;&#xA;    query {&#xA;      player(slug:&quot;lionel-andres-messi-cuccittini&quot;){&#xA;            cards(rarities:[limited]) {&#xA;                nodes {&#xA;                    slug&#xA;                    userOwnerWithRate {&#xA;                        from&#xA;        }&#xA;        }&#xA;      pageInfo{&#xA;        startCursor&#xA;        hasNextPage&#xA;        endCursor&#xA;    }&#xA;    }&#xA;    }&#xA;  }&#xA;&quot;&quot;&quot;&#xA;url = 'https://api.sorare.com/graphql/'&#xA;r = requests.post(url, json={'query': query})&#xA;json_data = json.loads(r.text)&#xA;print(json_data)&#xA;</code></pre>&#xA;<p>Do you have an idea to help me get all the pages of a request please?</p>&#xA;",19455222,,19455222,2022-07-01 10:27:00,2022-07-01 10:27:00,Python - API- pagination Graphql,<python><graphql>,0,3,0,2022-06-30 20:19:40
72835644,1,72886714,,4,422,"<p>Shopify recently announced <a href=""https://shopify.dev/api/shopifyql"" rel=""nofollow noreferrer"">ShopifyQL</a> for easier accessing of analytics data. However, I'm unclear of how to actually make a ShopifyQL call. They do include an <a href=""https://shopify.dev/api/shopifyql/example"" rel=""nofollow noreferrer"">example</a>.</p>&#xA;<pre><code>{&#xA;  # &quot;FROM sales SHOW total_sales BY month SINCE -1y UNTIL today&quot; passes a ShopifyQL query to the GraphQL query.&#xA;  shopifyqlQuery(query: &quot;FROM sales SHOW total_sales BY month SINCE -1y UNTIL today&quot;) {&#xA;    __typename&#xA;    ... on TableResponse {&#xA;      tableData {&#xA;        rowData&#xA;        columns {&#xA;          # Elements in the columns section describe which column properties you want to return.&#xA;          name&#xA;          dataType&#xA;          displayName&#xA;        }&#xA;      }&#xA;    }&#xA;    # parseErrors specifies that you want errors returned, if there were any, and which error properties you want to return.&#xA;    parseErrors {&#xA;      code&#xA;      message&#xA;      range {&#xA;        start {&#xA;          line&#xA;          character&#xA;        }&#xA;        end {&#xA;          line&#xA;          character&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>However, using the <a href=""https://shopify.dev/apps/tools/graphiql-admin-api"" rel=""nofollow noreferrer"">GraphiQL</a> tool to run the query hits a number of errors:</p>&#xA;<pre><code>{&#xA;  &quot;errors&quot;: [&#xA;    {&#xA;      &quot;message&quot;: &quot;Field 'shopifyqlQuery' doesn't exist on type 'QueryRoot'&quot;,&#xA;      &quot;locations&quot;: [&#xA;        {&#xA;          &quot;line&quot;: 3,&#xA;          &quot;column&quot;: 3&#xA;        }&#xA;      ],&#xA;      &quot;path&quot;: [&#xA;        &quot;query&quot;,&#xA;        &quot;shopifyqlQuery&quot;&#xA;      ],&#xA;      &quot;extensions&quot;: {&#xA;        &quot;code&quot;: &quot;undefinedField&quot;,&#xA;        &quot;typeName&quot;: &quot;QueryRoot&quot;,&#xA;        &quot;fieldName&quot;: &quot;shopifyqlQuery&quot;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>I also tried making an authenticated call with the example query above using my app's Node server, but ran into the same issues.</p>&#xA;<p>What am I missing here?</p>&#xA;",17026016,,,,2022-07-06 16:04:31,How to Make a ShopifyQL query?,<javascript><node.js><graphql><shopify>,1,0,0,2022-07-02 00:24:50
72839627,2,,71262491,0,,"<p>To use fragment with <strong>apollo-angular</strong> when querying the graphql server</p>&#xA;<p>create a variable like this</p>&#xA;<pre><code>POST_FIELDS = gql`&#xA;    fragment POST_FIELDS on Post {&#xA;      _id&#xA;      title&#xA;      content&#xA;      creator {&#xA;        _id&#xA;        name&#xA;        email&#xA;      }&#xA;      imageUrl&#xA;      updatedAt&#xA;    }&#xA;  `;&#xA;</code></pre>&#xA;<p>The explanation for above query is as follow -</p>&#xA;<ul>&#xA;<li><strong>POST_FIELDS</strong> - Name of fragment to be used</li>&#xA;<li><strong>Post</strong> - Defined schema name on your graphql server (Not on your frontend)</li>&#xA;<li>Rest of the inner fields of Post is the schema of post</li>&#xA;</ul>&#xA;<p><strong>Now use the fragment in your gql query like this</strong></p>&#xA;<pre><code>this._apolloClient.watchQuery&lt;any&gt;({&#xA;      query: gql`&#xA;        query FetchPosts($page: Int = 1) { // FetchPosts is the operation name&#xA;          posts(page: $page) { // posts is the resolver to execute on server&#xA;            posts { // Required response&#xA;              ...POST_FIELDS // Used the defined fragment&#xA;            }&#xA;            totalPosts // // Required response&#xA;          }&#xA;        }&#xA;        ${this.POST_FIELDS} // Injected the above defined fragment&#xA;      `,&#xA;      variables: {&#xA;        page: 1,&#xA;      },&#xA;      context: {&#xA;        headers: new HttpHeaders().set(&quot;Authorization&quot;, this.token), // Passed additional custom header along with the global headers&#xA;      },&#xA;    }).valueChanges.subscribe({&#xA;      next: (result: any) =&gt; {&#xA;        this.posts = result?.data?.posts.posts;&#xA;        this.loading = result.loading;&#xA;        this.error = result.error;&#xA;        console.log('Logging Fetch Posts Query----', this.posts, this.loading, this.error);&#xA;      }&#xA;    });&#xA;</code></pre>&#xA;<p><strong>Note</strong>: Do remove the comments from gql template literal query while using the exact code as explained above.</p>&#xA;<p>Hope this help you or somebody else.</p>&#xA;<p>Happy Coding! Thanks.</p>&#xA;",8568159,,,,2022-07-02 14:03:15,"",,0,0,0,2022-07-02 14:03:15
72852573,1,,,0,43,"<p>I am trying to get a list of all organizations in Github. I've created a script that goes through USERS where the type is Org but I'm only getting 900 records where it seems I should be getting 4 595 896 according to the user count summary.</p>&#xA;<p>Using the Github Graph QL. I use a loop in python to get the endCursor while the hasNextPage is True. But it seems like its only retrieving a portion of the results.</p>&#xA;<pre><code>query OrgList($endCursor: String) {&#xA;  search(query: &quot;type:org&quot;, type: USER, first: 100, after: $endCursor) {&#xA;    userCount&#xA;    pageInfo {&#xA;      hasNextPage&#xA;      endCursor&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        ... on Organization {&#xA;          id&#xA;          name&#xA;          email&#xA;          websiteUrl&#xA;          description&#xA;          updatedAt&#xA;          createdAt&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>But this only seems to give me 9 end cursors and the userCount is above 4 million</p>&#xA;",11062821,,,,2022-07-04 06:32:42,Github API V4 - get list of organizations,<python><graphql><github-api>,0,0,0,2022-07-04 06:32:42
72863366,2,,70107150,1,,"<p>Shopify will only show data on orders that are less than 60 days old. As you have stated &quot;first: 10&quot; you're asking for the first 10 orders on that store which are likely over 60 days old. Try getting the last 10 orders using the reverse boolean.</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>query {&#xA;  orders(first: 10, reverse:true) {&#xA;    edges {&#xA;      node {&#xA;        customerJourney {&#xA;          moments {&#xA;            ... on CustomerVisit {&#xA;              utmParameters {&#xA;                source&#xA;                campaign&#xA;                content&#xA;                medium&#xA;                term&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;",7572192,,,,2022-07-05 02:14:04,"",,0,0,0,2022-07-05 02:14:04
72875570,2,,72835849,1,,"<p>You're almost there, but there are two issues here:</p>&#xA;<ol>&#xA;<li><p><code>items</code> returns a Connection, which means you still need to include another set of curly braces to &quot;select&quot; which fields you'd like.</p>&#xA;</li>&#xA;<li><p>The GitHub ProjectsV2 API doesn't look like it supports selection of individual items yet, only paginating through a list of items. This means that what you actually want to use is something like:</p>&#xA;</li>&#xA;</ol>&#xA;<pre><code>query {&#xA;  node(id: \&quot;PROJECT_NODE_ID\&quot;) {&#xA;    ... on ProjectV2 {&#xA;      items(first: 10) {&#xA;        nodes {&#xA;          content {&#xA;            ... on DraftIssue {&#xA;              title&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;",5216923,,,,2022-07-05 21:10:12,"",,0,0,0,2022-07-05 21:10:12
72891610,1,,,0,296,"<p>I want to make nestjs graphql input type with refer to it self. so it can be nested object.</p>&#xA;<p>I want to do is</p>&#xA;<pre><code>type Tree = {&#xA;  [key: string]: Tree | string | number;&#xA;};&#xA;&#xA;// it can be like&#xA;const example1: Tree = {&#xA;  user: {&#xA;    name: 'foo',&#xA;  },&#xA;};&#xA;&#xA;//or&#xA;const example2: Tree = {&#xA;  id: {&#xA;    $eq: 1,&#xA;  },&#xA;};&#xA;</code></pre>&#xA;<p>Change it to graphql input type, but i can not figure out.</p>&#xA;<p>I tried to do is</p>&#xA;<pre class=""lang-js prettyprint-override""><code>@InputType()&#xA;export class TreeClass {&#xA;  @Field(() =&gt; TreeClass)&#xA;  @IsNotEmpty()&#xA;  tree: string;&#xA;}&#xA;&#xA;@InputType()&#xA;export class AddQsInput {&#xA;...&#xA;  @Field(() =&gt; TreeClass, { nullable: true })&#xA;  @IsNotEmpty()&#xA;  @IsOptional()&#xA;  filters?: any;&#xA;...&#xA;}&#xA;</code></pre>&#xA;<p>error like</p>&#xA;<p><code>GraphQLError: Cannot reference Input Object &quot;TreeClass&quot; within itself through a series of non-null fields: &quot;tree&quot;.</code></p>&#xA;",14491004,,,,2022-07-07 05:14:49,"Nestjs graphql, How to make refer to it self input type?",<typescript><graphql><nestjs><typescript-generics><nestjs-graphql>,1,0,0,2022-07-07 02:17:20
72893880,2,,72893753,0,,"<p>You need to use pagination as mentioned <a href=""https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/query-engine/order-pagination.html#pagination"" rel=""nofollow noreferrer"">here</a></p>&#xA;<pre><code>strapi.db.query('api::doctors').findMany({&#xA;  offset: 15, &#xA;  limit: 10,&#xA;});&#xA;</code></pre>&#xA;",1749403,,,,2022-07-07 07:31:04,"",,0,0,0,2022-07-07 07:31:04
72911211,1,,,0,55,"<p>I am working on a react project together with GraphQL.</p>&#xA;<p>I do query data for medical cases. However, I want to filter for cases, where the UpdateDate is max. 1 year old. How can I achieve this? It is a mongo database and the respective field is a Date format (no string)</p>&#xA;<p>This is my query:</p>&#xA;<pre><code>&#xA;export const getIssuesPaginationQuery = gql`&#xA;  query CaseManagerDashboard($options: CasePaginationArgsInput!) {&#xA;    pagination: getIssuesPagination(options: $options) {&#xA;      items {&#xA;        _id&#xA;        CaseNumber&#xA;        CaseNumberNormalized&#xA;        CreationDate&#xA;        UpdateDate&#xA;        AccidentDate&#xA;        SinglePerson {&#xA;          _id&#xA;          Firstname&#xA;          Lastname&#xA;          Birthday&#xA;          InvoiceCheck {&#xA;            CreationDate&#xA;          }&#xA;        }&#xA;        Clerks {&#xA;          _id&#xA;          Firstname&#xA;          Lastname&#xA;        }&#xA;      }&#xA;      totalCount&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/d2ZDM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d2ZDM.png"" alt=""pic"" /></a></p>&#xA;",13548393,,,,2022-07-08 12:11:41,GraphQL React 18: Filter Query for Date,<javascript><reactjs><graphql>,0,0,0,2022-07-08 12:11:41
72915643,1,,,0,119,"<p>I was using SvelteKit without the amazing <code>&quot;strict&quot;: true</code> in <code>tsconfig.json</code> until today.</p>&#xA;<p>I have this code generated (with <a href=""https://github.com/dotansimha/graphql-code-generator"" rel=""nofollow noreferrer"">codegen</a>) from a Graphql schema that I cannot change:</p>&#xA;<pre><code>export type PlayerListQuery = {&#xA;  __typename?: &quot;Query&quot;;&#xA;  playerList: {&#xA;    __typename?: &quot;PlayerConnection&quot;;&#xA;    edges?: Array&lt;{&#xA;      __typename?: &quot;PlayerEdge&quot;;&#xA;      cursor: any;&#xA;      node?: {&#xA;        __typename?: &quot;Player&quot;;&#xA;        name?: string | null;&#xA;        age?: number | null;&#xA;        id: string;&#xA;      } | null;&#xA;    } | null&gt; | null;&#xA;    pageInfo: {&#xA;      __typename?: &quot;PageInfo&quot;;&#xA;      hasNextPage: boolean;&#xA;      hasPreviousPage: boolean;&#xA;      startCursor?: any | null;&#xA;      endCursor?: any | null;&#xA;    };&#xA;  };&#xA;};&#xA;</code></pre>&#xA;<p>which comes from this:</p>&#xA;<pre><code>type PlayerConnection {&#xA;  totalCount: Int!&#xA;  pageInfo: PageInfo!&#xA;  edges: [PlayerEdge]&#xA;}&#xA;&#xA;type PlayerEdge {&#xA;  cursor: Cursor!&#xA;  node: Player&#xA;}&#xA;</code></pre>&#xA;<p>and I'm using it like this in Svelte:</p>&#xA;<pre class=""lang-html prettyprint-override""><code>{#each $store.data.playerList.edges || [] as { cursor, node } (cursor)}&#xA;  {node?.name || &quot;No name&quot;}&#xA;  &lt;br&gt;&#xA;  {node?.age || &quot;No age&quot;}&#xA;{:else}&#xA;  Empty array!&#xA;{/each}&#xA;</code></pre>&#xA;<p>Now with the <code>strict</code> option the error is:</p>&#xA;<pre><code>(parameter) cursor: any&#xA;Property 'cursor' does not exist on type '{ __typename?: &quot;PlayerEdge&quot; | undefined; cursor: any; node?: { __typename?: &quot;Player&quot; | undefined; name?: string | null | undefined; ... more ...; | undefined; } | null | undefined; } | null'.ts(2339)&#xA;</code></pre>&#xA;<p>both for <code>cursor</code> and <code>node</code> because it's right, they can be <code>null</code> or <code>undefined</code>.</p>&#xA;<p>What do you suggest to fix this?</p>&#xA;",10088259,,10088259,2022-07-08 18:43:14,2022-07-08 18:43:14,"Property 'cursor' does not exist on type X, null or undefined, using generated graphql type with Svelte #each",<javascript><typescript><graphql><svelte><svelte-3>,0,0,0,2022-07-08 18:33:45
72938985,2,,70933025,1,,"<p>There is a by-default limit set of maxTokens as <strong>15000</strong>, you can change it using below configuration:</p>&#xA;<pre><code>ParserOptions.setDefaultParserOptions(ParserOptions.newParserOptions().maxTokens(&lt;YOUR_NEW_VALUE&gt;).build());&#xA;</code></pre>&#xA;",2413271,,,,2022-07-11 12:57:19,"",,0,0,0,2022-07-11 12:57:19
72943965,2,,71499390,0,,"<p>Well... I'm not the best on GraphQL, but had the same question and found the answer that worked for me.</p>&#xA;<p>Try replacing:</p>&#xA;<pre><code>$orderBy: [EntriesOrderByOrderByClause!]) {&#xA;</code></pre>&#xA;<p>by:</p>&#xA;<pre><code>$orderBy: [EntriesOrderByRelationOrderByClause!]) {&#xA;</code></pre>&#xA;",19529534,,,,2022-07-11 19:53:57,"",,0,0,0,2022-07-11 19:53:57
72949492,1,,,0,198,"<p>Context:</p>&#xA;<p>I am trying to query for all notifications sent or received by a user in my mobile app, and am getting results that (I think) show that AWS AppSync's OR filtering is slightly broken (or that I do not understand how it works)</p>&#xA;<p>Note that I am performing these queries using AWS AppSync Queries, but the results are consistent when using their GUI or by sending the queries from the React Native app</p>&#xA;<p>Here is my list query using the OR statement</p>&#xA;<pre><code>query listAllNotifsForUser {&#xA;  listNotifications(filter: {sentUserID: {eq: &quot;arbitrary-id-1&quot;}, or: {receivedUserID: {eq: &quot;arbitrary-id-1&quot;}}}) {&#xA;    items {&#xA;      id&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This query returns</p>&#xA;<pre><code>  &quot;data&quot;: {&#xA;&quot;listNotifications&quot;: {&#xA;  &quot;items&quot;: [],&#xA;  &quot;nextToken&quot;: null&#xA;}&#xA;</code></pre>&#xA;<p>Here is my query when listing specifically notifications that have the sentUserID equal to arbitrary-id-1 (no OR statement, only the first half of the OR filter from above)</p>&#xA;<pre><code>query listAllNotifsForUser {&#xA;  listNotifications(filter: {sentUserID: {eq: &quot;arbitrary-id-1&quot;}}) {&#xA;    items {&#xA;      id&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>and here is the result from that query</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;listNotifications&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;id&quot;: &quot;88d204c8-7346-4f69-bc6a-c1e5db1ce5f4&quot;&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;29e03351-75f0-46b2-933b-c3cca43a6067&quot;&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;e21cf81a-7cb3-4331-90af-6ef266f75820&quot;&#xA;        },&#xA;        {&#xA;          &quot;id&quot;: &quot;17b42150-ae7c-4852-a58c-85d73ed2e247&quot;&#xA;        }&#xA;      ],&#xA;      &quot;nextToken&quot;: null&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Notice the ONLY difference between these two queries is the removal of the 'or' and the second half of the boolean check, which from basic knowledge of programming, one would not imagine this should ever limit the results compared to a single boolean statement</p>&#xA;<p>Any thoughts?</p>&#xA;",10747873,,,,2022-07-12 14:12:52,Why does this AWS AppSync list operation using OR return an empty list even when part of the OR returns truthy values?,<graphql><aws-amplify><boolean-logic><aws-appsync>,1,0,0,2022-07-12 08:50:37
72950387,1,,,1,144,"<p>Creating and maintaining <code>graphql.schema</code> which includes all Queries, Mutations, relations, filters, etc. is not easy to be done manually.&#xA;Is there a tool I can use to generate <code>graphql.schema</code> from model objects or database schema, or type?<br />&#xA;the tools I found so far do not generate schema, or does not generate interface, or their filter are lacking many attributes such as <code>gte lte notIn cursor, etc.</code></p>&#xA;<p>currently found resources:&#xA;graphback, relay, apollo, dgs, ts-graphql</p>&#xA;",3705055,,,,2022-07-12 09:54:37,How to generate graphql.schema from models?,<graphql><apollo><graphql-js><relay><prisma-graphql>,0,0,0,2022-07-12 09:54:37
72953772,2,,72949492,0,,"<p>I did this on my AppSync console and it worked:</p>&#xA;<pre><code>query MyQuery {&#xA;  listJobListings(filter: {or: [{ city: {eq: &quot;Chongqing City&quot;} }, { city: {eq: &quot;Beijing&quot;} }]}) {&#xA;    nextToken&#xA;    items {&#xA;      city&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Which means you'll need to do this:</p>&#xA;<pre><code>query listAllNotifsForUser {&#xA;  listNotifications(filter: {or: [{ sentUserID: {eq: &quot;user-id&quot;} }, { sentUserID: {eq: &quot;user-id&quot;} }]}) {&#xA;    items {&#xA;      id&#xA;    }&#xA;    nextToken&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>More information <a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#compound-filters"" rel=""nofollow noreferrer"">here</a></p>&#xA;",19206079,,,,2022-07-12 14:12:52,"",,0,0,0,2022-07-12 14:12:52
72954232,1,,,2,66,"<p>There's a situation where there are two possible types to fill <code>data</code> property. I have made a <code>union</code> type for that (<code>ComponentItem</code>) to determine which field needs to be returned. The first schema (<code>ComponentItem1</code>) should just be a hardcoded list but the second one (<code>ComponentItem2</code>) is more dynamic where it gets a <code>searchTerm</code> from query and it actually calls an endpoint to fill the <code>list</code> and also has <code>hasNextPage</code> property.</p>&#xA;<p>Here are the schemas I made:</p>&#xA;<pre><code>type Component {&#xA;  id&#xA;  title&#xA;  data: ComponentItem&#xA;}&#xA;</code></pre>&#xA;<pre><code>union ComponentItem = ComponentItem1 | ComponentItem2&#xA;</code></pre>&#xA;<pre><code>type ComponentItem1 {&#xA;    list: [List!]!&#xA;}&#xA;&#xA;type ComponentItem2 {&#xA;    hasNextPage: Boolean;&#xA;    list: [List!]!&#xA;}&#xA;</code></pre>&#xA;<p>In the resolver I'm resolving the union type in order to generate proper <code>__typename</code>:</p>&#xA;<pre><code>const resolver: {&#xA;    ComponentItem: {&#xA;        __resolveType(object) {&#xA;            if(object.searchTerm){&#xA;               return &quot;ComponentItem2&quot;&#xA;            }&#xA;            return &quot;ComponentItem1&quot;&#xA;        },&#xA;    },&#xA;}&#xA;</code></pre>&#xA;<p>What I'm currently doing is to resolve the <code>list</code> and <code>hasNextPage</code> individually but in this scenario I'm sending the request to the same endpoint twice.</p>&#xA;<pre><code>const resolver = {&#xA;   ...resolver,&#xA;   ComponentItem2: {&#xA;     list: async (root, __, context) =&gt; {&#xA;         const result = await fetch('search-endpoint')&#xA;         return result?.items || []&#xA;     }&#xA;     hasNextPage: async (root, __, context) =&gt; {&#xA;         const result = await fetch('search-endpoint')&#xA;         return result?.hasNextPage || false&#xA;     }&#xA;&#xA;   }&#xA;   &#xA;}&#xA;</code></pre>&#xA;<p>My question is how it is possible to share that result in another field resolver (Other than using &quot;context&quot;). Or if there's any better way to handle this situation let me know.</p>&#xA;",6798783,,6798783,2022-07-12 18:02:54,2022-07-12 18:02:54,Resolve two GraphQL schema fields using one endpoint,<javascript><node.js><reactjs><graphql><apollo>,0,1,0,2022-07-12 14:46:19
72955361,1,,,0,25,"<p>I get data as ordered by some criteria.</p>&#xA;<pre><code>export default {&#xA;  Query: {&#xA;    seeAllFeedOrder: protectedResolver(() =&gt; {&#xA;&#xA;return client.user.findMany({&#xA;    orderBy: {&#xA;      feeds: {&#xA;        _count: &quot;desc&quot;,&#xA;      },&#xA;    },&#xA;</code></pre>&#xA;<p>and this data is ordered as below.&#xA;as you can see it descends by number.</p>&#xA;<p><a href=""https://i.stack.imgur.com/v7xno.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/v7xno.png"" alt=""enter image description here"" /></a></p>&#xA;<p>But when I get data from front-end by using <code>useQuery</code>.</p>&#xA;<p>(I search and fetchPolicy can remain the order, so I put, but it doesn't work either.)</p>&#xA;<pre><code>     const { data: allFeedData, loading: allFeedLoading } = useQuery(&#xA;        SEE_ALL_FEED_ORDER,&#xA;        {&#xA;          fetchPolicy: &quot;cache-and-network&quot;,&#xA;        }&#xA;      );&#xA;</code></pre>&#xA;<p>result order is broken. (1-&gt;2-&gt;1)&#xA;Then it's meaningless to use order in <code>backend</code>.</p>&#xA;<pre><code>Object {&#xA;  &quot;seeAllLikeOrder&quot;: Array [&#xA;    Object {&#xA;      &quot;directFeedNumber&quot;: 1,&#xA;    },&#xA;    Object {&#xA;      &quot;directFeedNumber&quot;: 2,&#xA;    },&#xA;    Object {&#xA;      &quot;directFeedNumber&quot;: 1,&#xA;    },&#xA;  ],&#xA;}&#xA;</code></pre>&#xA;<p>Should I order the fetched data again in frontend...?</p>&#xA;",17653656,,,,2022-07-12 16:13:52,Prisma & gql : order is broken when I get data from frontend via useQuery,<graphql><prisma>,0,1,0,2022-07-12 16:13:52
72956492,2,,72017223,1,,"<p>This is what I could figure out so far, the Documentation for SearchNode is missing, but I could get id's for events:</p>&#xA;<pre><code>query($filter: SearchConnectionFilter!) {&#xA;    keywordSearch(filter: $filter) {&#xA;      count&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          id&#xA;          &#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>Input JSON:</p>&#xA;<pre><code>{ &quot;filter&quot; : { &#xA;    &quot;query&quot; : &quot;party&quot;, &#xA;    &quot;lat&quot; : 43.8, &#xA;    &quot;lon&quot; : -79.4, &quot;radius&quot; : 100,&#xA;    &quot;source&quot; : &quot;EVENTS&quot; &#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Hope that helps. Trying to figure out this new GraphQL API</p>&#xA;",7703572,,7703572,2022-07-12 18:39:11,2022-07-12 18:39:11,"",,0,1,0,2022-07-12 17:51:52
72960936,1,,,0,21,"<p>I'm working on a schema right now and I'm wondering if it makes sense to add pagination (specifically, cursor pagination) to an object's field. For example:</p>&#xA;<pre><code>type User {&#xA;   friends(first: Int, after: String): FriendConnection!&#xA;}&#xA;</code></pre>&#xA;<p>However, if there is a query that returns multiple users then adding an <code>after</code> cursor to the <code>User</code>'s <code>friends</code> field would not make sense, since the <code>after</code> cursor would only be relevant for a single user. Should pagination only be used at top level queries?</p>&#xA;",12265645,,,,2022-07-13 04:24:32,Should I add pagination to GraphQL object fields?,<graphql><pagination><graphql-schema>,0,0,0,2022-07-13 04:24:32
72965895,1,,,0,110,"<p>Hi I have nested/subquery query inside SQL server and I want to extract data using GraphQL&#xA;Is it possible to create a subquery  inside Banana cake pop(GraphQL) tool ,</p>&#xA;<p>My query (normal)</p>&#xA;<pre><code>query{&#xA;  configuration    &#xA;  (take: 100 skip: 1000 where: {name:{eq:&quot;viewassets&quot;},value:{eq:&quot;1&quot;}} ) {&#xA;    items{&#xA;      userID&#xA;    }pageInfo {&#xA;      hasNextPage&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",17366304,,17366304,2022-07-13 11:59:16,2022-07-13 11:59:16,Nested/Subquery Query inside Banana cake pop (GraphQL tool),<sql-server><graphql>,0,0,0,2022-07-13 11:57:40
72966091,2,,72965146,0,,"<p>Ok I fixed this.&#xA;For those who wondering, I added to my query this:</p>&#xA;<pre><code> if (price.length &gt; 0) {&#xA;        query.price = { $gte: price[0], $lte: price[1] };&#xA;      }&#xA;</code></pre>&#xA;<p>and</p>&#xA;<pre><code>products = await Product.find(query).sort().skip(skip).limit(limit);&#xA;</code></pre>&#xA;",13574542,,,,2022-07-13 12:11:53,"",,0,0,0,2022-07-13 12:11:53
72989646,1,73095279,,2,394,"<p>I have a GraphQL schema that returns orders and the products that are part of that order. I have added a filter to return only orders that contains products searched for by the user. This filter is done on a <code>icontains</code>.</p>&#xA;<p>However I have found that if a user searches for <code>angel</code> for example, and an order contains two or more products that contain the string <code>angel</code> it returns the order that many times duplicating the records returned to the frontend.</p>&#xA;<p><strong>Query:</strong></p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  dateFilterList&#xA;  Purchases(first: 15, after: &quot;&quot;, username_Icontains: &quot;&quot;, PurchaseOrdersProductsOrderId_ProductName: &quot;angel&quot;) {&#xA;    pageCursors {&#xA;      previous {&#xA;        cursor&#xA;      }&#xA;      first {&#xA;        cursor&#xA;        page&#xA;      }&#xA;      around {&#xA;        cursor&#xA;        isCurrent&#xA;        page&#xA;      }&#xA;      last {&#xA;        cursor&#xA;        page&#xA;      }&#xA;      next {&#xA;        cursor&#xA;      }&#xA;    }&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        cmOrderId&#xA;        username&#xA;        date&#xA;        articles&#xA;        merchandiseValue&#xA;        shippingValue&#xA;        trusteeValue&#xA;        totalValue&#xA;        products {&#xA;          edges {&#xA;            node {&#xA;              id&#xA;              productId&#xA;              productName&#xA;              productNumber&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p><strong>Json Response:</strong></p>&#xA;<pre class=""lang-json prettyprint-override""><code>{&#xA;  &quot;data&quot;: {&#xA;  ...&#xA;  &quot;purchases&quot;: {&#xA;    ...&#xA;      &quot;edges&quot;: [&#xA;        {&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;&quot;,&#xA;            &quot;cmOrderId&quot;: 12345,&#xA;            &quot;username&quot;: &quot;UserA&quot;,&#xA;            &quot;date&quot;: &quot;2022-06-29T16:38:51&quot;,&#xA;            &quot;articles&quot;: 40,&#xA;            &quot;merchandiseValue&quot;: &quot;&quot;,&#xA;            &quot;shippingValue&quot;: &quot;&quot;,&#xA;            &quot;trusteeValue&quot;: &quot;&quot;,&#xA;            &quot;totalValue&quot;: &quot;&quot;,&#xA;            &quot;products&quot;: {&#xA;              &quot;edges&quot;: [&#xA;                {&#xA;                  &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;&quot;,&#xA;                    &quot;productId&quot;: &quot;&quot;,&#xA;                    &quot;productName&quot;: &quot;Angel of Grace&quot;,&#xA;                    &quot;productNumber&quot;: &quot;1&quot;&#xA;                  }&#xA;                },&#xA;                {&#xA;                  &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;&quot;,&#xA;                    &quot;productId&quot;: &quot;&quot;,&#xA;                    &quot;productName&quot;: &quot;Angel of Sanctions&quot;,&#xA;                    &quot;productNumber&quot;: &quot;1&quot;&#xA;                  }&#xA;                },&#xA;                ...&#xA;              ]&#xA;            }&#xA;          },&#xA;          &quot;node&quot;: {&#xA;            &quot;id&quot;: &quot;&quot;,&#xA;            &quot;cmOrderId&quot;: 12345,&#xA;            &quot;username&quot;: &quot;UserA&quot;,&#xA;            &quot;date&quot;: &quot;2022-06-29T16:38:51&quot;,&#xA;            &quot;articles&quot;: 40,&#xA;            &quot;merchandiseValue&quot;: &quot;&quot;,&#xA;            &quot;shippingValue&quot;: &quot;&quot;,&#xA;            &quot;trusteeValue&quot;: &quot;&quot;,&#xA;            &quot;totalValue&quot;: &quot;&quot;,&#xA;            &quot;products&quot;: {&#xA;              &quot;edges&quot;: [&#xA;                {&#xA;                  &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;&quot;,&#xA;                    &quot;productId&quot;: &quot;&quot;,&#xA;                    &quot;productName&quot;: &quot;Angel of Grace&quot;,&#xA;                    &quot;productNumber&quot;: &quot;1&quot;&#xA;                  }&#xA;                },&#xA;                {&#xA;                  &quot;node&quot;: {&#xA;                    &quot;id&quot;: &quot;&quot;,&#xA;                    &quot;productId&quot;: &quot;&quot;,&#xA;                    &quot;productName&quot;: &quot;Angel of Sanctions&quot;,&#xA;                    &quot;productNumber&quot;: &quot;1&quot;&#xA;                  }&#xA;                },&#xA;                ...&#xA;              ]&#xA;            }&#xA;          },&#xA;          ...&#xA;</code></pre>&#xA;<p><strong>Schema:</strong></p>&#xA;<pre class=""lang-py prettyprint-override""><code># region Integration Purchase Orders&#xA;class PurchaseOrderFilter(FilterSet):&#xA;    class Meta:&#xA;        model = purchase_orders&#xA;        fields = {'date': ['gt', 'lt', 'isnull'], 'username': ['icontains'],}&#xA;&#xA;    purchase_orders_products_order_id__product_name = CharFilter(lookup_expr=&quot;icontains&quot;)&#xA;&#xA;&#xA;class PurchaseOrderProductFilter(FilterSet):&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;        fields = {&quot;product_name&quot;: [&quot;icontains&quot;]}&#xA;&#xA;&#xA;class PurchasesProducts(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders_products&#xA;        interfaces = (graphene.relay.Node,)&#xA;        filterset_class = PurchaseOrderProductFilter&#xA;&#xA;&#xA;class Purchases(DjangoObjectType):&#xA;    id = graphene.ID(source='pk', required=True)&#xA;    products = DjangoFilterConnectionField(PurchasesProducts)&#xA;&#xA;    class Meta:&#xA;        model = purchase_orders&#xA;        interfaces = (graphene.relay.Node,)&#xA;        filterset_class = PurchaseOrderFilter&#xA;        connection_class = ArtsyConnection&#xA;&#xA;    @staticmethod&#xA;    def resolve_products(self, info, **kwargs):&#xA;        return purchase_orders_products.objects.filter(order_id=self.id).order_by('product_name').all()&#xA;&#xA;&#xA;class PurchasesQuery(ObjectType):&#xA;    date_filter_list = graphene.List(graphene.List(graphene.String))&#xA;    purchases = ArtsyConnectionField(Purchases)&#xA;&#xA;    @staticmethod&#xA;    def resolve_date_filter_list(self, info, **kwargs):&#xA;        years = purchase_orders.objects.filter(user_id=info.context.user.id).annotate(year=ExtractYear('date'), month=ExtractMonth('date'), ).order_by().values_list('year', 'month').order_by('-year', '-month').distinct()&#xA;        return years&#xA;&#xA;    @staticmethod&#xA;    def resolve_purchases(self, info, **kwargs):&#xA;        return purchase_orders.objects.filter(user_id=info.context.user.id).all().order_by(&quot;-date&quot;)&#xA;&#xA;&#xA;PurchasesSchema = graphene.Schema(query=PurchasesQuery)&#xA;# endregion&#xA;</code></pre>&#xA;",5429320,,5429320,2022-07-15 15:58:10,2022-07-25 13:25:57,GraphQL query returning duplicate results,<python><python-3.x><graphql><graphene-python><graphene-django>,1,2,0,2022-07-15 06:02:57
72992404,2,,72893753,0,,<p>Doctors(pagination: {limit:-1 }){&#xA;........&#xA;}`;</p>&#xA;<p>To get all records you have to pass this in your graph query.&#xA;pagination: {limit:-1 }. That works for me</p>&#xA;,8888491,,,,2022-07-15 10:11:32,"",,0,0,0,2022-07-15 10:11:32
73071959,1,73072123,,1,88,"<p>The thing I'm doing here is fetching anime characters from anilist graphql api. The reason I've added a loop is so I could fetch data from a certain character id to a limit. For example 1-100. But I want to respect their API rate limits and so I'd like a way to limit my requests to 1 per second. Hence, I've used <code>setTimeout</code>, but I still got rate-limited from the API and using <code>setInterval</code> only keeps on looping it every 5 seconds. Like the same data gets fetched every 5 seconds.&#xA;Is there any way I can make it as I've mentioned?</p>&#xA;<p>My code:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const fs = require(&quot;fs&quot;);&#xA;const number = 3;&#xA;const axios = require(&quot;axios&quot;);&#xA;&#xA;async function fetchData() {&#xA;  for (let i = 1; i &lt;= number; i++) {&#xA;    const query = axios&#xA;      .post(&#xA;        &quot;https://graphql.anilist.co&quot;,&#xA;        {&#xA;          query: `query character(&#xA;                    $id: Int&#xA;                    $page: Int&#xA;                    $sort: [MediaSort]&#xA;                    $onList: Boolean&#xA;                    $withRoles: Boolean = false&#xA;                  ) {&#xA;                    Character(id: $id) {&#xA;                      id&#xA;                      name {&#xA;                        first&#xA;                        middle&#xA;                        last&#xA;                        full&#xA;                        native&#xA;                        userPreferred&#xA;                        alternative&#xA;                        alternativeSpoiler&#xA;                      }&#xA;                      image {&#xA;                        large&#xA;                      }&#xA;                      favourites&#xA;                      isFavourite&#xA;                      isFavouriteBlocked&#xA;                      description&#xA;                      age&#xA;                      gender&#xA;                      bloodType&#xA;                      dateOfBirth {&#xA;                        year&#xA;                        month&#xA;                        day&#xA;                      }&#xA;                      media(page: $page, sort: $sort, onList: $onList) @include(if: $withRoles) {&#xA;                        pageInfo {&#xA;                          total&#xA;                          perPage&#xA;                          currentPage&#xA;                          lastPage&#xA;                          hasNextPage&#xA;                        }&#xA;                        edges {&#xA;                          id&#xA;                          characterRole&#xA;                          voiceActorRoles(sort: [RELEVANCE, ID]) {&#xA;                            roleNotes&#xA;                            voiceActor {&#xA;                              id&#xA;                              name {&#xA;                                userPreferred&#xA;                              }&#xA;                              image {&#xA;                                large&#xA;                              }&#xA;                              language: languageV2&#xA;                            }&#xA;                          }&#xA;                          node {&#xA;                            id&#xA;                            type&#xA;                            isAdult&#xA;                            bannerImage&#xA;                            title {&#xA;                              userPreferred&#xA;                            }&#xA;                            coverImage {&#xA;                              large&#xA;                            }&#xA;                            startDate {&#xA;                              year&#xA;                            }&#xA;                            mediaListEntry {&#xA;                              id&#xA;                              status&#xA;                            }&#xA;                          }&#xA;                        }&#xA;                      }&#xA;                    }&#xA;                  }`,&#xA;          variables: {&#xA;            id: i,&#xA;            withRoles: false,&#xA;          },&#xA;        },&#xA;        {&#xA;          headers: {&#xA;            &quot;Content-Type&quot;: &quot;application/json&quot;,&#xA;          },&#xA;        }&#xA;      )&#xA;      .then((response) =&gt; {&#xA;        // console.log(response.data.data.Character)&#xA;        const jsonContent =&#xA;          JSON.stringify(response.data.data.Character, null, 4) + &quot;, &quot;;&#xA;&#xA;        fs.appendFile(&quot;./chars.json&quot;, jsonContent, function (err) {&#xA;          if (err) {&#xA;            return console.log(err);&#xA;          }&#xA;&#xA;          console.log(&quot;The file was saved!&quot;);&#xA;        });&#xA;      })&#xA;      .catch((error) =&gt; console.log(`Code: ${error}`, error));&#xA;  }&#xA;}&#xA;&#xA;fetchData();&#xA;</code></pre>&#xA;",19382271,,,,2022-07-23 19:28:11,set timer inside a loop for graphql query,<javascript><node.js><axios><graphql>,1,0,0,2022-07-21 19:57:17
73082905,2,,73079276,5,,<pre><code>{selection.name for field in info.selected_fields for selection in field.selections}&#xA;</code></pre>&#xA;,36433,,,,2022-07-22 15:42:56,"",,0,4,0,2022-07-22 15:42:56
73106968,2,,73101686,0,,"<p>I did it this way as below.</p>&#xA;<p>I am waiting for your opinions and I will leave it for others - maybe it will be useful to someone...</p>&#xA;<p><strong>Filter option types</strong></p>&#xA;<pre><code>import { registerEnumType } from '@nestjs/graphql';&#xA;&#xA;export enum FilterOption {&#xA;  Equals = 'Equals',&#xA;  NotEquals = 'NotEquals',&#xA;  Contains = 'Contains',&#xA;  NotContains = 'NotContains',&#xA;  In = 'In',&#xA;  NotIn = 'NotIn',&#xA;}&#xA;&#xA;registerEnumType(FilterOption, {&#xA;  name: 'FilterOption',&#xA;});&#xA;</code></pre>&#xA;<p><strong>Filter input (aggregates the filter when multiple filters)</strong></p>&#xA;<pre><code>import { Field, InputType } from '@nestjs/graphql';&#xA;import { FilterItemInput } from './filter-item.input';&#xA;&#xA;@InputType()&#xA;export class FilterInput {&#xA;    @Field(() =&gt; [FilterItemInput])&#xA;    public readonly items?: [FilterItemInput];&#xA;}&#xA;</code></pre>&#xA;<p><strong>Filter item (miltiple filtering)</strong></p>&#xA;<pre><code>import { Field, InputType } from '@nestjs/graphql';&#xA;import { FilterOption } from '../enums/filter-option';&#xA;&#xA;@InputType()&#xA;export class FilterItemInput {&#xA;    @Field()&#xA;    public readonly fieldName?: String;&#xA;&#xA;    @Field()&#xA;    public readonly value?: String;&#xA;&#xA;    @Field(() =&gt; FilterOption)&#xA;    public readonly filterOption: FilterOption&#xA;}&#xA;</code></pre>&#xA;<p><strong>Resolver</strong></p>&#xA;<pre><code>//FindAll&#xA;@Query(() =&gt; [Customer])&#xA;@Roles({roles: ['user']})&#xA;async customers(@Args('filter') filter: FilterInput) {&#xA;  const customers = await this.customerService.findAll(filter.items);&#xA;  return customers;&#xA;}&#xA;</code></pre>&#xA;<p><strong>Service</strong></p>&#xA;<pre><code>async findAll(filters: [FilterItemInput]): Promise&lt;Customer[]&gt; {&#xA;  &#xA;  var findFilters: Array&lt;any&gt; = [];&#xA;&#xA;  if(filters) {&#xA;    filters.forEach((filter) =&gt; {&#xA;      if(filter.filterOption == FilterOption.Equals)&#xA;        findFilters.push({[`${filter.fieldName}`] : {$eq: filter.value}})&#xA;      if(filter.filterOption == FilterOption.NotEquals)&#xA;        findFilters.push({[`${filter.fieldName}`] : {$ne: filter.value}})&#xA;      if(filter.filterOption == FilterOption.Contains)&#xA;        findFilters.push({[`${filter.fieldName}`] : {$regex: '.*' + filter.value, $options: 'i'}})&#xA;      if(filter.filterOption == FilterOption.NotContains)&#xA;        findFilters.push({[`${filter.fieldName}`] : { $not: {$regex:'.*' + filter.value + '.*', $options: 'i'} }})      &#xA;      if(filter.filterOption == FilterOption.In)&#xA;        findFilters.push({[`${filter.fieldName}`] : { $in: filter.value.split(',') }})&#xA;      if(filter.filterOption == FilterOption.NotIn)&#xA;        findFilters.push({[`${filter.fieldName}`] : { $nin: filter.value.split(',') }})&#xA;    })&#xA;  }&#xA;&#xA;  const filter = findFilters.reduce((a, v) =&gt; ({...a, ...v}), {});&#xA;  const query = this.customerModel.find(filter);&#xA;  return await query.exec();&#xA;}&#xA;</code></pre>&#xA;<p><strong>Query example</strong></p>&#xA;<pre><code>query allCustomers {&#xA;  customers(filter:{&#xA;    items: [&#xA;            {  &#xA;              fieldName: &quot;name&quot;,&#xA;              value: &quot;John,Alice,Johny,Robert&quot;,&#xA;              filterOption: In&#xA;            },&#xA;            {  &#xA;              fieldName: &quot;surname&quot;,&#xA;              value: &quot;d&quot;,&#xA;              filterOption: Contains&#xA;            },&#xA;            {  &#xA;              fieldName: &quot;customerType&quot;,&#xA;              value: &quot;BUSINESS&quot;,&#xA;              filterOption: Equals&#xA;            },&#xA;        &#xA;    ]&#xA;  }) {&#xA;    id, name, surname, customerType, customerStatus,&#xA;    addresses {id, city, street, addressType }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p><strong>Searching results</strong></p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;customers&quot;: [&#xA;      {&#xA;        &quot;id&quot;: &quot;62daea0e2cddf6617044f0c2&quot;,&#xA;        &quot;name&quot;: &quot;Alice&quot;,&#xA;        &quot;surname&quot;: &quot;Doe&quot;,&#xA;        &quot;customerType&quot;: &quot;BUSINESS&quot;,&#xA;        &quot;customerStatus&quot;: &quot;ACTIVE&quot;,&#xA;        &quot;addresses&quot;: []&#xA;      },&#xA;      {&#xA;        &quot;id&quot;: &quot;62dd5a7b25d2eb85ccf2db88&quot;,&#xA;        &quot;name&quot;: &quot;Johny&quot;,&#xA;        &quot;surname&quot;: &quot;Doe&quot;,&#xA;        &quot;customerType&quot;: &quot;BUSINESS&quot;,&#xA;        &quot;customerStatus&quot;: &quot;ACTIVE&quot;,&#xA;        &quot;addresses&quot;: []&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",10599107,,10599107,2022-07-25 10:16:16,2022-07-25 10:16:16,"",,0,0,0,2022-07-25 09:33:01
73116565,1,,,0,50,"<p>I am using the graphql playground client, and I am only getting back the first graphql response.  I am expecting multiple responses given the data set that I am querying, and I am receiving the first response.</p>&#xA;<pre><code>query($search: ServiceEntitySearch!, $cursor: CursorInput) {&#xA;  searchServiceEntities(search: $search, cursor: $cursor) {&#xA;    nodes {...&#xA;</code></pre>&#xA;<p>Query variables</p>&#xA;<pre><code>  &quot;search&quot;: {},&#xA;  &quot;cursor&quot;: {&#xA;    &quot;startCursor&quot;: null,&#xA;    &quot;endCursor&quot;: &quot;MTA0MTExMw==&quot;,&#xA;    &quot;hasNextPage&quot;: true,&#xA;    &quot;hasPreviousPage&quot;: false,&#xA;    &quot;forward&quot;: true,&#xA;    &quot;complexSort&quot;: null,&#xA;    &quot;pageSize&quot;: 100&#xA;  }&#xA;}```&#xA;</code></pre>&#xA;",19621298,,,,2022-07-26 00:17:54,Graphql playground cursor queries,<graphql><graphql-playground>,0,0,0,2022-07-26 00:17:54
73136229,2,,73040227,0,,"<p>Created a secondary index on the <code>Message</code> model with a sort field on <code>createdAt</code>.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>type Message @model {&#xA;  id: ID!&#xA;  authorId: String! @index(name: &quot;byAuthorId&quot;, queryField: &quot;getMessagesByAuthorId&quot;, sortKeyFields: [ &quot;createdAt&quot; ])&#xA;  content: String!&#xA;  conversation: Conversation @belongsTo&#xA;}&#xA;</code></pre>&#xA;<p>Amplify created a new query to fetch the messages and apply sorting. Following example uses react-query to fetch the messages from an <code>authorId</code> with sorting.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>export function useMessagesPerAuthorId({&#xA;  id,&#xA;  filter,&#xA;  enabled = true,&#xA;}: {&#xA;  id: string | undefined;&#xA;  filter: any;&#xA;  enabled?: boolean;&#xA;}) {&#xA;  return useQuery(&#xA;    ['conversations', 'messages', id, filter],&#xA;    () =&gt; fetchMessagesByAuthorId({ id: id!, filter }),&#xA;    { enabled: enabled &amp;&amp; !!id }&#xA;  );&#xA;}&#xA;&#xA;async function fetchMessagesByAuthorId({ id, filter }: { id: string; filter: any }) {&#xA;  const query: any = await API.graphql({&#xA;    query: getMessagesByAuthorId,&#xA;    variables: { authorId: id, sortDirection: 'DESC', filter },&#xA;  });&#xA;&#xA;  const data: Message[] = query.data?.getMessagesByAuthorId.items;&#xA;&#xA;  return data;&#xA;}&#xA;</code></pre>&#xA;<p>Now we can call that hook in our view component and pass the filters.</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const { isLoading, data: messages = [] } = useMessagesPerAuthorId({&#xA;    id: profile?.id,&#xA;    filter: {&#xA;      and: [{ conversationMessagesId: { eq: conversationId } }, { deleted: { eq: false } }],&#xA;    },&#xA;    enabled: !!profile?.id,&#xA;  });&#xA;</code></pre>&#xA;",1934484,,,,2022-07-27 10:22:20,"",,0,0,0,2022-07-27 10:22:20
73150895,1,,,0,97,"<p>I'm using the following code to merge 2 typesDefs to one:</p>&#xA;<pre><code>import { mergeTypeDefs } from '@graphql-tools/merge';&#xA;import topicsTypes from '../modules/topics/typeDefs';&#xA;import contentTypes from '../modules/content/typeDefs';&#xA;&#xA;const types = [contentTypes, topicsTypes];&#xA;&#xA;export default mergeTypeDefs(types)&#xA;</code></pre>&#xA;<p>When I run <code>graphql-schema-linter</code> I get an error:</p>&#xA;<p><code>22:1 The fields of object type </code>Query<code> should be sorted in alphabetical order. Expected sorting: contentAccessTokenByUUID, documentContent, documentTopics type-fields-sorted-alphabetically</code></p>&#xA;<p>I tried changing the order of the types in the array to <code>[topicsTypes, contentTypes];</code></p>&#xA;<p>But I get the same error, how can I force <code>mergeTypeDefs</code> to merge the defs alphabetically?</p>&#xA;",1850978,,,,2022-08-29 10:03:59,Graphql tools - mergeTypeDefs sort alphabetically,<graphql><graphql-tools>,1,0,0,2022-07-28 10:00:57
73186722,2,,71892457,0,,<pre><code>  &lt;div v-if=&quot;result &amp;&amp; result.posts&quot;&gt;&#xA;    &lt;p v-for=&quot;edge in result.posts.edges.node&quot; :key=&quot;edge.id&quot;&gt;&#xA;      {{ edge.title }}&#xA;    &lt;/p&gt;&#xA;  &lt;/div&gt;&#xA;</code></pre>&#xA;,7101865,,,,2022-07-31 20:32:13,"",,0,0,0,2022-07-31 20:32:13
73189240,1,73202582,,0,17,"<p>I'm using Strapi 4, and I try to add computed field to my custom resolver. (I'm not a graphql expert). I've followed this tutorial to do it.&#xA;<a href=""https://www.theitsolutions.io/blog/how-to-add-custom-graphql-query-to-strapi-v4"" rel=""nofollow noreferrer"">https://www.theitsolutions.io/blog/how-to-add-custom-graphql-query-to-strapi-v4</a></p>&#xA;<p>I’m also using the “<strong>toEntityResponseCollection</strong>” methods to send the datas and display it in graphql playground.</p>&#xA;<p>But, when I send it back, I get a null result.</p>&#xA;<p>Here is my custom resolver</p>&#xA;<pre><code>&#xA;&quot;use strict&quot;;&#xA;&#xA;module.exports =&#xA;  (strapi, toEntityResponseCollection, toEntityResponse) =&gt;&#xA;  ({ nexus }) =&gt; ({&#xA;    typeDefs: `&#xA;    type PopularityResponse {      &#xA;      id: ImpressionEntityResponseCollection&#xA;      startDate: String&#xA;      endDate: String&#xA;      branding: String&#xA;    }&#xA;&#xA;    extend type Query {&#xA;      popularity(id: ID!, startDate: String, endDate: String, branding: String): PopularityResponse&#xA;    }&#xA;  `,&#xA;    resolvers: {&#xA;      Query: {&#xA;        popularity: {&#xA;          resolve: async (parent, args, context) =&gt; ({&#xA;            id: args.id,&#xA;            startDate: args.startDate,&#xA;            endDate: args.endDate,&#xA;            branding: args.branding,&#xA;          }),&#xA;        },&#xA;      },&#xA;      PopularityResponse: {&#xA;        id: {&#xA;          resolve: async (parent, args) =&gt; {&#xA;            &#xA;            let query = {&#xA;              value: await strapi.entityService.findMany(&#xA;                &quot;api::impression.impression&quot;,&#xA;                {&#xA;                  filters: {&#xA;                    googleid: {&#xA;                      id: {&#xA;                        $eq: parent.id,&#xA;                      },&#xA;                    },&#xA;                    date_debut: {&#xA;                      $gte: parent.startDate,&#xA;                    },&#xA;                    date_fin: {&#xA;                      $lte: parent.endDate,&#xA;                    },&#xA;                  },&#xA;                },&#xA;                args&#xA;              ),&#xA;            };&#xA;            console.log(query.value);&#xA;            console.log(parent);&#xA;&#xA;            let aggregate = query.value.reduce(&#xA;              (acc, key) =&gt; {&#xA;                // vérifie si la campagne est dans la liste&#xA;                if (&#xA;                  [parent.branding].some((elem) =&gt; {&#xA;                    let reg = new RegExp(elem);&#xA;                    return reg.test(key.campaignName);&#xA;                  })&#xA;                ) {&#xA;                  let brandingIndex = acc.branding.findIndex(&#xA;                    (el) =&gt; el.date_debut == key.date_debut&#xA;                  );&#xA;                  if (brandingIndex !== -1) {&#xA;                    // si on a un élément&#xA;                    acc.branding[brandingIndex].search_impression_share +=&#xA;                      parseInt(key.search_impression_share);&#xA;                  } else {&#xA;                    acc.branding.push({&#xA;                      search_impression_share: parseInt(&#xA;                        key.search_impression_share&#xA;                      ),&#xA;                      date_debut: key.date_debut,&#xA;                    });&#xA;                  }&#xA;                } else {&#xA;                  let nobrandingIndex = acc.nobranding.findIndex(&#xA;                    (el) =&gt; el.date_debut == key.date_debut&#xA;                  );&#xA;                  if (nobrandingIndex !== -1) {&#xA;                    // si on a un élément&#xA;                    acc.nobranding[nobrandingIndex].search_impression_share +=&#xA;                      parseInt(key.search_impression_share);&#xA;                  } else {&#xA;                    acc.nobranding.push({&#xA;                      search_impression_share: parseInt(&#xA;                        key.search_impression_share&#xA;                      ),&#xA;                      date_debut: key.date_debut,&#xA;                    });&#xA;                  }&#xA;                }&#xA;&#xA;                return acc;&#xA;              },&#xA;              { branding: [], nobranding: [] }&#xA;            );&#xA;&#xA;            console.log(&quot;==========&gt;&gt;&gt;&gt;&quot;,aggregate);&#xA;&#xA;            let y = [query.value[0]];&#xA;&#xA;            return toEntityResponseCollection([aggregate]);&#xA;          },         &#xA;        },&#xA;      },&#xA;    },&#xA;    resolversConfig: {&#xA;      &quot;Query.popularity&quot;: {&#xA;        auth: {&#xA;          scope: [&#xA;            &quot;api::impression.impression.findOne&quot;,&#xA;            &quot;api::impression.impression.find&quot;,&#xA;          ],&#xA;        },&#xA;      },&#xA;    },&#xA;  });&#xA;</code></pre>&#xA;<p>Here is my graphql query</p>&#xA;<pre><code>query GetPopularity {&#xA;  popularity(id: &quot;37&quot;, startDate:&quot;2022-06-13&quot;,endDate:&quot;2022-07-15&quot;,branding:&quot;brand&quot;) {&#xA;    myData {&#xA;      data {&#xA;        attributes {&#xA;          googleid {&#xA;            data {&#xA;              attributes {&#xA;                g_customer_id&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>When I log the result ssr, I get my computed datas, but when I look at grapql Playground, I get null.</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;popularity&quot;: {&#xA;      &quot;id&quot;: {&#xA;        &quot;data&quot;: [&#xA;          {&#xA;            &quot;attributes&quot;: {&#xA;              &quot;search_impression_share&quot;: null,&#xA;              &quot;search_top_impression_share&quot;: null&#xA;            }&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I don't know what to do to make it work.&#xA;I do it like this, because I need to fetch a huge amount of datas. I know that strapi has a 100 limit result from graphql. Even if I can manualy increase it in the config file, I understand it's not a good practice.</p>&#xA;<p>If you have any idea how to solve this, please let me know.</p>&#xA;<p>Thanks</p>&#xA;<p>Fabien</p>&#xA;",9324489,,,,2022-08-02 05:57:02,Add computed field to graphql results within Strapi 4,<graphql><strapi>,1,0,0,2022-08-01 05:44:52
73195401,2,,73195073,1,,"<pre><code>update(cache, data) {&#xA;&#xA;        const comment = data.data.addComment;&#xA;        cache.writeFragment({&#xA;          fragment: commentFragment,&#xA;          data: comment,&#xA;          fragmentName: &quot;commentFragment&quot;,&#xA;        });&#xA;&#xA;        const gallery: Gallery = cache.readFragment({&#xA;          id: `Gallery:${comment.galleryId}`,&#xA;          fragment: galleryFragment,&#xA;          fragmentName: 'galleryFragment'&#xA;        });&#xA;        if (gallery) {    &#xA;          const newComments = [...gallery.comments, comment]&#xA;          cache.writeFragment({&#xA;            id: `Gallery:${comment.galleryId}`,&#xA;            fragment: galleryFragment,&#xA;            fragmentName: 'galleryFragment',&#xA;            data: { ...gallery, comments: newComments }&#xA;          });&#xA;        }&#xA;      }&#xA;</code></pre>&#xA;",1002995,,,,2022-08-01 14:38:59,"",,0,0,0,2022-08-01 14:38:59
73197982,1,,,0,333,"<p>I'm trying to create custom sorting for the product mutation.</p>&#xA;<p>Need a product sorting based on product ratings. Once i have override the \Magento\CatalogGraphql\SearchAdapter\Query\Builder\Sort. It throwing a error .</p>&#xA;<p>I have added the following line to</p>&#xA;<pre><code> $sorts[] = [&#xA;            $fieldName =&gt; [&#xA;                'order' =&gt; strtolower($item['direction']), 'unmapped_type' =&gt; 'long'&#xA;            ]&#xA;        ];&#xA;</code></pre>&#xA;<p>Please let me know how to add a custom sort in magento graphql (Elastic search)</p>&#xA;",3651637,,,,2022-08-01 18:19:30,Custom Sorting is not working in Magento 2.4.3-p1 - Product Graphql,<sorting><graphql><product><magento2><magento2.4>,0,0,0,2022-08-01 18:19:30
73200949,1,,,0,135,"<p>I'm trying to query order data in the past 7 days with graphql for shopify. My query successfully pulls all order data but I'm having trouble narrowing down the date range.</p>&#xA;<p>This query works for all data:</p>&#xA;<pre><code> const currentOrders = await client.query({&#xA;      data: {&#xA;        query: GET_ALL_LINE_ITEMS,&#xA;        variables: { endCursor },&#xA;      },&#xA;    });&#xA;&#xA;const GET_ALL_LINE_ITEMS = `&#xA;query storeOrders($endCursor: String) {&#xA;  orders(first:25, reverse:true, sortKey: CREATED_AT, after: $endCursor) {&#xA;    edges {&#xA;      node {&#xA;        lineItems(first: 10) {&#xA;          edges{&#xA;            node {&#xA;              name&#xA;              quantity&#xA;              variantTitle&#xA;              variant {&#xA;                id &#xA;                product {&#xA;                  id&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasNextPage, endCursor&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;&#xA;</code></pre>&#xA;<p>This is the query I've created to get the last 7 days:</p>&#xA;<pre><code>  let date = new Date();&#xA;  let sevenDaysAgo = date - 1000 * 60 * 60 * 24 * 1; &#xA;  sevenDaysAgo = new Date(sevenDaysAgo);&#xA;&#xA;  let dd = String(sevenDaysAgo.getDate()).padStart(2, &quot;0&quot;);&#xA;  let mm = String(sevenDaysAgo.getMonth() + 1).padStart(2, &quot;0&quot;); &#xA;  let yyyy = sevenDaysAgo.getFullYear();&#xA;&#xA;  sevenDaysAgo = yyyy + &quot;-&quot; + mm + &quot;-&quot; + dd;&#xA; &#xA;    const currentOrders = await client.query({&#xA;      data: {&#xA;        query: GET_ALL_LINE_ITEMS,&#xA;        variables: { endCursor, sevenDaysAgo },&#xA;      },&#xA;    });&#xA;&#xA;const GET_ALL_LINE_ITEMS = `&#xA;query storeOrders($endCursor: String) {&#xA;  orders(first:25, query:&quot;created_at:&gt;'$sevenDaysAgo'&quot;, reverse:true, sortKey: CREATED_AT, after: $endCursor) {&#xA;    edges {&#xA;      node {&#xA;        lineItems(first: 10) {&#xA;          edges{&#xA;            node {&#xA;              name&#xA;              quantity&#xA;              variantTitle&#xA;              variant {&#xA;                id &#xA;                product {&#xA;                  id&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasNextPage, endCursor&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;</code></pre>&#xA;<p>It runs, however, the date is not respected and results before the request date are shown.</p>&#xA;<p>This is what the <a href=""https://shopify.dev/api/admin-graphql/2022-07/queries/orders#examples-Get_the_first_10_orders_updated_after_December_1__2019"" rel=""nofollow noreferrer"">Shopify docs</a> says:</p>&#xA;<pre><code>{&#xA;  orders(first: 10, query:&quot;created_at:&gt;2019-12-01&quot;) {&#xA;    edges {&#xA;      node {&#xA;        id&#xA;        updatedAt&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>How do I pull all graphql results after a given date?</p>&#xA;<p>EDIT:</p>&#xA;<p>Doing the following query works to this tells me it is an issue with the variable:</p>&#xA;<pre><code>const GET_ALL_LINE_ITEMS = `&#xA;query storeOrders($endCursor: String) {&#xA;  orders(first:25, query:&quot;updated_at:&gt;2019-12-01&quot;, reverse:true, sortKey: CREATED_AT, after: $endCursor) {&#xA;    edges {&#xA;      node {&#xA;        lineItems(first: 10) {&#xA;          edges{&#xA;            node {&#xA;              name&#xA;              quantity&#xA;              variantTitle&#xA;              variant {&#xA;                id &#xA;                product {&#xA;                  id&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    pageInfo {&#xA;      hasNextPage, endCursor&#xA;    }&#xA;  }&#xA;}&#xA;`;&#xA;&#xA;&#xA;</code></pre>&#xA;",17026016,,17026016,2022-08-02 01:02:40,2022-08-02 21:20:27,How Do I Query 7 Days Ago in Shopify Graphql?,<node.js><graphql><shopify>,1,0,0,2022-08-02 00:56:26
73202582,2,,73189240,0,,"<p>I found how to solve my issue.&#xA;I’ve created a specific type which aggregate the datas.&#xA;Now I’m able to fetch my computed elements.</p>&#xA;<pre><code>&quot;use strict&quot;;&#xA;&#xA;module.exports =&#xA;  (strapi, toEntityResponseCollection, toEntityResponse) =&gt;&#xA;  ({ nexus }) =&gt; ({&#xA;    typeDefs: `&#xA;    type PopularityResponse {      &#xA;      id: ImpressionEntityResponseCollection&#xA;      startDate: String&#xA;      endDate: String&#xA;      branding: String&#xA;      aggregated: aggregateInput&#xA;    }&#xA;&#xA;    type aggregateInput {&#xA;      brand: [singleAggregate]&#xA;      nobrand: [singleAggregate]&#xA;    }&#xA;&#xA;    type singleAggregate {&#xA;      date_debut: String&#xA;      search_impression_share: Int&#xA;    }&#xA;&#xA;    extend type Query {&#xA;      popularity(id: ID!, startDate: String, endDate: String, branding: String): PopularityResponse&#xA;    }&#xA;  `,&#xA;    resolvers: {&#xA;      Query: {&#xA;        popularity: {&#xA;          resolve: async (parent, args, context) =&gt; ({&#xA;            id: args.id,&#xA;            startDate: args.startDate,&#xA;            endDate: args.endDate,&#xA;            branding: args.branding,&#xA;          }),&#xA;        },&#xA;      },&#xA;      PopularityResponse: {&#xA;        aggregated: {&#xA;          resolve: async (parent, args, ctx) =&gt; {&#xA;            let compile = await strapi.entityService.findMany(&#xA;              &quot;api::impression.impression&quot;,&#xA;              {&#xA;                filters: {&#xA;                  googleid: {&#xA;                    id: {&#xA;                      $eq: parent.id,&#xA;                    },&#xA;                  },&#xA;                  date_debut: {&#xA;                    $gte: parent.startDate,&#xA;                  },&#xA;                  date_fin: {&#xA;                    $lte: parent.endDate,&#xA;                  },&#xA;                },&#xA;              },&#xA;              args&#xA;            );&#xA;&#xA;            // console.log(compile);&#xA;&#xA;            let aggregate = compile.reduce(&#xA;              (acc, key) =&gt; {&#xA;                // vérifie si la campagne est dans la liste&#xA;                if (&#xA;                  [parent.branding].some((elem) =&gt; {&#xA;                    let reg = new RegExp(elem);&#xA;                    return reg.test(key.campaignName);&#xA;                  })&#xA;                ) {&#xA;                  let brandingIndex = acc.branding.findIndex(&#xA;                    (el) =&gt; el.date_debut == key.date_debut&#xA;                  );&#xA;                  if (brandingIndex !== -1) {&#xA;                    // si on a un élément&#xA;                    acc.branding[brandingIndex].search_impression_share +=&#xA;                      parseInt(key.search_impression_share);&#xA;                  } else {&#xA;                    acc.branding.push({&#xA;                      search_impression_share: parseInt(&#xA;                        key.search_impression_share&#xA;                      ),&#xA;                      date_debut: key.date_debut,&#xA;                    });&#xA;                  }&#xA;                } else {&#xA;                  let nobrandingIndex = acc.nobranding.findIndex(&#xA;                    (el) =&gt; el.date_debut == key.date_debut&#xA;                  );&#xA;                  if (nobrandingIndex !== -1) {&#xA;                    // si on a un élément&#xA;                    acc.nobranding[nobrandingIndex].search_impression_share +=&#xA;                      parseInt(key.search_impression_share);&#xA;                  } else {&#xA;                    acc.nobranding.push({&#xA;                      search_impression_share: parseInt(&#xA;                        key.search_impression_share&#xA;                      ),&#xA;                      date_debut: key.date_debut,&#xA;                    });&#xA;                  }&#xA;                }&#xA;&#xA;                return acc;&#xA;              },&#xA;              { branding: [], nobranding: [] }&#xA;            );&#xA;            return {&#xA;              brand: aggregate.branding,&#xA;              nobrand: () =&gt; {&#xA;                return aggregate.nobranding;&#xA;              },&#xA;            };&#xA;          },&#xA;        },        &#xA;      },&#xA;    },&#xA;    resolversConfig: {&#xA;      &quot;Query.popularity&quot;: {&#xA;        auth: {&#xA;          scope: [&#xA;            &quot;api::impression.impression.findOne&quot;,&#xA;            &quot;api::impression.impression.find&quot;,&#xA;          ],&#xA;        },&#xA;      },&#xA;    },&#xA;  });&#xA;````&#xA;</code></pre>&#xA;",9324489,,,,2022-08-02 05:57:02,"",,0,0,0,2022-08-02 05:57:02
73206167,1,,,0,79,"<p>In my application I have 2 models:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>class Employee(models.Model): &#xA;    first_name = models.CharField(max_length=100, null=False)&#xA;    last_name  = models.CharField(max_length=100, null=False)&#xA;    email_id   = models.EmailField(null=False)&#xA;&#xA;&#xA;class UserGroup(models.Model):&#xA;    created_by = models.EmailField(null=False)&#xA;</code></pre>&#xA;<p>An <strong>UserGroup</strong> can be created by an <strong>Employee</strong> or by the <strong>&quot;System&quot;</strong>. So, the possible values for <code>&quot;created_by&quot;</code> are:</p>&#xA;<ol>&#xA;<li><code>&quot;employeex@mail.com&quot;</code></li>&#xA;<li><code>&quot;System&quot;</code></li>&#xA;</ol>&#xA;<p>Now, I want to expose this property in graphql. From the graphql, I want to be able to get the properties of <code>created_by</code> (like <code>firstName</code>, <code>lastName</code> etc) if <code>created_by</code> is an Employee. Otherwise I want to get String in the graphql response.</p>&#xA;<p>Here is what I have done so far:</p>&#xA;<pre class=""lang-py prettyprint-override""><code>import graphene&#xA;from graphene_django.types import DjangoObjectType&#xA;&#xA;from models import Employee, UserGroup&#xA;&#xA;&#xA;class EmployeeObjectType(DjangoObjectType):&#xA;    class Meta:&#xA;        model = Employee&#xA;&#xA;&#xA;class UserGroupCreatedBy(graphene.Union):&#xA;    class Meta:&#xA;        types = (EmployeeObjectType, graphene.String, )&#xA;&#xA;&#xA;class UserGroupType(DjangoObjectType):&#xA;    created_by = graphene.Field(UserGroupCreatedBy)&#xA;&#xA;    def resolve_created_by(self, info):&#xA;        if self.created_by == &quot;System&quot;:&#xA;            return self.created_by&#xA;        return Employee.objects.get(email_id=self.created_by)&#xA;&#xA;    class Meta:&#xA;        model = UserGroup&#xA;</code></pre>&#xA;<pre><code>query {&#xA;    userGroups {&#xA;        createdBy {&#xA;            ... on EmployeeType {&#xA;                firstName&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>When I request the graphql API, this is the error that I am getting:</p>&#xA;<pre><code>ERROR:django.request:Internal Server Error: /graphql&#xA;Traceback (most recent call last):&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/core/handlers/exception.py&quot;, line 47, in inner&#xA;    response = get_response(request)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/deprecation.py&quot;, line 113, in __call__&#xA;    response = self.process_request(request)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/middleware/common.py&quot;, line 53, in process_request&#xA;    if self.should_redirect_with_slash(request):&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/middleware/common.py&quot;, line 71, in should_redirect_with_slash&#xA;    not is_valid_path(request.path_info, urlconf) and&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/urls/base.py&quot;, line 154, in is_valid_path&#xA;    resolve(path, urlconf)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/urls/base.py&quot;, line 25, in resolve&#xA;    return get_resolver(urlconf).resolve(path)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/urls/resolvers.py&quot;, line 549, in resolve&#xA;    for pattern in self.url_patterns:&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/functional.py&quot;, line 48, in __get__&#xA;    res = instance.__dict__[self.name] = self.func(instance)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/urls/resolvers.py&quot;, line 593, in url_patterns&#xA;    patterns = getattr(self.urlconf_module, &quot;urlpatterns&quot;, self.urlconf_module)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/utils/functional.py&quot;, line 48, in __get__&#xA;    res = instance.__dict__[self.name] = self.func(instance)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/django/urls/resolvers.py&quot;, line 586, in urlconf_module&#xA;    return import_module(self.urlconf_name)&#xA;  File &quot;/usr/local/lib/python3.9/importlib/__init__.py&quot;, line 127, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1030, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1007, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 680, in _load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 850, in exec_module&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 228, in _call_with_frames_removed&#xA;  File &quot;/code/project_name/urls.py&quot;, line 34, in &lt;module&gt;&#xA;    from spm.graphql.data_loaders import (&#xA;  File &quot;/code/spm/graphql/__init__.py&quot;, line 1, in &lt;module&gt;&#xA;    from .schema import *&#xA;  File &quot;/code/spm/graphql/schema.py&quot;, line 102, in &lt;module&gt;&#xA;    schema = graphene.Schema(query=Query, mutation=Mutation)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/schema.py&quot;, line 78, in __init__&#xA;    self.build_typemap()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/schema.py&quot;, line 167, in build_typemap&#xA;    self._type_map = TypeMap(&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 80, in __init__&#xA;    super(TypeMap, self).__init__(types)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/typemap.py&quot;, line 31, in __init__&#xA;    self.update(reduce(self.reducer, types, OrderedDict()))  # type: ignore&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 88, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 117, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/typemap.py&quot;, line 109, in reducer&#xA;    field_map = type_.fields&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/pyutils/cached_property.py&quot;, line 22, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 198, in fields&#xA;    return define_field_map(self, self._fields)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 212, in define_field_map&#xA;    field_map = field_map()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 275, in construct_fields_for_type&#xA;    map = self.reducer(map, field.type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 88, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 93, in graphene_reducer&#xA;    return self.reducer(map, type.of_type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 88, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 117, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/typemap.py&quot;, line 109, in reducer&#xA;    field_map = type_.fields&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/pyutils/cached_property.py&quot;, line 22, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 198, in fields&#xA;    return define_field_map(self, self._fields)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 212, in define_field_map&#xA;    field_map = field_map()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 275, in construct_fields_for_type&#xA;    map = self.reducer(map, field.type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 88, in reducer&#xA;    return self.graphene_reducer(map, type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 117, in graphene_reducer&#xA;    return GraphQLTypeMap.reducer(map, internal_type)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/typemap.py&quot;, line 99, in reducer&#xA;    for t in type_.types:&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/pyutils/cached_property.py&quot;, line 22, in __get__&#xA;    value = obj.__dict__[self.func.__name__] = self.func(obj)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 429, in types&#xA;    return define_types(self, self._types)&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphql/type/definition.py&quot;, line 440, in define_types&#xA;    types = types()&#xA;  File &quot;/usr/local/lib/python3.9/site-packages/graphene/types/typemap.py&quot;, line 251, in types&#xA;    assert internal_type.graphene_type == objecttype&#xA;AttributeError: 'GraphQLScalarType' object has no attribute 'graphene_type'&#xA;</code></pre>&#xA;",8208804,,,,2022-08-02 10:42:32,Django graphene - Unable to query union field,<django><graphql><graphene-django>,0,0,0,2022-08-02 10:42:32
73207826,1,,,0,64,"<p>Say I want to query an object tree like this:</p>&#xA;<pre><code>query UsersWithOrgs {&#xA;  users {&#xA;    nodes {&#xA;      firstName&#xA;      lastName&#xA;      orgMemberships {&#xA;        nodes {&#xA;          joinedAt&#xA;          organization {&#xA;            name&#xA;            foundedAt&#xA;            location {&#xA;              city&#xA;              country&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Now say I want to filter for only the users where the org they <code>joinedAt &lt;= 6 months ago</code>, or only the users where the org they joined is in England.</p>&#xA;<pre><code>query UsersWhereJoinedRecently {&#xA;  users {&#xA;    nodes {&#xA;      firstName&#xA;      lastName&#xA;      orgMemberships(joinedAt: { lte: &quot;2022/03/12&quot; }) {&#xA;        nodes {&#xA;          joinedAt&#xA;          organization {&#xA;            name&#xA;            foundedAt&#xA;            location {&#xA;              city&#xA;              country&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;query UsersWhereOrgInEngland {&#xA;  users {&#xA;    nodes {&#xA;      firstName&#xA;      lastName&#xA;      orgMemberships {&#xA;        nodes {&#xA;          joinedAt&#xA;          organization {&#xA;            name&#xA;            foundedAt&#xA;            location(country: &quot;England&quot;) {&#xA;              city&#xA;              country&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is this the &quot;GraphQL way&quot; of defining filters on nested objects? Or should the filters be hoisted up somehow?</p>&#xA;<p>Based on the definitions above, I would instead expect <code>UsersWhereJoinedRecently</code> to return all users in the app, but <code>orgMemberships</code> would be filtered to only include those after the <code>joinedAt</code> date. Likewise, I would expect <code>UsersWhereOrgInEngland</code> to return all users with all their orgs, but only return the location for the org if the country is &quot;England&quot;. That is not at all what I want, I want only the users where if that deeply nested condition is false, not to return the user. What is the appropriate way people handle this situation?</p>&#xA;<p>To me there are two passes in the overall query:</p>&#xA;<ol>&#xA;<li>Joins and Wheres.</li>&#xA;<li>Projection.</li>&#xA;</ol>&#xA;<p>First, we must fetch all users where the deeply nested condition is true. Then given those top-level IDs for the user, we fetch the projected schema.</p>&#xA;<p>So first:</p>&#xA;<pre><code>// userIds = &#xA;select id from users&#xA;inner join memberships on memberships.userId = users.id&#xA;where memberships.joinedAt &lt;= &quot;2022/03/12&quot;&#xA;</code></pre>&#xA;<p>Then:</p>&#xA;<pre><code>select firstName, lastName from users where id in userIds&#xA;select joinedAt, orgId from orgMemberships where userId in userIds and joinedAt &lt;= &quot;2022/03/12&quot;&#xA;... select from each of the other tables.&#xA;... then build into tree and return to client.&#xA;</code></pre>&#xA;<p>Same with the other query.</p>&#xA;<p>So because of these two seemingly completely separate phases, it makes me think that all filtering should be passed in at the top level in some fashion in GraphQL. Like:</p>&#xA;<pre><code>query UsersWhereJoinedRecently {&#xA;  users(membershipJoinedAt: { lte: &quot;2022/03/12&quot; }) {&#xA;    nodes {&#xA;      firstName&#xA;      lastName&#xA;      orgMemberships {&#xA;        nodes {&#xA;          joinedAt&#xA;          organization {&#xA;            name&#xA;            foundedAt&#xA;            location {&#xA;              city&#xA;              country&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is that correct, is that the recommended practice? Or what is recommended practice in these sorts of &quot;filter by nested objects&quot; scenarios?</p>&#xA;",169992,,,,2022-08-02 12:48:09,How to add filter to nested objects in GraphQL the GraphQL way?,<graphql>,0,0,0,2022-08-02 12:48:09
73209887,2,,71713679,0,,"<p>The variable must be a JSON string, but not in <code>&quot;&quot;</code>.</p>&#xA;<p>And take the request as JSON like below:</p>&#xA;<pre><code>String str = {&#xA;    &quot;query&quot; : &quot;query branchLocator ($filterCriteria: [FilterCriteria], $sortBy: SortBy) {&#xA;        branchLocator (filterCriteria: $filterCriteria, offset: 0, limit: 20, sortBy: $sortBy) { &#xA;            postalCode latitude longitude addId1 addName1 addAddress1 addCity1 distance1 addId2 addName2 addAddress2 addCity2 distance2 addId3 addName3 addAddress3 addCity3 distance3 addId4 addName4 addAddress4 addCity4 distance4 addId5 addName5 addAddress5 addCity5 distance5 addId6 addName6 addAddress6 addCity6 distance6&#xA;        }&#xA;    }&quot;,&#xA;    &quot;variables&quot;: {&#xA;         &quot;filterCriteria&quot;:[{&#xA;             &quot;key&quot;:&quot;postalCode&quot;,&#xA;             &quot;filterInput&quot;:{&quot;filterType&quot;:&quot;eq&quot;,&quot;filterValues&quot;:[&quot;123456&quot;]}&#xA;         }]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;",19675881,,4970679,2022-08-06 05:54:54,2022-08-06 05:54:54,"",,0,0,0,2022-08-02 15:11:55
73220316,1,,,0,15,"<p>I want to get data between two Date <br/>&#xA;In my Schema <br/></p>&#xA;<pre><code>transactionDate : String&#xA;</code></pre>&#xA;<p>the function to get data between two date</p>&#xA;<pre><code> async getLogsByDate(start, end) {&#xA;    return await this.logModel&#xA;&#xA;      .find({ date: { $gte: start, $lte: end } })&#xA;      .then((res) =&gt; res);&#xA;  &#xA;  }&#xA;</code></pre>&#xA;<p>I use graphql client, Date I passed here is of type String</p>&#xA;<pre><code>{getLogsByDate(datelogCharts:{start:&quot;2022-03-05&quot;,end:&quot;2022-04-05&quot;}) {_id transactionDate} }&#xA;</code></pre>&#xA;<p>OUTPUT&#xA;I got all dates seems the filter i put doesn't work or I don't know</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;getLogsByDate&quot;: [&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-03-05&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-06-15&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-03-05&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-03-05&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-03-05&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-03-05&quot;&#xA;      },&#xA;      {&#xA;        &quot;transactionDate&quot;: &quot;2022-13-05&quot;&#xA;      },&#xA;</code></pre>&#xA;",19289986,,,,2022-08-03 10:57:44,How to campare two date of type string mongoose,<node.js><typescript><date><mongoose><graphql>,1,0,0,2022-08-03 10:39:00
73220548,2,,73220316,0,,"<p>Try:</p>&#xA;<pre><code>async getLogsByDate(start, end) {&#xA;return await this.logModel&#xA;&#xA;  .find({ date: { $gte: new Date(start), $lte: new Date(end) } })&#xA;  .then((res) =&gt; res);&#xA;&#xA;}&#xA;</code></pre>&#xA;<p>As it is of type string, it will not convert to Date. Mongoose is smart but just not that smart.</p>&#xA;",8975155,,8975155,2022-08-03 10:57:44,2022-08-03 10:57:44,"",,0,2,0,2022-08-03 10:57:13
73229685,2,,68745075,0,,"<p>Relay matches connection identity not only by the parent id and connection key but also using the latest arguments (&quot;filters) that connection was called with.&#xA;By passing <code>filters: []</code> to the connection you're telling relay that no arguments should be used to determine connection identity. This can work sometimes but if your arguments actually affect the output of your connection this can introduced some unexpected behaviors, such as your connection results not updating when only some argument has changed.&#xA;Alternatively you can pass the latest arguments you called your connection with to your <code>getConnectionId</code> call. This can be very verbose and difficult to do at times but there's no other work around.</p>&#xA;<p>From the docs: <a href=""https://relay.dev/docs/guided-tour/list-data/updating-connections/#connection-identity-with-filters"" rel=""nofollow noreferrer"">https://relay.dev/docs/guided-tour/list-data/updating-connections/#connection-identity-with-filters</a></p>&#xA;",6567153,,,,2022-08-04 02:19:28,"",,0,0,0,2022-08-04 02:19:28
73235148,2,,73233495,0,,"<p>If I understand you correctly you have trouble to receive all of the data from one request.</p>&#xA;<p><code>[UseSorting]</code> doesn't have any impact on the data that is returned, until you specify the request with <a href=""https://chillicream.com/docs/hotchocolate/fetching-data/sorting"" rel=""nofollow noreferrer"">sorting parameters</a>.</p>&#xA;<p>If you have problems, that not all of your data is returned in one request you should either</p>&#xA;<ul>&#xA;<li>delete <code>[UsePaging(DefaultPageSize = 150)]</code></li>&#xA;<li>change the page size (e.g. <code>[UsePaging(DefaultPageSize = 500)]</code>)</li>&#xA;<li>use the pagination by adding fields like 'first', 'last', 'after' or 'before' to the query (e.g. <code>query{yourQuery(first:4) {...}}</code>)</li>&#xA;</ul>&#xA;",18102554,,4398441,2022-08-07 14:10:32,2022-08-07 14:10:32,"",,0,0,0,2022-08-04 11:27:59
73252163,2,,72757670,0,,"<p>Seems like you are using Strapi</p>&#xA;<p>you should use filters instead where. And you should inform the conditional</p>&#xA;<pre><code>and, or, not, eq, qei, ne, startsWith, endsWith, contains, notContains, containsi, notContainsi, gt, gte, lt, lte, null, notNull,in, notIn, between&#xA;&#xA;shoeposts {&#xA;  data {&#xA;    attributes(filters: {slug: { eq: &quot;NikeDunkLow&quot; }}) &#xA;    {&#xA;      title&#xA;      slug&#xA;    }&#xA;  }&#xA;}}&#xA;</code></pre>&#xA;",5761080,,,,2022-08-05 15:34:14,"",,0,0,0,2022-08-05 15:34:14
73253272,2,,55263450,0,,"<p>in Strapi v4 pagination returns total number of records of content type</p>&#xA;<pre><code>  query GetPhotosMeta {&#xA;    photos {&#xA;      __typename&#xA;      meta {&#xA;        __typename&#xA;        pagination {&#xA;          __typename              &#xA;          total&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p><a href=""https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/graphql-api.html#pagination"" rel=""nofollow noreferrer"">https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/graphql-api.html#pagination</a></p>&#xA;",3487579,,,,2022-08-05 17:14:39,"",,0,0,0,2022-08-05 17:14:39
73255986,1,,,0,127,"<p>I am trying to figure out how I can use types that have been defined in my lib/graphql to return results in my views.</p>&#xA;<p>I can see my lib/graphql has a useful type as follows:</p>&#xA;<pre><code>export type IssueWhereInput = {&#xA;  AND?: InputMaybe&lt;Array&lt;IssueWhereInput&gt;&gt;;&#xA;  NOT?: InputMaybe&lt;Array&lt;IssueWhereInput&gt;&gt;;&#xA;  OR?: InputMaybe&lt;Array&lt;IssueWhereInput&gt;&gt;;&#xA;  Template?: InputMaybe&lt;TemplateListRelationFilter&gt;;&#xA;  User?: InputMaybe&lt;UserListRelationFilter&gt;;&#xA;  createdAt?: InputMaybe&lt;DateTimeFilter&gt;;&#xA;  description?: InputMaybe&lt;StringFilter&gt;;&#xA;  id?: InputMaybe&lt;StringFilter&gt;;&#xA;  issueCategory?: InputMaybe&lt;EnumCategoryFilter&gt;;&#xA;  title?: InputMaybe&lt;StringFilter&gt;;&#xA;  updatedAt?: InputMaybe&lt;DateTimeFilter&gt;;&#xA;  userId?: InputMaybe&lt;StringFilter&gt;;&#xA;};&#xA;</code></pre>&#xA;<p>I want to use the issueCategory? filter so that I can find entries in my psql that are saved as 'CLIMATE_CHANGE'.</p>&#xA;<p>I have an issue.service.ts in my back end which I think I have tried to implement to use this concept, but I cannot find a way to get the codegen for getAllClimateChangeIssuesQyery to make the query in the generated file. I don't know why.</p>&#xA;<pre><code>import { prisma } from &quot;../../lib/prisma&quot;&#xA;import { Service } from &quot;typedi&quot;&#xA;import { IssueInput } from &quot;./inputs/create.input&quot;&#xA;import { Resolver } from &quot;type-graphql&quot;&#xA;import { Issue } from &quot;./issue.model&quot;&#xA;&#xA;@Service()&#xA;@Resolver(() =&gt; Issue)&#xA;export class IssueService {&#xA;  async createIssue(data: IssueInput) {&#xA;    return await prisma.issue.create({ data })&#xA;  }&#xA;&#xA;  async getAllIssues() {&#xA;    return await prisma.issue.findMany()&#xA;  }&#xA;&#xA;  async getAllClimateChangeIssues() {&#xA;    return await prisma.issue.findMany({where: {issueCategory: &quot;CLIMATE_CHANGE&quot;}}) &#xA;  }&#xA;&#xA;  async getIssue(id: string) {&#xA;    return await prisma.issue.findUnique({ where: { id } })&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>As an alternative, maybe I could use the above IssueWhereInput to filter the db entries so that those where the issueCategory equals: 'CLIMATE_CHANGE' are returned.</p>&#xA;<p>I cannot find an example showing how to do this.</p>&#xA;<p>Is there a method statement showing if or how I can use IssueWhereInput on the front end to return queries using the filters it seems to provide?</p>&#xA;",2860931,,62576,2022-08-06 02:10:33,2022-08-06 02:10:33,how to use types in a query,<typescript><graphql><graphql-codegen>,0,0,0,2022-08-05 23:02:55
73284313,2,,72669627,-1,,<p>I had to filter these _deleted records in the code. Did not find a way to filter out in GraphQL Response</p>&#xA;,6446688,,,,2022-08-08 21:41:53,"",,0,1,0,2022-08-08 21:41:53
73310577,1,,,0,145,<p>I have a graphql file with a date in ISO format. I would like to pass a variable instead of hardcoding the date. I would like to use Date.toISOstring() or some get current date method.</p>&#xA;<p>GRAPHQL FILE</p>&#xA;<pre><code>let today = Date.toISOString() //or DateNow()&#xA;&#xA;query guide {&#xA;        tv {&#xA;            guide(date: &quot;2022-08-10T00:00:00Z &lt;-replace--${today}&quot;) {&#xA;                entries {&#xA;                    channel {&#xA;                        show{&#xA;                            ......&#xA;                    }&#xA;&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>Is this possible?</p>&#xA;,15276785,,,,2022-08-10 20:31:19,how to pass date variable to graphQL call in svelte?,<api><datetime><variables><graphql><svelte>,1,0,0,2022-08-10 17:40:05
73348763,1,,,0,31,"<p>I have a nested GraphQL query with the following structure</p>&#xA;<pre><code>    query{&#xA;                &#xA;    parentMetrics(cityNames: [&quot;Cali&quot;], orderingDateFrom: &quot;2021-01-01&quot;){&#xA;            sales&#xA;            orders&#xA;            childMetrics(cityNames: [&quot;Cali&quot;], orderingDateFrom: &quot;2021-01-01&quot;){&#xA;                aov&#xA;            }&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>As you can see I am repeating the arguments because in the backend we run different queries to get <em>parentMetrics</em> and <em>childMetrices</em> but they require the same set of args which is redundant.</p>&#xA;<p>Can I do something like this instead?</p>&#xA;<pre><code>query{&#xA;            &#xA;parentMetrics(cityNames: [&quot;Cali&quot;], orderingDateFrom: &quot;2021-01-01&quot;){&#xA;        sales&#xA;        orders&#xA;        childMetrics{&#xA;            aov&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>I am using <strong>github.com/graphql-go/graphql</strong> and currently this is what my code looks like</p>&#xA;<pre><code> &quot;parentMetrics&quot;: &amp;graphql.Field{&#xA;                            Type:    partnerGQL.ParentMetrics,&#xA;                            Args:    graphql.FieldConfigArgument{&#xA;                                             &quot;cityNames&quot;: &amp;graphql.ArgumentConfig{&#xA;                                             Type:graphql.NewList(graphql.String),&#xA;                                             }&#xA;                                             &quot;orderingDateFrom&quot;:&amp;graphql.ArgumentConfig{&#xA;                            Type: graphql.String,&#xA;    }&#xA;        },&#xA;                            Resolve: partnerResolver.ResolveOrderItemMetrics,&#xA;}&#xA;                    &#xA;</code></pre>&#xA;<p>The <em>parentMetric</em>s type has the nested Resolver for <em>childMetrics</em></p>&#xA;",11943818,,1594915,2022-08-14 08:03:21,2022-08-14 12:39:03,Pass parent resolver arguments in child resolver,<go><graphql><graphql-go>,1,0,0,2022-08-14 02:21:26
73378505,2,,73378132,1,,<p>You'll need to import the fragment into your query code. Instead of this:</p>&#xA;<pre><code>gql`&#xA;  fragment StuffTable on Stuff {&#xA;    id&#xA;    status&#xA;  }&#xA;`;&#xA;&#xA;export const GetStuffDocument = gql`&#xA;  query GetStuff($id: ID!) {&#xA;    stuff(id: $id) {&#xA;      id&#xA;      ...StuffTable&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>You can do this:</p>&#xA;<pre><code>const STUFF_TABLE_FRAGMENT = gql`&#xA;  fragment StuffTable on Stuff {&#xA;    id&#xA;    status&#xA;  }&#xA;`;&#xA;&#xA;export const GetStuffDocument = gql`&#xA;  ${STUFF_TABLE_FRAGMENT}&#xA;  query GetStuff($id: ID!) {&#xA;    stuff(id: $id) {&#xA;      id&#xA;      ...StuffTable&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>That will make sure that the fragment StuffTable is included in your query!</p>&#xA;,1466592,,,,2022-08-16 18:13:59,"",,0,0,0,2022-08-16 18:13:59
73418517,1,,,0,38,"<p>Is it possible to extend the <code>aggregate</code> query in Hasura or alternatively write a custom query that will fetch aggregated data on an array relationship, one that returns non <code>NULL</code> values ordered by <code>timestamp desc</code>?</p>&#xA;<p>Assuming my table looks like this...</p>&#xA;<pre><code>&#xA;+-———+————+———+————————+————————+-———————————+&#xA;| event_id |   state   | amount |        address        |         notes         |            timestamp             |&#xA;+-———+————+———+————————+————————+-———————————+&#xA;| order123 | fulfilled | NULL   | NULL                  | NULL                  | 2022-07-01T17:08:12.032316+00:00 |&#xA;| order123 | NULL      | NULL   | NULL                  | Delivered to customer | 2022-07-01T17:07:12.032316+00:00 |&#xA;| order123 | NULL      | NULL   | 300 Post St, CA 94108 | NULL                  | 2022-07-01T17:06:12.032316+00:00 |&#xA;| order123 | accepted  | NULL   | NULL                  | NULL                  | 2022-07-01T17:05:12.032316+00:00 |&#xA;| order123 | pending   | 100    | NULL                  | NULL                  | 2022-07-01T17:04:12.032316+00:00 |&#xA;+-———+————+———+————————+————————+-———————————+&#xA;&#xA;&#xA;</code></pre>&#xA;<p>I'm looking for my aggregation query to pull out the latest value from each of those columns, ignoring the <code>NULL</code>s. The result of the query should look like this...</p>&#xA;<pre><code>+-———+————+———+————————+————————+-———————————+&#xA;| event_id |   state   | amount |        address        |         notes         |            timestamp             |&#xA;+-———+————+———+————————+————————+-———————————+&#xA;| order123 | fulfilled | 100    | 300 Post St, CA 94108 | Delivered to customer | 2022-07-01T17:08:12.032316+00:00 |&#xA;+-———+————+———+————————+————————+-———————————+&#xA;</code></pre>&#xA;<p>I really like the built-in <code>aggregate</code> query which using the <code>max</code> function allows me to pull out the aggregate highest values like so...</p>&#xA;<pre><code>author_aggregate {&#xA;  aggregate {&#xA;    max {&#xA;      event_id&#xA;      state&#xA;      amount&#xA;      address&#xA;      notes&#xA;      timestamp&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>The issue with this query however is that the max value isn't necessarily the latest value.</p>&#xA;<p>Any help with this will be appreciated. Thanks in advance!</p>&#xA;",658082,,,,2022-08-19 14:44:29,Hasura Graph QL Aggregate Based on Non null values,<mysql><postgresql><graphql><hasura>,0,0,0,2022-08-19 14:44:29
73420256,1,,,0,19,"<p>I am using Mongodb's path field to create a model tree structure. The path field allows you to return the child elements of a document. The structure of my data is as follows:<br />&#xA;<a href=""https://i.stack.imgur.com/TmBlM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TmBlM.png"" alt=""data structure"" /></a><br />&#xA;If I were to call the parent of my data using path, I'd get it's children:&#xA;<a href=""https://i.stack.imgur.com/KCnhL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KCnhL.png"" alt=""children of parent"" /></a><br />&#xA;On the page for mongodb model tree structure via paths, it shows a way that you can call the parent with the children with a caret at the beginning of the regex:</p>&#xA;<pre><code>db.categories.find( { path: /^,Books,/ } )&#xA;</code></pre>&#xA;<p>However, in practice, this command does not return anything:<br />&#xA;<a href=""https://i.stack.imgur.com/O5TDe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/O5TDe.png"" alt=""regex not returning anything"" /></a><br />&#xA;How can I get the regex to return the parent and the children together like is demonstrated? I have figured out an alternative solution that requires I call first the parent independently and then the children, but it makes the code very messy and the most optimal solution here would be with working regex. Thank you</p>&#xA;",17564201,,8260484,2022-08-19 17:47:20,2022-08-19 17:47:20,What is the right way to use regex in Mongodb with the path field?,<regex><mongodb><graphql><path><backend>,0,0,0,2022-08-19 17:23:22
73426281,1,,,0,54,"<p>I'm developing an application that will allow users to search for other users by ordering them by geo location.</p>&#xA;<p>According to the information found on the internet, to do this on amplify I have to perform the following steps:</p>&#xA;<ul>&#xA;<li>create an elastic search mapping, indicating the type 'geo_point' on the lastPosition attribute (I would like to define it once in the project file and not at each build in the elastic search console)</li>&#xA;<li>create a custom query and a custom vtl resolver and set the sort by lastPosition (of type '_geo_distance') in it.</li>&#xA;</ul>&#xA;<p>But I don't understand how to do these 2 steps, so I need some suggestion :(.</p>&#xA;<pre><code>// my schema.graphql&#xA;   type User&#xA;  @model&#xA;  @auth(rules: [{allow: owner}, {allow: private, operations: [read]}])&#xA;  @searchable {&#xA;  // ...other fields&#xA;  id: ID!&#xA;  lastPosition: Position&#xA;  positionUpdatedAt: AWSDateTime&#xA;}&#xA;&#xA;type Position {&#xA;  lat: Float!&#xA;  lon: Float!&#xA;}&#xA;</code></pre>&#xA;<pre><code>// my custom searchUsers query in graphql/custom_queries.ts&#xA;export const searchUsersNearby = /* GraphQL */ `&#xA;  query SearchUsersNearby(&#xA;    $filter: SearchableUserFilterInput&#xA;    $sort: [SearchableUserSortInput]&#xA;    $location: PositionInput // current user position that i need to use in vtl resolver to sort users by distance, &#xA;    $limit: Int&#xA;    $nextToken: String&#xA;    $from: Int&#xA;    $aggregates: [SearchableUserAggregationInput]&#xA;  ) {&#xA;    searchUsersNearby(&#xA;      filter: $filter&#xA;      sort: $sort&#xA;      limit: $limit&#xA;      nextToken: $nextToken&#xA;      from: $from&#xA;      aggregates: $aggregates&#xA;    ) {&#xA;      items {&#xA;        id&#xA;        // ...other fields&#xA;        lastPosition&#xA;        positionUpdatedAt&#xA;        createdAt&#xA;        updatedAt&#xA;        owner&#xA;      }&#xA;      nextToken&#xA;      total&#xA;      aggregateItems {&#xA;        name&#xA;        result {&#xA;          ... on SearchableAggregateScalarResult {&#xA;            value&#xA;          }&#xA;          ... on SearchableAggregateBucketResult {&#xA;            buckets {&#xA;              key&#xA;              doc_count&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;&#xA;</code></pre>&#xA;<p>I use amplify v8.1.0 with transformer v2.</p>&#xA;<p>Thank you guys</p>&#xA;",19807880,,,,2022-08-20 11:25:16,AWS Amplify searchable field by geo distance (location),<amazon-web-services><elasticsearch><graphql><aws-amplify>,0,0,0,2022-08-20 11:25:16
73432595,2,,72017223,1,,"<p>You can do something like this (customize it with whatever fields you want from <a href=""https://www.meetup.com/api/schema/#Event"" rel=""nofollow noreferrer"">Event</a>):</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const axios = require('axios');&#xA;&#xA;const data = {&#xA;  query: `&#xA;query($filter: SearchConnectionFilter!) {&#xA;  keywordSearch(filter: $filter) {&#xA;    count&#xA;    edges {&#xA;      cursor&#xA;      node {&#xA;        id&#xA;        result {&#xA;          ... on Event {&#xA;            title&#xA;            eventUrl&#xA;            description&#xA;            dateTime&#xA;            going&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}`,&#xA;  variables: {&#xA;    filter: {&#xA;      query: &quot;party&quot;,&#xA;      lat: 43.8,&#xA;      lon: -79.4,&#xA;      radius: 100,&#xA;      source: &quot;EVENTS&quot;,&#xA;    },&#xA;  },&#xA;};&#xA;&#xA;axios({&#xA;  method: &quot;post&quot;,&#xA;  url: `https://api.meetup.com/gql`,&#xA;  headers: {&#xA;    Authorization: `Bearer YOUR_OAUTH_ACCESS_TOKEN`,&#xA;  },&#xA;  data,&#xA;})&#xA;&#xA;&#xA;</code></pre>&#xA;",355567,,,,2022-08-21 07:58:31,"",,0,0,0,2022-08-21 07:58:31
73447658,2,,73447570,2,,"<p>It looks like you have to use two pipeable operators like <code>take(), filter()</code>:</p>&#xA;<pre><code>.pipe(&#xA;  filter(resp =&gt; resp !== undefined &amp;&amp; resp !== null),&#xA;  take(1) // &lt;--- It will only take one successful valid response&#xA;)&#xA;.subscribe(...)&#xA;</code></pre>&#xA;",1059101,,,,2022-08-22 15:35:22,"",,0,1,0,2022-08-22 15:35:22
73458411,1,73460621,,0,157,"<p>It is possible using in one query also where and filter.&#xA;At the moment it is my query:</p>&#xA;<pre><code>  query Memories($id: ID!) {&#xA;      memories(where: { event: { id: $id } }) {&#xA;        id&#xA;        name&#xA;        story&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>I want add filter:</p>&#xA;<pre><code>filter: {&#xA;    name: {&#xA;      anyofterms: &quot;england&quot;&#xA;    },&#xA;</code></pre>&#xA;",19828587,,,,2022-08-23 14:35:21,How to use where and filter in GraphQL in one query?,<graphql>,1,1,0,2022-08-23 12:04:15
73460621,2,,73458411,0,,"<p>That depends on the schema of your API, as there is no &quot;general&quot; filter concept in GraphQL. The API must explicity define such a feature.&#xA;If your API defines a filter on the <code>memories</code> field, than you could probably specify both <code>filter</code> <em>and</em> <code>where</code>, like so:</p>&#xA;<pre><code>query Memories($id: ID!) {&#xA;      memories(&#xA;        where: { event: { id: $id } },&#xA;        filter: { name: { anyofterms: &quot;england&quot; } }&#xA;      ) {&#xA;        id&#xA;        name&#xA;        story&#xA;      }&#xA;    }&#xA;&#xA;</code></pre>&#xA;",6134498,,,,2022-08-23 14:35:21,"",,0,1,0,2022-08-23 14:35:21
73460883,1,,,0,112,"<p>How do you load nested types? For example, I have fairly simple model that looks like:</p>&#xA;<pre><code>public class Customer&#xA;{&#xA;    public string CustomerId { get; set; }&#xA;    &#xA;    public string Forename { get; set; }&#xA;    &#xA;    public string LastName { get; set; }&#xA;    &#xA;    public ICollection&lt;Order&gt; Orders { get; set; }&#xA;}&#xA;&#xA;public class Order&#xA;{&#xA;    public string OrderId { get; set; }&#xA;    &#xA;    public string CustomerId { get; set; }&#xA;}&#xA;</code></pre>&#xA;<p>My query does the following (returns hardcoded data)</p>&#xA;<pre><code>    [UseProjection]&#xA;    [UseFiltering]&#xA;    [UseSorting]&#xA;    public IQueryable&lt;Customer&gt; Customers()&#xA;    {&#xA;        var customers = new List&lt;Customer&gt;&#xA;        {&#xA;            new()&#xA;            {&#xA;                CustomerId = &quot;1&quot;, Forename = &quot;Foo&quot;, LastName = &quot;Blah&quot;,&#xA;                Orders = _orderService.GetOrdersByCustomerId(&quot;&quot;)&#xA;            },&#xA;            new()&#xA;            {&#xA;                CustomerId = &quot;2&quot;, Forename = &quot;Bar&quot;, LastName = &quot;BlahBlah&quot;,&#xA;                Orders = _orderService.GetOrdersByCustomerId(&quot;&quot;)&#xA;            }&#xA;        };&#xA;        &#xA;        return customers.AsQueryable();&#xA;    }&#xA;</code></pre>&#xA;<p>The <code>_orderService</code> its calling is returning hardcoded data:</p>&#xA;<pre><code>    public ICollection&lt;Order&gt; GetOrdersByCustomerId(string customerId)&#xA;    {&#xA;        return new List&lt;Order&gt;&#xA;        {&#xA;            new() { OrderId = $&quot;{customerId}-99&quot;, CustomerId = &quot;1&quot; },&#xA;            new() { OrderId = $&quot;{customerId}-98&quot;, CustomerId = &quot;2&quot; }&#xA;        };&#xA;    }&#xA;</code></pre>&#xA;<p>My query works fine for the top level but doesn't seem to filter the nested types.</p>&#xA;<pre><code>query {&#xA;  customers(where: { customerId: { eq: &quot;1&quot; } }) {&#xA;    forename&#xA;    lastName&#xA;    orders {&#xA;      orderId&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I am clearly missing something or perhaps I misusing.</p>&#xA;<p>For my desired output I would need to change the query to be:</p>&#xA;<pre><code>query {&#xA;  customers(where: { customerId: { eq: &quot;1&quot; } }) {&#xA;    forename&#xA;    lastName&#xA;    orders(where: { customerId: { eq: &quot;1&quot; } }) {&#xA;      orderId&#xA;      customerId&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",1134076,,1134076,2022-08-23 15:37:48,2022-08-23 15:53:20,Loading Nested Objects GraphQL,<c#><asp.net-core><graphql><hotchocolate>,1,0,0,2022-08-23 14:52:54
73489591,1,73489621,,0,40,"<p>I am looking to convert this specific GraphQL code snippet to GAS.</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>mutation {&#xA;  createReportExport(input: {&#xA;    reportId: ""XXXX"",&#xA;    fileContentType: CSV,&#xA;    frequency: ONCE,&#xA;    reportFilters: [&#xA;      {&#xA;        attributeName: ""Sale Date"",&#xA;        relativeDateQuery: {&#xA;          greaterEqual: ""P14D""&#xA;        }&#xA;      }&#xA;    ]&#xA;  }) {&#xA;    reportExport {&#xA;      id&#xA;      fileUrl&#xA;    }&#xA;  }&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>Below is what I have tried in GAS</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-html lang-html prettyprint-override""><code>  var query = 'mutation {createReportExport(input: {reportId: ""urn:abc:Report:3318979a-7628-44ab-aa0d-a822f856b908"",fileContentType: CSV,frequency: ONCE,reportFilters: [{attributeName: ""Sale Date"",relativeDateQuery: {greaterEqual: ""P10D""}}]}) {reportExport {idfileUrl}}}'&#xA;  &#xA; var query2 = {&#xA;  'operationName': 'Mutation',&#xA;  'query': {query},&#xA;  'variables': {}&#xA;  }&#xA;&#xA;  var ql = '{insert URL}';&#xA;  var content = {&#xA;    ""method"": 'POST', &#xA;    ""headers"": {""Authorization"": httpBasicHeader,&#xA;    ""contentType"": ""application/json""},&#xA;    ""payload"": JSON.stringify(query2)&#xA;    };&#xA;  &#xA;  var response = UrlFetchApp.fetch(ql, content);&#xA;  var data = (response.getContentText());&#xA;  Logger.log(data);</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>I have two variables, 'query' and 'query2' that I have tried. I am getting a {&quot;errors&quot;:[{&quot;message&quot;:&quot;No query document supplied&quot;}]} error message when running it in GAS.</p>&#xA;<p>When I run the first code snippet in another environment, it runs successfully. I am looking to keep my project within GAS if possible, since I have figured out the rest of the problems with my project and this is the last thing holding me back.</p>&#xA;",19590474,,,,2022-08-25 14:48:59,Converting GraphQL mutation to Google Apps Scripts,<google-apps-script><graphql>,1,0,0,2022-08-25 14:46:38
73511840,1,,,0,37,"<p>Hi I would like to draw from graphql only those records whose date is equal to the month - August</p>&#xA;<p>If I want to pull another month, it is enough to replace it only in the query. At the moment, my query takes all the months instead of the ones it gives inside the filter</p>&#xA;<p>schema.json</p>&#xA;<pre><code>{&#xA;  &quot;kind&quot;: &quot;collectionType&quot;,&#xA;  &quot;collectionName&quot;: &quot;product_popularities&quot;,&#xA;  &quot;info&quot;: {&#xA;    &quot;singularName&quot;: &quot;product-popularity&quot;,&#xA;    &quot;pluralName&quot;: &quot;product-popularities&quot;,&#xA;    &quot;displayName&quot;: &quot;Popularity&quot;,&#xA;    &quot;description&quot;: &quot;&quot;&#xA;  },&#xA;  &quot;options&quot;: {&#xA;    &quot;draftAndPublish&quot;: true&#xA;  },&#xA;  &quot;pluginOptions&quot;: {},&#xA;  &quot;attributes&quot;: {&#xA;    &quot;podcast&quot;: {&#xA;      &quot;type&quot;: &quot;relation&quot;,&#xA;      &quot;relation&quot;: &quot;manyToOne&quot;,&#xA;      &quot;target&quot;: &quot;api::product.products&quot;,&#xA;      &quot;inversedBy&quot;: &quot;products&quot;&#xA;    },&#xA;    &quot;value&quot;: {&#xA;      &quot;type&quot;: &quot;integer&quot;&#xA;    },&#xA;    &quot;date&quot;: {&#xA;      &quot;type&quot;: &quot;date&quot;&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>My query</p>&#xA;<pre><code>query {&#xA;  Popularities(filters: {date: {contains: [2022-08]}}) {&#xA;    data {&#xA;      attributes {&#xA;        date&#xA;        value&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Response</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;Popularities&quot;: {&#xA;      &quot;data&quot;: [&#xA;        {&#xA;          &quot;attributes&quot;: {&#xA;            &quot;date&quot;: &quot;2022-08-03&quot;,&#xA;            &quot;value&quot;: 50&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;attributes&quot;: {&#xA;            &quot;date&quot;: &quot;2022-08-04&quot;,&#xA;            &quot;value&quot;: 1&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;attributes&quot;: {&#xA;            &quot;date&quot;: &quot;2022-08-10&quot;,&#xA;            &quot;value&quot;: 100&#xA;          }&#xA;        },&#xA;        {&#xA;          &quot;attributes&quot;: {&#xA;            &quot;date&quot;: &quot;2022-07-06&quot;,&#xA;            &quot;value&quot;: 20&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",13613817,,,,2022-08-27 14:28:19,How in strapi graphql I can pull records from a given month,<graphql><strapi>,0,0,0,2022-08-27 14:28:19
73520045,1,,,0,274,"<p>I am trying to filter GraphQL query result by joined table column (field).&#xA;Relationship between tables is Many-to-Many (with bridge table of course) and I want to filter Advertisements by the Cities related to them.</p>&#xA;<p>I am using C#, .NET 6.0 and EF Core with HotChocolate NuGet package for GraphQL. Just a reminder, filtering by main table columns works just fine. Here is how my Query class looks like:&#xA;<a href=""https://i.stack.imgur.com/Ofqp9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ofqp9.png"" alt=""enter image description here"" /></a></p>&#xA;<p>And here are the queries I tried:&#xA;<a href=""https://i.stack.imgur.com/vIUIU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vIUIU.png"" alt=""enter image description here"" /></a></p>&#xA;<p><a href=""https://i.stack.imgur.com/4Q7zN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4Q7zN.png"" alt=""enter image description here"" /></a></p>&#xA;<p><a href=""https://i.stack.imgur.com/FAUbM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FAUbM.png"" alt=""enter image description here"" /></a></p>&#xA;<p>Here are them typed:</p>&#xA;<pre><code>{&#xA;  advertisements(where: { and: [{ type: { eq: SERVICE } }, {or: [{cities.name: { {eq:&quot;London&quot;} }}]}] }) {&#xA;    title&#xA;    id&#xA;    owner {&#xA;      firstName&#xA;      lastName&#xA;    }&#xA;    description&#xA;    rateType&#xA;    price&#xA;    categories {&#xA;      name&#xA;    }&#xA;    cities {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<hr />&#xA;<pre><code>{&#xA;  advertisements(where: { and: [{ type: { eq: SERVICE } }, {or: [{cities: {name: {eq:&quot;London&quot;}} }]}] }) {&#xA;    title&#xA;    id&#xA;    owner {&#xA;      firstName&#xA;      lastName&#xA;    }&#xA;    description&#xA;    rateType&#xA;    price&#xA;    categories {&#xA;      name&#xA;    }&#xA;    cities {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<hr />&#xA;<pre><code>{&#xA;  advertisements(where: { type: { eq: SERVICE } }) {&#xA;    title&#xA;    id&#xA;    owner {&#xA;      firstName&#xA;      lastName&#xA;    }&#xA;    description&#xA;    rateType&#xA;    price&#xA;    categories {&#xA;      name&#xA;    }&#xA;    cities(where: {name: {eq: &quot;London&quot;}}) {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",12770130,,,,2022-09-08 07:36:34,How to filter GraphQL query result by joined table column (field),<c#><.net><graphql><entity-framework-core><hotchocolate>,1,0,0,2022-08-28 15:39:44
73520215,1,,,0,78,"<p>I have the following table that I would like to index, filter with beginsWith and sort:</p>&#xA;<div class=""s-table-container"">&#xA;<table class=""s-table"">&#xA;<thead>&#xA;<tr>&#xA;<th>id</th>&#xA;<th>geo</th>&#xA;<th>createdAt</th>&#xA;<th>content</th>&#xA;</tr>&#xA;</thead>&#xA;<tbody>&#xA;<tr>&#xA;<td>1</td>&#xA;<td>a7y8c</td>&#xA;<td>2022-08-27T21:02:43.325Z</td>&#xA;<td>Lorem</td>&#xA;</tr>&#xA;<tr>&#xA;<td>2</td>&#xA;<td>b1x0b</td>&#xA;<td>2022-08-26T12:32:43.464Z</td>&#xA;<td>Imsum</td>&#xA;</tr>&#xA;<tr>&#xA;<td>3</td>&#xA;<td>c1x0c</td>&#xA;<td>2022-08-25T19:34:52.233Z</td>&#xA;<td>Dolor</td>&#xA;</tr>&#xA;<tr>&#xA;<td>4</td>&#xA;<td>c1x0d</td>&#xA;<td>2022-08-24T21:12:43.323Z</td>&#xA;<td>Consetetur</td>&#xA;</tr>&#xA;<tr>&#xA;<td>5</td>&#xA;<td>c1x0e</td>&#xA;<td>2022-08-23T11:43:53.723Z</td>&#xA;<td>sadipscing</td>&#xA;</tr>&#xA;<tr>&#xA;<td>6</td>&#xA;<td>d3f0f</td>&#xA;<td>2022-08-22T16:34:53.245Z</td>&#xA;<td>takimata.</td>&#xA;</tr>&#xA;</tbody>&#xA;</table>&#xA;</div>&#xA;<p>My goal is to filter the field <code>geo</code> with <code>beginsWith=c1x</code> and sort the result by <code>createdAt</code>. Then get the result:</p>&#xA;<div class=""s-table-container"">&#xA;<table class=""s-table"">&#xA;<thead>&#xA;<tr>&#xA;<th>id</th>&#xA;<th>geo</th>&#xA;<th>createdAt</th>&#xA;<th>content</th>&#xA;</tr>&#xA;</thead>&#xA;<tbody>&#xA;<tr>&#xA;<td>3</td>&#xA;<td><strong>c1x</strong>0c</td>&#xA;<td>2022-08-25T19:34:52.233Z</td>&#xA;<td>Dolor</td>&#xA;</tr>&#xA;<tr>&#xA;<td>4</td>&#xA;<td><strong>c1x</strong>0d</td>&#xA;<td>2022-08-24T21:12:43.323Z</td>&#xA;<td>Consetetur</td>&#xA;</tr>&#xA;<tr>&#xA;<td>5</td>&#xA;<td><strong>c1x</strong>0e</td>&#xA;<td>2022-08-23T11:43:53.723Z</td>&#xA;<td>sadipscing</td>&#xA;</tr>&#xA;</tbody>&#xA;</table>&#xA;</div>&#xA;<p>My GraphQL schema looks like this:</p>&#xA;<pre><code>type Item&#xA;  id: ID!&#xA;  content: String&#xA;  geo: String&#xA;  createdAt: AWSDateTime!&#xA;  status: Status @index(name: &quot;listItemsByDate&quot;, queryField: &quot;listItemsByDate&quot;, sortKeyFields: [&quot;geo&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>With <code>sortKeyFields: [&quot;createdAt&quot;, &quot;geo&quot;]</code> the sorting is correct and with <code>sortKeyFields: [&quot;geo&quot;, &quot;createdAt&quot;]</code> the filtering works with startsWith.</p>&#xA;<p>Does anyone have an idea how I can solve the poblem?</p>&#xA;",19862896,,19862896,2022-08-28 16:10:49,2022-08-28 16:10:49,Amplify/DynamoDB GSI filter (beginsWith) & sort GraphQL result,<amazon-web-services><graphql><amazon-dynamodb><aws-amplify><dynamodb-queries>,0,5,0,2022-08-28 16:05:56
73542430,1,,,0,27,<p>At the moment I am building components with pagination.&#xA;How can I query list number(only) the total count number of all elements from this query?</p>&#xA;,18755927,,1594915,2022-08-31 04:37:14,2022-08-31 04:37:14,How to calculate total items in query?,<graphql>,0,1,0,2022-08-30 12:25:25
73558447,2,,72389715,0,,<p>Your only option as of now would be use the gql-tag gql`` or put the fragments inside the same gql file.</p>&#xA;,8445200,,,,2022-08-31 15:37:51,"",,0,0,0,2022-08-31 15:37:51
73570518,1,,,0,34,"<p>I'm trying to get familiar with graphql. So I have an entity called <code>Car</code> in BE. And I have only <code>Cars</code> exposed.</p>&#xA;<p>Now I'm trying to find all the cars from <code>Cars</code>, where year(launch) is certain say 2001. It's actually a variable. Now I think the following query should work.</p>&#xA;<pre><code>query GetCars($y: String!) {&#xA;      cars({ year: $y }) {&#xA;        id&#xA;        year&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>But it gives me error saying, <strong><code>Expected Name found {</code></strong>, it throws the error at the second dollar sign.</p>&#xA;<p><code>filters</code> and <code>where</code> is also undefined.</p>&#xA;<p>Can anyone give me some hint to resolve this problem?</p>&#xA;<p>Using: <strong>GraphiQL</strong></p>&#xA;",12252394,,12252394,2022-09-01 17:49:38,2022-09-01 19:37:17,Expected Name found { ; tring to find objects with specific field value,<express><graph><graphql>,1,0,0,2022-09-01 13:51:39
73572349,1,73883840,,0,167,"<p>We are using Github Projects V2. I have created a custom field say 'MyCustomField'.&#xA;I want to read the value of custom field MyCustomField using Github GraphQL API.&#xA;I am following <a href=""https://docs.github.com/en/issues/planning-and-tracking-with-projects/automating-your-project/using-the-api-to-manage-projects#finding-information-about-items-in-a-project"" rel=""nofollow noreferrer"">Gtihub GraphQL API Docs</a></p>&#xA;<p>So far I have got till reading a few predefined fields on Gtihub Issues like title, url, assignees and labels. I am using Windows PowerShell:</p>&#xA;<pre><code>$project_id=&quot;MyProjectIDFetchedUsingDifferentQuery&quot;&#xA;gh api graphql -f query='&#xA;  query($project_id: ID!){&#xA;    node(id: $project_id) {&#xA;        ... on ProjectV2 {&#xA;          items(last: 20) {&#xA;            nodes{&#xA;              id              &#xA;              content{              &#xA;                ...on Issue {&#xA;                  title&#xA;                  url&#xA;                  assignees(first: 10) {&#xA;                    nodes{&#xA;                      login&#xA;                    }&#xA;                  }&#xA;                  labels(first:5) {&#xA;                    edges {&#xA;                        node {&#xA;                          name&#xA;                        }&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }' -f project_id=$project_id&#xA;</code></pre>&#xA;<p>I am not able to find a way to get the custom field MyCustomField.&#xA;I am expecting to write some query like below:</p>&#xA;<pre><code>$project_id=&quot;MyProjectIDFetchedUsingDifferentQuery&quot;&#xA;gh api graphql -f query='&#xA;  query($project_id: ID!){&#xA;    node(id: $project_id) {&#xA;        ... on ProjectV2 {&#xA;          items(last: 20) {&#xA;            nodes{&#xA;              id              &#xA;              content{              &#xA;                ...on Issue {&#xA;                  title&#xA;                  url&#xA;                  assignees(first: 10) {&#xA;                    nodes{&#xA;                      login&#xA;                    }&#xA;                  }&#xA;                  labels(first:5) {&#xA;                    edges {&#xA;                        node {&#xA;                          name&#xA;                        }&#xA;                    }&#xA;                  }&#xA;                  customFields(first:5) {&#xA;                    nodes {&#xA;                        name&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }' -f project_id=$project_id&#xA;</code></pre>&#xA;",8335233,,8335233,2022-09-01 16:47:34,2022-09-28 15:10:31,GitHub GraphQL API Read custom field in Project V2,<graphql><github-api><github-projects>,1,0,0,2022-09-01 15:57:45
73582594,2,,73581933,2,,"<p>You can use the createQueryBuilder of typeorm. You can check the use of bracket <a href=""https://typeorm.io/select-query-builder"" rel=""nofollow noreferrer"">here</a>. You can use orWhere wherever you need to use the OR condition. By your query, you can use the below code:</p>&#xA;<pre><code>createQueryBuilder(&quot;MyModel&quot;)&#xA;  .where(&quot;MyModel.type = :type&quot;, { type: &quot;new&quot; })&#xA;  .andWhere(&quot;MyModel.status = :status&quot;, { status: &quot;A&quot; })&#xA;  .andWhere(&#xA;    new Brackets((qb) =&gt; {&#xA;      qb.where(&quot;MyModel.region = :region&quot;, {&#xA;        region: &quot;central&quot;,&#xA;      }).orWhere(&quot;MyModel.zip_code = :zip&quot;, { zip: &quot;4831&quot; });&#xA;    })&#xA;  );&#xA;</code></pre>&#xA;<p>This will result in the SQL query:</p>&#xA;<pre><code>select * from model where type=&quot;new&quot; and status=&quot;A&quot; and (region=&quot;central&quot; or zip_code=&quot;4831&quot;);&#xA;</code></pre>&#xA;",17632251,,,,2022-09-02 12:28:38,"",,0,0,0,2022-09-02 12:28:38
73583795,1,,,0,58,"<p>We are working on a multi tenant django app that needs to display datetimes in tenant's timezone.</p>&#xA;<p>We achieve multitenancy using django-tenants, it separates tenants via Posgresql different schemas.</p>&#xA;<p>We are using graphql through graphene to expose our APIs, and we would like to make this implementation transparent to it, thus avoiding to manipulate every datetime we receive in input with timezone.localtime(received_datetime).</p>&#xA;<p>We've written a middleware that should do the job but graphene queries keep displaying the naive datetimes, to our understanding this is because django, while timezone aware, manage datetimes timezone only at forms and template levels, as per docs: <a href=""https://docs.djangoproject.com/en/4.1/topics/i18n/timezones/"" rel=""nofollow noreferrer"">https://docs.djangoproject.com/en/4.1/topics/i18n/timezones/</a></p>&#xA;<blockquote>&#xA;<p>When support for time zones is enabled, Django stores datetime information in UTC in the database, uses time-zone-aware datetime objects internally, and translates them to the end user’s time zone in templates and forms.</p>&#xA;</blockquote>&#xA;<p>By looking at timezone.now and timezone.localtime(timezone.now) values we get the correct results, but every date we get from graphql is both aware and with django &quot;from settings&quot; timezone (UTC), instead of tenant's timezone:</p>&#xA;<pre><code>timezone.now(). # prints 2022-09-02 13:38:46.658864+00:00&#xA;timezone.localtime(timezone.now()) # prints 2022-09-02 22:56:16.620355+09:00&#xA;</code></pre>&#xA;<p>Querying graphql api instead outputs:</p>&#xA;<pre><code>&quot;edges”: [&#xA;    {&#xA;      “node”: {&#xA;        “id”: “UG9saWN5Tm9kZToxNQ==“,&#xA;        “createdAt”: “2022-09-01T13:55:04.542763+00:00&quot; # in UTC timezone, instead of tenant's timezone&#xA;      }&#xA;    }&#xA;  ]&#xA;</code></pre>&#xA;<p><strong>middleware.py</strong></p>&#xA;<pre><code>class TimezoneMiddleware:&#xA;def __init__(self, get_response):&#xA;    self.get_response = get_response&#xA;&#xA;def __call__(self, request):&#xA;    tenant = request.tenant&#xA;    if not tenant.schema_name == &quot;public&quot;:&#xA;        if tenant.timezone:&#xA;            timezone.activate(pytz.timezone(tenant.timezone))&#xA;            &#xA;        else:&#xA;            timezone.deactivate()&#xA;    return self.get_response(request)&#xA;</code></pre>&#xA;<p><strong>settings.py</strong></p>&#xA;<pre><code>...&#xA;TIME_ZONE = &quot;UTC&quot;&#xA;USE_TZ = True&#xA;...&#xA;</code></pre>&#xA;<p><strong>tenant_model.py</strong></p>&#xA;<pre><code>class Client(TenantMixin):&#xA;&#xA;TIERS = [&#xA;    ('1', '1'),&#xA;    ('2', '2'),&#xA;    ('3','3')&#xA;]&#xA;&#xA;name = models.CharField(max_length=100)&#xA;paid_until =  models.DateField()&#xA;on_trial = models.BooleanField()&#xA;tier = models.CharField(max_length=20, choices=TIERS, default = '1')&#xA;created_on = models.DateField(auto_now_add=True)&#xA;storage_name = models.CharField(max_length=254, default='local')&#xA;dashboard_base_url = models.CharField(max_length=254, default='https://foo.bar')&#xA;auto_create_schema = True&#xA;timezone = models.CharField(max_length=254, default=&quot;Asia/Tokyo&quot;)&#xA;</code></pre>&#xA;<p>Every datetime we receive in input is a naive datetime (YYYY-MM-DDTHH:mm:ss format), is there any way to automagically (through a middleware) make it aware using tenant's timezone?</p>&#xA;",5810646,,,,2022-09-02 14:04:42,Unable to get graphql's datetime in tenant's timezone,<django><datetime><graphql><timezone><graphene-django>,0,0,0,2022-09-02 14:04:42
73615977,1,,,1,32,"<p>i try to get all the data which is belong to logged user but got incomplete result, it suppose to be returning 22 data but the code only returning 19 data</p>&#xA;<pre><code>export const getHistoryList = async (filterPayload: Array&lt;IFilterPayload&gt;, dispatch: Dispatch&lt;any&gt;) =&gt; {&#xA;    dispatch(setProductStart())&#xA;  &#xA;    let payload: IHistoryList[] = [];&#xA;    let filter: ModelImportHistoryFilterInput = {};&#xA;    let orFilter: ModelImportHistoryFilterInput[] = [];&#xA;  &#xA;    filterPayload.map((item) =&gt; {&#xA;        if (item.type === &quot;merchantID&quot;) {&#xA;          filter = { ...filter, merchantImportHistoriesId: { eq: item.value } };&#xA;        }&#xA;        if (item.type === &quot;action&quot;) {&#xA;          orFilter.push({ action: { eq: ImportHistoryAction[item.value as keyof typeof ImportHistoryAction] } });&#xA;        }&#xA;    });&#xA;  &#xA;    orFilter = orFilter.filter(item =&gt; item.action?.eq !== undefined);&#xA;    if (orFilter.length &gt; 0) {&#xA;      filter = { ...filter, or: orFilter };&#xA;    }&#xA;  &#xA;    const result = await (API.graphql({&#xA;        query: queriesCustom.listImportHistoriesCustom,&#xA;        variables: { filter: filter }&#xA;    }) as Promise&lt;{ data?: any }&gt;)&#xA;        .then((response) =&gt; {&#xA;            const data = response.data.listImportHistories.items;&#xA;            return data&#xA;        })&#xA;  &#xA;   ...&#xA;   &#xA;  }&#xA;</code></pre>&#xA;<p><a href=""https://i.stack.imgur.com/ZG4Zu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZG4Zu.png"" alt=""enter image description here"" /></a></p>&#xA;<p>if i remove the filter from variables i got only 100 data from total 118 data</p>&#xA;<p><a href=""https://i.stack.imgur.com/lA0m4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lA0m4.png"" alt=""enter image description here"" /></a></p>&#xA;<p>i already try this temporary solution to set the limit in variables to 2000, which is worked, but i don't think this is the correct approach</p>&#xA;<pre><code>  const result = await (API.graphql({&#xA;      query: queriesCustom.listImportHistoriesCustom,&#xA;      variables: { limit: 2000, filter: filter }&#xA;  }) as Promise&lt;{ data?: any }&gt;)&#xA;      .then((response) =&gt; {&#xA;          const data = response.data.listImportHistories.items;&#xA;          return data&#xA;      })&#xA;</code></pre>&#xA;<p>how can i overcome this problem please help?</p>&#xA;",7034717,,,,2022-09-06 01:52:06,"fetch list of data got incomplete result, how to remove the limitation",<graphql><amazon-dynamodb><aws-amplify>,0,0,0,2022-09-06 01:52:06
73646227,1,,,0,11,"<p>I had a working component with infinite scroll I have none added any extra packages, and the extra data is being received from the API but for show reason the components has stopped re-rendering after the updateQuery function has run. Any help would be appreicated.</p>&#xA;<p><code>const { loading, error, data, fetchMore, subscribeToMore } = useQuery(GET_TIPS, {fetchPolicy: &quot;network-only&quot;, variables: {filter: `{&quot;valid&quot;: true}`, limit: 20}});</code></p>&#xA;<pre><code>          variables: {&#xA;            filter: `{&quot;_id&quot;: {&quot;$lt&quot;: &quot;${lastId}&quot;}, &quot;valid&quot;: true}`,&#xA;            limit: 20&#xA;          },&#xA;          updateQuery(previousResult, { fetchMoreResult }) {&#xA;            &#xA;            const connection = fetchMoreResult.getTips;&#xA;            if (connection.length === 0) {&#xA;              return {&#xA;                getTips: [...previousResult.getTips],&#xA;              };&#xA;            }&#xA;            lastId = connection[connection.length - 1]._id&#xA;            if (connection.length &lt; 20) {&#xA;              setHasMore(false)&#xA;            }&#xA;            console.log(connection)&#xA;            console.log(hasMore)&#xA;            return {&#xA;              getTips: [...previousResult.getTips, ...connection],&#xA;            };&#xA;          },```&#xA;</code></pre>&#xA;",15118622,,,,2022-09-08 08:52:13,"React Apollo client ""3.6.9"" fetchMore has stopped re-rendering component ""network-only""",<reactjs><apollo-client>,0,0,0,2022-09-08 08:52:13
73650899,1,,,0,96,"<p>I've been stuck with this problem in my graphQL API, and I don't know how to unsolved it.</p>&#xA;<p>schema.graphQL:</p>&#xA;<pre><code>type User @model {&#xA;  id: ID!&#xA;  username: String!&#xA;  email: String!&#xA;&#xA;  orders: [Order] @connection(keyName: &quot;byUser&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type Car @model {&#xA;  id: ID!&#xA;  type: String!&#xA;  latitude: Float,&#xA;  longitude: Float,&#xA;  heading: Float,&#xA;  isActive: Boolean&#xA;&#xA;  orders: [Order] @connection(keyName: &quot;byCar&quot;, fields: [&quot;id&quot;])&#xA;}&#xA;&#xA;type Order @model&#xA;  @key(name: &quot;byUser&quot;, fields: [&quot;userId&quot;])&#xA;  @key(name: &quot;byCar&quot;, fields: [&quot;carId&quot;, &quot;createAt&quot;]) {&#xA;  id:ID!&#xA;  createAt: ID!&#xA;&#xA;  type: String!&#xA;&#xA;  originLatitude: Float!&#xA;  originLongitude: Float!&#xA;&#xA;  destLatitude: Float!&#xA;  destLongitude: Float!&#xA;&#xA;  userId: ID! // I think theres something wrong at here.&#xA;  user: User @connection(fields: [&quot;userId&quot;])&#xA;&#xA;  carId: ID!&#xA;  car: Car @connection(fields: [&quot;carId&quot;])&#xA;}&#xA;</code></pre>&#xA;<p>Mutations.js (Generated by AWS):</p>&#xA;<pre><code>export const createOrder = /* GraphQL */ `&#xA;  mutation CreateOrder(&#xA;    $input: CreateOrderInput!&#xA;    $condition: ModelOrderConditionInput&#xA;  ) {&#xA;    createOrder(input: $input, condition: $condition) {&#xA;      id&#xA;      createAt&#xA;      type&#xA;      originLatitude&#xA;      originLongitude&#xA;      destLatitude&#xA;      destLongitude&#xA;      userId&#xA;      user {&#xA;        id&#xA;        username&#xA;        email&#xA;        orders {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      carId&#xA;      car {&#xA;        id&#xA;        type&#xA;        latitude&#xA;        longitude&#xA;        heading&#xA;        isActive&#xA;        orders {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      createdAt&#xA;      updatedAt&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>code:</p>&#xA;<pre><code>    // submit to server&#xA;        try {&#xA;            const userInfo = await Auth.currentAuthenticatedUser();&#xA;&#xA;            const date = new Date();&#xA;            const input = {&#xA;                createAt: date.toISOString(),&#xA;                type,&#xA;                originLatitude: originPlace.details.geometry.location.lat || 0,&#xA;                originLongitude: originPlace.details.geometry.location.lng || 0,&#xA;&#xA;                destLatitude: destinationPlace.details.geometry.location.lat || 0,&#xA;                destLongitude: destinationPlace.details.geometry.location.lng || 0,&#xA;                &#xA;                userID: userInfo.attributes.sub,&#xA;                carID: &quot;1&quot;,&#xA;            }&#xA;&#xA;            const response = await API.graphql (&#xA;                graphqlOperation (&#xA;                    createOrder, {&#xA;                        input: input&#xA;                    },&#xA;                )&#xA;            )&#xA;&#xA;            console.log(response);&#xA;            Alert.alert (&#xA;                &quot;Order has been submitted successful!!!&quot;,&#xA;                [{&#xA;                    text: &quot;Go home&quot;,&#xA;                    onPress: () =&gt; navigation.navigate('HomeScreen')&#xA;                }]&#xA;            )&#xA;        } catch (e) {&#xA;            console.error(e);&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>when I try to submit it to the server it gave me an error.</p>&#xA;<blockquote>&#xA;<p>{&quot;data&quot;: null, &quot;errors&quot;: [{&quot;locations&quot;: null, &quot;message&quot;: &quot;The&#xA;variables input contains a field name 'userID' that is not defined for&#xA;input object type 'CreateOrderInput' &quot;, &quot;path&quot;: null}]}</p>&#xA;</blockquote>&#xA;",15785417,,7399478,2022-09-08 14:50:56,2022-09-08 14:50:56,"""The variables input contains a field name 'userID' that is not defined for input object type 'CreateOrderInput'",<javascript><react-native><aws-lambda><graphql><aws-amplify>,0,2,0,2022-09-08 14:38:19
73654507,1,,,0,121,"<p>I'm trying to filter some data from strapi based on key fields.&#xA;I have a key in every component, and I can sort each component by that key.&#xA;In graphql, I need to filter multiple components using the &quot;and&quot; &amp; &quot;or&quot; keywords.</p>&#xA;<pre><code> query {&#xA;  pageLayouts(filters: { key: { eq: &quot;faqs&quot; } }) {&#xA;    data {&#xA;      id&#xA;      attributes {&#xA;        title&#xA;        subtitle&#xA;        menus {&#xA;          data {&#xA;            id&#xA;            attributes {&#xA;              name&#xA;              Entry {&#xA;                id&#xA;                title&#xA;                link&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<h1>What i need is:</h1>&#xA;<pre><code>filters: { key: { eq: &quot;faqs&quot; or &quot;aboutus&quot;, or &quot;privacy&quot; or home page&quot;} }&#xA;</code></pre>&#xA;<p>It's like retriving data</p>&#xA;",16986538,,,,2022-09-08 20:01:56,How to deep filter data from strapi using graphql?,<graphql><strapi>,0,0,0,2022-09-08 20:01:56
73669620,1,,,0,34,"<p>I'm making a clone of social app. I'm using graphQL as my backend. My problem is that every time I query a list of data it is returning the same result. When I will release that app, the user base will be very small so the amount or data is less in number. So I'm facing the issue described below:</p>&#xA;<p><strong>1.</strong> My data in data base is like:</p>&#xA;<p>I'd=1 title=hello1</p>&#xA;<p>I'd=2 title=hello2</p>&#xA;<p>I'd=3 title=hello3</p>&#xA;<p><strong>2.</strong> When I'm querying data through pagination with limit=3, I'm getting list of items is like:</p>&#xA;<p><strong>Query 1</strong></p>&#xA;<p>I'd=1 title=hello1</p>&#xA;<p>I'd=2 title=hello2</p>&#xA;<p>I'd=3 title=hello3</p>&#xA;<p><strong>3.</strong> When I'm adding new items to data base, it is invoked in between the items like below:</p>&#xA;<p>I'd=1 title=hello1</p>&#xA;<p><strong>I'd=4 title=hello4</strong></p>&#xA;<p>I'd=2 title=hello2</p>&#xA;<p>I'd=3 title=hello3</p>&#xA;<p><strong>I'd=5 title=hello5</strong></p>&#xA;<p><strong>4.</strong> So next fresh query result(limit=3) Will be like:</p>&#xA;<p><strong>Query 2</strong></p>&#xA;<p>I'd=1 title=hello1</p>&#xA;<p><strong>I'd=4 title=hello4</strong></p>&#xA;<p>I'd=2 title=hello2</p>&#xA;<p>Look at the data set previously our query result was: I'd=1,2 &amp; 3 now I'd=1,4 &amp; 2 so the user will get same result as id=1,2 is in new list.</p>&#xA;<p>If I will save pagination nextToken/cursor(I'd=3) of first query(<strong>query 1</strong>) then after new data added to data base the new query will start from I'd=5, because it is present after I'd=3. Look at the new dataset it will miss I'd=4 because nextToken is saved for I'd=3 for the query will start from I'd=5. Hope you can understand.</p>&#xA;<p>If your suggestion is add a sort key of created at, I want say that if I will add some filter, the data set will become so much selective that might become the reason of limited number of data in feed and we know a feed should query unlimited data.</p>&#xA;",19709318,,19709318,2022-09-10 08:54:27,2022-09-10 08:54:27,How to code a simple algorithm to fetch list of data through pagination in a fresh new application?,<api><graphql><amazon-dynamodb><aws-appsync-resolver>,0,1,0,2022-09-10 05:57:53
73679650,1,,,0,104,<p>Say I have the following fragment:</p>&#xA;<pre><code>fragment ConversationSnippet on Conversation {&#xA;    uuid&#xA;    unreadMessages&#xA;    profileThatHasUnreadMessages&#xA;    updatedAt&#xA;    createdAt&#xA;    profiles{&#xA;        ...ConversationProfileSnippet&#xA;    }&#xA;    messages{&#xA;        ...MessageSnippet&#xA;    }&#xA;    ongoingCall&#xA;    pendingCall&#xA;    pendingCallProfile {&#xA;        ...ConversationProfileSnippet&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>The <code>pendingCallProfile</code> could be null null. Is there a way for me to specify that in the fragment? I'm facing an issue where if the <code>pendingCallProfile</code> is null the entire query fails to return anything.</p>&#xA;,1714029,,,,2022-09-11 14:11:13,Graphql Codegen specifying optional fields,<graphql><graphql-codegen><urql>,1,0,0,2022-09-11 13:26:47
73679942,1,,,0,61,"<p>I am using AWS Amplify for a project. Within it, I'm using Datastore and GraphQL. The data is stored in DynamoDB. I store the statistics of each user in a table. Each time the user does something useful in the app, a new record is added in the table with the latest statistic. I want to show only the latest statistic in my interface. For this I'm using the following code.</p>&#xA;<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">&#xD;&#xA;<div class=""snippet-code"">&#xD;&#xA;<pre class=""snippet-code-js lang-js prettyprint-override""><code> var userStats = await DataStore.query(&#xA;   UserStats, &#xA;   (c) =&gt; c.userId('eq', userid),&#xA;   {sort: (s) =&gt; s.altCreatedAt(SortDirection.DESC)},&#xA;   {limit: 1}&#xA;  );</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;<p>This query is fetching results from the table for the correct userid, it is sorting it correctly, but the {limit: 1} part of it is not working. I get everything, not just the last record. Then, in subsequent code, I have to take the first item in the array. I feel that is inefficient. It would be better if the query working right and I get just the latest statistic. How can I solve this? Is there a better way to handle this problem?</p>&#xA;",4513611,,,,2022-09-11 14:10:22,AWS Amplify Datastore GraphQL DyanmoDB API limit not working in query,<graphql><amazon-dynamodb><aws-amplify><aws-datastore>,0,0,0,2022-09-11 14:10:22
73687573,1,,,0,31,"<p>The backend Java code is sending the API response in <strong>application/csv</strong> format and I need to consume it using <strong>GraphQL</strong> and I need to use the <strong>CSV response</strong> to download the response as a CSV file. How do I write a GraphQL query for the same. Thanks !</p>&#xA;<pre><code> EXAMPLE API RESPONSE&#xA;&quot;Name #&quot;, &quot;Description&quot;, &quot;AGE&quot;&#xA;&quot;JOHN&quot;,&quot;STUDENT&quot;,&quot;22&quot;&#xA;&quot;BOB&quot;,&quot;TEACHER&quot;,&quot;34&quot;&#xA;&quot;JOEY&quot;,&quot;STUDENT&quot;,&quot;30&quot;&#xA;</code></pre>&#xA;",19624423,,19624423,2022-09-12 10:34:19,2022-09-12 10:34:19,How to consume a Java API into GraphQL while the API is sending response in application/csv format,<java><reactjs><api><graphql><graphql-js>,0,0,0,2022-09-12 10:04:58
73710340,2,,71967450,1,,"<p>I just ran into this same issue. I can't make out the error you're reporting, but here is what worked for me.</p>&#xA;<p>You can use <code>filter</code> at the collection level to drill down to nested fields for the corresponding <code>attributes</code>. This follows the GraphQL example at the bottom of this <a href=""https://strapi.io/blog/deep-filtering-alpha-26"" rel=""nofollow noreferrer"">Strapi resource on filtering nested fields</a>.</p>&#xA;<h2>Solution</h2>&#xA;<pre><code>query GetActs ($age:Int, $place:String) {&#xA;  acts (filters: {ages: {age: {eq: $age}}, places: {place: {eq: $place}}}) {&#xA;    data {&#xA;      id&#xA;      attributes {&#xA;        Title&#xA;        ages {&#xA;          data {&#xA;            id&#xA;            attributes {&#xA;              age&#xA;            }&#xA;          }&#xA;        }&#xA;        places {&#xA;          data {&#xA;            id&#xA;            attributes {&#xA;              place&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",3145115,,3145115,2022-09-22 01:46:48,2022-09-22 01:46:48,"",,0,0,0,2022-09-14 00:40:10
73722245,1,73722357,,0,21,"<p>I'm trying to set the date time in Prisma migrate to human like one minute age, one month ago how I can manage to do it?</p>&#xA;",16946991,,,,2022-09-14 19:39:49,"How i can turn datetime to like ""one minute age"" in prisma node js graphql?",<node.js><graphql><prisma>,1,0,0,2022-09-14 19:29:10
73722491,2,,73721476,0,,"<p>Went and used postman to build the GraphQL and exported the cURL syntax after it was working properly.</p>&#xA;<pre><code>curl --location --request POST 'https://freeagent.network/api/graphql' \&#xA;--header 'Authorization: bearer MY_TOKEN' \&#xA;--header 'Content-Type: application/json' \&#xA;--header 'Cookie: hazel=True' \&#xA;--data-raw '{&quot;query&quot;:&quot;query listEntityValues($entity: String!, $fields: [String], $order: [[String]], $limit: Int, $offset: Int, $pattern: String, $filters: [Filter]) {\n        listEntityValues(entity: $entity, fields: $fields, order: $order, limit: $limit, offset: $offset, pattern: $pattern, filters: $filters) {\n          count\n          entity_values {\n            id\n            seq_id\n            field_values\n          }\n        }\n      }&quot;,&quot;variables&quot;:{&quot;entity&quot;:&quot;product&quot;,&quot;show_hidden&quot;:false}}'&#xA;</code></pre>&#xA;",2355051,,,,2022-09-14 19:52:36,"",,0,0,0,2022-09-14 19:52:36
73768648,1,,,0,18,<p>I am trying to add float values in enum typedef as given below:</p>&#xA;<pre><code>enum PRIORITYTYPE {&#xA;        0.1&#xA;        0.2&#xA;        0.3&#xA;        0.4&#xA;        0.5&#xA;        0.6&#xA;        0.7&#xA;        0.8&#xA;        0.9&#xA;        1.0&#xA;    }&#xA;</code></pre>&#xA;<p>But I getting error. How to solve this issue by checking fixed values and place it in typedef? whereas string working proper when I enter sting as given but not float nor int</p>&#xA;<pre><code>enum FREQUENCYTYPE {&#xA;        Daily&#xA;        Weekly&#xA;        Monthly&#xA;        Yearly&#xA;    }&#xA;</code></pre>&#xA;,19379832,,,,2022-09-19 04:55:21,How to passing enum in typedef as a float?,<enums><graphql><typedef>,0,2,0,2022-09-19 04:55:21
73774404,2,,51526079,0,,"<p>GraphQL doesn't directly support case insensitive, but regex sure does. This worked for me:</p>&#xA;<p>'{brand: {regexp: &quot;/$normalBrand/i&quot;}}'</p>&#xA;",10634931,,,,2022-09-19 13:46:03,"",,0,0,0,2022-09-19 13:46:03
73782645,1,,,0,22,"<p>The following is a graph QL example:</p>&#xA;<p>Query:</p>&#xA;<pre class=""lang-bash prettyprint-override""><code>query ABC(&#xA;  $x: String!&#xA;  $y: timestamp!&#xA;  $z: timestamp!&#xA;) {&#xA;    area&#xA;    getInTime&#xA;    getOutTime&#xA;&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Variable:</p>&#xA;<pre class=""lang-bash prettyprint-override""><code>{&#xA;&quot;x&quot; : &quot;22222&quot;,&#xA;&quot;y&quot; : &quot;333&quot;,&#xA;&quot;z&quot; : &quot;4444&quot;&#xA;}&#xA;</code></pre>&#xA;<p>Now, is there any way that I could use dynamic variable names instead of the query param names(x,y,z) without changing the param names from the Query.</p>&#xA;<p>Thanks.</p>&#xA;",19099652,,,,2022-09-20 06:53:17,Dynamic Graph QL variable names,<graphql>,0,0,0,2022-09-20 06:53:17
73797543,2,,73788238,0,,"<p>Did you miss the comma?</p>&#xA;<p>Behind <code>Queries::AllUsers</code> need <code>,</code></p>&#xA;<pre class=""lang-rb prettyprint-override""><code>...&#xA;&#xA;RSpec.describe Queries::AllUsers, type: :request do&#xA;&#xA;...&#xA;</code></pre>&#xA;",7360286,,,,2022-09-21 08:23:41,"",,0,4,0,2022-09-21 08:23:41
73798247,1,,,0,102,"<p>I need to have filter on ResolveField items with this structure.&#xA;This is my Schema First simple example:</p>&#xA;<pre><code>type Product {&#xA;  price: Int&#xA;  categoryId: Int&#xA;  metadata: ProductMetadata&#xA;}&#xA;&#xA;type ProductMetadata {&#xA;  field: String&#xA;  language: LangEnum&#xA;  productId: Int&#xA;  value: String;&#xA;}&#xA;input ProductFilters {&#xA;  price: Int&#xA;}&#xA;&#xA;type Query {&#xA;  getProducts(&#xA;    filters: ProductFilters&#xA;  )&#xA;}&#xA;</code></pre>&#xA;<p>I want to query the structure like this in nestJs:</p>&#xA;<pre><code>  getProducts(filters: {parentId: 0}, page: 1) {&#xA;    price&#xA;    categoryId&#xA;    metadata(filters: {title: &quot;something&quot;})&#xA;}&#xA;</code></pre>&#xA;<p>Any clue?</p>&#xA;",2723021,,,,2022-09-21 09:14:12,Nested filter GraphQl solution in NestJs with @ResolveField,<graphql><nestjs><nestjs-graphql>,0,0,0,2022-09-21 09:14:12
73807296,2,,73806392,0,,"<p>For any others stumbling on this, I ended up getting this to work with <a href=""https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/graphql-api.html#pagination"" rel=""nofollow noreferrer"">pagination from the Strapi GraphQL API</a></p>&#xA;<h2>Solution</h2>&#xA;<pre><code>const GET_RECENT_POSTS_QUERY = `&#xA;query ($limit: Int!) {&#xA;  posts (pagination: {start: 0, limit: $limit}, sort: &quot;publishedAt:DESC&quot;) {&#xA;    data {&#xA;      attributes {&#xA;        publishedAt&#xA;        title&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;`&#xA;&#xA;export default function Example() {&#xA;  const [res] = useQuery({&#xA;    query: GET_RECENT_POSTS_QUERY,&#xA;    variables: { limit: 3 },&#xA;  })&#xA;  // ...&#xA;</code></pre>&#xA;",3145115,,,,2022-09-21 21:50:15,"",,0,0,0,2022-09-21 21:50:15
73816804,2,,73815201,0,,"<p>I believe this is what you are looking for:</p>&#xA;<pre><code>import stardog&#xA;&#xA;conn_details = {&#xA;  'endpoint': 'http://localhost:5820',&#xA;  'username': 'admin',&#xA;  'password': 'admin'&#xA;}&#xA;&#xA;conn = stardog.Connection('myDb', **conn_details) # assuming you have this since you already have 'conn', just sending it to a DB named 'myDb'&#xA;&#xA;file = open('snomed.ttl', 'rb') # just opening a file as a binary object to mimic&#xA;file_name = 'snomed.ttl' # adding this to keep your function as it is&#xA;&#xA;def add_graph(file, file_name):&#xA;    file.seek(0)&#xA;    file_content = file.read() # this will be of type bytes&#xA;    if 'snomed' in file_name:&#xA;        conn.begin() # added this to begin a connection, but I do not think it is required&#xA;        conn.add(stardog.content.Raw(file_content, content_type='text/turtle'), graph_uri='sct:900000000000207008')&#xA;        conn.commit() # added this to commit the added data&#xA;&#xA;add_graph(file, file_name) # I just ran this directly in the Python file for the example.&#xA;</code></pre>&#xA;<p>Take note of the <code>conn.add</code> line where I used <code>text/turtle</code> as the <code>content-type</code>.  I added some more context so it can be a running example.</p>&#xA;<p>Here is the sample file as well <code>snomed.ttl</code>:</p>&#xA;<pre><code>&lt;http://api.stardog.com/id=1&gt; a :person ;&#xA;   &lt;http://api.stardog.com#first_name&gt; &quot;John&quot; ;&#xA;   &lt;http://api.stardog.com#id&gt; &quot;1&quot; ;&#xA;   &lt;http://api.stardog.com#dob&gt; &quot;1995-01-05&quot; ;&#xA;   &lt;http://api.stardog.com#email&gt; &quot;john.doe@example.com&quot; ;&#xA;   &lt;http://api.stardog.com#last_name&gt; &quot;Doe&quot; .&#xA;</code></pre>&#xA;<p><strong>EDIT - Query Test</strong></p>&#xA;<p>If it runs successfully and there are no errors in <code>stardog.log</code> you should be able to see results using this query. Note that you have to specify the Named Graph since the data was added there.  If you query without specifying, it will show no results.</p>&#xA;<pre><code>SELECT * {&#xA;    GRAPH &lt;sct:900000000000207008&gt; {&#xA;        ?s ?p ?o&#xA;    }&#xA;}&#xA;</code></pre>&#xA;<p>You can run that query in <code>stardog.studio</code> but if you want it in Python, this will print the JSON result:</p>&#xA;<pre><code>print(conn.select('SELECT * { GRAPH &lt;sct:900000000000207008&gt; { ?s ?p ?o } }'))&#xA;</code></pre>&#xA;",1469640,,1469640,2022-09-23 12:23:46,2022-09-23 12:23:46,"",,0,3,0,2022-09-22 14:56:05
73841025,1,,,0,33,"<p>I am using Redis to store JSON data with a model that has <code>Id</code> and <code>Name</code> fields.  My goal is to implement cursor pagination over this data using the <code>Name</code> as the cursor.  I realize this isn't unique and I'll need to do some additional work to resolve the issues presented by that using that particular field as the cursor.  However I am struggling to find a way to even begin to implement a basic cursor pagination with Redis commands.  Redis has options for various string operations using the &quot;Search&quot; module but these are limited to search within a given string, nothing with comparisons.  Am I barking up the wrong tree here and cursor pagination is not possible?  Or is there something fundamental I am missing in my design?</p>&#xA;",186464,,,,2022-10-09 06:06:26,Cursor Pagination with RedisJSON,<redis><graphql>,1,0,0,2022-09-24 22:47:14
73863508,1,,,0,13,"<p>I am new to graphql, working on an existing schema. I've to add new filters into my existing API, but either my syntax is wrong or my query in postman is wrong.</p>&#xA;<p>Essentially, I want to be able to query on both <code>population</code> and <code>country</code></p>&#xA;<p>Here's how my schema looks:</p>&#xA;<pre><code>scalar JSON&#xA;&#xA;schema {&#xA;   query: Query&#xA;}&#xA;....&#xA;&#xA;input PercentageInput {&#xA;  gte: Int&#xA;}&#xA;&#xA;input Population {&#xA;  percentage: PercentageInput&#xA;}&#xA;&#xA;input Country {&#xA;  percentage: PercentageInput&#xA;}&#xA;&#xA;input And {&#xA;  population: [Population]&#xA;  country: [Country]&#xA;}&#xA;&#xA;input AudienceFilterInput {&#xA;  market: String&#xA;  and: [Population]&#xA;}&#xA;&#xA;input TalentMetadataFilterInput {&#xA;  citizen_of: ListFilterInput&#xA;  gender: [String]&#xA;  original_country: [String]&#xA;  audience: AudienceFilterInput&#xA;}&#xA;</code></pre>&#xA;<p>I would ideally want to query with both population and country with percentage greater than some value.</p>&#xA;<p>Whenever I query in Postman using this:</p>&#xA;<pre><code>query MyQuery {&#xA;    talentMetadata(&#xA;    filter: { audience: { and: [ population {male_percentage : { gte: 80 }}, country { us_percentage : { gte: 30 }}]} },,&#xA;    size: 100)..&#xA;}&#xA;</code></pre>&#xA;<p>I get the following error:</p>&#xA;<pre><code>&quot;message&quot;: &quot;Field \&quot;male_percentage\&quot; is not defined by type \&quot;Population\&quot;. Did you mean \&quot;percentage\&quot;?&quot;,&#xA;</code></pre>&#xA;<p>Also, if you share the postman query along with the schema, would be awesome.</p>&#xA;",3977629,,,,2022-09-27 22:19:10,"Graphql schema, add multiple custom objects in and and or",<graphql><apollo><express-graphql>,1,0,0,2022-09-27 06:56:59
73870746,2,,73870595,0,,"<p>This happens because the <code>on</code> keyword is a reserved keyword in GraphQL.</p>&#xA;<p>One of the Type Conditions is <code>on</code> NamedType, see <a href=""https://spec.graphql.org/June2018/#sec-Type-Conditions"" rel=""nofollow noreferrer"">the official spec file of GraphQL</a>.</p>&#xA;<pre><code>query FragmentTyping {&#xA;  profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) {&#xA;    handle&#xA;    ...userFragment&#xA;    ...pageFragment&#xA;  }&#xA;}&#xA;&#xA;fragment userFragment on User {&#xA;  friends {&#xA;    count&#xA;  }&#xA;}&#xA;&#xA;fragment pageFragment on Page {&#xA;  likers {&#xA;    count&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>See the <code>on</code> used in <code>fragment userFragment on User</code>? Your GraphQL got confused because you are using <code>on</code> as a field within the query, while it expects to be a fragment. <a href=""https://graphql.org/learn/queries/#fragments"" rel=""nofollow noreferrer"">Read more about fragments here</a>. Also, a fragment's name can be anything, except for <code>on</code>, see the <a href=""https://spec.graphql.org/June2018/#sec-Language.Fragments"" rel=""nofollow noreferrer"">official spec file</a>.</p>&#xA;<p>One way to solve this issue might be to rename the field in your query, but I am not sure if GraphQL will complain about this approach as well:</p>&#xA;<pre><code>query TimeLine($inputData: InputData!) {&#xA;    getTimeLine(inputData: $inputData) {&#xA;        dataOn: on&#xA;        updated&#xA; }&#xA;}&#xA;</code></pre>&#xA;",6022243,,,,2022-09-27 16:16:30,"",,0,3,0,2022-09-27 16:16:30
73874311,2,,73863508,0,,<p>I got the solution working.</p>&#xA;<p>Here's how my schema looks:</p>&#xA;<pre><code>scalar JSON&#xA;&#xA;schema {&#xA;   query: Query&#xA;}&#xA;....&#xA;&#xA;input PercentageInput {&#xA;  gte: Int&#xA;}&#xA;&#xA;input Population {&#xA;  genx_percentage: PercentageInput&#xA;  geny_percentage: PercentageInput&#xA;}&#xA;&#xA;input Country {&#xA;  male_percentage: PercentageInput&#xA;  female_percentage: PercentageInput&#xA;}&#xA;&#xA;input AudienceFilterInput {&#xA;  country: Country&#xA;  population: Population&#xA;}&#xA;&#xA;input TalentMetadataFilterInput {&#xA;  citizen_of: ListFilterInput&#xA;  gender: [String]&#xA;  original_country: [String]&#xA;  audience: AudienceFilterInput&#xA;}&#xA;</code></pre>&#xA;<p>This with the below query:</p>&#xA;<pre><code>query MyQuery {&#xA;    &#xA;  talentMetadata(&#xA;    filter: {&#xA;      audience: {&#xA;        country: { female_percentage: { gte: 80 } }&#xA;        population: { genx_plus_percentage: { gte: 30 } }&#xA;      }&#xA;    }&#xA;    size: 100&#xA;  ) {&#xA;    items {&#xA;      states&#xA;      drinks&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;,3977629,,,,2022-09-27 22:19:10,"",,0,0,0,2022-09-27 22:19:10
73874887,1,,,-2,63,<p>Is there any way I could re-write this SQL query using <strong>Prisma Client</strong>.</p>&#xA;<pre><code>SELECT TOP 1 * FROM [myTable] &#xA;WHERE Name = 'Test' and Size = 2 and PType = 'p'&#xA;ORDER BY ABS( Area - @input ) &#xA;</code></pre>&#xA;,3278869,,,,2022-10-07 17:27:35,closest numeric value in database using Prisma Client,<sql><sqlite><prisma><prisma-graphql>,1,0,0,2022-09-27 23:57:57
73913077,2,,73900867,1,,"<p>This is the expected behavior of Postgres and doesn't have anything in particular to do with Hasura. <code>https://stackoverflow.com/questions/5876218/difference-between-timestamps-with-without-time-zone-in-postgresql</code></p>&#xA;<p>Effectively though the <code>timestamptz</code> datatype stores a date as UTC which is a specific point in time that can be later interpreted into any other timezone.</p>&#xA;<p>That's why you can see that you're inserting a date on the 29th but getting back a date on the 30th.</p>&#xA;<p>If you specifically need to know what the original timezone was you'll have to store that data separately. You can query out the date in any timezone, for example:</p>&#xA;<pre class=""lang-sql prettyprint-override""><code>SELECT in AT TIME ZONE 'CST' FROM attendance&#xA;</code></pre>&#xA;",1364771,,,,2022-09-30 19:09:39,"",,0,0,0,2022-09-30 19:09:39
73936522,1,,,0,33,"<p>I'm trying to send graphql request with an array in the query is there any way I can do that?</p>&#xA;<pre><code>&#xA;query Filter($user: [String]) {&#xA;  filter(user: $user) {&#xA;    id&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>and this array that I want to send</p>&#xA;<p>user = [{ &quot;userName&quot;:[{&quot;userName&quot;:&quot;simo&quot;},{&quot;userName&quot;:&quot;jhon&quot;}]}]</p>&#xA;",16946991,,,,2022-10-03 13:55:57,how i can send array in graphql request,<node.js><reactjs><graphql><graphql-mutation>,0,0,0,2022-10-03 13:55:57
73978366,1,,,0,41,"<p><strong>1.</strong> I want to create a GraphQL query that can filter by multiple records.<br />&#xA;It is about filtering details of statistics. For example, the statistic contains the fields &quot;Number of deaths&quot;, &quot;Number of cases&quot;, &quot;Number of recovered&quot;.<br />&#xA;I have already written queries that can filter by the individual fields. Now I want to program a query that uses multiple filters, or a query in which multiple queries are nested.<br />&#xA;I have already tried to define the individual steps of each query in a common query. You can see this in the attached images. The program compiles first. However, when I execute the query in the GraphQL UI, I get error messages</p>&#xA;<p><strong>2.</strong> Unfortunately, I have not yet received any helpful tips regarding my query or my error.</p>&#xA;<p><a href=""https://i.stack.imgur.com/qDlnn.png"" rel=""nofollow noreferrer"">Screenshot</a></p>&#xA;<p>At the top left you can see the individual queries, at the top right the merged query and at the bottom the errors as soon as I try to execute the query.</p>&#xA;",20054308,,13302,2022-10-06 18:16:43,2022-10-06 18:16:43,Nested queries in SmallRye GraphQL,<graphql><quarkus><smallrye>,0,1,0,2022-10-06 18:15:07
73983980,1,,,0,10,"<p>I have an input like this:</p>&#xA;<pre><code>filter(name: String, value: &quot;abc&quot;)&#xA;filter(name: String, value: 1)&#xA;filter(name: String, value: [1,2,3,4])&#xA;filter(name: String, value: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])&#xA;</code></pre>&#xA;<p>How to config schema.graphqls so it can accept like this:</p>&#xA;<pre><code>input filter{&#xA;     name: String&#xA;     value: (can be mutiple base on input Int, String, Float, Boolean)&#xA;}&#xA;</code></pre>&#xA;",20182085,,20182085,2022-10-09 17:58:52,2022-10-09 17:58:52,"How to configurate schema graphqls input can select mutiple type with same field ? (Graphql, Spring Boot)",<spring><graphql>,0,0,0,2022-10-07 07:49:25
73991780,1,,,1,30,"<p>I have this query in sequelize which is returning data but the join skews my sum aggregate.  Here is the code...</p>&#xA;<pre><code>key: &quot;listGoogleTextAds&quot;,&#xA;    prototype:&#xA;      &quot;(customer_id: Int, start_date: String, end_date: String): [GoogleTextAds]&quot;,&#xA;    run: async args =&gt; {&#xA;      const allIds = await google_text_ads&#xA;        .findAll({&#xA;          attributes: [&#xA;            &quot;ad_id&quot;,&#xA;            [sequelize.fn(&quot;max&quot;, sequelize.col(&quot;google_text_ads.date&quot;)), &quot;date&quot;],&#xA;            [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_text_ads.impressions&quot;)), &quot;impressions&quot;],&#xA;            [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_text_ads.clicks&quot;)), &quot;clicks&quot;],&#xA;            [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_text_ads.cost&quot;)), &quot;cost&quot;]&#xA;          ],&#xA;          where: {&#xA;            customer_id: args.customer_id,&#xA;            date: {&#xA;              [Op.gte]: args.start_date,&#xA;              [Op.lte]: args.end_date&#xA;            },&#xA;            status: {&#xA;              [Op.in]: [&quot;ENABLED&quot;]&#xA;            },&#xA;            type: {&#xA;              [Op.in]: [&quot;EXPANDED_TEXT_AD&quot;]&#xA;            }&#xA;          },&#xA;          group: [&quot;ad_id&quot;],&#xA;          include: [&#xA;            {&#xA;              model: google_ads_group_name,&#xA;              as: 'google_ads_group_name',&#xA;              required: true,&#xA;              attributes: [&#xA;                &quot;ad_group_name&quot;,&#xA;                &quot;ad_group_id&quot;&#xA;              ],&#xA;              where: {&#xA;                customer_id: args.customer_id,&#xA;                date: {&#xA;                  [Op.gte]: args.start_date,&#xA;                  [Op.lte]: args.end_date&#xA;                },&#xA;                status: {&#xA;                  [Op.in]: [&quot;ENABLED&quot;]&#xA;                }&#xA;              },&#xA;              required: false&#xA;            },&#xA;          ]&#xA;        })&#xA;        .map(item =&gt; item.toJSON());&#xA;      const textAds = uniqBy(&#xA;        await google_text_ads.findAll({&#xA;          where: sequelize.where(&#xA;            sequelize.fn(&#xA;              &quot;concat&quot;,&#xA;              sequelize.col(&quot;ad_id&quot;),&#xA;              &quot;-&quot;,&#xA;              sequelize.col(&quot;date&quot;)&#xA;            ),&#xA;            {&#xA;              [Op.in]: allIds.map(({ ad_id, date }) =&gt; `${ad_id}-${date}`)&#xA;            }&#xA;          )&#xA;        }),&#xA;        ({ ad_id, date }) =&gt; `${ad_id}-${date}`&#xA;      );&#xA;      return textAds.map(ad =&gt; {&#xA;        const idMap = allIds.find(({ ad_id }) =&gt; ad_id === ad.ad_id);&#xA;        return {&#xA;          ...ad.toJSON(),&#xA;          clicks: idMap.clicks,&#xA;          impressions: idMap.impressions,&#xA;          cost: idMap.cost,&#xA;          google_ads_group_name: idMap.google_ads_group_name&#xA;        };&#xA;      });&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>I was able to write the correct query which returns everything correctly.  I'm just confused as to how to achieve a nested left join in sequelize.  Appreciate any advice.  Here's the working query...</p>&#xA;<pre><code>SELECT &#xA;  `google_text_ads`.`ad_id`,&#xA;  MAX(`google_text_ads`.`date`) AS `date`,&#xA;  SUM(`google_text_ads`.`impressions`) AS `impressions`,&#xA;  SUM(`google_text_ads`.`clicks`) AS `clicks`,&#xA;  SUM(`google_text_ads`.`cost`) AS `cost`,&#xA;  ra.ad_group_name&#xA;FROM&#xA;  `google_text_ads` AS `google_text_ads`&#xA;LEFT JOIN&#xA;  ( SELECT&#xA;      ad_group_name,&#xA;      ad_group_id&#xA;    FROM &#xA;      google_ads_groups &#xA;    GROUP BY&#xA;      ad_group_id&#xA;  ) ra &#xA;ON google_text_ads.ad_group_id = ra.ad_group_id     &#xA;WHERE&#xA;  `google_text_ads`.`customer_id` = 139&#xA;  AND (`google_text_ads`.`date` &gt;= '2022-09-07'&#xA;  AND `google_text_ads`.`date` &lt;= '2022-10-06')&#xA;  AND `google_text_ads`.`status` IN ('ENABLED')&#xA;  AND `google_text_ads`.`type` IN ('EXPANDED_TEXT_AD')&#xA;GROUP BY `ad_id`;&#xA;</code></pre>&#xA;",884345,,1973735,2022-10-08 04:32:13,2022-11-17 21:03:32,How can I left join with a nested query in Sequelize?,<node.js><graphql><sequelize.js>,1,0,0,2022-10-07 19:17:41
74001475,1,,,0,51,"<p>You have specified an Apollo key but have not specified a graph ref; usage reporting is disabled. To enable usage reporting, set the <code>APOLLO_GRAPH_REF</code> environment variable to <code>your-graph-id@your-graph-variant</code>. To disable this warning, install <code>ApolloServerPluginUsageReportingDisabled</code></p>&#xA;<p>I am struggling to find instructions for how to 'finish' the setup for an apollo classic graph. All of this worked fine last week but no longer does (I can see on Apollo's instructions page that something changed on 4 Oct and maybe requires people to change their graph reference).</p>&#xA;<p>I'm trying to solve these problems one step at a time, but cannot make sense of the instructions for apollo.</p>&#xA;<p>The format represented in the error message has two fragments, separated by an 'a' symbol. The format of the apollo key in the federation 2 instructions also has two fragments, but they are separated by a colon.</p>&#xA;",2860931,,,,2022-11-10 07:57:51,How can I find out what my Apollo Graph Ref is?,<apollo><apollo-server>,1,0,0,2022-10-09 01:00:49
74003457,2,,68409211,0,,"<p>Let's say you want to save an <code>Array</code> of <code>String</code> inside the <code>components</code> of the <code>@model</code> below:</p>&#xA;<pre><code>type Note @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  title: String&#xA;  movie: String&#xA;  components: []&#xA;}&#xA;</code></pre>&#xA;<p>You can either use <code>AWSJSON</code> and save it in a String format as <a href=""https://stackoverflow.com/a/68435202/8382155"">Rawan mentioned</a> above or you can try this way:</p>&#xA;<pre><code>type Note @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  title: String&#xA;  movie: String&#xA;  components: [String]&#xA;}&#xA;</code></pre>&#xA;",8382155,,,,2022-10-09 09:09:30,"",,0,0,0,2022-10-09 09:09:30
74024171,1,,,0,28,"<p>I have this schema:</p>&#xA;<pre><code>type Query {&#xA;    locations(id: String): [GQLLocation]&#xA;}&#xA;&#xA;type GQLLocation {&#xA;    id: ID!&#xA;    name: String&#xA;    description: String&#xA;    parent: GQLLocation&#xA;    children: [GQLLocation]&#xA;    devices: [GQLDevice]&#xA;    tenantId: String&#xA;    numberOfLocations: Float&#xA;    numberOfDevices: Float&#xA;}&#xA;&#xA;type GQLDevice {&#xA;    id: ID!&#xA;    commNr: String&#xA;}&#xA;</code></pre>&#xA;<p>And this data fetcher for locations:</p>&#xA;<pre><code>@DgsQuery&#xA;@PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#xA;public DataFetcherResult&lt;List&lt;GQLLocation&gt;&gt; locations(@InputArgument(&quot;id&quot;) String locationId, DgsDataFetchingEnvironment dfe) {&#xA;</code></pre>&#xA;<p>Location children are resolved using a data loader.&#xA;Authentication is done via a request header.</p>&#xA;<br/>&#xA;Queries like these work fine:&#xA;<pre><code>{locations {&#xA;  id, name, children {&#xA;   id, name&#xA;  }&#xA;}}&#xA;</code></pre>&#xA;<p>As soon as I try to get the children of a child it fails with this error message:</p>&#xA;<pre><code>2022-10-11 08:54:19,706 ERROR [1154868] [ForkJoinPool.commonPool-worker-5] c.n.g.d.e.DefaultDataFetcherExceptionHandler [DefaultDataFetcherExceptionHandler.kt:36] Exception while executing data fetcher for /locations[7]/children[3]/children: An Authentication object was not found in the SecurityContext&#xA;org.springframework.security.authentication.AuthenticationCredentialsNotFoundException: An Authentication object was not found in the SecurityContext&#xA;</code></pre>&#xA;<p>It sounds like when resolving the children of the second level (child of a child) the authentication data in the context is lost. Am I doing anything wrong?</p>&#xA;",1461499,,,,2022-10-11 07:01:02,DGS Framework: Authentication is failing in nested queries,<spring-boot><graphql><netflix-dgs>,0,0,0,2022-10-11 07:01:02
74048030,1,74048301,,0,57,"<p>I'm working on a project where I need to filter by the values of certain variables. I tried to follow a couple of examples on how to do this, but for some reason I'm getting <code>null</code> instead of the value that I was expecting.</p>&#xA;<p>schema.js</p>&#xA;<pre><code>type User {&#xA;    _id: ID!&#xA;    email: String!&#xA;    firstName: String&#xA;    lastName: String&#xA;    lifeStyle: [LifeStyle]&#xA;    date: Date&#xA;  }&#xA;&#xA;type LifeStyle {&#xA;  diet: [Diet]&#xA;  strick_diet: Boolean&#xA;}&#xA;&#xA; input UserFilters {&#xA;     strick_diet: Boolean&#xA;  }&#xA;&#xA;  input UserFilterInput {&#xA;     filter: UserFilters &#xA;  }&#xA;&#xA; type Query {&#xA;    filter(input: UserFilterInput):[User]&#xA;  }&#xA;</code></pre>&#xA;<p>user-resolvers.js</p>&#xA;<pre><code>import User from '../../models/User.js';&#xA;import { requireAuth } from '../../services/auth.js';&#xA;&#xA;export default {&#xA;  filter: async(parent, args, context, info) =&gt; {&#xA;    try {&#xA;      const { filter } = args;&#xA;      const shouldApplyFilters = filter !== null;&#xA;      let users = context.db.User;&#xA;   &#xA;      let lifeStylefilter = users.lifeStyle&#xA;  &#xA;      if (!shouldApplyFilters) {&#xA;        return users;&#xA;      }&#xA;&#xA;      const shouldApplyStrickDietFilter = filter.strick_diet;&#xA;&#xA;&#xA;      if (shouldApplyStrickDietFilter) {&#xA;        users = lifeStylefilter.filter((a) =&gt; a.strick_diet === filter.strick_diet)&#xA;      }&#xA;&#xA;      return {&#xA;        firstName: users.firstName,&#xA;      };&#xA;    }&#xA;  catch (error) {&#xA;    throw error;&#xA;  }&#xA;  },&#xA;};&#xA;&#xA;</code></pre>&#xA;<p>In Apollo, I have:</p>&#xA;<pre><code>query($input: UserFilterInput){&#xA;   filter(input: $input)  {&#xA;    firstName&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>with variables:</p>&#xA;<pre><code>{&#xA;  &quot;input&quot;: {&#xA;    &quot;filter&quot;: {&#xA;    &quot;strick_diet&quot;: true&#xA;  }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is giving me:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;filter&quot;: null&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",19222783,,2805154,2022-10-12 21:35:32,2022-10-12 21:46:47,filtering in apollo giving a null value instead of expected return,<graphql><apollo>,1,0,0,2022-10-12 21:07:21
74049335,1,,,0,17,<p>I'm used to refetching graphql fragments on Relay and was wondering when it would make sense to refetch its root query instead. This may be graphql client-agnostic but I'm not familiar with any other clients. Thank you.</p>&#xA;,11086815,,,,2022-10-13 00:45:48,when to refetch query over refetching graphql fragment on Relay,<graphql><relayjs>,0,0,0,2022-10-13 00:45:48
74060284,1,,,0,18,"<p>There is JSON-object (an array of different structures) like:</p>&#xA;<pre><code>&quot;cells&quot;: [&#xA;  {&#xA;     &quot;x&quot;:3,&#xA;     &quot;y&quot;:6,&#xA;  },&#xA;  {&#xA;     &quot;type&quot;: &quot;shape&quot;,&#xA;     &quot;direction&quot;: right,&#xA;  },&#xA;  ....&#xA;  {&#xA;     &quot;a&quot;: 4,&#xA;     &quot;b&quot;: 5,&#xA;     &quot;c&quot;: 6,&#xA;  }&#xA;]&#xA;</code></pre>&#xA;<p>I need to save this object using graphql mutation. Whats the way to do it?</p>&#xA;<pre><code>type A {&#xA;  x: Int!&#xA;  y: Int!&#xA;}&#xA;type B {&#xA;  type: String!&#xA;  direction: String!&#xA;}&#xA;type C {&#xA;  a: Int!&#xA;  b: Int!&#xA;  c: Int!&#xA;}&#xA;&#xA;union Request = A | B | C&#xA;&#xA;input InputR {&#xA;   cells: [Request!]!&#xA;}&#xA;&#xA;type Mutation {&#xA;    save(cells: InputR!): InputR&#xA;}&#xA;</code></pre>&#xA;<p>I tried the following, but it doesnt work. Any ideas?</p>&#xA;<p>Thanks!</p>&#xA;",9109375,,,,2022-10-13 19:57:59,GraphQL input parameter,<graphql>,1,0,0,2022-10-13 18:32:41
74097731,1,,,0,12,<p>is it possibile to reshape a field in order to have a situation like this</p>&#xA;<p>from this:</p>&#xA;<pre><code>query firDetail($firId: Int) {&#xA;  Firs(where: {id: {eq: $firId}}) {&#xA;    nodes {&#xA;      id&#xA;      codiceFir&#xA;      accettato&#xA;      accettatoParzialmente&#xA;      respinto&#xA;      movimenti {      &#xA;        rifiutoId     &lt;--field to flat&#xA;      } &#xA;      codiceFir&#xA;      cantiereProduttoreId&#xA;</code></pre>&#xA;<p>to this:</p>&#xA;<pre><code>query firDetail($firId: Int) {&#xA;  Firs(where: {id: {eq: $firId}}) {&#xA;    nodes {&#xA;      id&#xA;      codiceFir&#xA;      accettato&#xA;      accettatoParzialmente&#xA;      respinto&#xA;      reshaperdField   &lt;---flattened field&#xA;      codiceFir&#xA;      cantiereProduttoreId&#xA;</code></pre>&#xA;<p>i've tried to prepend an alias in this way but this rename only the field</p>&#xA;<pre><code>uery firDetail($firId: Int) {&#xA;  Firs(where: {id: {eq: $firId}}) {&#xA;    nodes {&#xA;      id&#xA;      codiceFir&#xA;      accettato&#xA;      accettatoParzialmente&#xA;      respinto&#xA;      reshaperdField : movimenti {      &#xA;        rifiutoId    &#xA;      } &#xA;      codiceFir&#xA;      cantiereProduttoreId&#xA;</code></pre>&#xA;,1820422,,,,2022-10-17 13:01:28,rename and reshape / flatten graphql query field,<graphql>,0,0,0,2022-10-17 13:01:28
74140030,1,,,0,17,"<p>I have a question regarding GraphQL because I do not know if it is possible or not.</p>&#xA;<p>I have a simple scheme like this:</p>&#xA;<pre><code>enum Range{&#xA;  D,&#xA;  D_1,&#xA;  D_7&#xA;}&#xA;&#xA;type Data {&#xA;  id: Int!&#xA;  levels(range: [Range!]):[LevelEntry]&#xA;}&#xA;&#xA;type LevelEntry{&#xA;  range: Range!&#xA;  levelData: LevelData&#xA;}&#xA;&#xA;type LevelData {&#xA;  range: Range!&#xA;  users: Int&#xA;  name: String&#xA;  stairs: Int&#xA;  money: Float&#xA;}&#xA;</code></pre>&#xA;<p>Basically I want to do a query so I can retrieve different attributes for the different entries on the levelData property of levels array which can be filtered by some levels range.</p>&#xA;<p>For instance:</p>&#xA;<pre><code>data {&#xA;  &quot;id&quot;: 1,&#xA;  &quot;levels&quot;: [&#xA;     {&#xA;       &quot;range&quot;: D,&#xA;       &quot;levelData&quot;: {&#xA;          &quot;range&quot;: D,&#xA;          &quot;users&quot;: 1&#xA;       }&#xA;     },&#xA;     {&#xA;       &quot;range&quot;: D_1,&#xA;       &quot;levelData&quot;: {&#xA;          &quot;range&quot;: D_1,&#xA;          &quot;users&quot;: 1,&#xA;          &quot;name&quot;: &quot;somename&quot;&#xA;       }&#xA;     }&#xA;]&#xA;&#xA;</code></pre>&#xA;<p>This means i want for D &quot;range, users&quot; properties and for D_1 &quot;range,users,name&quot; properties</p>&#xA;<p>I have done an example of query but I do not know if this is possible:</p>&#xA;<pre><code>query data(range: [D,D_1]){&#xA;  id,&#xA;  levels {&#xA;    range&#xA;    ... on D {&#xA;     range,&#xA;     users&#xA;    }&#xA;    ... on D_1 {&#xA;     range,&#xA;     users,&#xA;     name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Is it possible? If it is how can i do it?</p>&#xA;",10079966,,,,2022-10-20 12:38:59,GraphQL on clause with enum type,<graphql>,0,0,0,2022-10-20 12:38:59
74142353,1,,,0,39,<p>How can I reuse variable arguments in GQL Apollo React? e.g. in a situation where the inputs are the same but we need different data corresponding for a different situation.</p>&#xA;<p>Is there a way to define this inside or outside of this query call?</p>&#xA;<pre><code>const REQUEST_1 = gql`&#xA;  query QueryA(&#xA;    $page: Int&#xA;    $a: String&#xA;    $b: Number&#xA;    $etc: EtcFilter&#xA;  ) {&#xA;    getData(&#xA;      limit: 24&#xA;      page: $page&#xA;      a: $a&#xA;      b: $b&#xA;      etc: $etc&#xA;    ) {&#xA;      total&#xA;      result {&#xA;        id&#xA;        time&#xA;        location&#xA;      }&#xA;    }&#xA;  }&#xA;  `&#xA;const REQUEST_2 = gql`&#xA;  query QueryA(&#xA;    $page: Int&#xA;    $a: String&#xA;    $b: Number&#xA;    $etc: EtcFilter&#xA;  ) {&#xA;    getData(&#xA;      limit: 24&#xA;      page: $page&#xA;      a: $a&#xA;      b: $b&#xA;      etc: $etc&#xA;    ) {&#xA;      total&#xA;      result {&#xA;        postContent&#xA;        date&#xA;        coordinates&#xA;        id&#xA;      }&#xA;    }&#xA;  }&#xA;  `&#xA;&#xA;</code></pre>&#xA;,2426524,,,,2022-10-26 10:26:22,How to make inputs more DRY in React Apollo?,<apollo-client><react-apollo>,1,0,0,2022-10-20 15:18:12
74146152,1,,,0,27,"<pre class=""lang-cs prettyprint-override""><code>public async Task&lt;RefNoGraphQlViewModelV1&gt; SearchDocsInNetworkGraphQl(string customerId, string documentNumber)&#xA;{&#xA;    var jsonResult = await GraphQlClient.PostQuery(URLConstants.graphQlURL, new GraphQlRequest&#xA;    {&#xA;        Query = &quot;query ($customerIds: [String!]!, $documentNumbers: [String!]!) { searchDocsInNetwork(first: 5, where: {usbcCustomerId: { in:  $customerIds },  documentNumber: { in: $documentNumbers }     }) {    pageInfo {    hasNextPage    hasPreviousPage      startCursor     endCursor    }   edges {      cursor     node    {       carrierCode        referenceNumber   }}}}&quot;,&#xA;        Variables = new&#xA;        {&#xA;            documentNumbers = documentNumber,&#xA;            customerIds = customerId&#xA;        }&#xA;    });&#xA;&#xA;    return new JavaScriptSerializer().Deserialize&lt;RefNoGraphQlViewModelV1&gt;(jsonResult);&#xA;}&#xA;</code></pre>&#xA;<p>trying to fetch data using this query in api, but getting the following error&#xA;<code>&quot;{\&quot;errors\&quot;:[{\&quot;message\&quot;:\&quot;Either the parameter query or the parameter id has to be set.\&quot;,\&quot;extensions\&quot;:{\&quot;code\&quot;:\&quot;HC0013\&quot;}}]}&quot;</code></p>&#xA;",17618869,,48503,2022-10-20 21:02:49,2022-10-20 21:02:49,Graphql HC0013 error while quering out in web api,<c#><.net><graphql><webapi>,0,0,0,2022-10-20 20:47:44
74151228,1,74163725,,0,17,<p>I am currently working on a project involving graphQL and I was wondering if the action of retrieving every elements of a given type in a query was taking significantly more time than only retrieving some or if this time was negligible.</p>&#xA;<p>Here is an exemple:</p>&#xA;<pre><code>fragment GlobalProtocolStatsFields on GlobalProtocolStats {&#xA;totalProfiles&#xA;totalBurntProfiles&#xA;totalPosts&#xA;totalMirrors&#xA;totalComments&#xA;totalCollects&#xA;totalFollows&#xA;totalRevenue {&#xA;    ...Erc20AmountFields&#xA;}}&#xA;</code></pre>&#xA;<p>vs</p>&#xA;<pre><code>fragment GlobalProtocolStatsFields on GlobalProtocolStats {&#xA;totalProfiles&#xA;totalBurntProfiles&#xA;totalPosts&#xA;totalMirrors&#xA;}&#xA;</code></pre>&#xA;<p>Thanks in advance!</p>&#xA;,19585282,,,,2022-10-22 12:51:48,"Retrieving all fields vs only some in graphql, Time Comparison",<graphql>,1,0,0,2022-10-21 09:00:48
74178674,2,,74075902,1,,<p>You specify these things in the application code and keep the PK and SK as strings always.</p>&#xA;<p>They usually look like this</p>&#xA;<pre><code>PK                    SK&#xA;Type#{productType}    ProductId#{productId}&#xA;</code></pre>&#xA;<p>Then productType and productId should also we included as attributes so you can use the data and not extract it from the PK and SK.</p>&#xA;,5625696,,,,2022-10-24 08:53:57,"",,0,0,0,2022-10-24 08:53:57
74179449,2,,74179294,0,,<p>It looks like you are repeating the query: I don't understand why the first line in your Postman test. Try like this:</p>&#xA;<pre><code>query {&#xA;  getEsgScoresData(name: $name) {&#xA;    date&#xA;  }&#xA;}&#xA;</code></pre>&#xA;,20121447,,20121447,2022-10-24 11:53:39,2022-10-24 11:53:39,"",,0,3,0,2022-10-24 09:58:48
74184743,2,,74182220,0,,"<p>You're mapping when you should be filtering. Also your comments aren't attached to the parent, they are just a variable in scope.</p>&#xA;<p>Change:</p>&#xA;<pre><code>return parent.comment.map(&#xA;  commentList =&gt; parent.productId === commentList.productId&#xA;)&#xA;</code></pre>&#xA;<p>to:</p>&#xA;<pre><code>return comments.filter(&#xA;  el =&gt; parent.productId === el.productId&#xA;)&#xA;</code></pre>&#xA;",2805154,,2805154,2022-10-24 23:07:39,2022-10-24 23:07:39,"",,0,2,0,2022-10-24 17:29:19
74195694,1,,,0,33,"<p>I am trying to perform a listItem call with AppSync from my NextJS front-end. I can successfully make the following calls:</p>&#xA;<ul>&#xA;<li>listItems from front-end</li>&#xA;<li>listItems with filter from the AppSync console.</li>&#xA;</ul>&#xA;<p>When I try the call I get this error:</p>&#xA;<pre><code>Error: Invalid AST Node: { query: &quot;\n  query ListCards(\n    $filter: ModelCardFilterInput\n    $limit: Int\n    $nextToken: String\n  ) {\n    listCards(filter: $filter, limit: $limit, nextToken: $nextToken) {\n      items {\n        approvedTime\n        approvedUser\n        canRead\n        canUpdate\n        clientID\n        id\n        input\n        feedback\n        name\n        output\n        scheduledTime\n        status\n        type\n        createdAt\n        updatedAt\n        _version\n        _deleted\n        _lastChangedAt\n      }\n      nextToken\n      startedAt\n    }\n  }\n&quot;, filter: { cardID: [Object] } }.&#xA;</code></pre>&#xA;<p>My failing code:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  const listCardsFilteredResponse = (await API.graphql(&#xA;    graphqlOperation({&#xA;      query: listCards,&#xA;      filter: { clientID: { eq: &quot;d9a6c7a2-45b1-48a8-b012-5908d216f86f&quot; } },&#xA;    })&#xA;  ))&#xA;</code></pre>&#xA;<p>My working js code:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>  const listCardsResponse = (await API.graphql(&#xA;    graphqlOperation(listCards)&#xA;  ))&#xA;</code></pre>&#xA;<p>My working query in the AppSync console:</p>&#xA;<pre><code>query MyQuery {&#xA;  listCards(filter: {clientID: {eq: &quot;d9a6c7a2-45b1-48a8-b012-5908d216f86f&quot;}}) {&#xA;    nextToken&#xA;    startedAt&#xA;    items {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I've looked for <a href=""https://stackoverflow.com/questions/53947508/how-to-do-filteration-in-aws-amplify-graphql-client"">similar posts</a>, but I still haven't had any luck.</p>&#xA;",11664580,,,,2022-10-25 14:31:02,Perform a GraphQL/AppSync call from an Amplify js front-end - Error: Invalid AST Node,<javascript><graphql><aws-amplify><aws-appsync>,1,0,0,2022-10-25 14:27:09
74195741,2,,74195694,0,,"<p>I fixed the problem by rewriting the code from:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>    graphqlOperation({&#xA;      query: listCards,&#xA;      filter: { clientID: { eq: &quot;d9a6c7a2-45b1-48a8-b012-5908d216f86f&quot; } },&#xA;    })&#xA;</code></pre>&#xA;<p>to:</p>&#xA;<pre class=""lang-js prettyprint-override""><code>    graphqlOperation(listCards, {&#xA;      filter: { clientID: { eq: &quot;d9a6c7a2-45b1-48a8-b012-5908d216f86f&quot; } },&#xA;    })&#xA;</code></pre>&#xA;<p>Confusingly, this is in contradiction to the example in the documentation -&#xA;<a href=""https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#compound-filters"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js/#compound-filters</a> :</p>&#xA;<pre class=""lang-js prettyprint-override""><code>await API.graphql({ query: listProducts, variables: { filter: filter}}));&#xA;</code></pre>&#xA;",11664580,,,,2022-10-25 14:31:02,"",,0,0,0,2022-10-25 14:31:02
74197440,2,,74193085,1,,"<p>You can do this with two subtypes as an example using <a href=""https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/"" rel=""nofollow noreferrer"">unions and interfaces</a>, you can easily extend to additional ones.</p>&#xA;<p>In your <em>typeDefs</em>:</p>&#xA;<pre><code>interface CoreOrder {&#xA;  id: ID!&#xA;  tokenValue: String!&#xA;  number: Int!&#xA;  shippingTotal: Float!&#xA;}&#xA;&#xA;Type Order1 implements CoreOrder {&#xA;  id: ID!&#xA;  tokenValue: String!&#xA;  number: Int!&#xA;  shippingTotal: Float!&#xA;  total: Float!&#xA;}&#xA;&#xA;Type Order2 implements CoreOrder {&#xA;  id: ID!&#xA;  tokenValue: String!&#xA;  number: Int!&#xA;  shippingTotal: Float!&#xA;  duplicates: Int!&#xA;}&#xA;&#xA;union Order = Order1 | Order 2&#xA;</code></pre>&#xA;<p>Now your query can be defined to return whichever fields are appropriate:</p>&#xA;<pre><code>query GetOrder($query: String!) {&#xA;  getOrder(query: $query) {&#xA;    __typename&#xA;    id&#xA;    tokenValue&#xA;    number&#xA;    shippingTotal&#xA;    ... on Order1 {&#xA;      total&#xA;    }&#xA;    ... on Order2 {&#xA;      duplicates&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>You'll need to implement:</p>&#xA;<ol>&#xA;<li>a <code>__resolveType</code> <a href=""https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#resolving-a-union"" rel=""nofollow noreferrer"">resolver</a> that figures out what type your query is returning</li>&#xA;<li>resolvers for <code>CoreOrder</code> to handle those 4 fields</li>&#xA;<li>an <code>Order1</code> resolver for the <code>total</code> field</li>&#xA;<li>an <code>Order2</code> resolver for the <code>duplicates</code> field</li>&#xA;</ol>&#xA;<p>Your GraphQL server will then figure out which resolvers to call and in what order and package up the results for your client.</p>&#xA;",2805154,,,,2022-10-25 16:36:14,"",,0,0,0,2022-10-25 16:36:14
74231056,1,,,0,40,"<p>DB: PostgreSQL</p>&#xA;<p>My table structure:</p>&#xA;<pre><code>    id bigint NOT NULL DEFAULT nextval('user_seq'::regclass),&#xA;    user_first_active_at timestamp(3) without time zone,&#xA;    created_at timestamp(3) without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,&#xA;    updated_at timestamp(3) without time zone NOT NULL&#xA;</code></pre>&#xA;<p>The field <code>user_first_active_at</code> <strong>is saved in DB as UTC.</strong></p>&#xA;<p>I am trying to fetch the results via raw Prisma query</p>&#xA;<pre><code>// currentDate is new Date() - 2 Days&#xA;const users = this.prisma.$queryRaw&lt;User[]&gt;`&#xA;      SELECT id::INTEGER &#xA;        FROM  users WHERE &#xA;        user_first_active_at &gt;= ${currentDate} // current date param is passed as 2022-10-28 05:00:00.000 UTC&#xA;</code></pre>&#xA;<p>Consider the UTC Time is <code>2022-10-28 05:00:00.000 UTC</code> and my DB state</p>&#xA;<p>Sample records in DB</p>&#xA;<pre><code>ID |  user_first_active_at      | created_at                 | updated_at&#xA;1  | 2022-10-25 18:59:00.000 | 2022-10-12 11:40:37.268942 | 2022-10-12 11:40:37.268942&#xA;2  | 2022-10-25 19:00:01.000 | 2022-10-12 11:40:37.268942 | 2022-10-12 11:40:37.268942&#xA;</code></pre>&#xA;<p>The query would fetch the Row2.</p>&#xA;<p>However my expectation is query should not pick any result as <code>user_first_active_at + 2 days</code> &gt; Current UTC i.e <code>2022-10-28 05:00:00.000 UTC</code></p>&#xA;<p>Looks like Prisma is converting <code>user_first_active_at</code> again to UTC.</p>&#xA;<p>Is there a way I can make this work?</p>&#xA;",5828621,,13416247,2022-10-28 06:24:17,2022-10-28 06:24:17,Prisma select query with DateTime in UTC and data type being timestamp without time zone,<javascript><node.js><prisma><prisma-graphql>,0,3,0,2022-10-28 05:37:42
74247079,1,,,0,29,<p>I have several different GraphQL queries. For example</p>&#xA;<pre><code>const FETCH_PERSON = gql`&quot;some query&quot;`&#xA;</code></pre>&#xA;<p>That i just store as a const in the compnent file im using it in for now.</p>&#xA;<p>My question is what is the best practice when it comes to storing hardcoded queries? And maybe some queries that requires 1 or more parameters.</p>&#xA;<p>Is it creating a helper class with all the functions that return the full query string? Or what other alternative is there?</p>&#xA;<p>And how should that helper method/function look like? Would appreciate an example of input and output and how to use it with Apollo.</p>&#xA;,3344447,,,,2022-10-29 16:58:26,Whats best practice when storing GraphQL queries using Apollo client in React,<reactjs><graphql><apollo>,1,0,0,2022-10-29 16:46:30
74248020,1,,,1,57,"<p>I have two queries one searches for all facilities with pagination another searches for facilityById.&#xA;In facilities i ask for some fields eg:&#xA;`</p>&#xA;<pre><code>export const GET_FACILITIES = gql`&#xA;  query getFacilities(&#xA;    $after: String&#xA;    $order: [FacilityModelSortInput!]&#xA;    $where: FacilityModelFilterInput&#xA;    $first: Int&#xA;  ) {&#xA;    facilities(after: $after, order: $order, where: $where, first: $first) {&#xA;      pageInfo {&#xA;        endCursor&#xA;        hasNextPage&#xA;        hasPreviousPage&#xA;        startCursor&#xA;      }&#xA;&#xA;      edges {&#xA;        cursor&#xA;        node {&#xA;          timeStamp&#xA;          id&#xA;          latitude&#xA;          longitude&#xA;        }&#xA;      }&#xA;    }&#xA;  }`&#xA;</code></pre>&#xA;<p>`</p>&#xA;<p>when fetching  by facility id i want to expand on this facilities inner fields like so:</p>&#xA;<p>`</p>&#xA;<pre><code>export const DETAIL_QUERY = gql`&#xA;  query detailQuery($id: ID!) {&#xA;    facilityById(id: $id) {&#xA;      id&#xA;&#xA;     &#xA;      generadores {&#xA;        id&#xA;        &#xA;        capacity&#xA;        voltage&#xA;      }&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>`</p>&#xA;<p>I know I could do separate query on backend to get these generators, but i want to get them like this. Problem is that the query by id is breaking the pagination on the multiple query. data from fetchMore becomes only the new fetched data and not all data on cache, i see the data on cache with apollo fierefox addon working fine, but returned data by useQuery is not, pageInfo is also only on start cursor of 15 items,  on cache is all items. I am using</p>&#xA;<p>relayStylePagination(),</p>&#xA;<p>works fine untill the byID query is executed.</p>&#xA;<p>I tried to work with pagination, fetching by id adding fields is breaking pagination.</p>&#xA;",17316842,,,,2022-10-29 18:59:03,useQuery Breaking after useQuery by id apollo client,<graphql><apollo-client>,0,4,0,2022-10-29 18:59:03
74262501,1,,,0,21,"<p>I am trying to order an array returned by resolver in GraphQL.&#xA;I can only think of way of ordering data using DB Query, but how can we order data that GraphQL resolves using its resolver functions?</p>&#xA;<p>Below is my Query resolver:</p>&#xA;<pre><code>getAllNotifications: (&#xA;      _parent,&#xA;      _args: { authorId: string },&#xA;      context: Context&#xA;    ) =&gt; {&#xA;      return context.prisma.blog.findMany({&#xA;        where: {&#xA;          authorId: _args.authorId,&#xA;        },&#xA;        orderBy: {&#xA;          created_at: &quot;desc&quot;,&#xA;        },&#xA;      });&#xA;    },&#xA;</code></pre>&#xA;<p>And my query:</p>&#xA;<pre><code>query Query($authorId: String) {&#xA;  getAllNotifications(authorId: $authorId) {&#xA;    title&#xA;    comment {&#xA;      id&#xA;      created_at&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>And result:</p>&#xA;<pre><code>{&#xA;  &quot;data&quot;: {&#xA;    &quot;getAllNotifications&quot;: [&#xA;      {&#xA;        &quot;title&quot;: &quot;First Ride! &quot;,&#xA;        &quot;comment&quot;: [ &lt;--- I am trying to order this comment array using created_at date&#xA;          {&#xA;            &quot;id&quot;: &quot;cl8afqaqx001209jtxx7mt5h6&quot;,&#xA;            &quot;created_at&quot;: &quot;2022-09-20T16:53:07.689Z&quot;&#xA;          },&#xA;          {&#xA;            &quot;id&quot;: &quot;cl8agiq71001509l27or7oxyd&quot;,&#xA;            &quot;created_at&quot;: &quot;2022-09-20T17:15:14.077Z&quot;&#xA;          },&#xA;          {&#xA;            &quot;id&quot;: &quot;cl8ahmvrm003109l8dp684bn6&quot;,&#xA;            &quot;created_at&quot;: &quot;2022-09-20T17:46:27.538Z&quot;&#xA;          },&#xA;          {&#xA;            &quot;id&quot;: &quot;cl99kj24p002609iajdbpycg0&quot;,&#xA;            &quot;created_at&quot;: &quot;2022-10-15T06:59:24.169Z&quot;&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I didn't found anything in Graphql docs regarding ordering data returned by resolver</p>&#xA;",8702713,,,,2022-10-31 16:28:35,Order result resolved via resolver in graphql + apollo server + nodejs,<node.js><graphql><prisma><apollo-server><prisma-graphql>,1,0,0,2022-10-31 11:20:15
74264765,1,,,0,35,"<p>In the below GraphQL query, how to get employees by 'companyName'. Please help.</p>&#xA;<p><a href=""https://ms-gateway-f4b4o225iq-ue.a.run.app/graphql"" rel=""nofollow noreferrer"">https://ms-gateway-f4b4o225iq-ue.a.run.app/graphql</a></p>&#xA;<pre><code>query FetchEmployeesQuery(&#xA;  $where: String&#xA;  $limit: Int&#xA;  $offset: Int&#xA;  $sort: [String!]&#xA;) {&#xA;  &#xA;&#xA;  employees(&#xA;    sort: $sort&#xA;  )  {&#xA;    total&#xA;    {&#xA;      ...EmployeeListFragment&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment EmployeeListFragment on EmployeeItem {&#xA;  id&#xA;  employeeNumber&#xA;  externalId&#xA;  firstName&#xA;  lastName&#xA;  companyName&#xA;  email&#xA;  customerGroup {&#xA;    id&#xA;    version&#xA;    name&#xA;    key&#xA;  }&#xA;  dateOfBirth&#xA;}&#xA;</code></pre>&#xA;<p>I tried to filter by passing company name, but ended up with errors.</p>&#xA;",17868499,,6022243,2022-10-31 14:35:27,2022-10-31 14:35:27,How to filter by 'companyName',<javascript><graphql><graphql-js><express-graphql>,0,0,0,2022-10-31 14:24:18
74266358,2,,74262501,0,,"<p>GraphQL doesn't have functions for selection and ordering, those are jobs that resolvers must do.</p>&#xA;<p>Add a resolver for <code>comment</code> that sorts the <code>comment</code> array. Your existing sort just sorts based on the <code>created_at</code> date of the post.</p>&#xA;",2805154,,,,2022-10-31 16:28:35,"",,0,0,0,2022-10-31 16:28:35
74276666,1,,,0,55,"<p>I am trying to pass several values of variables into where part of the GraphQL Query but I'm facing the problem that not all variables have values and default values like null are not accepted by the GraphQL endpoint.</p>&#xA;<p>I think that I need to pass only variables that do have non-null values and from these non-null values create the <strong>where condition</strong>. I tried to find some examples but the examples I found contains only the simple where condition above one attribute only.</p>&#xA;<p>I found this example too: <a href=""https://www.howtographql.com/typescript-apollo/8-filtering-pagination-and-sorting/"" rel=""nofollow noreferrer"">https://www.howtographql.com/typescript-apollo/8-filtering-pagination-and-sorting/</a></p>&#xA;<p>But it seems to be a pretty awful and not simple implementation.</p>&#xA;<p>Could someone tell me what pattern should I use to achieve dynamic filtering for more fields at the same time?</p>&#xA;<p>Thanks for any advice.</p>&#xA;<p><strong>Query where i Would like to use more condtitions:</strong></p>&#xA;<pre><code>export const GET_SCENE_EVENTS_BY_PAGINATION_FILTER = gql`&#xA;    query queryEvents($sceneId: Int!,  $numberOfRows: Int!, $eventTypeId: Byte!, $from: DateTime!, $to: DateTime!) {&#xA;        queryEvents(&#xA;            sceneId: $sceneId&#xA;            where: { and: [{ dateTime: { gte: $from } },{ dateTime: { lte: $to } }, { eventTypeId: { eq: $eventTypeId }}] }&#xA;            # how many events from beggining of list&#xA;            first: $numberOfRows&#xA;            order: [{ dateTime: DESC }]&#xA;        )&#xA;        {${SCENE_EVENT_RESPONSE_STRUCT}}&#xA;    }&#xA;`;&#xA;</code></pre>&#xA;",535556,,,,2022-11-01 20:46:01,GraphQL + Apollo + Angular how to pass multiple where conditions into Query?,<angular><graphql><apollo-client>,1,0,0,2022-11-01 13:25:13
74281593,2,,74276666,0,,"<p>I think what you're looking for is this:</p>&#xA;<pre><code>query queryEvents($sceneId: Int!,  $numberOfRows: Int!, $whereClause: QueryEventInput!) {&#xA;    queryEvents(&#xA;        sceneId: $sceneId&#xA;        where: $whereClause&#xA;        # how many events from beggining of list&#xA;        first: $numberOfRows&#xA;        order: [{ dateTime: DESC }]&#xA;    )&#xA;    {${SCENE_EVENT_RESPONSE_STRUCT}}&#xA;}&#xA;</code></pre>&#xA;<p>You don't want variables that are the individual elements of your where clause. You want a single variable that is the <em>entire</em> where clause. Check the input type of <code>where</code>, and that's what you will replace what I called <code>QueryEventInput</code>.</p>&#xA;",652728,,,,2022-11-01 20:46:01,"",,0,0,0,2022-11-01 20:46:01
74286714,1,,,0,12,"<p>I have some problems with Apollo cache, ill describe the scenario:&#xA;I have a query,QueryOne that returns a data with a key named &quot;getUserData&quot;&#xA;And another query, queryTwo that returns different data with the same key named &quot;getUserData&quot;, both responses may have the same key but the values are different.</p>&#xA;<p>That behavior causes my cache to get overridden, as far as I see Apollo saves key-value and not key-value per query.&#xA;I need Apollo cache to separate those two cached objects and understand they key might be the same but the response is different and is per query.</p>&#xA;<p>Can somebody point me to the right direction? Ive read the docs.</p>&#xA;",11494418,,,,2022-11-03 19:12:41,Problems with cacheing in apollo client,<apollo-client>,1,0,0,2022-11-02 09:06:52
74286792,1,,,-1,64,"<p>I am trying to get price of a token in a range of blocks or timestamp using the Uniswap V2 subgraph. (<a href=""https://thegraph.com/hosted-service/subgraph/uniswap/uniswap-v2"" rel=""nofollow noreferrer"">https://thegraph.com/hosted-service/subgraph/uniswap/uniswap-v2</a>)</p>&#xA;<p>Here is the query I try:</p>&#xA;<pre><code>{&#xA;  tokens( where:{id:&quot;0x6070c2215a18cd8efaf340166876ac9ce4d1e79b&quot;},  first: 10, orderBy: txCount) {&#xA;    id,&#xA;    symbol,&#xA;    name,&#xA;    totalSupply,&#xA;    derivedETH&#xA;    txCount&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>The exact thing that I try to get is, price of the X token in Y timestamp but the query above does not return as I expect. (I couldn't understand why)</p>&#xA;<p>Thanks in advance</p>&#xA;",18814671,,,,2022-11-02 14:52:05,How to get any token price (ERC20) according to a block number or timestamp?,<graphql><ethereum><erc20><uniswap><thegraph>,1,0,0,2022-11-02 09:12:58
74297529,1,74302167,,0,54,"<p>The nested fragment <code>regularUserResponseFragmentDocument</code></p>&#xA;<pre><code>import { graphql } from '../../generated/graphql';&#xA;&#xA;export const regularErrorFragmentDocument = graphql(`&#xA;  fragment regularError on FieldError {&#xA;    field&#xA;    message&#xA;  }&#xA;`);&#xA;&#xA;export const regularUserFragmentDocument = graphql(`&#xA;  fragment regularUser on User {&#xA;    id&#xA;    username&#xA;  }&#xA;`);&#xA;&#xA;export const regularUserResponseFragmentDocument = graphql(`&#xA;  fragment regularUserResponse on UserResponse {&#xA;    errors {&#xA;      ...regularError&#xA;    }&#xA;    user {&#xA;      ...regularUser&#xA;    }&#xA;  }&#xA;`);&#xA;</code></pre>&#xA;<p>is used in a component like so:</p>&#xA;<pre><code>if (response.data?.login) {&#xA;  const data = useFragment(regularUserResponseFragmentDocument, response.data.login);&#xA;  const errorsData = useFragment(regularErrorFragmentDocument, data.errors);&#xA;  if (errorsData) {&#xA;    setErrors(toErrorMap([...errorsData]));&#xA;  }&#xA;  const userData = useFragment(regularUserFragmentDocument, data.user);&#xA;  if (userData) {&#xA;    await router.push('/');&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>Is there a way to avoid use of <code>useFragment</code> on the nested fragments?</p>&#xA;",5524590,,,,2022-11-03 11:11:38,Graphql-codegen nested fragment use inside a React component,<graphql-codegen>,1,0,0,2022-11-03 02:17:00
74301407,2,,74299658,1,,"<pre class=""lang-js prettyprint-override""><code>export const mainQuery = gql`&#xA;    query fetchData {&#xA;      ...series1 &#xA;      ...series2&#xA;    }&#xA;    ${series1Q}&#xA;    ${series2Q}&#xA;`  &#xA;</code></pre>&#xA;<p>In this snippet of code, what you are essentially doing is listing each fragment name and then each fragment. The way to do this for an unknown number of fragments is by iterating over the fragments, which would look something like this (note that the <code>series</code> array now has the fragment name stored separately):</p>&#xA;<pre class=""lang-js prettyprint-override""><code>const series = &#xA;[{&#xA;    name: 'series1',&#xA;    sql: gql`&#xA;        fragment series1 on timeseriesDataQuery {&#xA;            series1: timeseriesData(sourceId: &quot;source1&quot;) {&#xA;                data {&#xA;                    time&#xA;                    value&#xA;                }&#xA;            }&#xA;        }&#xA;    `,&#xA;},&#xA;{&#xA;    name: 'series2',&#xA;    sql: gql`&#xA;        fragment series2 on timeseriesDataQuery {&#xA;            series2: timeseriesData(sourceId: &quot;source2&quot;) {&#xA;                data {&#xA;                    time&#xA;                    value&#xA;                }&#xA;            }&#xA;        }&#xA;    `&#xA;}]&#xA;&#xA;export const mainQuery = gql`&#xA;    query fetchData {&#xA;      ${series.map(query =&gt; `...${query.name}`).join('\n')}&#xA;    }&#xA;    ${series.map(query =&gt; query.sql).join('\n')}&#xA;`&#xA;</code></pre>&#xA;",1857909,,1857909,2022-11-03 16:49:47,2022-11-03 16:49:47,"",,0,4,0,2022-11-03 10:20:10
74319616,2,,74299658,1,,"<p>So I think the main issue was with the fragment piece being parsed to [object Object] when using the map func: <code>${query.sql}</code> or other equivalent,</p>&#xA;<p>A workaround was to get the fragment query using <strong>query.sql.loc.source.body</strong></p>&#xA;<p>Example of a working example using @Dakeyras answer:</p>&#xA;<pre><code>const series = &#xA;[{&#xA;    name: 'series1',&#xA;    sql: gql`&#xA;        fragment series1 on timeseriesDataQuery {&#xA;            series1: timeseriesData(sourceId: &quot;source1&quot;) {&#xA;                data {&#xA;                    time&#xA;                    value&#xA;                }&#xA;            }&#xA;        }&#xA;    `,&#xA;},&#xA;{&#xA;    name: 'series2',&#xA;    sql: gql`&#xA;        fragment series2 on timeseriesDataQuery {&#xA;            series2: timeseriesData(sourceId: &quot;source2&quot;) {&#xA;                data {&#xA;                    time&#xA;                    value&#xA;                }&#xA;            }&#xA;        }&#xA;    `&#xA;}]&#xA;&#xA;export const mainQuery = gql`&#xA;    query fetchData {&#xA;      ${series.map(query =&gt; `...${query.name}`).join('\n')}&#xA;    }&#xA;    ${series.map(query =&gt; `${query.sql.loc?.source.body}`).join('\n')}&#xA;`&#xA;</code></pre>&#xA;",2442424,,,,2022-11-04 15:47:36,"",,0,0,0,2022-11-04 15:47:36
74321216,1,,,1,143,"<p>new to V8 of tanstack react table ... appears to be quite different to V7 in areas&#xA;would love some advice.</p>&#xA;<p>I need to sort server-side using apollo graphql</p>&#xA;<p>from reading the docs i know that you need to use the prop &quot;manualSorting&quot;</p>&#xA;<p>It just isnt clear exactly what to do from there</p>&#xA;<pre><code>  const [sorting, setSorting] = useState&lt;SortingState&gt;([]);&#xA;&#xA;  const hasVar = Boolean(reactiveVar);&#xA;&#xA;  const selectedRowId = useReactiveVar(&#xA;    reactiveVar ?? makeVar&lt;SelectedID&gt;(null)&#xA;  );&#xA;&#xA;  const { controlledPageCount, setControlledPageCount, formatLoadSorts } =&#xA;    useLoadTableUtils();&#xA;&#xA;  const serverSideTable = useReactTable({&#xA;    data,&#xA;    columns,&#xA;    pageCount: controlledPageCount,&#xA;    state: {&#xA;      sorting,&#xA;      pagination,&#xA;    },&#xA;    onPaginationChange: setPagination,&#xA;    manualPagination: true,&#xA;    onSortingChange: setSorting,&#xA;    manualSorting: true,&#xA;    debugTable: true,&#xA;    getCoreRowModel: getCoreRowModel(),&#xA;    enableSorting: true,&#xA;    sortingFns,&#xA;  });&#xA;</code></pre>&#xA;",20419875,,6036428,2022-11-04 18:23:23,2022-11-04 18:23:23,tanstack v8 react table - how to sort server-side with manualSorting,<sorting><graphql><server-side><react-table>,0,0,0,2022-11-04 17:57:46
74345441,1,,,0,34,"<p>I'm looking for a way to access source object of the source object used in graphql @SchemaMapping.</p>&#xA;<pre class=""lang-java prettyprint-override""><code>record Children() {}&#xA;record Parent(List&lt;Children&gt; childrens, String surname) {}&#xA;</code></pre>&#xA;<pre class=""lang-java prettyprint-override""><code>@SchemaMapping&#xA;String surname(Children children) {&#xA;  return &quot;&quot; // should access parent.surname()&#xA;}&#xA;</code></pre>&#xA;<pre><code>type Parent {&#xA;  children: [Children]&#xA;  surname: String&#xA;}&#xA;&#xA;type Children {&#xA;  surname: String&#xA;}&#xA;</code></pre>&#xA;",13349153,,,,2022-11-07 14:38:03,Spring-GraphQL: source of source in @SchemaMapping,<java><spring><graphql>,1,0,0,2022-11-07 10:52:42
74348317,2,,74345441,0,,"<p>First you should update your <strong>Children</strong> record with the fields you declare in your schema (initially, the <em>surname</em> String):</p>&#xA;<p>Then, I would suggest you included a way to link a <strong>Children</strong> to a <strong>Parent</strong> different to the <em>surname</em> (because as I believe from what you ask, that is not an option): for example, a <em>parentId</em>.</p>&#xA;<pre><code>record Children(Long, parentId, String surname) {}&#xA;record Parent(Long id, List&lt;Children&gt; childrens, String surname) {}&#xA;&#xA;type Parent {&#xA;  id: ID&#xA;  children: [Children]&#xA;  surname: String&#xA;}&#xA;&#xA;type Children {&#xA;  parentId: ID&#xA;  surname: String&#xA;}&#xA;</code></pre>&#xA;<p>Then you could implement your schema mapping with a filter or whichever business method you have:</p>&#xA;<pre><code>@SchemaMapping&#xA;String surname(Children children)&#xA;  return db.stream()&#xA;  .filter(aParent -&gt; aParent.id()==children.parentId())&#xA;  .findAny()&#xA;  .orElseGet(()-&gt;...) //etc&#xA;  .surname();&#xA;}&#xA;</code></pre>&#xA;",20121447,,,,2022-11-07 14:38:03,"",,0,0,0,2022-11-07 14:38:03
74376771,1,,,0,29,"<p>In my React application, I am using the Apollo Client, with <a href=""https://www.apollographql.com/docs/react/pagination/cursor-based/#relay-style-cursor-pagination"" rel=""nofollow noreferrer"">relayStylePagination()</a>. Our API uses the <a href=""https://relay.dev/graphql/connections.htm"" rel=""nofollow noreferrer"">Connection pattern</a> to provide the data.</p>&#xA;<p><img src=""https://i.stack.imgur.com/0IvZw.png"" alt=""Apollo Client"" title=""Apollo Client"" /></p>&#xA;<p>I want to introduce AG Grid to display large sets of data and to be able to use both pagination and infinite scroll behaviour. This implies the use of a <a href=""https://www.ag-grid.com/react-data-grid/server-side-model/#server-side-row-model"" rel=""nofollow noreferrer"">Server-Side row model</a> in my implementation.</p>&#xA;<p>This has proven to be difficult. I can't find any examples of this particular setup in the wild. AG Grid's <a href=""https://www.ag-grid.com/react-data-grid/server-side-operations-graphql/#server-side-datasource"" rel=""nofollow noreferrer"">own examples</a> using GraphQL, utilise start and end rows to build and perform the paginated requests.</p>&#xA;<p>I need to use cursor-based pagination to build my queries. As seen on line 105 in my test-code below, I want to update the variable <code>after</code> (currently set to <code>null</code> in order to fetch the 10 first results).</p>&#xA;<p><img src=""https://i.stack.imgur.com/iOwYd.png"" alt=""Test implementation"" title=""Test implementation"" /></p>&#xA;<p>Any and all input, nudges in the right direction and/or examples on how to do this is highly appreciated.</p>&#xA;",1845979,,1845979,2022-11-09 15:09:22,2022-11-09 15:09:22,"How do I use AG Grid (Server-Side Row Model) and Apollo GraphQL client, with Relay-style cursor pagination in React?",<reactjs><graphql><pagination><ag-grid><apollo>,0,0,0,2022-11-09 14:46:54
74397878,2,,66696029,0,,"<p>You need to pass the same variable with the same values you use when executing  the mutation and in the same order</p>&#xA;<pre><code>existingData = cache.readQuery({&#xA;   query: QUERY_NAME,&#xA;     variables: {&#xA;        x: mutationValue1,&#xA;        y: mutationValue2&#xA;        z: mutationValue3&#xA;   },&#xA; });`&#xA;</code></pre>&#xA;",8935972,,,,2022-11-11 03:58:53,"",,0,0,0,2022-11-11 03:58:53
74423510,1,,,0,26,"<p>I'm very new into graphql but I'm able to insert a new &quot;notification&quot; that belongs to a &quot;Tienda&quot; which means store, however I'm not able to indicate to which store it belongs to.</p>&#xA;<p>This is the schema</p>&#xA;<pre><code>type Tienda @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  cliente: [Cliente] @manyToMany(relationName: &quot;clienteDeTienda&quot;)&#xA;  news: [Notificacion] @hasMany&#xA;&#xA;}&#xA;&#xA;type Cliente @model {&#xA;  id: ID!&#xA;  name: String!&#xA;  stores: [Tienda] @manyToMany(relationName: &quot;clienteDeTienda&quot;)  &#xA;}&#xA;&#xA;type Notificacion @model {&#xA;  id: ID!&#xA;  store: Tienda @belongsTo&#xA;  content: String!&#xA;}&#xA;</code></pre>&#xA;<p>This is how I insert a new notification:</p>&#xA;<pre><code>const response = await API.graphql(graphqlOperation(createNotificacion, {input:data}))&#xA;</code></pre>&#xA;<p>This is what data has inside:</p>&#xA;<pre><code>Object {&#xA;  &quot;content&quot;: &quot;Nueva notificacion&quot;,&#xA;}&#xA;</code></pre>&#xA;<p>And this is the response I get from console.log(response):</p>&#xA;<pre><code>Object {&#xA;  &quot;data&quot;: Object {&#xA;    &quot;createNotificacion&quot;: Object {&#xA;      &quot;content&quot;: &quot;Nueva notificacion&quot;,&#xA;      &quot;createdAt&quot;: &quot;2022-11-13T18:04:55.000Z&quot;,&#xA;      &quot;id&quot;: &quot;9f50d333-fc9e-478f-be6a-c54275797a27&quot;,&#xA;      &quot;store&quot;: null,&#xA;      &quot;tiendaNewsId&quot;: null,&#xA;      &quot;updatedAt&quot;: &quot;2022-11-13T18:04:55.000Z&quot;,&#xA;    },&#xA;  },&#xA;}&#xA;</code></pre>&#xA;<p>As you can see &quot;content&quot; was added to the notification but &quot;store&quot; is null but I haven't been successful in inserting the store ID in there.</p>&#xA;<p>This is how the mutations is defined:</p>&#xA;<pre><code>export const createNotificacion = /* GraphQL */ `&#xA;  mutation CreateNotificacion(&#xA;    $input: CreateNotificacionInput!&#xA;    $condition: ModelNotificacionConditionInput&#xA;  ) {&#xA;    createNotificacion(input: $input, condition: $condition) {&#xA;      id&#xA;      store {&#xA;        id&#xA;        name&#xA;        cliente {&#xA;          nextToken&#xA;        }&#xA;        news {&#xA;          nextToken&#xA;        }&#xA;        createdAt&#xA;        updatedAt&#xA;      }&#xA;      content&#xA;      createdAt&#xA;      updatedAt&#xA;      tiendaNewsId&#xA;    }&#xA;  }&#xA;`;&#xA;</code></pre>&#xA;<p>I've tried with the following 3 methods which give no error but still doesn't link to it's parent:</p>&#xA;<pre><code>API.graphql(graphqlOperation(createNotificacion, {input:data, store:{id:'55988776-11af-42b8-b93b-9de9af35f7dc'}}))&#xA;</code></pre>&#xA;<p>And</p>&#xA;<pre><code>API.graphql(graphqlOperation(createNotificacion, {input:data, store:'55988776-11af-42b8-b93b-9de9af35f7dc'}))&#xA;</code></pre>&#xA;<p>And:</p>&#xA;<pre><code>API.graphql(graphqlOperation(createNotificacion, {input:data},{store:'55988776-11af-42b8-b93b-9de9af35f7dc'}))&#xA;</code></pre>&#xA;<p>Please somebody point me the right path or documentation about how to do this. I need to know how to perform the graphqlOperation correctly.</p>&#xA;<p>Thank you very much</p>&#xA;",14351825,,14351825,2022-11-13 19:46:37,2022-11-14 15:44:51,Graphql insert a child while indicating his parent,<graphql>,1,7,0,2022-11-13 18:12:42
74448274,2,,72504559,0,,"<p>I am following the same course, and found the solution based on the <a href=""https://github.com/urql-graphql/urql/blob/main/exchanges/graphcache/src/extras/simplePagination.ts"" rel=""nofollow noreferrer"">urql pagination example on github</a>. You can literally just swap <code>resolveFieldByKey</code> to <code>resolve</code> in the <a href=""https://github.com/benawad/lireddit/blob/master/web/src/utils/createUrqlClient.ts"" rel=""nofollow noreferrer"">source code</a>, an it works the same way.</p>&#xA;<p>So just use:</p>&#xA;<pre><code>const isItInTheCache = cache.resolve(&#xA;  cache.resolve(entityKey, fieldKey) as string,&#xA;  &quot;posts&quot;&#xA;);&#xA;&#xA;...&#xA;&#xA;const key = cache.resolve(entityKey, fi.fieldKey) as string;&#xA;const data = cache.resolve(key, &quot;posts&quot;) as string[];&#xA;</code></pre>&#xA;",8683221,,,,2022-11-15 15:32:13,"",,0,0,0,2022-11-15 15:32:13
74451934,2,,74449808,1,,"<p>Looks like you've got a type mismatch if you're trying to compare a date and a DateTime:</p>&#xA;<pre class=""lang-cs prettyprint-override""><code>public DateTime? JoinDate {get; set;}&#xA;</code></pre>&#xA;<p>Even <code>DateTime</code>s which are initialised with only a date will contain a time component:</p>&#xA;<pre class=""lang-cs prettyprint-override""><code>var myDateTime = new DateTime(2022, 11, 16);&#xA;&#xA;Console.WriteLine(myDateTime.ToString());&#xA;// Outputs 16/11/2022 12:00:00 am&#xA;</code></pre>&#xA;<p>The issue is if you try to perform an <code>eq</code> on a <code>JoinDate</code> which is <code>&quot;2022-11-16 08:00&quot;</code> with a passed date of <code>&quot;2022-11-16&quot;</code>, the date you're passing in is converted to a <code>DateTime</code> of <code>&quot;2022-11-16 00:00&quot;</code>.</p>&#xA;<p>Then you're comparing <code>&quot;2022-11-16 08:00&quot;</code> with <code>&quot;2022-11-16 00:00&quot;</code>, which are not equal.</p>&#xA;",6632744,,,,2022-11-15 20:42:49,"",,0,3,0,2022-11-15 20:42:49
74456114,1,74456134,,-1,16,"<p>I'm using <a href=""https://doug-martin.github.io/nestjs-query/"" rel=""nofollow noreferrer"">Nestjs-query</a>.</p>&#xA;<p>I have an object type (ex: <code>Todo</code>) which, most of the time, I want to use pagination to fetch the list.</p>&#xA;<pre><code>@ObjectType('Todo')&#xA;@QueryOptions({ pagingStrategy: PagingStrategies.CURSOR })&#xA;export class Todo {&#xA;  @IDField(() =&gt; ID)&#xA;  id!: number;&#xA;&#xA;  @FilterableField({ nullable: true })&#xA;  description?: string;&#xA;}&#xA;</code></pre>&#xA;<p>It generates the GraphQL query end point:</p>&#xA;<pre><code>  todos(&#xA;    &quot;&quot;&quot;Limit or page results.&quot;&quot;&quot;&#xA;    paging: CursorPaging = {first: 10}&#xA;&#xA;    &quot;&quot;&quot;Specify to filter the records returned.&quot;&quot;&quot;&#xA;    filter: TodoFilter = {}&#xA;&#xA;    &quot;&quot;&quot;Specify to sort results.&quot;&quot;&quot;&#xA;    sorting: [TodoSort!] = []&#xA;  ): TodoConnection!&#xA;</code></pre>&#xA;<p>But on some occasions, I want to fetch the entire list (unpaginated) of TODOs. But <code>paging.first</code> cannot be <code>null</code> or smaller than <code>1</code>.</p>&#xA;<p>Is there a way to fetch the unpaginated list without writing a new query endpoint by hand?</p>&#xA;",12066144,,,,2022-11-16 06:37:56,Nestjs-query - How to generate the paginated and unpaginated query?,<graphql><nestjs><nestjs-query>,1,0,0,2022-11-16 06:35:57
74456134,2,,74456114,0,,"<p>It is possible by adding a new resolver to the module:</p>&#xA;<pre><code>NestjsQueryGraphQLModule.forFeature({&#xA;  imports: [TodoModule],&#xA;  resolvers: [&#xA;    {&#xA;      // Assuming Todo is decorated with `@QueryOptions({ pagingStrategy: PagingStrategies.CURSOR })`&#xA;      DTOClass: Todo,&#xA;      EntityClass: Todo,&#xA;      // ...&#xA;    },&#xA;    {&#xA;      DTOClass: Todo,&#xA;      EntityClass: Todo,&#xA;      pagingStrategy: PagingStrategies.NONE,&#xA;      read: {&#xA;        // Give a custom name to not conflict with the first resolver.&#xA;        many: { name: 'todoUnpaginated' },&#xA;      },&#xA;      // ...&#xA;    },&#xA;  ],&#xA;}),&#xA;</code></pre>&#xA;<p>And it generates the schema:</p>&#xA;<pre><code>  todos(&#xA;    &quot;&quot;&quot;Limit or page results.&quot;&quot;&quot;&#xA;    paging: CursorPaging = {first: 10}&#xA;&#xA;    &quot;&quot;&quot;Specify to filter the records returned.&quot;&quot;&quot;&#xA;    filter: TodoFilter = {}&#xA;&#xA;    &quot;&quot;&quot;Specify to sort results.&quot;&quot;&quot;&#xA;    sorting: [TodoSort!] = []&#xA;  ): TodoConnection!&#xA;  todosUnpaginated(&#xA;    &quot;&quot;&quot;Specify to filter the records returned.&quot;&quot;&quot;&#xA;    filter: TodoFilter = {}&#xA;&#xA;    &quot;&quot;&quot;Specify to sort results.&quot;&quot;&quot;&#xA;    sorting: [TodoSort!] = []&#xA;  ): [Todo!]!&#xA;</code></pre>&#xA;",12066144,,,,2022-11-16 06:37:56,"",,0,0,0,2022-11-16 06:37:56
74460820,1,74462279,,0,15,"<p>ièm trying to use OR inside AND by passing an array of object to OR</p>&#xA;<pre><code>city=[{city:berlin},{city:newyork}]&#xA;brand=[{brand:bmw},{brand:nissan}]&#xA;  filter: async(_,{city ,brand,model}) =&gt;{&#xA;  const ads =await Client.Ads.findMany({where:{&#xA;      AND:[&#xA;        OR:city&#xA;      ,&#xA;      OR:brand&#xA;      ]&#xA;        &#xA;      &#xA;  }})&#xA;&#xA;&#xA;</code></pre>&#xA;",16946991,,,,2022-11-16 14:33:29,how to use OR array inside AND prisma,<prisma><prisma-graphql>,1,0,0,2022-11-16 12:55:42
74482059,2,,73991780,0,,"<p>So the trick is to let you sum aggregate colums query to run by itself.  Then run a second query where you map to the id's you've already found.  This keeps your aggregates pure and can still do an additional join!</p>&#xA;<pre><code>{&#xA;  key: &quot;listGoogleSiteLinks&quot;,&#xA;  prototype:&#xA;    &quot;(customer_id: Int, start_date: String, end_date: String): [GoogleAdExtensions]&quot;,&#xA;  run: async args =&gt; {&#xA;    const allIds = await google_ad_extensions&#xA;      .findAll({&#xA;        attributes: [&#xA;          &quot;extension_feed_item_id&quot;,&#xA;          [sequelize.fn(&quot;max&quot;, sequelize.col(&quot;google_ad_extensions.date&quot;)), &quot;date&quot;],&#xA;          [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_ad_extensions.impressions&quot;)), &quot;impressions&quot;],&#xA;          [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_ad_extensions.clicks&quot;)), &quot;clicks&quot;],&#xA;          [sequelize.fn(&quot;sum&quot;, sequelize.col(&quot;google_ad_extensions.cost_micros&quot;)), &quot;cost&quot;]&#xA;        ],&#xA;        where: {&#xA;          customer_id: args.customer_id,&#xA;          date: {&#xA;            [Op.gte]: args.start_date,&#xA;            [Op.lte]: args.end_date&#xA;          }&#xA;        },&#xA;        group: [&quot;extension_feed_item_id&quot;]&#xA;      })&#xA;      .map(item =&gt; item.toJSON());&#xA;    const adExtensions = uniqBy(&#xA;      await google_ad_extensions.findAll({&#xA;        where: sequelize.where(&#xA;          sequelize.fn(&#xA;            &quot;concat&quot;,&#xA;            sequelize.col(&quot;extension_feed_item_id&quot;),&#xA;            &quot;-&quot;,&#xA;            sequelize.col(&quot;google_ad_extensions.date&quot;)&#xA;          ),&#xA;          {&#xA;            [Op.in]: allIds.map(&#xA;              ({ extension_feed_item_id, date }) =&gt;&#xA;                `${extension_feed_item_id}-${date}`&#xA;            )&#xA;          }&#xA;        ),&#xA;        include: [&#xA;          {&#xA;            model: google_ads_group_name,&#xA;            as: 'google_ads_group_name',&#xA;            required: true,&#xA;            attributes: [&#xA;              &quot;ad_group_name&quot;,&#xA;              &quot;ad_group_id&quot;&#xA;            ],&#xA;            where: {&#xA;              customer_id: args.customer_id,&#xA;              date: {&#xA;                [Op.gte]: args.start_date,&#xA;                [Op.lte]: args.end_date&#xA;              }&#xA;            }&#xA;          },&#xA;        ]&#xA;      }),&#xA;      ({ extension_feed_item_id, date }) =&gt;&#xA;        `${extension_feed_item_id}-${date}`&#xA;    );&#xA;&#xA;    return adExtensions.map(ad =&gt; {&#xA;      const idMap = allIds.find(&#xA;        ({ extension_feed_item_id }) =&gt;&#xA;          extension_feed_item_id === ad.extension_feed_item_id&#xA;      );&#xA;      return {&#xA;        ...ad.toJSON(),&#xA;        clicks: idMap.clicks,&#xA;        impressions: idMap.impressions,&#xA;        cost: idMap.cost,&#xA;        google_ads_group_name: ad.google_ads_group_name&#xA;      };&#xA;    });&#xA;  }&#xA;},&#xA;</code></pre>&#xA;",884345,,,,2022-11-17 21:03:32,"",,0,0,0,2022-11-17 21:03:32
74507910,1,74508229,,0,26,"<p>I'm attempting to filter a query by a specific field. I can achieve this in Apollo explorer in dev tools but I can't seem to translate this into code.</p>&#xA;<p>The following works in Apollo explorer:</p>&#xA;<pre><code>query ListUsersByType($filter: TableUsersFilterInput) {&#xA;  listUsers(filter: $filter) {&#xA;    items {&#xA;      email&#xA;      id&#xA;      type&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<pre><code>{&#xA;  &quot;filter&quot;: {&#xA;    &quot;type&quot;: {&#xA;      &quot;eq&quot;: &quot;ADMIN&quot;&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>I am unsure how this translates to the code using the useQuery hook however.</p>&#xA;<p>When I try the following it doesn't filter the list at all, it just fetches all of them regardless of type:</p>&#xA;<pre><code>const ListUsersByType = gql`&#xA;  query ListUsersByType($type: TableUsersFilterInput) {&#xA;    listUsers(filter: $type) {&#xA;      items {&#xA;        email&#xA;        id&#xA;        type&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<pre><code>  const { data, loading, error } = useQuery(ListUsersByType, {&#xA;    variables: {&#xA;      filter: {&#xA;        type: {&#xA;          eq: 'ADMIN',&#xA;        },&#xA;      },&#xA;    },&#xA;  })&#xA;</code></pre>&#xA;<p>What am I missing here?</p>&#xA;",20547034,,,,2022-11-20 12:50:15,How to implement a filter on a query in Apollo?,<graphql><apollo><react-apollo>,1,0,0,2022-11-20 12:03:57
74508229,2,,74507910,0,,"<p>Your names are not correct</p>&#xA;<p>Here you say <code>filter will use the variable type</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>const ListUsersByType = gql`&#xA;  query ListUsersByType($type: TableUsersFilterInput) {&#xA;    listUsers(filter: $type) {&#xA;      items {&#xA;        email&#xA;        id&#xA;        type&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p>And here you pass <code>filter</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>  const { data, loading, error } = useQuery(ListUsersByType, {&#xA;    variables: {&#xA;      filter: {&#xA;        type: {&#xA;          eq: 'ADMIN',&#xA;        },&#xA;      },&#xA;    },&#xA;  })&#xA;</code></pre>&#xA;<p>You can</p>&#xA;<p><strong>First solution</strong></p>&#xA;<p>replace <code>$type</code> by <code>$filter</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>const ListUsersByType = gql`&#xA;  query ListUsersByType($filter: TableUsersFilterInput) {&#xA;    listUsers(filter: $filter) {&#xA;      items {&#xA;        email&#xA;        id&#xA;        type&#xA;      }&#xA;    }&#xA;  }&#xA;`&#xA;</code></pre>&#xA;<p><strong>Second solution</strong></p>&#xA;<p>rename the variable <code>filter</code> to <code>type</code></p>&#xA;<pre class=""lang-js prettyprint-override""><code>  const { data, loading, error } = useQuery(ListUsersByType, {&#xA;    variables: {&#xA;      type: {&#xA;        type: {&#xA;          eq: 'ADMIN',&#xA;        },&#xA;      },&#xA;    },&#xA;  })&#xA;</code></pre>&#xA;<p><strong>My opinion</strong></p>&#xA;<p>I let you choose but the first option seems the best</p>&#xA;",12239272,,,,2022-11-20 12:50:15,"",,0,0,0,2022-11-20 12:50:15
74524081,1,,,0,16,"<p>I'm using Contentful's GraphQL API. What I want to do is to query all the events that haven't past yet.</p>&#xA;<p>I tried using <code>lt</code>, but that doesn't seem to be working. I also found out that the date is a string, so what options do I have?</p>&#xA;<pre><code>eventCollection(where: {eventEndDate: {lt: &quot;2022-10-27T00:00:00.000-06:00&quot;}}){&#xA;    items {&#xA;      slug&#xA;      eventEndDate&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>A normal query (without the where condition) gives you:</p>&#xA;<pre><code>&quot;eventCollection&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;slug&quot;: &quot;black-friday&quot;,&#xA;          &quot;eventEndDate&quot;: &quot;2022-11-27T12:00:00.000-07:00&quot;&#xA;        }&#xA;      ]&#xA;    }&#xA;</code></pre>&#xA;",20551523,,4253183,2022-11-22 09:16:18,2022-11-22 09:16:18,How to graphql after a certain date in contentful?,<graphql><contentful><contentful-api>,1,0,0,2022-11-21 19:36:49
74530104,2,,74524081,0,,"<p>You should have an <code>eventEndDate_gte</code> filter available. On every field, there will be type dependent filter available. It's best to use <a href=""https://www.contentful.com/developers/docs/references/graphql/#/reference/exploring-the-schema-with-graphiql"" rel=""nofollow noreferrer"">GraphiQL</a> or <a href=""https://www.contentful.com/marketplace/app/graphql-playground/"" rel=""nofollow noreferrer"">the GraphQL Playground</a> to discover available filter options.</p>&#xA;<p>The following filter works fine for my space.</p>&#xA;<pre><code>query {&#xA;  tilPostCollection(where: {date_gte: &quot;2022-09-05T00:00:00.000+02:00&quot;}) {&#xA;    items {&#xA;      title&#xA;      date&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;",4253183,,,,2022-11-22 09:15:25,"",,0,0,0,2022-11-22 09:15:25
74536867,1,,,1,12,"<p>so we have a microservice architecture and there was a need for queries of different types from different microservices. so we implemented the graphQL gateway and it works and it is really good. but there was this peculiar need that is just driving me insane on how to do it. we are using nestjs and typeorm.</p>&#xA;<p><strong>Problem</strong>: the problem is, we want to search on user entity which is in the person service and also on related entities to user on different services. for example let say i want users with the name like &quot;john&quot; who hadn't a payment (their userid doesn't exist on the records) in last week and haven't bought our latest product (again their userid not existing on the records) but purchased the one before that (their userid and payment id exists). as you see they are deeply connected. on top of that we want to show the final result with pagination and how many results matched it. as you can see the result of each filter is closely related to the other ones.</p>&#xA;<p>so i can easily make a root query on the users with the filter of name &quot;john&quot; then have a query inside it of orphan type userPayment which queries payment and also the product one (all being handled by federation) and in the frontend just filter the result of the ones which these fields are empty. but the thing is, my pagination and view gets messed up, the total count for pagination comes from the root users query and the other two queries are run for each of matching users.</p>&#xA;<p>so the question is how can you make a query like this ? i searched around and heard about CQRS but isn't there another approach besides duplicating data and one database and stuff ? also since we are using the typescript i cannot query each one and hold all their data in code. if 10000 users were found, javascript simply runs out of heap memory.</p>&#xA;<p>what do you suggest?</p>&#xA;",9948431,,,,2022-11-22 17:35:09,query result composition problem in graphQL gateway,<typescript><graphql><nestjs><typeorm><graphql-federation>,0,2,0,2022-11-22 17:35:09
74540029,1,,,1,31,"<p>I have a table with a date field of type timestamp with time zone, the field in the typeorm model is of type date. I use a nodejs express server.</p>&#xA;<p>When I get the datetime it returns the value with one hour less.</p>&#xA;<p>How can I solve it?</p>&#xA;<p>Value in the database:</p>&#xA;<p>2022-11-23 00:08:00+01</p>&#xA;<p>Value returned by the server:</p>&#xA;<p>2022-11-22T23:08:00.000Z</p>&#xA;",9813306,,,,2022-11-23 06:31:56,How to get timestamp with timezone in typeorm?,<node.js><postgresql><orm><typeorm><apollo-server>,1,1,0,2022-11-22 23:11:23
74549535,1,,,0,12,<p>How can I extend my date type filter or override my date type filer in C# with ASP.NET Core? API call is coming to GraphQL. I am able to achieve string type filter but not able to find anything related to dates type</p>&#xA;,4331209,,13302,2022-11-23 16:14:06,2022-11-23 16:14:06,Trying to customize date filter in GraphQL API call using C# and ASP.NET Core,<c#><asp.net-core><graphql><graphql-dotnet>,0,1,0,2022-11-23 15:47:48
74563095,1,,,0,12,"<p>I've added a @searchable directive to my Amplify/GraphQL schema as follows:</p>&#xA;<pre><code>type Card&#xA;  @model &#xA;  @searchable &#xA;  {&#xA;    name: String&#xA;    id: ID!&#xA;  }&#xA;</code></pre>&#xA;<p>I've added some items, which I can retrieve with listCards in my AppSync Console:</p>&#xA;<pre><code>query MyQuery {&#xA;  listCards {&#xA;    items {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# Returns:&#xA;{&#xA;  &quot;data&quot;: {&#xA;    &quot;listCards&quot;: {&#xA;      &quot;items&quot;: [&#xA;        {&#xA;          &quot;name&quot;: &quot;hunter&quot;&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;url1&quot;&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;testThur&quot;&#xA;        },&#xA;        {&#xA;          &quot;name&quot;: &quot;testThur2&quot;&#xA;        },&#xA;...&#xA;}&#xA;</code></pre>&#xA;<p>Now, when I try to use <code>searchCards</code> I can't get it to return anything:</p>&#xA;<pre><code>query MyQuery {&#xA;  searchCards(filter: {name: {ne: &quot;nonsense&quot;}}) {&#xA;    nextToken&#xA;    total&#xA;    items {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# Returns:&#xA;{&#xA;  &quot;data&quot;: {&#xA;    &quot;searchCards&quot;: {&#xA;      &quot;nextToken&quot;: null,&#xA;      &quot;total&quot;: null,&#xA;      &quot;items&quot;: []&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>How do I get this working?</p>&#xA;",11664580,,11664580,2022-11-24 18:46:03,2022-11-24 18:47:32,Unable to return any data in AppSync console with search - using @searchable directive in Amplify,<graphql><aws-amplify><aws-appsync>,1,0,0,2022-11-24 15:31:19
74576851,1,,,1,34,"<p>I have two components, one of the components creates new items, the other one displays them using an &quot;infinite scroll list&quot;. These two components do not have a parent/child relationship and they're not rendered at the same time (they're on different &quot;pages&quot;).</p>&#xA;<p>I've followed <a href=""https://www.apollographql.com/docs/react/data/mutations/#include-modified-objects-in-mutation-responses"" rel=""nofollow noreferrer"">these docs</a> and included the modified object in the mutation of my first component. And I can see the new object in the Apollo cache using dev tools. (<code>Car:&lt;some UUID&gt;</code> gets added in the cache after the mutation runs)</p>&#xA;<p>My paginated component is configured with <a href=""https://www.apollographql.com/docs/react/pagination/cursor-based/#relay-style-cursor-pagination"" rel=""nofollow noreferrer"">relay style pagination</a>, and the pagination works fine, but when I add a new item it doesn't appear in the list until I refresh the page.</p>&#xA;<p>My InMemoryCache looks like this:</p>&#xA;<pre class=""lang-json prettyprint-override""><code>    ...&#xA;    typePolicies: {&#xA;      // paginated results&#xA;      Query: {&#xA;        fields: {&#xA;          cars: relayStylePagination()&#xA;        }&#xA;      },&#xA;      CarsResult: {&#xA;        fields: {&#xA;          edges: {&#xA;            // Concatenate the incoming list items with&#xA;            // the existing list items.&#xA;            merge(existing = [], incoming) {&#xA;              return [...existing, ...incoming]&#xA;            }&#xA;          }&#xA;        }&#xA;      },&#xA;      PageInfo: {&#xA;        fields: {&#xA;          endCursor: {&#xA;            merge(existing, incoming) {&#xA;              return incoming&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;<p>The mutation looks like this:</p>&#xA;<pre><code>  ${CAR_SUMMARY_FRAGMENT}&#xA;  mutation CreateCar($name: String!) {&#xA;    createCar(&#xA;      input: {&#xA;        name: $name&#xA;      }&#xA;    ) {&#xA;      ...CarSummary&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>The <code>CreateCar</code> return type is <code>Car</code></p>&#xA;<p>Then my paginated query:</p>&#xA;<pre><code>  query CarsPaginated($after: Cursor) {&#xA;    cars(&#xA;      page: { first: 25, after: $after }&#xA;      orderBy: { field: CREATE_TIME, direction: DESC }&#xA;    ) {&#xA;      edges {&#xA;        node {&#xA;          ...CarSummary&#xA;        }&#xA;      }&#xA;      totalCount&#xA;      pageInfo {&#xA;        hasNextPage&#xA;        endCursor&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;<p>The <code>CarsPaginated</code> return type is <code>CarsResult</code>:</p>&#xA;<pre><code>type CarsResult {&#xA;  edges: [CarEdge]&#xA;  pageInfo: PageInfo!&#xA;  totalCount: Int!&#xA;}&#xA;&#xA;type CarEdge {&#xA;  node: Car&#xA;  cursor: Cursor!&#xA;}&#xA;&#xA;</code></pre>&#xA;<p>Ideally, I'd like the new item to show up at the top of my items list on the other component.</p>&#xA;<ul>&#xA;<li>I've tried to use the &quot;refetchQueries&quot; attribute but the paginated query is not active since the list component is not rendered at that time.</li>&#xA;</ul>&#xA;<p>Maybe there's something I need to do in the typePolicies?</p>&#xA;",4884034,,,,2022-12-03 15:57:37,Apollo cache update is not reflected on paginated query,<apollo-client><react-apollo>,1,0,0,2022-11-25 18:44:08
74582708,1,,,0,15,"<p>Im developing a React front-end which consumes an GraphQL API.  My coworker sent me this query and asked me to make it &quot;dynamic&quot;, being able to accept variables that will come from the frontend and filter the query based on date input.</p>&#xA;<p>This is the original query, without any modification:</p>&#xA;<pre><code>query {&#xA;  orders(&#xA;    filter: {&#xA;      and: [&#xA;        {invoice_iso_date: { gte: &quot;2022-08-01T00:00:00.000Z&quot;}}, &#xA;        {invoice_iso_date: { lte: &quot;2022-08-31T23:59:59.999Z&quot;}} &#xA;      ]&#xA;      marketplace_cnpj: { eq: &quot;04565289000147&quot; }&#xA;      seller_cnpj: { eq: &quot;35991059000173&quot; }&#xA;      process_status: { eq: &quot;1&quot; }&#xA;      process_stage: { eq: &quot;8&quot; }&#xA;    }&#xA;    paging: { limit: 10, offset: 0 }&#xA;  ) {&#xA;    totalCount&#xA;    nodes {&#xA;      print_counter&#xA;      invoice_iso_date&#xA;      electronic_invoice&#xA;      order_id&#xA;      customer_order_id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This is the modified query i tried to make, using variables.</p>&#xA;<pre><code>query getDanfes($startDate: String!, $endDate: String!) {&#xA;  orders(&#xA;    filter: {&#xA;      and: [&#xA;        { invoice_iso_date: { gte: $startDate } }&#xA;        { invoice_iso_date: { lte: $endDate } }&#xA;      ]&#xA;      marketplace_cnpj: { eq: &quot;04565289000147&quot; }&#xA;      seller_cnpj: { eq: &quot;35991059000173&quot; }&#xA;      process_status: { eq: &quot;1&quot; }&#xA;      process_stage: { eq: &quot;8&quot; }&#xA;    }&#xA;    paging: { limit: 10, offset: 0 }&#xA;  ) {&#xA;    totalCount&#xA;    nodes {&#xA;      print_counter&#xA;      invoice_iso_date&#xA;      electronic_invoice&#xA;      order_id&#xA;      customer_order_id&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;<p>This query doesnt work and returns &quot;internal server error&quot;.&#xA;I think its something wrong with the syntax, but im not sure what. Can somebody tell me where i messed up?</p>&#xA;",16474184,,,,2022-11-26 13:44:24,Unable to pass variables to GraphQL query using React application,<reactjs><syntax><graphql><graphql-js>,0,1,0,2022-11-26 13:44:24
74618696,1,,,1,23,"<p>I'm currently migrating a site from REST to graphql and I have a query that accepts a 'period' argument</p>&#xA;<pre><code>valuations(period: $period) {&#xA; low&#xA;}&#xA;</code></pre>&#xA;<p>In my resolvers im making an aggregate call to mongodb timeseries based on the period to return a certain timeframe of results.</p>&#xA;<pre><code>  valuations: async ({ collectible_id }, { period }, { prisma }) =&gt; {&#xA;        switch (true){&#xA;            case period === 1:&#xA;                return [await CollectiblePrice.aggregate([&#xA;                    {&#xA;                        &quot;$match&quot;: {&#xA;                            collectibleId: collectible_id,&#xA;                            &quot;date&quot;: {&#xA;                                $gte: new Date(new Date().getTime() - (24 * 60 * 60 * 1000))&#xA;                            }&#xA;                        }&#xA;                    },&#xA;                ])]&#xA;            case period === 2:&#xA;                return [await CollectiblePrice.aggregate([&#xA;                    {&#xA;                        &quot;$match&quot;: {&#xA;                            collectibleId: collectible_id,&#xA;                            &quot;date&quot;: {&#xA;                                $gte: new Date(new Date().getTime() - (48 * 60 * 60 * 1000))&#xA;                            }&#xA;                        }&#xA;                    },&#xA;                ])]&#xA;            case period === 7:&#xA;                console.log('7 day period...')&#xA;                return [await CollectiblePrice.aggregate([&#xA;                    {&#xA;                        &quot;$match&quot;: {&#xA;                            collectibleId: collectible_id,&#xA;                            &quot;date&quot;: {&#xA;                                $gte: new Date(new Date().getTime() - (7 * 24 * 60 * 60 * 1000))&#xA;                            }&#xA;                        }&#xA;                    },&#xA;                ])]&#xA;            case period === 28 || 30:&#xA;                return [await CollectiblePrice.aggregate([&#xA;                    {&#xA;                        &quot;$match&quot;: {&#xA;                            collectibleId: collectible_id,&#xA;                            &quot;date&quot;: {&#xA;                                $gte: new Date(new Date().getTime() - (30 * 24 * 60 * 60 * 1000))&#xA;                            }&#xA;                        }&#xA;                    },&#xA;                ])]&#xA;            case period === 90:&#xA;                return [await CollectiblePrice.aggregate([&#xA;                    {&#xA;                        &quot;$match&quot;: {&#xA;                            collectibleId: collectible_id,&#xA;                            &quot;date&quot;: {&#xA;                                $gte: new Date(new Date().getTime() - (90 * 24 * 60 * 60 * 1000))&#xA;                            }&#xA;                        }&#xA;                    },&#xA;                ])]&#xA;            default:&#xA;                return [await CollectiblePrice.aggregate([&#xA;                {&#xA;                    &quot;$match&quot;: {&#xA;                        collectibleId: collectible_id,&#xA;                        &quot;date&quot;: {&#xA;                            $gte: new Date(new Date().getTime() - (24 * 60 * 60 * 1000))&#xA;                        }&#xA;                    }&#xA;                },&#xA;            ])]&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;<p>This is working fine for most periods, but as I enter large periods like '90' I'm getting the error</p>&#xA;<pre><code>&quot;message&quot;: &quot;Float cannot represent non numeric value: Infinity&quot;,&#xA;</code></pre>&#xA;<p>I assume this is most likely an issue with the data and the value being something other than expected ? However it does work fine on the REST api and pipes into a graphing package just fine, is there a way I can allow or skip this value to return my results regardless of this entity?</p>&#xA;<p>Thanks,</p>&#xA;",6583984,,2805154,2022-11-29 21:51:42,2022-11-29 21:51:42,"GraphQL ""Float cannot represent non numeric value: Infinity""",<mongodb><graphql>,0,1,0,2022-11-29 18:29:11
74641850,2,,74617188,0,,"<p>Contains is not a valid search filter for lists.&#xA;You should make use of the 'all', 'none', 'some' or 'any' filter for lists.</p>&#xA;<p>As you can see in the documentation&#xA;<a href=""https://chillicream.com/docs/hotchocolate/v12/fetching-data/filtering/#list-filter"" rel=""nofollow noreferrer"">https://chillicream.com/docs/hotchocolate/v12/fetching-data/filtering/#list-filter</a></p>&#xA;",4873908,,,,2022-12-01 12:26:55,"",,0,1,0,2022-12-01 12:26:55
74642760,1,,,0,13,"<p>I need help in writing resolver for my GraphQL query with Spring.</p>&#xA;<p>problem is that each of the objects you see here are being passed from different API and I need to combine them with defined dependency. Since Graphql automatically calls instance api for each customer, I am not sure how to write resolver which can filter customers based on certain instance name</p>&#xA;<p>Here is my schema query and schema.graphqls</p>&#xA;<pre><code>  customers(filter: {tenant: {instance: {instanceName: &quot;ABC&quot;}}}){&#xA;    tenants{&#xA;      tenantId&#xA;      instance{&#xA;        instanceName&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;schema&#xA;&#xA;type Customer{&#xA;    customerName: String&#xA;    tenants: [Tenant]&#xA;}&#xA;&#xA;type Tenant{&#xA;    tenantId: ID&#xA;    instance: Instance&#xA;}&#xA;&#xA;type Instance{&#xA;    instanceId: ID&#xA;    instanceName: String&#xA;}&#xA;&#xA;type Query{&#xA;    customers(filter: CustomerFilterInput): [Customer]&#xA;}&#xA;&#xA;input CustomerFilterInput{&#xA;    customerName: String&#xA;    tenant: TenantInput&#xA;}&#xA;&#xA;input TenantInput{&#xA;    tenantId: String&#xA;    instance: InstanceInput&#xA;}&#xA;&#xA;input InstanceInput{&#xA;    instanceName: String&#xA;    instanceId: String&#xA;}&#xA;</code></pre>&#xA;",3955989,,3955989,2022-12-02 01:07:18,2022-12-02 01:07:18,How to write resolver for my query with Spring GraphQL,<spring><graphql><spring-graphql>,0,2,0,2022-12-01 13:38:25
74655591,1,,,-1,10,<p>I want to sort by field like sort by chair sort by box in springboot graphql and test in graphql query</p>&#xA;<p>Don't know how to try</p>&#xA;,19101039,,,,2022-12-02 12:11:12,Springboot graphql sortby field in datafetcher pagination,<java><spring-boot><graphql><graphql-java>,0,1,0,2022-12-02 12:11:12
74665229,1,,,0,12,"<p>I am trying to figure out how to post a date to a prisma database.</p>&#xA;<p>I have a prisma.schema which has a createdAt field as follows:</p>&#xA;<pre><code>  createdAt       DateTime @default(now()) @db.Timestamptz(6)&#xA;</code></pre>&#xA;<p>I made a model with a date field in it as follows:</p>&#xA;<pre><code>@Field()&#xA;  createdAt: Date;&#xA;</code></pre>&#xA;<p>And a create.input.ts with a similar field:</p>&#xA;<pre><code>@IsNotEmpty()&#xA;  @Field()&#xA;  createdAt: Date;&#xA;</code></pre>&#xA;<p>then, in the form, I'm trying to add the createdAt date as the date the form is submitted, as follows:</p>&#xA;<pre><code> return form.handler(() =&gt; createIssueGroup({ variables: { data: { ...data, createdAt: Date.now() } } })),&#xA;</code></pre>&#xA;<p>However, I get an error that says type number is not assignable to type string. I don't think I'm using a string in any of the date fields.</p>&#xA;<p>How can I post a date to prisma?</p>&#xA;",2860931,,,,2022-12-03 08:49:47,How to add a date to a prisma typescript form?,<prisma><typegraphql>,0,0,0,2022-12-03 08:49:47
74674006,1,,,1,20,"<p>I am New in <code>Django</code> and <code>GraphQL</code>, following the the <a href=""https://www.valentinog.com/blog/channels-ariadne/"" rel=""nofollow noreferrer"">article</a>,&#xA;I am using <strong>python 3.8 in virtual env</strong> and <strong>3.10 in windows</strong>, but same error occurs on both side, also tried the this <a href=""https://stackoverflow.com/questions/73983324/ariadne-python-modulenotfounderror-no-module-named-graphql-type"">Question</a>, i also heard that GraphQL generate queries, But dont know how to generate it, But this error occurs:</p>&#xA;<pre><code>Traceback (most recent call last):&#xA;  File &quot;/usr/lib/python3.8/threading.py&quot;, line 932, in _bootstrap_inner&#xA;    self.run()&#xA;  File &quot;/usr/lib/python3.8/threading.py&quot;, line 870, in run&#xA;    self._target(*self._args, **self._kwargs)&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/utils/autoreload.py&quot;, line 64, in wrapper&#xA;    fn(*args, **kwargs)&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/core/management/commands/runserver.py&quot;, line 125, in inner_run    autoreload.raise_last_exception()&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/utils/autoreload.py&quot;, line 87, in raise_last_exception&#xA;    raise _exception[1]&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/core/management/__init__.py&quot;, line 398, in execute&#xA;    autoreload.check_errors(django.setup)()&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/utils/autoreload.py&quot;, line 64, in wrapper&#xA;    fn(*args, **kwargs)&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/__init__.py&quot;, line 24, in setup&#xA;    apps.populate(settings.INSTALLED_APPS)&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/apps/registry.py&quot;, line 91, in populate&#xA;    app_config = AppConfig.create(entry)&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/django/apps/config.py&quot;, line 193, in create&#xA;    import_module(entry)&#xA;  File &quot;/usr/lib/python3.8/importlib/__init__.py&quot;, line 127, in import_module&#xA;    return _bootstrap._gcd_import(name[level:], package, level)&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1014, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 991, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 961, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1014, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 991, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 961, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1014, in _gcd_import&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 991, in _find_and_load&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 975, in _find_and_load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 671, in _load_unlocked&#xA;  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 783, in exec_module&#xA;  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/ariadne/__init__.py&quot;, line 1, in &lt;module&gt;&#xA;    from .enums import (&#xA;  File &quot;/home/talha/ve/lib/python3.8/site-packages/ariadne/enums.py&quot;, line 17, in &lt;module&gt;&#xA;    from graphql.type import GraphQLEnumType, GraphQLNamedType, GraphQLSchema&#xA;ModuleNotFoundError: No module named 'graphql.type'```&#xA;&#xA;</code></pre>&#xA;",10635370,,,,2022-12-04 09:33:48,No module named 'graphql.type' in Django,<python><django><graphql><ariadne-graphql>,1,0,0,2022-12-04 08:43:42
74677265,1,,,0,25,"<p>I can't sort by fields and order in graphql because those options doesn't exist in my graphql tree. If I add manually fields and order I getting error - Field order is not defined by type MarkdownRemarkSortInput and Field fields is not defined by type MarkdownRemarkSortInput. Any solutions for that?<a href=""https://i.stack.imgur.com/gFyE9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gFyE9.png"" alt=""enter image description here"" /></a></p>&#xA;<p>I was trying to add manually but that's not helping.</p>&#xA;",7670745,,466862,2022-12-04 13:57:39,2022-12-04 20:46:45,"allMarkdownRemark doesn't have a ""field"" and ""order"" in sort",<reactjs><graphql><gatsby>,1,0,0,2022-12-04 13:55:22
